language: rs
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut start_index = 0;\n\
    \    let mut open_parens = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  start_index = i;\n            }\n            open_parens += 1;\n        } else\
    \ if c == ')' {\n            open_parens -= 1;\n            if open_parens ==\
    \ 0 {\n                result.push(paren_string[start_index..=i].to_string());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpbnawoj54.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_parens = Vec::new();\n    let mut last_open_paren = 0;\n   \
    \ let mut separate_groups = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            open_parens.push(i);\n        } else if\
    \ c == ')' {\n            if let Some(open_idx) = open_parens.pop() {\n      \
    \          if open_parens.is_empty() {\n                    separate_groups.push(paren_string[last_open_paren..i\
    \ + 1].to_string());\n                    last_open_paren = i + 1;\n         \
    \       }\n            }\n        }\n    }\n    separate_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpwm19s6cu.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut out: Vec<String> = Vec::new();\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    let mut opened = false;\n   \
    \ let mut closed = false;\n    let mut s = String::new();\n    for ch in chars\
    \ {\n        match ch {\n            '(' => {\n                opened = true;\n\
    \                stack.push(ch);\n            }\n            ')' => {\n      \
    \          closed = true;\n                stack.pop();\n            }\n     \
    \       _ => {}\n        }\n        if opened && closed {\n            opened\
    \ = false;\n            closed = false;\n            out.push(s.clone());\n  \
    \          s.clear();\n        }\n        if !stack.is_empty() {\n           \
    \ s.push(ch);\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"((\", \")(\", \")\", \"(((\", \"))\", \"(\", \"(((\", \"))\", \"()\"]`,\n\
    \ right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp7o2yzg2o.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    let mut current_string: String\
    \ = String::new();\n    let mut current_counter: u8 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_counter += 1;\n            current_string.push(c);\n\
    \        } else if c == ')' {\n            current_counter -= 1;\n           \
    \ current_string.push(c);\n        }\n        if current_counter == 0 {\n    \
    \        output.push(current_string);\n            current_string = String::new();\n\
    \        }\n    }\n    return output;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpfq4rmsgc.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO\n    return vec![];\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpyiwm0ysd.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_vec: Vec<String> = Vec::new();\n    let mut saved_string: String\
    \ = String::new();\n    let mut inside_paren = false;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if inside_paren {\n                saved_string.push(c);\n\
    \            } else {\n                inside_paren = true;\n            }\n \
    \       } else if c == ')' {\n            if inside_paren {\n                saved_string.push(c);\n\
    \                paren_vec.push(saved_string.clone());\n                saved_string.clear();\n\
    \                inside_paren = false;\n            }\n        } else if inside_paren\
    \ {\n            saved_string.push(c);\n        }\n    }\n    paren_vec\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \")\", \"(()\", \")\", \"(()\", \")\", \")\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmptiv3zcvc.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ group = String::new();\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            stack.push(c);\n        } else if c == ')' {\n          \
    \  stack.pop();\n            if stack.is_empty() {\n                result.push(group);\n\
    \                group = String::new();\n            }\n        } else if !c.is_whitespace()\
    \ {\n            group.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmprohkt807.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .fold((vec![], Vec::new()), |(mut\
    \ acc, mut temp), c| {\n            match c {\n                '(' => {\n    \
    \                temp.push(c);\n                }\n                ')' => {\n\
    \                    temp.push(c);\n                    acc.push(temp.iter().collect());\n\
    \                    temp = Vec::new();\n                }\n                _\
    \ => (),\n            }\n            (acc, temp)\n        })\n        .0\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\", \")\", \"\
    ()\", \"()\", \")\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpktdg500s.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate groups of parenthesis in string: {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate groups of parenthesis
    in string: (()()) ((())) () ((())()())'', /tmp/tmpc9vvwtto.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    panic!(\"Not implemented\");\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Not implemented'', /tmp/tmp8cfp3_os.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut cur_group: String\
    \ = String::new();\n    let mut open_paren_count: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_paren_count += 1;\n            cur_group.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  cur_group.push(c);\n            if open_paren_count == 0 {\n              \
    \  groups.push(cur_group);\n                cur_group = String::new();\n     \
    \       }\n        }\n    }\n    return groups;\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut start = 0;\n    let mut end = 1;\n    let mut open_parens = 0;\n\
    \    let mut closed_parens = 0;\n    while end < chars.len() {\n        if chars[end]\
    \ == '(' {\n            open_parens += 1;\n        } else if chars[end] == ')'\
    \ {\n            closed_parens += 1;\n        }\n        if open_parens > 0 &&\
    \ open_parens == closed_parens {\n            result.push(chars[start..end+1].iter().collect());\n\
    \            open_parens = 0;\n            closed_parens = 0;\n            start\
    \ = end + 1;\n        }\n        end += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \") (\", \"(())\", \") (\", \") (\", \"(())\", \"()\", \"\
    ()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpcq40x11g.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut curr_string = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == ' ' {\n            continue;\n        }\n        if c == '(' {\n      \
    \      paren_count += 1;\n        }\n        curr_string.push(c);\n        if\
    \ c == ')' {\n            paren_count -= 1;\n        }\n        if paren_count\
    \ == 0 {\n            groups.push(curr_string);\n            curr_string = String::new();\n\
    \        }\n    }\n    return groups;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut ret = Vec::new();\n    let mut open_parens = 0;\n    let mut start_index\
    \ = 0;\n    for (index, c) in paren_string.chars().enumerate() {\n        match\
    \ c {\n            '(' => {\n                if open_parens == 0 {\n         \
    \           start_index = index;\n                }\n                open_parens\
    \ += 1;\n            }\n            ')' => {\n                open_parens -= 1;\n\
    \                if open_parens == 0 {\n                    ret.push(paren_string[start_index..index\
    \ + 1].to_string());\n                }\n            }\n            _ => (),\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpkmkv06ql.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    if paren_string.is_empty() {\n        return vec![];\n    }\n\n    let mut\
    \ start_idx = 0;\n    let mut end_idx = 0;\n    let mut result: Vec<String> =\
    \ vec![];\n\n    let mut open_paren_count = 0;\n    let mut closed_paren_count\
    \ = 0;\n\n    for (idx, ch) in paren_string.chars().enumerate() {\n        match\
    \ ch {\n            '(' => {\n                open_paren_count += 1;\n       \
    \         if open_paren_count == 1 {\n                    start_idx = idx;\n \
    \               }\n            }\n            ')' => {\n                closed_paren_count\
    \ += 1;\n                if open_paren_count == closed_paren_count {\n       \
    \             end_idx = idx;\n                    let element = paren_string[start_idx..=end_idx].trim().to_string();\n\
    \                    result.push(element);\n                    open_paren_count\
    \ = 0;\n                    closed_paren_count = 0;\n                }\n     \
    \       }\n            _ => {}\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp245nlime.rs:49:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // The following tokens will be used to parse the paren_string\n    let open_paren\
    \ = '(';\n    let close_paren = ')';\n    let whitespace = ' ';\n\n    // The\
    \ following accumulator will store the parsed groups of parens\n    let mut groups\
    \ = Vec::new();\n\n    // The following accumulator will store the opening parens\
    \ seen so far\n    let mut paren_stack = Vec::new();\n\n    // The following accumulator\
    \ will store the parsed string of parens so far\n    let mut group_string = String::new();\n\
    \n    // Iterate over the characters in the input string\n    for c in paren_string.chars()\
    \ {\n        match c {\n            open_paren => {\n                // On an\
    \ open paren, push it onto the stack\n                paren_stack.push(open_paren);\n\
    \                // And add it to the string accumulator\n                group_string.push(open_paren);\n\
    \            }\n            close_paren => {\n                // On a close paren,\
    \ check the stack to make sure it matches the last open paren\n              \
    \  match paren_stack.pop() {\n                    Some(open_paren) => {\n    \
    \                    // If it does, add it to the string accumulator\n       \
    \                 group_string.push(close_paren);\n                    }\n   \
    \                 None => {\n                        // If it doesn't, we have\
    \ an error and should return None\n                        return Vec::new();\n\
    \                    }\n                }\n                // If the stack is\
    \ now empty, we've completed a group\n                if paren_stack.is_empty()\
    \ {\n                    // Save that group in the groups accumulator\n      \
    \              groups.push(group_string);\n                    // And reset the\
    \ group accumulator for the next group\n                    group_string = String::new();\n\
    \                }\n            }\n            whitespace => {\n             \
    \   // Ignore whitespace\n            }\n            _ => {\n                //\
    \ The input had an unexpected character, so return an empty vector\n         \
    \       return Vec::new();\n            }\n        }\n    }\n\n    // When the\
    \ loop completes, return the vector of parsed groups\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp6jhlo196.rs:67:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let iter = paren_string.chars();\n    let mut res = Vec::new();\n    let\
    \ mut cur_string = String::new();\n    let mut balance = 0;\n    for x in iter\
    \ {\n        if x == '(' {\n            balance += 1;\n            cur_string.push(x);\n\
    \        } else if x == ')' {\n            balance -= 1;\n            cur_string.push(x);\n\
    \        } else if x == ' ' {\n            continue;\n        }\n        if balance\
    \ == 0 {\n            res.push(cur_string);\n            cur_string = String::new();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut tmp_str: String =\
    \ String::new();\n    let mut open_parens: u8 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  tmp_str.clear();\n            }\n            open_parens += 1;\n          \
    \  tmp_str.push(c);\n        } else if c == ')' {\n            open_parens -=\
    \ 1;\n            tmp_str.push(c);\n            if open_parens == 0 {\n      \
    \          groups.push(tmp_str.clone());\n            }\n        }\n    }\n  \
    \  groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Preprocess the string to remove spaces\n    let paren_string = paren_string.replace(\"\
    \ \", \"\");\n\n    // If the string is empty or has an odd number of characters,\
    \ there is no solution\n    if paren_string.is_empty() || paren_string.len() %\
    \ 2 != 0 {\n        return vec![];\n    }\n\n    // Create a vector to hold the\
    \ results\n    let mut results = Vec::new();\n\n    // Create a stack to hold\
    \ the characters we're reading\n    let mut stk = vec![];\n\n    // Create a string\
    \ to hold the current group we're reading\n    let mut group = String::new();\n\
    \n    // Create a boolean to tell us if we're in the middle of reading a group\n\
    \    let mut reading_group = false;\n\n    // Loop through each character of the\
    \ string\n    for c in paren_string.chars() {\n        match c {\n           \
    \ // If the character is a left parentheses, push it to the stack\n          \
    \  '(' => {\n                // If we weren't reading a group, set reading_group\
    \ to true\n                if !reading_group {\n                    reading_group\
    \ = true;\n                }\n\n                stk.push(c);\n            }\n\
    \            // If the character is a right parentheses, pop a character from\
    \ the stack\n            ')' => {\n                // Make sure we're not trying\
    \ to pop from an empty stack\n                if stk.is_empty() {\n          \
    \          return vec![];\n                }\n\n                // Pop the character\
    \ from the stack\n                stk.pop();\n\n                // If we've emptied\
    \ the stack, add the group to the results and reset the group and reading_group\
    \ booleans\n                if stk.is_empty() {\n                    results.push(group.clone());\n\
    \                    group = String::new();\n                    reading_group\
    \ = false;\n                }\n            }\n            // If the character\
    \ is anything else, the input is invalid\n            _ => return vec![],\n  \
    \      }\n\n        // If we're reading a group, add the character to the group\n\
    \        if reading_group {\n            group.push(c);\n        }\n    }\n\n\
    \    // If the stack is not empty after we've run through the whole string, the\
    \ input is invalid\n    if\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpn64z5xhe.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659976037
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut counter = 0;\n    let mut current_string\
    \ = String::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            counter += 1;\n        } else if c == ')' {\n            counter\
    \ -= 1;\n        }\n        if c != ' ' {\n            current_string.push(c);\n\
    \        }\n        if counter == 0 {\n            result.push(current_string);\n\
    \            current_string = String::new();\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmptclspq5s.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| *c != ' ')\n        .fold(\n\
    \            (Vec::new(), 0),\n            |(mut paren_groups, mut current_group_idx),\
    \ c| {\n                if c == '(' {\n                    if current_group_idx\
    \ == paren_groups.len() {\n                        paren_groups.push(String::new());\n\
    \                    }\n                    paren_groups[current_group_idx].push(c);\n\
    \                    (paren_groups, current_group_idx + 1)\n                }\
    \ else {\n                    paren_groups[current_group_idx - 1].push(c);\n \
    \                   (paren_groups, current_group_idx - 1)\n                }\n\
    \            },\n        )\n        .0\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()()()\", \"()()()()()()\", \"()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpde28z_1k.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut v: Vec<String> = Vec::new();\n    let mut current_str = String::new();\n\
    \    let mut open_paren_count = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            open_paren_count += 1;\n            current_str.push(c);\n\
    \        } else if c == ')' {\n            open_paren_count -= 1;\n          \
    \  current_str.push(c);\n            if open_paren_count == 0 {\n            \
    \    v.push(current_str);\n                current_str = String::new();\n    \
    \        }\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current: String =\
    \ String::new();\n    let mut i: usize = 0;\n    while i < paren_string.len()\
    \ {\n        if i < paren_string.len() - 1 && paren_string.get(i..i + 2) == Some(\"\
    ()\") {\n            result.push(String::from(\"()\"));\n            i += 2;\n\
    \        } else if paren_string.get(i..i + 1) == Some(\"(\") {\n            current.push('(');\n\
    \            i += 1;\n        } else if paren_string.get(i..i + 1) == Some(\"\
    )\") {\n            current.push(')');\n            result.push(current);\n  \
    \          current = String::new();\n            i += 1;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\", \"(()\", \")\", \"()\", \"()\", \"(()\", \"\
    ()\", \"()\", \")\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpk6x60vp1.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Separate groups are balanced (each open brace is properly closed) and\
    \ not nested within each other\n    // Ignore any spaces in the input string.\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzy7hpeug.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut curr_group = String::new();\n  \
    \  let mut group_vec = Vec::new();\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            stack.push(c);\n            curr_group.push(c);\n\
    \        } else if c == ')' {\n            match stack.pop() {\n             \
    \   Some(_) => curr_group.push(c),\n                None => panic!(\"Not valid\"\
    ),\n            }\n            if stack.is_empty() {\n                group_vec.push(curr_group);\n\
    \                curr_group = String::new();\n            }\n        }\n    }\n\
    \    group_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut start = 0;\n    let mut paren_count\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            if paren_count == 0 {\n                start = i;\n     \
    \       }\n            paren_count += 1;\n        } else if c == ')' {\n     \
    \       paren_count -= 1;\n            if paren_count == 0 {\n               \
    \ result.push(paren_string[start..=i].chars().filter(|c| *c != ' ').collect());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string;\n    let mut result: Vec<String> = Vec::new();\n\
    \    while paren_string.len() > 0 {\n        match paren_string.find('(') {\n\
    \            Some(next_pos) => {\n                paren_string = paren_string.split_off(next_pos);\n\
    \                match find_closing_paren(&paren_string) {\n                 \
    \   Some(close_pos) => {\n                        result.push(paren_string.split_off(0..close_pos\
    \ + 1));\n                    }\n                    None => panic!(\"No matching\
    \ closing paren\"),\n                }\n            }\n            None => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_closing_paren` in this scope\n\
    \  --> /tmp/tmpoprx0x2r.rs:14:23\n   |\n14 |                 match find_closing_paren(&paren_string)\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoprx0x2r.rs:16:60\n   |\n16 |  \
    \                       result.push(paren_string.split_off(0..close_pos + 1));\n\
    \   |                                                            ^^^^^^^^^^^^^^^^\
    \ expected `usize`, found struct `std::ops::Range`\n   |\n   = note: expected\
    \ type `usize`\n            found struct `std::ops::Range<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976037
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .split(|c| c == ' ')\n        .filter(|&s| !s.is_empty())\n\
    \        .map(|s| s.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \")\", \"((\", \"))\", \"((\", \")(\", \"))\"]`,\n right: `[\"()\"\
    , \"(())\", \"(()())\"]`', /tmp/tmpc5sofku3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut\
    \ buffer: String = String::new();\n    let mut temp_stack: Vec<String> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            temp_stack.push(String::from(\"\
    (\"));\n        } else if c == ')' {\n            temp_stack.pop();\n        \
    \    if temp_stack.is_empty() {\n                paren_groups.push(buffer.clone());\n\
    \                buffer.clear();\n            }\n        } else if c == ' ' {\n\
    \            continue;\n        } else {\n            buffer.push(c);\n      \
    \  }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpx6d7mp5r.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_parens = 0;\n    let mut result = Vec::new();\n    let mut current_group\
    \ = String::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            open_parens += 1;\n            current_group.push(c);\n        }\
    \ else if c == ')' {\n            open_parens -= 1;\n            current_group.push(c);\n\
    \            if open_parens == 0 {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut open_parens: u8 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  current_group.push(c);\n            }\n            open_parens += 1;\n    \
    \    } else if c == ')' {\n            open_parens -= 1;\n            if open_parens\
    \ == 0 {\n                current_group.push(c);\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if c != ' ' {\n            current_group.push(c);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpix4_zw4y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Break down groups of nested parentheses in {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Break down groups of nested
    parentheses in (()()) ((())) () ((())()())'', /tmp/tmp64bzh836.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n    let mut\
    \ paren_groups: Vec<String> = Vec::new();\n    let mut start_group: usize = 0;\n\
    \    let mut next_group: usize = 0;\n    while next_group < paren_vec.len() {\n\
    \        if paren_vec[next_group] == '(' {\n            start_group = next_group;\n\
    \            next_group += 1;\n            while paren_vec[next_group] != ')'\
    \ {\n                next_group += 1;\n            }\n            let mut paren_group:\
    \ String = String::new();\n            for paren in paren_vec[start_group..=next_group].iter()\
    \ {\n                paren_group.push(*paren);\n            }\n            paren_groups.push(paren_group);\n\
    \        }\n        next_group += 1;\n    }\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \"((()\", \"()\", \"((()\", \"()\", \"()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpfkqcqjan.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res: Vec<String> = Vec::new();\n    let mut stack: Vec<char> = Vec::new();\n\
    \    let mut tmp_string: String = String::new();\n    let mut prev_char: char\
    \ = ')';\n\n    for c in paren_string.chars() {\n        match c {\n         \
    \   ' ' => {},\n            '(' => {\n                if prev_char == ')' {\n\
    \                    res.push(tmp_string);\n                    tmp_string = String::new();\n\
    \                }\n                stack.push(c);\n            },\n         \
    \   ')' => {\n                if let Some(pop) = stack.pop() {\n             \
    \       if pop != '(' {\n                        res.push(tmp_string);\n     \
    \                   tmp_string = String::new();\n                    }\n     \
    \           }\n            },\n            _ => {},\n        }\n        prev_char\
    \ = c;\n        tmp_string.push(c);\n    }\n    res.push(tmp_string);\n    res\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"(()\", \"()) ((())) () ((())\", \"()\", \"())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmppi01xdrm.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut out: Vec<String> = Vec::new();\n    let mut temp_string = String::new();\n\
    \    let mut paren_group_count = 0;\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            paren_group_count += 1;\n        } else if c\
    \ == ')' {\n            paren_group_count -= 1;\n        }\n        if paren_group_count\
    \ == 0 {\n            if !temp_string.is_empty() {\n                out.push(temp_string);\n\
    \                temp_string = String::new();\n            }\n        } else {\n\
    \            temp_string.push(c);\n        }\n    }\n    out\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpm72d8s15.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    let mut start = 0;\n    let\
    \ mut end = 0;\n    let mut open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                open_parens += 1;\n\
    \                if open_parens == 1 {\n                    start = end;\n   \
    \             }\n            }\n            ')' => {\n                open_parens\
    \ -= 1;\n                if open_parens == 0 {\n                    output.push(paren_string[start..end].to_string());\n\
    \                }\n            }\n            _ => {}\n        }\n        end\
    \ += 1;\n    }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpikegn5u2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut this_group = String::new();\n\
    \    let mut paren_depth = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                paren_depth += 1;\n             \
    \   this_group.push(c);\n            }\n            ')' => {\n               \
    \ paren_depth -= 1;\n                this_group.push(c);\n                if paren_depth\
    \ == 0 {\n                    result.push(this_group);\n                    this_group\
    \ = String::new();\n                }\n            }\n            _ => {}\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut paren_string = paren_string.trim().to_string();\n\
    \    while paren_string.len() > 0 {\n        let mut paren_count = 0;\n      \
    \  let mut output_string = String::new();\n        let mut chars = paren_string.chars();\n\
    \        while let Some(c) = chars.next() {\n            if c == '(' {\n     \
    \           paren_count += 1;\n                output_string.push(c);\n      \
    \      } else if c == ')' {\n                paren_count -= 1;\n             \
    \   output_string.push(c);\n            } else if c == ' ' {\n               \
    \ continue;\n            } else {\n                panic!(\"Unexpected character\
    \ found\");\n            }\n            if paren_count == 0 {\n              \
    \  break;\n            }\n        }\n        result.push(output_string);\n   \
    \     paren_string = chars.collect();\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut buf = String::new();\n    let mut ret = Vec::new();\n    let mut\
    \ open_parens = 0;\n    for c in paren_string.chars() {\n        if open_parens\
    \ == 0 && c != '(' {\n            continue;\n        }\n        match c {\n  \
    \          '(' => {\n                open_parens += 1;\n                buf.push(c);\n\
    \            }\n            ')' => {\n                open_parens -= 1;\n    \
    \            buf.push(c);\n                if open_parens == 0 {\n           \
    \         ret.push(buf);\n                    buf = String::new();\n         \
    \       }\n            }\n            _ => {}\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Convert the String to a char Vec\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_count = 0;\n    let mut new_string = String::new();\n    let\
    \ mut out_vec = Vec::new();\n\n    for i in 0..chars.len() {\n        match chars[i]\
    \ {\n            '(' => {\n                paren_count += 1;\n               \
    \ new_string.push('(');\n            }\n            ')' => {\n               \
    \ if paren_count > 0 {\n                    paren_count -= 1;\n              \
    \      new_string.push(')');\n                } else {\n                    //\
    \ This is the closing bracket that matches the first opening bracket, so\n   \
    \                 // push the string to the output vector, and start a new string\n\
    \                    out_vec.push(new_string);\n                    new_string\
    \ = String::new();\n                }\n            }\n            _ => (),\n \
    \       }\n    }\n\n    if !new_string.is_empty() {\n        out_vec.push(new_string);\n\
    \    }\n\n    out_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpmv32v7u_.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut group: String = String::new();\n\
    \    let mut paren_depth: i32 = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            paren_depth += 1;\n            group.push(c);\n\
    \        } else if c == ')' {\n            paren_depth -= 1;\n            group.push(c);\n\
    \            if paren_depth == 0 {\n                groups.push(group);\n    \
    \            group = String::new();\n            }\n        } else if c == ' '\
    \ {\n            continue;\n        } else {\n            group.push(c);\n   \
    \     }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    let mut last_start: usize\
    \ = 0;\n    let mut paren_count: u32 = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \            }\n            ')' => {\n                paren_count -= 1;\n    \
    \            if paren_count == 0 {\n                    output.push(paren_string[last_start..=i].to_string());\n\
    \                    last_start = i + 1;\n                }\n            }\n \
    \           _ => (),\n        }\n    }\n    output\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmplugz2dfk.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    return Vec::new();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpmyvlacx4.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Write code here\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut counter = 0;\n    let mut prev = 0;\n    let mut result = Vec::new();\n\
    \    for (i, c) in chars.iter().enumerate() {\n        match c {\n           \
    \ '(' => counter += 1,\n            ')' => counter -= 1,\n            _ => (),\n\
    \        }\n        if counter == 0 {\n            result.push(paren_string[prev..=i].to_string());\n\
    \            prev = i + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmphh4c7tll.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO\n    Vec::new()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpsox3ntno.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate nested parens into separate groups {}\", paren_string)\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate nested parens into
    separate groups (()()) ((())) () ((())()())'', /tmp/tmpxaip6bmw.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ ctr = 0;\n    let mut start = 0;\n    let mut end = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            stack.push(ctr);\n        } else if c\
    \ == ')' {\n            stack.pop();\n        }\n\n        if stack.is_empty()\
    \ {\n            end = ctr;\n            output.push(paren_string[start..end +\
    \ 1].to_string());\n            start = ctr + 1;\n        }\n        ctr += 1;\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp3h4o73mh.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack = Vec::new();\n    let mut str_stack = Vec::new();\n\
    \    let mut new_str = String::new();\n    let mut result = Vec::new();\n\n  \
    \  for ch in paren_string.chars() {\n        if ch == '(' {\n            if let\
    \ Some(c) = paren_stack.last() {\n                if *c == '(' {\n           \
    \         str_stack.push(new_str);\n                    new_str = String::new();\n\
    \                }\n            }\n            paren_stack.push(ch);\n       \
    \ } else if ch == ')' {\n            if let Some(c) = paren_stack.last() {\n \
    \               if *c == '(' {\n                    paren_stack.pop();\n     \
    \               if paren_stack.is_empty() {\n                        result.push(new_str);\n\
    \                        new_str = String::new();\n                    }\n   \
    \             }\n            }\n        } else if ch != ' ' {\n            new_str.push(ch);\n\
    \        }\n    }\n\n    if !new_str.is_empty() {\n        result.push(new_str);\n\
    \    }\n\n    if !str_stack.is_empty() {\n        new_str = str_stack.pop().unwrap();\n\
    \        while !str_stack.is_empty() {\n            new_str = format!(\"{}{}\"\
    , str_stack.pop().unwrap(), new_str);\n        }\n        result.push(new_str);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmp_9fybe_j.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut temp = String::new();\n    let\
    \ mut remaining_open = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            remaining_open += 1;\n            temp.push(c);\n       \
    \ } else if c == ')' {\n            remaining_open -= 1;\n            temp.push(c);\n\
    \            if remaining_open == 0 {\n                result.push(temp);\n  \
    \              temp = String::new();\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .replace(\" \", \"\")\n        .chars()\n        .fold(Vec::new(),\
    \ |mut acc, c| {\n            match c {\n                '(' => acc.push(String::new()),\n\
    \                ')' => {\n                    let n = acc.len();\n          \
    \          acc[n - 1].push(c);\n                    acc.push(acc.remove(n - 1));\n\
    \                }\n                _ => acc[acc.len() - 1].push(c),\n       \
    \     }\n            acc\n        })\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0499]: cannot borrow `acc` as mutable more than once at a time\n\
    \  --> /tmp/tmphtwfax7f.rs:17:30\n   |\n17 |                     acc.push(acc.remove(n\
    \ - 1));\n   |                     ---------^^^^^^^^^^^^^^^^^-\n   |         \
    \            |   |    |\n   |                     |   |    second mutable borrow\
    \ occurs here\n   |                     |   first borrow later used by call\n\
    \   |                     first mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmphtwfax7f.rs:17:30\n   |\n17\
    \ |                     acc.push(acc.remove(n - 1));\n   |                   \
    \           ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local as the argument\
    \ to this call\n  --> /tmp/tmphtwfax7f.rs:17:21\n   |\n17 |                  \
    \   acc.push(acc.remove(n - 1));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0502]: cannot borrow `acc` as immutable because it is also borrowed as\
    \ mutable\n  --> /tmp/tmphtwfax7f.rs:19:26\n   |\n19 |                 _ => acc[acc.len()\
    \ - 1].push(c),\n   |                      ----^^^^^^^^^-----\n   |          \
    \            |   |\n   |                      |   immutable borrow occurs here\n\
    \   |                      mutable borrow occurs here\n   |                  \
    \    mutable borrow later used here\n   |\nhelp: try adding a local storing this...\n\
    \  --> /tmp/tmphtwfax7f.rs:19:26\n   |\n19 |                 _ => acc[acc.len()\
    \ - 1].push(c),\n   |                          ^^^^^^^^^\nhelp: ...and then using\
    \ that local here\n  --> /tmp/tmphtwfax7f.rs:19:22\n   |\n19 |               \
    \  _ => acc[acc.len() - 1].push(c),\n   |                      ^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0499, E0502.\nFor more information about an error, try `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_string: Vec<char> = paren_string.chars().filter(|c| *c != ' ').collect();\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group\
    \ = String::new();\n    let mut nesting = 0;\n    for c in paren_string {\n  \
    \      match c {\n            '(' => {\n                nesting += 1;\n      \
    \          paren_group.push(c);\n            }\n            ')' => {\n       \
    \         nesting -= 1;\n                paren_group.push(c);\n              \
    \  if nesting == 0 {\n                    paren_groups.push(paren_group);\n  \
    \                  paren_group = String::new();\n                }\n         \
    \   }\n            _ => panic!(\"Input string contains characters other than (\
    \ and )\"),\n        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec: Vec<String> = Vec::new();\n    let mut temp: String = String::new();\n\
    \    let mut num_open: u8 = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            num_open += 1;\n            temp.push(c);\n        }\
    \ else if c == ')' {\n            num_open -= 1;\n            temp.push(c);\n\
    \        } else if c != ' ' {\n            return vec![];\n        }\n       \
    \ if num_open == 0 && temp.len() > 0 {\n            vec.push(temp.clone());\n\
    \            temp.clear();\n        }\n    }\n    if num_open != 0 || temp.len()\
    \ > 0 {\n        return vec![];\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut results = Vec::new();\n    let mut\
    \ t = String::new();\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            stack.push(0);\n            t.push(c);\n        } else if c ==\
    \ ')' {\n            if let Some(_) = stack.pop() {\n                t.push(c);\n\
    \                if stack.is_empty() {\n                    results.push(t);\n\
    \                    t = String::new();\n                }\n            }\n  \
    \      }\n    }\n    results\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO - implement this function\n    vec![]\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpa8y8k9rn.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut last_close = 0;\n\
    \    let mut paren_count = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n            if paren_count == 0 {\n\
    \                groups.push(paren_string[last_close..i+1].to_string());\n   \
    \             last_close = i+1;\n            }\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpi_pec8fl.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut stack: Vec<char> =\
    \ Vec::new();\n    let mut curr_group: String = String::new();\n    for i in paren_string.chars()\
    \ {\n        if i == ' ' {\n            continue;\n        } else if i == '('\
    \ {\n            stack.push(i);\n            curr_group.push(i);\n        } else\
    \ if i == ')' {\n            if stack.pop().unwrap() == '(' {\n              \
    \  curr_group.push(i);\n                if stack.is_empty() {\n              \
    \      groups.push(curr_group);\n                    curr_group = String::new();\n\
    \                }\n            } else {\n                return vec![];\n   \
    \         }\n        }\n    }\n    if !stack.is_empty() {\n        return vec![];\n\
    \    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_count = 0;\n    let mut closed_count = 0;\n    let mut result:\
    \ Vec<String> = Vec::new();\n    let mut current_str = String::new();\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            open_count +=\
    \ 1;\n        } else if c == ')' {\n            closed_count += 1;\n        }\n\
    \        if open_count == closed_count {\n            if open_count != 0 {\n \
    \               result.push(current_str);\n                current_str = String::new();\n\
    \            }\n            open_count = 0;\n            closed_count = 0;\n \
    \       } else {\n            current_str.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpnb7pkba3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut close_paren_count = 0;\n    let mut result: Vec<String> = Vec::new();\n\
    \    let mut current_group: String = String::new();\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                if close_paren_count\
    \ > 0 {\n                    result.push(current_group);\n                   \
    \ current_group = String::new();\n                }\n                current_group.push('(');\n\
    \                close_paren_count = 0;\n            }\n            ')' => {\n\
    \                current_group.push(')');\n                close_paren_count +=\
    \ 1;\n            }\n            _ => (),\n        }\n    }\n    result.push(current_group);\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp200eygxo.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut l\
    \ = 0;\n    let mut ret = String::new();\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            i += 1;\n        } else if c == ')' {\n  \
    \          i -= 1;\n        }\n        ret.push(c);\n        if i == 0 {\n   \
    \         res.push(ret);\n            ret = String::new();\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpbw_9_6_a.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_str: String\
    \ = String::new();\n    let mut counter: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            counter += 1;\n            current_str.push(c);\n\
    \        } else if c == ')' {\n            counter -= 1;\n            current_str.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        }\n        if counter\
    \ == 0 {\n            result.push(current_str);\n            current_str = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| *c != ' ')\n        .fold(vec![String::new()],\
    \ |mut groups, c| {\n            if c == '(' {\n                groups.push(String::new());\n\
    \            } else if let Some(g) = groups.last_mut() {\n                g.push(c);\n\
    \            }\n            groups\n        })\n        .into_iter()\n       \
    \ .filter(|g| g.contains(')'))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")\", \"))\", \")))\", \")\", \"))\", \")\", \"))\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp_aqmbl1j.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut num_open_parens = 0;\n    let mut last_open_paren = 0;\n    let mut\
    \ group_strings = Vec::new();\n    for (idx, ch) in paren_string.chars().enumerate()\
    \ {\n        match ch {\n            '(' => {\n                num_open_parens\
    \ += 1;\n                if num_open_parens == 1 {\n                    last_open_paren\
    \ = idx;\n                }\n            }\n            ')' => {\n           \
    \     num_open_parens -= 1;\n                if num_open_parens == 0 {\n     \
    \               group_strings.push(\n                        paren_string\n  \
    \                          .chars()\n                            .skip(last_open_paren)\n\
    \                            .take(idx - last_open_paren + 1)\n              \
    \              .collect(),\n                    );\n                }\n      \
    \      }\n            _ => (),\n        }\n    }\n    group_strings\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpp_pw9pk6.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_list: Vec<String> = Vec::new();\n    let mut index = 0;\n \
    \   let mut paren_count = 0;\n    let mut start_index = 0;\n    let mut string_length\
    \ = paren_string.len();\n    while index < string_length {\n        if &paren_string[index..index\
    \ + 1] == \" \" {\n            index += 1;\n            continue;\n        }\n\
    \        if &paren_string[index..index + 1] == \"(\" {\n            if paren_count\
    \ == 0 {\n                start_index = index;\n            }\n            paren_count\
    \ += 1;\n        } else if &paren_string[index..index + 1] == \")\" {\n      \
    \      paren_count -= 1;\n            if paren_count == 0 {\n                paren_list.push(paren_string[start_index..index\
    \ + 1].to_string());\n            }\n        }\n        index += 1;\n    }\n \
    \   paren_list\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp42whtg6m.rs:39:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut start = 0;\n    let\
    \ mut num_open_parens = 0;\n    for (i, char) in paren_string.chars().enumerate()\
    \ {\n        if char == '(' {\n            num_open_parens += 1;\n        } else\
    \ if char == ')' {\n            num_open_parens -= 1;\n        }\n\n        if\
    \ num_open_parens == 0 {\n            groups.push(paren_string[start..i + 1].to_string());\n\
    \            start = i + 1;\n        }\n    }\n    groups\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpif9wa7uc.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut tokens = Vec::new();\n    let mut last_token = \"\".to_string();\n\
    \    for c in paren_string.chars() {\n        if c == ' ' {\n            continue;\n\
    \        }\n        if c == '(' {\n            if last_token.len() > 0 {\n   \
    \             tokens.push(last_token);\n            }\n            last_token\
    \ = \"(\".to_string();\n        } else if c == ')' {\n            last_token.push(')');\n\
    \            tokens.push(last_token);\n            last_token = \"\".to_string();\n\
    \        } else {\n            panic!(\"Unexpected character in string: {}\",\
    \ c);\n        }\n    }\n    tokens\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"()\", \"()\", \")\", \"(\", \"(\", \"()\", \")\", \")\", \"()\",\
    \ \"(\", \"(\", \"()\", \")\", \"()\", \"()\", \")\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpyaexdr6a.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    let mut st = String::new();\n    let mut cnt\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   cnt += 1;\n            st.push(c);\n        } else if c == ')' {\n       \
    \     cnt -= 1;\n            st.push(c);\n        }\n        if cnt == 0 && st.len()\
    \ > 0 {\n            res.push(st.clone());\n            st.clear();\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_vector: Vec<String> = Vec::new();\n    // code here\n    paren_vector\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpo0y37cwi.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Use a stack to solve this\n    // push open braces to the stack and pop\
    \ them when we encounter closed ones.\n    // if the stack is empty and we encounter\
    \ a closed brace, then we have encountered the end of a group\n    // if we encounter\
    \ a closed brace and the stack is not empty, then we encountered a nested group\n\
    \    // when we encounter the end of the string and the stack is empty, we encountered\
    \ the end of a group\n    let mut out_vec = Vec::new();\n    let mut inner_stack\
    \ = Vec::new();\n    let mut result_str = String::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            // push open parenthesis to the stack\n\
    \            inner_stack.push(c);\n            result_str.push(c);\n        }\
    \ else if c == ')' {\n            // pop a parenthesis from the stack\n      \
    \      if inner_stack.is_empty() {\n                // we reached the end of a\
    \ group, push the string to the vector, and reset the result string\n        \
    \        out_vec.push(result_str);\n                result_str = String::new();\n\
    \            } else {\n                // we have not reached the end of a group,\
    \ pop a parenthesis from the stack\n                // and add to the result string\n\
    \                inner_stack.pop();\n                result_str.push(c);\n   \
    \         }\n        }\n    }\n    if !inner_stack.is_empty() {\n        // we\
    \ encountered an error where the number of open and closed parentheses was not\
    \ equal\n        panic!(\"Your input string is not balanced!\");\n    }\n    if\
    \ !result_str.is_empty() {\n        // we have one more result to push to the\
    \ vector, do so\n        out_vec.push(result_str);\n    }\n    out_vec\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpnvk1jpmn.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut in_parentheses = false;\n    let mut group = String::new();\n   \
    \ let mut groups = Vec::new();\n    for c in paren_string.chars() {\n        if\
    \ in_parentheses {\n            if c == ')' {\n                groups.push(group);\n\
    \                group = String::new();\n                in_parentheses = false;\n\
    \            } else {\n                group.push(c);\n            }\n       \
    \ } else {\n            if c == '(' {\n                in_parentheses = true;\n\
    \            }\n        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"\", \"((\", \"\", \"((\", \"\", \"\"]`,\n right: `[\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"]`', /tmp/tmp8lz5pfz5.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ prev = 'x';\n\n    for c in paren_string.chars() {\n        if c == ' ' {\n\
    \            continue;\n        }\n        match c {\n            '(' => {\n \
    \               stack.push(c);\n            }\n            ')' => {\n        \
    \        stack.pop();\n                if stack.is_empty() {\n               \
    \     result.push(paren_string[prev.len_utf8()..c.len_utf8() + 1].to_string());\n\
    \                }\n            }\n            _ => panic!(\"Unexpected character\
    \ {}\", c),\n        }\n        prev = c;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"(\", \"(\", \"(\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmpzc3ixoqn.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack = vec![];\n    let mut paren_groups = vec![];\n    let\
    \ mut start_index = 0;\n    for (index, paren) in paren_string.chars().enumerate()\
    \ {\n        match paren {\n            '(' => paren_stack.push(paren),\n    \
    \        ')' => {\n                if paren_stack.len() > 0 {\n              \
    \      paren_stack.pop();\n                } else {\n                    panic!(\"\
    Attempting to close a parenthesis when stack is empty!\");\n                }\n\
    \            }\n            _ => {\n                //do nothing\n           \
    \ }\n        }\n        if paren_stack.len() == 0 {\n            paren_groups.push(paren_string[start_index..=index].to_string());\n\
    \            start_index = index + 1;\n        }\n    }\n    paren_groups\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkesaeyi0.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string;\n    let mut result: Vec<String> = Vec::new();\n\
    \    while paren_string.len() > 0 {\n        let group = balanced_parens(&paren_string).unwrap();\n\
    \        paren_string = paren_string.replacen(&group, \"\", 1);\n        paren_string\
    \ = paren_string.replacen(\" \", \"\", group.len());\n        result.push(group);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `balanced_parens` in this scope\n  -->\
    \ /tmp/tmp7362jegh.rs:11:21\n   |\n11 |         let group = balanced_parens(&paren_string).unwrap();\n\
    \   |                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut word = String::new();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for letter in paren_string.chars()\
    \ {\n        if letter == '(' {\n            stack.push(letter);\n        } else\
    \ if letter == ')' {\n            match stack.pop() {\n                Some(open_paren)\
    \ => {\n                    if open_paren == '(' {\n                        word.push(open_paren);\n\
    \                        word.push(letter);\n                    }\n         \
    \       }\n                None => (),\n            }\n        } else if letter\
    \ == ' ' {\n            if !word.is_empty() {\n                result.push(word.clone());\n\
    \                word.clear();\n            }\n        }\n    }\n    if !word.is_empty()\
    \ {\n        result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()()\", \"()()()\", \"()\", \"()()()()()\"]`,\n right: `[\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"]`', /tmp/tmp9hx9hzp8.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpcqxjcq7p.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut buffer = String::new();\n    let mut split_groups = Vec::new();\n\
    \    let mut open_parens = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_parens += 1;\n        } else if c == ')' {\n  \
    \          open_parens -= 1;\n        }\n        if c == ' ' {\n            continue;\n\
    \        } else if open_parens == 0 {\n            split_groups.push(buffer);\n\
    \            buffer = String::new();\n        } else {\n            buffer.push(c);\n\
    \        }\n    }\n    split_groups.push(buffer);\n    split_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\", \"\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpg8uc086y.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut next_paren_group:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            next_paren_group.push(c);\n\
    \        } else if c == ')' {\n            open_parens -= 1;\n            next_paren_group.push(c);\n\
    \            if open_parens == 0 {\n                paren_groups.push(next_paren_group);\n\
    \                next_paren_group = String::new();\n            }\n        }\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec: Vec<String> = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut count: i8 = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            count += 1;\n        } else if c == ')' {\n          \
    \  count -= 1;\n        }\n\n        if count == 0 {\n            if !current_string.is_empty()\
    \ {\n                vec.push(current_string);\n                current_string\
    \ = String::new();\n            }\n        } else {\n            current_string.push(c);\n\
    \        }\n    }\n    if !current_string.is_empty() {\n        vec.push(current_string);\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp94e6jrw3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp_rjyxurp.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|x| *x != ' ')\n        .filter(|x|\
    \ *x == '(' || *x == ')')\n        .fold(\n            (0, Vec::new(), String::new()),\n\
    \            |(depth, mut vec, mut str), x| {\n                if x == '(' {\n\
    \                    str.push(x);\n                    (depth + 1, vec, str)\n\
    \                } else if x == ')' {\n                    str.push(x);\n    \
    \                if depth == 1 {\n                        vec.push(str);\n   \
    \                     (0, vec, String::new())\n                    } else {\n\
    \                        (depth - 1, vec, str)\n                    }\n      \
    \          } else {\n                    panic!(\"This should never happen\");\n\
    \                }\n            },\n        )\n        .1\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    if paren_string.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ word = String::new();\n    let mut words = Vec::new();\n    let mut paren_depth\
    \ = 0;\n    for ch in paren_string.chars() {\n        if ch == ' ' {\n       \
    \     continue;\n        }\n        match ch {\n            '(' => {\n       \
    \         if paren_depth == 0 {\n                    if word.len() > 0 {\n   \
    \                     words.push(word);\n                        word = String::new();\n\
    \                    }\n                }\n                paren_depth += 1;\n\
    \                word.push(ch);\n            }\n            ')' => {\n       \
    \         paren_depth -= 1;\n                word.push(ch);\n                if\
    \ paren_depth == 0 {\n                    words.push(word);\n                \
    \    word = String::new();\n                }\n            }\n            _ =>\
    \ {\n                word.push(ch);\n            }\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate_paren_groups({:?})\", paren_string)\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate_paren_groups("(()())
    ((())) () ((())()())")'', /tmp/tmp0n_awjh6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"{}\", paren_string)\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: (()()) ((())) () ((())()())'',
    /tmp/tmpg7txmmkp.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // create a variable to hold the current balanced parens\n    let mut current_parens\
    \ = String::new();\n    // create a variable to hold the answer\n    let mut answer\
    \ = Vec::new();\n    // create a stack to keep track of parens\n    let mut stack\
    \ = Stack::new();\n    // iterate through the string\n    for char in paren_string.chars()\
    \ {\n        match char {\n            ' ' => (),\n            '(' => {\n    \
    \            // add the paren to the stack and to the current parens\n       \
    \         stack.push(char);\n                current_parens.push(char);\n    \
    \        }\n            ')' => {\n                // pop the stack\n         \
    \       match stack.pop() {\n                    // if there was an open paren,\
    \ add the closing paren to the current parens\n                    Some('(') =>\
    \ current_parens.push(char),\n                    // if the stack is empty, we\
    \ have an error\n                    None => panic!(\"There are no parens left\
    \ to close!\"),\n                    // if there was another char, the parens\
    \ don't match up\n                    Some(_) => panic!(\"The parens are mismatched!\"\
    ),\n                }\n                // if the stack is empty, push the current\
    \ parens to the answer\n                if stack.is_empty() {\n              \
    \      answer.push(current_parens.clone());\n                    current_parens.clear();\n\
    \                }\n            }\n            _ => panic!(\"There are no other\
    \ chars allowed in this string!\"),\n        }\n    }\n    // if the stack is\
    \ not empty, we have an error\n    if !stack.is_empty() {\n        panic!(\"There\
    \ were open parens that were not closed\");\n    }\n    // return the answer\n\
    \    answer\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpnc81g21_.rs:13:21\n   |\n13 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // write the code here\n    let mut groups: Vec<String> = Vec::new();\n \
    \   let mut current_group: String = String::new();\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        if c == ' ' {\n\
    \            continue;\n        }\n        if c == '(' {\n            stack.push(c);\n\
    \            current_group.push(c);\n        } else if c == ')' {\n          \
    \  if stack.is_empty() {\n                continue;\n            }\n         \
    \   let last_char = stack.pop().unwrap();\n            if last_char == '(' {\n\
    \                current_group.push(c);\n                if stack.is_empty() {\n\
    \                    groups.push(current_group.clone());\n                   \
    \ current_group.clear();\n                }\n            }\n        }\n    }\n\
    \    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: implement\n    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpmrdt5f03.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut current: String =\
    \ String::new();\n    let mut open: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open += 1;\n            current.push(c);\n\
    \        } else if c == ')' {\n            open -= 1;\n            current.push(c);\n\
    \            if open == 0 {\n                groups.push(current);\n         \
    \       current = String::new();\n            }\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut cur_group: String\
    \ = String::new();\n    let mut open_parens: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n            cur_group.push(c);\n\
    \        } else if c == ')' {\n            if open_parens == 0 {\n           \
    \     panic!(\"Mismatched parentheses\");\n            }\n            open_parens\
    \ -= 1;\n            cur_group.push(c);\n            if open_parens == 0 {\n \
    \               groups.push(cur_group);\n                cur_group = String::new();\n\
    \            }\n        } else if c != ' ' {\n            panic!(\"Unexpected\
    \ character {}\", c);\n        }\n    }\n    if open_parens != 0 {\n        panic!(\"\
    Mismatched parentheses\");\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let open = \"(\";\n    let close = \")\";\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut inside_paren = false;\n    for c in chars\
    \ {\n        if c == ' ' {\n            continue;\n        }\n        if c ==\
    \ '(' {\n            if inside_paren {\n                // if we're already inside\
    \ a paren, we start a new group\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n            current_group.push_str(open);\n\
    \            inside_paren = true;\n        } else if c == ')' {\n            current_group.push_str(close);\n\
    \            inside_paren = false;\n        }\n    }\n    paren_groups.push(current_group);\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"()())(\", \"(\", \"()))()(\", \"(\", \"())()())\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmph2_7p0oj.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut state = 0;\n    for c in paren_string.chars()\
    \ {\n        match state {\n            0 => {\n                if c == '(' {\n\
    \                    state = 1;\n                    current_group.push(c);\n\
    \                }\n            }\n            1 => {\n                if c ==\
    \ ')' {\n                    state = 0;\n                    current_group.push(c);\n\
    \                    paren_groups.push(current_group);\n                    current_group\
    \ = String::new();\n                } else if c == '(' {\n                   \
    \ current_group.push(c);\n                }\n            }\n            _ => (),\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \"((()\", \"()\", \"((()\", \"()\", \"()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpr07qi8hl.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res: Vec<String> = Vec::new();\n    let mut left_right_idx: Vec<usize>\
    \ = Vec::new();\n    let mut last_left_idx: usize = 0;\n    let mut count: usize\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            if count == 0 {\n                last_left_idx = i;\n   \
    \         }\n            count += 1;\n        } else if c == ')' {\n         \
    \   count -= 1;\n            if count == 0 {\n                left_right_idx.push((last_left_idx,\
    \ i + 1));\n            }\n        }\n    }\n    for (left, right) in left_right_idx\
    \ {\n        res.push(paren_string[left..right].to_string());\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5y_wfs24.rs:21:37\n   |\n\
    21 |                 left_right_idx.push((last_left_idx, i + 1));\n   |      \
    \                               ^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ tuple\n   |\n   = note: expected type `usize`\n             found tuple `(usize,\
    \ usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5y_wfs24.rs:25:9\n\
    \   |\n25 |     for (left, right) in left_right_idx {\n   |         ^^^^^^^^^^^^^\
    \    -------------- this expression has type `Option<usize>`\n   |         |\n\
    \   |         expected `usize`, found tuple\n   |\n   = note: expected type `usize`\n\
    \             found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group\
    \ = String::new();\n    let mut open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  paren_group.push('(');\n            }\n            open_parens += 1;\n    \
    \    } else if c == ')' {\n            open_parens -= 1;\n            if open_parens\
    \ == 0 {\n                paren_group.push(')');\n                paren_groups.push(paren_group);\n\
    \                paren_group = String::new();\n            }\n        }\n    }\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpjwopf7ci.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: implement me!\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4anmfkgr.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut ret: Vec<String> = Vec::new();\n    let mut cur_group: String = String::new();\n\
    \    let mut group_count: i8 = 0;\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            group_count += 1;\n            cur_group.push(c);\n\
    \        } else if c == ')' {\n            group_count -= 1;\n            cur_group.push(c);\n\
    \            if group_count == 0 {\n                ret.push(cur_group);\n   \
    \             cur_group = String::new();\n            }\n        }\n    }\n  \
    \  ret\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut out: Vec<String> = Vec::new();\n    let mut counter = 0;\n    let\
    \ mut sub = String::new();\n    for c in paren_string.chars() {\n        if c\
    \ == ' ' {\n            continue;\n        }\n        if c == '(' {\n        \
    \    counter += 1;\n        }\n        if c == ')' {\n            counter -= 1;\n\
    \        }\n        sub.push(c);\n        if counter == 0 {\n            out.push(sub);\n\
    \            sub = String::new();\n        }\n    }\n    out\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res: Vec<String> = Vec::new();\n    let mut index = 0;\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            let mut temp =\
    \ String::new();\n            let mut counter = 1;\n            let mut j = index\
    \ + 1;\n            loop {\n                if paren_string.chars().nth(j).unwrap()\
    \ == '(' {\n                    counter += 1;\n                } else if paren_string.chars().nth(j).unwrap()\
    \ == ')' {\n                    counter -= 1;\n                }\n           \
    \     if counter == 0 {\n                    res.push(temp);\n               \
    \     break;\n                }\n                temp.push(paren_string.chars().nth(j).unwrap());\n\
    \                j += 1;\n            }\n            index = j;\n        }\n \
    \       index += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpvih0qy8y.rs:16:48

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ current_str = String::new();\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n     \
    \       if let Some('(') = stack.pop() {\n                current_str.push(c);\n\
    \            }\n        } else if c == ' ' {\n            continue;\n        }\
    \ else {\n            current_str.push(c);\n        }\n        if stack.is_empty()\
    \ {\n            result.push(current_str);\n            current_str = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")))\", \")))\", \")\", \")))))\"]`,\n right: `[\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]`', /tmp/tmpiz7vhcvr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut res = Vec::new();\n    let mut start\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            stack.push(i);\n        } else if c == ')' {\n          \
    \  let idx = stack.pop().unwrap();\n            if stack.is_empty() {\n      \
    \          res.push(paren_string[idx..=i].replace(\" \", \"\"));\n           \
    \ }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate groups of nested parentheses from a String like\
    \ \\\"( ) (( )) (( )( ))\\\" into a Vec of strings: {:?}\", paren_string)\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate groups of nested
    parentheses from a String like "( ) (( )) (( )( ))" into a Vec of strings: "(()())
    ((())) () ((())()())"'', /tmp/tmpn9m4w6z3.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut curr_item = String::new();\n   \
    \ let mut output = Vec::new();\n    let mut paren_count = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                stack.push(c);\n            }\n            ')' => {\n       \
    \         paren_count -= 1;\n                stack.pop();\n            }\n   \
    \         _ => {}\n        }\n\n        curr_item.push(c);\n\n        if paren_count\
    \ == 0 {\n            output.push(curr_item.clone());\n            curr_item.clear();\n\
    \        }\n    }\n\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpa8mystp_.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpcqxjcq7p.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut stack = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  if c == ' ' {\n            continue;\n        } else if c == '(' {\n      \
    \      stack.push(c);\n            current_string.push(c);\n        } else if\
    \ c == ')' {\n            stack.pop();\n            current_string.push(c);\n\
    \            if stack.is_empty() {\n                result.push(current_string.clone());\n\
    \                current_string.clear();\n            }\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut level = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                level += 1;\n                current_group.push(c);\n\
    \            }\n            ')' => {\n                level -= 1;\n          \
    \      current_group.push(c);\n                if level == 0 {\n             \
    \       result.push(current_group);\n                    current_group = String::new();\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut group_str: String\
    \ = String::new();\n    let mut group_started: bool = false;\n    let mut group_closed:\
    \ bool = false;\n    let mut num_opened: usize = 0;\n    let mut num_closed: usize\
    \ = 0;\n    for c in paren_string.chars() {\n        if c != ' ' {\n         \
    \   if !group_started {\n                group_started = true;\n            }\n\
    \            if c == '(' {\n                num_opened += 1;\n            } else\
    \ if c == ')' {\n                num_closed += 1;\n            }\n           \
    \ group_str.push(c);\n            if num_opened == num_closed {\n            \
    \    group_closed = true;\n            }\n        }\n        if group_closed {\n\
    \            result.push(group_str.clone());\n            group_str.clear();\n\
    \            group_started = false;\n            group_closed = false;\n     \
    \       num_opened = 0;\n            num_closed = 0;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate_paren_groups for '{}'\", paren_string)\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate_paren_groups for
    ''(()()) ((())) () ((())()())'''', /tmp/tmpljdamyvr.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|&c| c != ' ')\n        .fold(\n\
    \            (Vec::new(), None),\n            |(mut acc, mut chunk): (Vec<String>,\
    \ Option<String>), c| {\n                match (chunk.as_mut(), c) {\n       \
    \             (Some(s), '(') => s.push(c),\n                    (Some(s), ')')\
    \ => {\n                        s.push(c);\n                        acc.push(s.drain(..).collect());\n\
    \                        (acc, None)\n                    }\n                \
    \    (None, '(') => (acc, Some(String::new())),\n                    _ => unreachable!(),\n\
    \                }\n            },\n        )\n        .0\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp76w31mlb.rs:15:39\n   |\n\
    15 |                     (Some(s), '(') => s.push(c),\n   |                  \
    \                     ^^^^^^^^^ expected tuple, found `()`\n   |\n   = note: \
    \ expected tuple `(Vec<String>, Option<String>)`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut depth: i32 = 0;\n    for i in paren_string.chars()\
    \ {\n        match i {\n            '(' => {\n                depth += 1;\n  \
    \              current_group.push(i);\n            }\n            ')' => {\n \
    \               depth -= 1;\n                current_group.push(i);\n        \
    \        if depth == 0 {\n                    result.push(current_group);\n  \
    \                  current_group = String::new();\n                }\n       \
    \     }\n            _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    let mut curr_str = String::new();\n    let\
    \ mut paren_count = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            if paren_count == 0 {\n                curr_str.push('(');\n\
    \            }\n            paren_count += 1;\n        } else if c == ')' {\n\
    \            paren_count -= 1;\n            if paren_count == 0 {\n          \
    \      curr_str.push(')');\n                res.push(curr_str);\n            \
    \    curr_str = String::new();\n            }\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpkakfqjc9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut partial_result = String::new();\n\
    \    let mut brace_depth = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                brace_depth += 1;\n             \
    \   partial_result.push(c);\n            }\n            ')' => {\n           \
    \     brace_depth -= 1;\n                partial_result.push(c);\n           \
    \     if brace_depth == 0 {\n                    result.push(partial_result);\n\
    \                    partial_result = String::new();\n                }\n    \
    \        }\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Your code here.\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpk6qtbrri.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // start with one current string and a vector of those\n    let mut current_string\
    \ = String::new();\n    let mut result_vector = Vec::new();\n\n    // iterate\
    \ over the chars in the input string\n    for c in paren_string.chars() {\n  \
    \      // ignore spaces\n        if c == ' ' {\n            continue;\n      \
    \  }\n\n        // if opening parenthesis, keep adding to the current string\n\
    \        if c == '(' {\n            current_string.push(c);\n        }\n\n   \
    \     // if closing parenthesis\n        if c == ')' {\n            // add it\
    \ to the current string\n            current_string.push(c);\n\n            //\
    \ if the current string is a balanced paren group, add it to the vector and reset\
    \ the current string\n            if is_balanced_paren_group(&current_string)\
    \ {\n                result_vector.push(current_string.clone());\n           \
    \     current_string = String::new();\n            }\n        }\n    }\n\n   \
    \ // return the vector of strings\n    result_vector\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced_paren_group` in this scope\n\
    \  --> /tmp/tmp70p9616p.rs:30:16\n   |\n30 |             if is_balanced_paren_group(&current_string)\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut buffer: String = String::new();\n\
    \    let mut paren_depth: i32 = 0;\n    for c in paren_string.chars() {\n    \
    \    match c {\n            '(' => {\n                paren_depth += 1;\n    \
    \            buffer.push(c);\n            }\n            ')' => {\n          \
    \      paren_depth -= 1;\n                buffer.push(c);\n                if\
    \ paren_depth == 0 {\n                    result.push(buffer);\n             \
    \       buffer = String::new();\n                }\n            }\n          \
    \  _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let mut\
    \ curr_stack = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            stack.push(c);\n            curr_stack.push(c);\n    \
    \    } else if c == ')' {\n            if stack.is_empty() {\n               \
    \ return vec![];\n            }\n            stack.pop();\n            curr_stack.push(c);\n\
    \            if stack.is_empty() {\n                result.push(curr_stack.iter().collect());\n\
    \                curr_stack = Vec::new();\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut balance = 0;\n    let mut start\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        match c\
    \ {\n            '(' => balance += 1,\n            ')' => balance -= 1,\n    \
    \        _ => {}\n        }\n        if balance == 0 {\n            result.push(paren_string[start..i\
    \ + 1].to_string());\n            start = i + 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpl9yl08wb.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut collection = Vec::new();\n    let\
    \ mut group = String::new();\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n            group.push(c);\n       \
    \ } else if c == ')' {\n            if stack.pop().is_none() {\n             \
    \   continue;\n            }\n            group.push(c);\n            if stack.is_empty()\
    \ {\n                collection.push(group);\n                group = String::new();\n\
    \            }\n        }\n    }\n    collection\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut answer = Vec::new();\n    let mut\
    \ current_string = String::new();\n    for c in paren_string.chars() {\n     \
    \   if c == ' ' {\n            continue;\n        } else if c == '(' {\n     \
    \       stack.push(c);\n            current_string.push(c);\n        } else if\
    \ c == ')' {\n            current_string.push(c);\n            if stack.len()\
    \ > 0 {\n                stack.pop();\n            }\n            if stack.len()\
    \ == 0 {\n                answer.push(current_string.clone());\n             \
    \   current_string.clear();\n            }\n        }\n    }\n    answer\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut s_groups: Vec<String> = Vec::new();\n    let mut current_group: String\
    \ = String::new();\n    let mut in_group: bool = false;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                if in_group {\n\
    \                    current_group.push(c);\n                } else {\n      \
    \              in_group = true;\n                    current_group.push(c);\n\
    \                }\n            }\n            ')' => {\n                if in_group\
    \ {\n                    current_group.push(c);\n                    s_groups.push(current_group);\n\
    \                    current_group = String::new();\n                    in_group\
    \ = false;\n                }\n            }\n            _ => {}\n        }\n\
    \    }\n    return s_groups;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \"((()\", \"()\", \"((()\", \"()\", \"()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpjb86p97d.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Code up a solution to the problem in task 2 here!\")\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Code up a solution to the
    problem in task 2 here!'', /tmp/tmp3600qslo.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut char_iter = paren_string.chars();\n\
    \    let mut paren_group: String = String::new();\n    while let Some(c) = char_iter.next()\
    \ {\n        if c == '(' {\n            let mut depth = 1;\n            while\
    \ let Some(c) = char_iter.next() {\n                if c == '(' {\n          \
    \          depth += 1;\n                } else if c == ')' {\n               \
    \     depth -= 1;\n                }\n                if depth == 0 {\n      \
    \              break;\n                }\n                paren_group.push(c);\n\
    \            }\n            groups.push(paren_group);\n            paren_group\
    \ = String::new();\n        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()\", \"(())\", \"\", \"(())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp0kvf6h94.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    let mut index: usize = 0;\n\
    \    let mut current_group: String = String::new();\n    while index < paren_string.len()\
    \ {\n        let c = paren_string.chars().nth(index).unwrap();\n        if c !=\
    \ ' ' {\n            current_group.push(c);\n        }\n\n        if c == ')'\
    \ {\n            output.push(current_group);\n            current_group = String::new();\n\
    \        }\n\n        index += 1;\n    }\n\n    output\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\", \")\", \"\
    ()\", \"()\", \")\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpj4xkwjkm.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut matches: Vec<String> = Vec::new();\n    let mut paren_stack: Vec<usize>\
    \ = Vec::new();\n    let mut inner_start: usize = 0;\n    let mut inner_end: usize\
    \ = 0;\n    for (pos, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            paren_stack.push(pos);\n        } else if c == ')' {\n  \
    \          let op = paren_stack.pop().unwrap();\n            if paren_stack.is_empty()\
    \ {\n                inner_end = pos;\n                let inner = &paren_string[op..inner_end\
    \ + 1];\n                matches.push(inner.to_string());\n            }\n   \
    \     }\n    }\n    matches\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp7uo2dm5u.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut a = paren_string.chars().filter(|&x| x != ' ').collect::<Vec<char>>();\n\
    \    let mut b = Vec::new();\n    while a.len() > 0 {\n        let mut start =\
    \ 0;\n        let mut end = 0;\n        let mut count = 0;\n        for i in 0..a.len()\
    \ {\n            if a[i] == '(' {\n                if count == 0 {\n         \
    \           start = i;\n                }\n                count += 1;\n     \
    \       } else if a[i] == ')' {\n                count -= 1;\n               \
    \ if count == 0 {\n                    end = i;\n                    break;\n\
    \                }\n            }\n        }\n        b.push(a[start..end + 1].iter().collect::<String>());\n\
    \        a = a[end + 1..].to_vec();\n    }\n    b\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: Write this code!\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpfk1kiifi.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut out: Vec<String> = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut current_level = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_level += 1;\n     \
    \           current_string.push(c);\n            }\n            ')' => {\n   \
    \             current_level -= 1;\n                current_string.push(c);\n \
    \               if current_level == 0 {\n                    out.push(current_string);\n\
    \                    current_string = String::new();\n                }\n    \
    \        }\n            _ => (),\n        }\n    }\n    out\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    if paren_string.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ to_return = vec![];\n    let mut start_idx = 0;\n    let mut open_paren_counter\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            if open_paren_counter == 0 {\n                start_idx =\
    \ i;\n            }\n            open_paren_counter += 1;\n        } else if c\
    \ == ')' {\n            open_paren_counter -= 1;\n            if open_paren_counter\
    \ == 0 {\n                to_return.push(paren_string[start_idx..i + 1].to_string());\n\
    \            }\n        }\n    }\n    to_return\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp_pb9cp7l.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate groups of parens in {}\", paren_string)\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate groups of parens
    in (()()) ((())) () ((())()())'', /tmp/tmp52q35rx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group:\
    \ String = String::new();\n    let mut stack: Vec<char> = Vec::new();\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else if c == ')' {\n            if stack.len() > 0 {\n            \
    \    stack.pop();\n                paren_group.push(c);\n            }\n     \
    \       if stack.len() == 0 {\n                paren_groups.push(paren_group);\n\
    \                paren_group = String::new();\n            }\n        } else if\
    \ c != ' ' {\n            paren_group.push(c);\n        }\n    }\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")))\", \")))\", \")\", \")))))\"]`,\n right: `[\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]`', /tmp/tmp34ip65wm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut counter = 0;\n    let mut open_index = 0;\n    let mut vec_str =\
    \ Vec::new();\n    let mut tmp_str = String::new();\n    let mut char_vec: Vec<char>\
    \ = paren_string.chars().collect();\n    for i in 0..char_vec.len() {\n      \
    \  if char_vec[i] == '(' {\n            if counter == 0 {\n                open_index\
    \ = i;\n            }\n            counter += 1;\n        } else if char_vec[i]\
    \ == ')' {\n            counter -= 1;\n            if counter == 0 {\n       \
    \         for j in open_index..=i {\n                    tmp_str.push(char_vec[j]);\n\
    \                }\n                vec_str.push(tmp_str);\n                tmp_str\
    \ = String::new();\n            }\n        }\n    }\n    vec_str\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp8o6tf1th.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut opening_parens = 0;\n    let mut curr_string = String::new();\n \
    \   let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            opening_parens += 1;\n            curr_string.push(c);\n\
    \        } else if c == ')' {\n            opening_parens -= 1;\n            curr_string.push(c);\n\
    \        } else if c == ' ' {\n            continue;\n        }\n\n        if\
    \ opening_parens == 0 {\n            result.push(curr_string.clone());\n     \
    \       curr_string.clear();\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate_paren_groups({:?})\", paren_string)\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate_paren_groups("(()())
    ((())) () ((())()())")'', /tmp/tmp0n_awjh6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut groups = paren_string.split(\"\
    \ \");\n    let mut open_count = 0;\n    let mut current_group = String::new();\n\
    \    for group in groups {\n        for c in group.chars() {\n            if c\
    \ == '(' {\n                open_count += 1;\n            } else if c == ')' {\n\
    \                open_count -= 1;\n            }\n            current_group.push(c);\n\
    \            if open_count == 0 {\n                result.push(current_group.clone());\n\
    \                current_group.clear();\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut pair = Vec::new();\n    let mut\
    \ i = 0;\n    while i < paren_string.len() {\n        if paren_string.chars().nth(i)\
    \ == Some('(') {\n            pair.push(i);\n        } else if paren_string.chars().nth(i)\
    \ == Some(')') {\n            let idx = pair.pop().unwrap();\n            let\
    \ s = paren_string.chars().skip(idx).take(i-idx+1).collect::<String>();\n    \
    \        result.push(s);\n        }\n        i += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"(()())\", \"()\", \"(())\", \"((()))\", \"()\", \"()\",\
    \ \"(())\", \"()\", \"()\", \"((())()())\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpz27_i58m.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpcqxjcq7p.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut curr_paren_group:\
    \ String = String::new();\n    let mut depth: i32 = 0;\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' => {\n                depth += 1;\n \
    \               curr_paren_group.push(ch);\n            }\n            ')' =>\
    \ {\n                depth -= 1;\n                curr_paren_group.push(ch);\n\
    \                if depth == 0 {\n                    paren_groups.push(curr_paren_group);\n\
    \                    curr_paren_group = String::new();\n                }\n  \
    \          }\n            _ => {}\n        }\n    }\n    paren_groups\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut sub_string: String\
    \ = String::new();\n    let mut brace_count: u32 = 0;\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                brace_count\
    \ += 1;\n                sub_string.push('(');\n            }\n            ')'\
    \ => {\n                brace_count -= 1;\n                sub_string.push(')');\n\
    \            }\n            _ => (),\n        }\n        if brace_count == 0 {\n\
    \            result.push(sub_string);\n            sub_string = String::new();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpwgfmh45t.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate the groups of parentheses in {:?}\", paren_string)\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate the groups of parentheses
    in "(()()) ((())) () ((())()())"'', /tmp/tmp7hacjzae.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res: Vec<String> = Vec::new();\n    let mut clean_string = String::new();\n\
    \    let mut i = 0;\n    while i < paren_string.len() {\n        if paren_string.chars().nth(i).unwrap()\
    \ != ' ' {\n            clean_string.push(paren_string.chars().nth(i).unwrap());\n\
    \        }\n        i += 1;\n    }\n    let mut i = 0;\n    while i < clean_string.len()\
    \ {\n        let mut j = i;\n        let mut counter = 0;\n        let mut cur_string\
    \ = String::new();\n        while j < clean_string.len() {\n            if clean_string.chars().nth(j).unwrap()\
    \ == '(' {\n                counter += 1;\n            } else if clean_string.chars().nth(j).unwrap()\
    \ == ')' {\n                counter -= 1;\n            }\n            cur_string.push(clean_string.chars().nth(j).unwrap());\n\
    \            if counter == 0 {\n                break;\n            }\n      \
    \      j += 1;\n        }\n        res.push(cur_string);\n        i = j + 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut group_start: Option<usize>\
    \ = None;\n    let mut paren_count: i32 = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            if group_start.is_none() {\n         \
    \       group_start = Some(i);\n            }\n            paren_count += 1;\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            if paren_count\
    \ == 0 {\n                result.push(paren_string[group_start.unwrap()..i + 1].to_string());\n\
    \                group_start = None;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpx5vys3fs.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO Implement this\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3dvgejs9.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976039
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut chars = paren_string.chars();\n\
    \    let mut buffer = String::new();\n    let mut depth = 0;\n    loop {\n   \
    \     match chars.next() {\n            Some('(') => {\n                depth\
    \ += 1;\n                buffer.push('(');\n            }\n            Some(')')\
    \ => {\n                depth -= 1;\n                buffer.push(')');\n     \
    \           if depth == 0 {\n                    result.push(buffer);\n      \
    \              buffer = String::new();\n                }\n            }\n   \
    \         Some(_) => (),\n            None => break,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    let mut start = 0;\n    let mut i = 0;\n \
    \   let mut depth = 0;\n    while i < paren_string.len() {\n        match paren_string.as_bytes()[i]\
    \ {\n            b'(' => {\n                if depth == 0 {\n                \
    \    start = i;\n                }\n                depth += 1;\n            }\n\
    \            b')' => {\n                depth -= 1;\n                if depth\
    \ == 0 {\n                    res.push(paren_string[start..i + 1].to_string());\n\
    \                }\n            }\n            _ => {}\n        }\n        i +=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp86pdmnwb.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // IMPLEMENT ME!\n    let mut count = 0;\n    let mut result = Vec::new();\n\
    \    let mut temp = String::new();\n    for ch in paren_string.chars() {\n   \
    \     if ch == '(' {\n            count += 1;\n        } else if ch == ')' {\n\
    \            count -= 1;\n        }\n        if count == 0 {\n            if !temp.is_empty()\
    \ {\n                result.push(temp);\n                temp = String::new();\n\
    \            }\n        } else {\n            temp.push(ch);\n        }\n    }\n\
    \    if !temp.is_empty() {\n        result.push(temp);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp74aiql__.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut start = 0;\n    let mut in_parens\
    \ = false;\n    for (index, ch) in paren_string.chars().enumerate() {\n      \
    \  if ch == '(' {\n            if !in_parens {\n                start = index;\n\
    \            }\n            in_parens = true;\n        } else if ch == ')' {\n\
    \            if in_parens {\n                result.push(paren_string[start..=index].replace(\"\
    \ \", \"\"));\n            }\n            in_parens = false;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"()\", \"((()\", \"()\", \"((()\", \"()\", \"()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpdvkiqr0q.rs:29:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = Vec::new();\n    let mut start_index = 0;\n\
    \    let mut open_count = 0;\n    let mut close_count = 0;\n    for (i, c) in\
    \ paren_string.chars().enumerate() {\n        if c == '(' {\n            open_count\
    \ += 1;\n        } else if c == ')' {\n            close_count += 1;\n       \
    \ }\n        if open_count == close_count {\n            groups.push(paren_string[start_index..i\
    \ + 1].to_string());\n            start_index = i + 1;\n        }\n    }\n   \
    \ groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxtnj7fz3.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut working_string = String::new();\n    let mut end_string = String::new();\n\
    \    let mut result = Vec::new();\n    let working_vector: Vec<char> = paren_string.chars().collect();\n\
    \    let mut paren_count = 0;\n    for char in working_vector {\n        if char\
    \ == '(' {\n            paren_count += 1;\n        } else if char == ')' {\n \
    \           paren_count -= 1;\n        }\n        working_string.push(char);\n\
    \        if paren_count == 0 {\n            result.push(working_string);\n   \
    \         working_string = String::new();\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpx9o2oxoj.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut paren_accumulator:\
    \ String = String::new();\n    let mut paren_level: i32 = 0;\n    for character\
    \ in paren_string.chars() {\n        match character {\n            '(' => {\n\
    \                paren_level += 1;\n                paren_accumulator.push(character);\n\
    \            }\n            ')' => {\n                paren_level -= 1;\n    \
    \            paren_accumulator.push(character);\n                if paren_level\
    \ == 0 {\n                    result.push(paren_accumulator);\n              \
    \      paren_accumulator = String::new();\n                }\n            }\n\
    \            _ => { /* Ignore */ }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: Implement me!\n    let mut acc = String::new();\n    let mut result\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        if c != ' ' {\n\
    \            acc.push(c);\n        }\n    }\n    let mut valid = false;\n    let\
    \ mut c = 0;\n    let mut previous = ' ';\n    let mut new_str = String::new();\n\
    \    for c_a in acc.chars() {\n        if c_a == '(' {\n            c += 1;\n\
    \        } else if c_a == ')' {\n            c -= 1;\n        }\n        if valid\
    \ {\n            if c == 0 {\n                result.push(new_str);\n        \
    \        new_str = String::new();\n                valid = false;\n          \
    \  } else {\n                new_str.push(c_a);\n            }\n        } else\
    \ {\n            if c > 0 {\n                valid = true;\n                new_str.push(c_a);\n\
    \            }\n        }\n        previous = c_a;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp3c9vtxn4.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut s: Vec<String> = Vec::new();\n    let mut t: Vec<char> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == ' ' {\n            continue;\n\
    \        }\n        if c == '(' {\n            t.push(c);\n        } else if c\
    \ == ')' {\n            if t.len() > 0 {\n                t.pop();\n         \
    \   }\n            if t.len() == 0 {\n                s.push(String::from(\"()\"\
    ));\n            }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpubk10wfw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut current_str: String\
    \ = String::new();\n    let mut paren_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n            current_str.push(c);\n\
    \        } else if c == ')' {\n            paren_count -= 1;\n            current_str.push(c);\n\
    \            if paren_count == 0 {\n                result.push(current_str);\n\
    \                current_str = String::new();\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Stack::new();\n    let mut group_start_index = None;\n  \
    \  let mut result = Vec::new();\n\n    for (i, paren) in paren_string.chars().enumerate()\
    \ {\n        if paren == '(' {\n            // Ignore space\n            if group_start_index.is_none()\
    \ {\n                group_start_index = Some(i);\n            }\n           \
    \ stack.push(paren);\n        } else if paren == ')' {\n            if stack.is_empty()\
    \ {\n                panic!(\"unbalanced parentheses\")\n            }\n     \
    \       stack.pop();\n            if stack.is_empty() {\n                let group\
    \ = paren_string.get(group_start_index.unwrap()..i + 1).unwrap();\n          \
    \      result.push(group.to_string());\n                group_start_index = None;\n\
    \            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmp5nz4pyb8.rs:8:21\n\
    \  |\n8 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"Separate paren groups {}\", paren_string)\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate paren groups (()())
    ((())) () ((())()())'', /tmp/tmps53y7tl_.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group\
    \ = String::new();\n    let mut i = 0;\n    while i < paren_string.len() {\n \
    \       if paren_string.chars().nth(i).unwrap() == '(' {\n            let mut\
    \ open_parens = 1;\n            while open_parens > 0 {\n                if paren_string.chars().nth(i).unwrap()\
    \ == '(' {\n                    open_parens += 1;\n                } else if paren_string.chars().nth(i).unwrap()\
    \ == ')' {\n                    open_parens -= 1;\n                }\n       \
    \         paren_group.push(paren_string.chars().nth(i).unwrap());\n          \
    \      i += 1;\n            }\n            paren_groups.push(paren_group);\n \
    \           paren_group = String::new();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp3ckpfkqq.rs:15:48

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976040
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut close_parens: Vec<usize> = Vec::new();\n    let mut open_parens:\
    \ Vec<usize> = Vec::new();\n    let mut temp_paren_string = paren_string.clone();\n\
    \    // The first task is to identify and remove all spaces within the input string\n\
    \    // This might be easier as a regex if we care about performance and memory\
    \ efficiency, but here we\n    // are just looking for simplicity and clarity.\n\
    \    for i in 0..temp_paren_string.len() {\n        if temp_paren_string.chars().nth(i).unwrap()\
    \ == ' ' {\n            // We need to remove the space at i\n            temp_paren_string.remove(i);\n\
    \        }\n    }\n    // Now we need to track the location of each close and\
    \ open parenthesis, respectively\n    for i in 0..temp_paren_string.len() {\n\
    \        if temp_paren_string.chars().nth(i).unwrap() == ')' {\n            close_parens.push(i);\n\
    \        } else if temp_paren_string.chars().nth(i).unwrap() == '(' {\n      \
    \      open_parens.push(i);\n        }\n    }\n    // The next task is to build\
    \ a vector containing the indexes of the beginning and ending of each\n    //\
    \ group of parenthesis. Note that we can't use the final index of the string as\
    \ an ending point,\n    // as this would cause an out of bounds error in the case\
    \ that the string ended with a close\n    // parenthesis.\n    let mut group_indexes:\
    \ Vec<Vec<usize>> = Vec::new();\n    for i in 0..open_parens.len() {\n       \
    \ let mut temp_indexes: Vec<usize> = Vec::new();\n        temp_indexes.push(open_parens[i]);\n\
    \        temp_indexes.push(close_parens[i]);\n        group_indexes.push(temp_indexes);\n\
    \    }\n    // Now we actually build the vector of parenthesis groups.\n    let\
    \ mut separated_groups: Vec<String> = Vec::new();\n    for i in 0..group_indexes.len()\
    \ {\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgp7quyjs.rs:50:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n41 |     for i in 0..group_indexes.len() {\n   |           \
    \                          - this delimiter might not be properly closed...\n\
    42 | }\n   | - ...as it matches this but it has different indentation\n...\n50\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpgp7quyjs.rs:7:51\n\
    \  |\n7 | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n  |\
    \    ---------------------                          ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n  |\n  = note: expected struct `Vec<String>`\n\
    \          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: implement this function\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkby3hq9l.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate paren groups: {}\", paren_string)\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate paren groups: (()())
    ((())) () ((())()())'', /tmp/tmpovtf9wah.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976040
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_group_nesting = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_group_nesting\
    \ += 1;\n                current_group.push(c);\n            }\n            ')'\
    \ => {\n                current_group_nesting -= 1;\n                current_group.push(c);\n\
    \                if current_group_nesting == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => (),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmprdj54nvh.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_vec: Vec<String> = Vec::new();\n    let mut next_paren_group:\
    \ String = String::new();\n    let mut num_open_parens: u32 = 0;\n    for paren\
    \ in paren_string.chars() {\n        match paren {\n            '(' => {\n   \
    \             num_open_parens += 1;\n                next_paren_group.push(paren);\n\
    \            }\n            ')' => {\n                num_open_parens -= 1;\n\
    \                next_paren_group.push(paren);\n                if num_open_parens\
    \ == 0 {\n                    paren_vec.push(next_paren_group);\n            \
    \        next_paren_group = String::new();\n                }\n            }\n\
    \            _ => {}\n        }\n    }\n    paren_vec\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec = Vec::new();\n    let mut counter = 0;\n    let mut temp = String::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            if counter\
    \ == 0 {\n                temp.push('(');\n            }\n            counter\
    \ += 1;\n        } else if c == ')' {\n            counter -= 1;\n           \
    \ if counter == 0 {\n                temp.push(')');\n                vec.push(temp);\n\
    \                temp = String::new();\n            }\n        }\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpoxi_aloc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut res = Vec::new();\n    let mut i = 0;\n    let mut current_group\
    \ = String::new();\n    let mut current_group_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                if current_group_level\
    \ == 0 {\n                    current_group = String::new();\n               \
    \ }\n                current_group.push(c);\n                current_group_level\
    \ += 1;\n            }\n            ')' => {\n                current_group.push(c);\n\
    \                current_group_level -= 1;\n                if current_group_level\
    \ == 0 {\n                    res.push(current_group);\n                }\n  \
    \          }\n            _ => {}\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `i`\n --> /tmp/tmp4oac38v7.rs:9:13\n  |\n9 |\
    \     let mut i = 0;\n  |             ^ help: if this is intentional, prefix it\
    \ with an underscore: `_i`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmp4oac38v7.rs:9:9\n\
    \  |\n9 |     let mut i = 0;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `current_group`\n  --> /tmp/tmp4oac38v7.rs:22:17\n  \
    \ |\n10 |     let mut current_group = String::new();\n   |         -----------------\
    \ move occurs because `current_group` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n16 |                     current_group = String::new();\n\
    \   |                     ------------- this reinitialization might get skipped\n\
    ...\n22 |                 current_group.push(c);\n   |                 ^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n...\n25 |                     res.push(current_group);\n\
    \   |                              ------------- value moved here, in previous\
    \ iteration of loop\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976039
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    return Vec::new();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpmyvlacx4.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976038
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n    let mut groups = Vec::new();\n    let mut\
    \ chars = paren_string.chars();\n    let mut last_char: char = ' ';\n    let mut\
    \ current_group = String::new();\n    while let Some(c) = chars.next() {\n   \
    \     if last_char == '(' && c == ' ' {\n            stack.push(c);\n        }\
    \ else if last_char == ' ' && c == ')' {\n            stack.pop();\n        }\
    \ else if last_char == '(' && c == '(' {\n            stack.push(c);\n       \
    \ } else if last_char == ')' && c == ')' {\n            stack.pop();\n       \
    \ }\n        if last_char == ' ' && c == '(' {\n            current_group.push('(');\n\
    \        } else if last_char == ')' && c == ' ' {\n            current_group.push(')');\n\
    \            groups.push(current_group.clone());\n            current_group.clear();\n\
    \        }\n        last_char = c;\n    }\n    groups\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpqrdo0h_l.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .replace(\" \", \"\")\n        .chars()\n        .fold(vec![(String::new(),\
    \ 0)], |mut paren_groups, c| {\n            match c {\n                '(' =>\
    \ {\n                    let mut active_string = paren_groups.pop().unwrap().0;\n\
    \                    active_string.push(c);\n                    paren_groups.push((active_string,\
    \ 1));\n                }\n                ')' => {\n                    let (mut\
    \ active_string, mut brace_count) = paren_groups.pop().unwrap();\n           \
    \         active_string.push(c);\n                    brace_count -= 1;\n    \
    \                if brace_count == 0 {\n                        paren_groups.push((active_string,\
    \ 0));\n                    } else {\n                        paren_groups.push((active_string,\
    \ brace_count));\n                    }\n                }\n                _\
    \ => panic!(\"unexpected character: {}\", c),\n            }\n            paren_groups\n\
    \        })\n        .into_iter()\n        .map(|(s, _)| s)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpixcfm6uy.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut open_count = 0;\n    let mut current_string\
    \ = String::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            open_count += 1;\n            current_string.push(c);\n        }\
    \ else if c == ')' {\n            open_count -= 1;\n            current_string.push(c);\n\
    \            if open_count == 0 {\n                result.push(current_string);\n\
    \                current_string = String::new();\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!(\"separate paren groups\");\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate paren groups'',
    /tmp/tmp55ldkcdv.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976040
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = Vec::new();\n    let mut slice = paren_string.as_str();\n\
    \    let mut start_slice = 0;\n    let mut end_slice = 0;\n    for i in 0..slice.len()\
    \ {\n        if slice.chars().nth(i).unwrap() == '(' {\n            let (new_slice,\
    \ new_start, new_end) =\n                scan_paren_group(slice, i, 0);\n    \
    \        slice = new_slice;\n            start_slice = new_start;\n          \
    \  end_slice = new_end;\n            result.push(String::from(&slice[start_slice..end_slice]));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `scan_paren_group` in this scope\n \
    \ --> /tmp/tmp8qufeojo.rs:15:17\n   |\n15 |                 scan_paren_group(slice,\
    \ i, 0);\n   |                 ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    if paren_string.is_empty() {\n        return vec![];\n    }\n\n    let mut\
    \ result: Vec<String> = vec![];\n    let mut start = None;\n    let mut stack\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            if start.is_none() {\n                start = Some(i);\n\
    \            }\n            stack += 1;\n        } else if c == ')' {\n      \
    \      stack -= 1;\n            if stack == 0 {\n                result.push(paren_string[start.unwrap()..=i].to_string());\n\
    \                start = None;\n            }\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpozq1liaw.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut chars = paren_string.chars();\n\
    \    let mut char_iter = chars.peekable();\n    let mut unprocessed_string = String::new();\n\
    \    while let Some(c) = char_iter.next() {\n        if c == ' ' {\n         \
    \   continue;\n        }\n        if c == '(' {\n            let mut depth = 1;\n\
    \            while let Some(c) = char_iter.next() {\n                if c == '('\
    \ {\n                    depth += 1;\n                } else if c == ')' {\n \
    \                   depth -= 1;\n                }\n                if depth ==\
    \ 0 {\n                    break;\n                }\n                unprocessed_string.push(c);\n\
    \            }\n            result.push(unprocessed_string);\n            unprocessed_string\
    \ = String::new();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()\", \"(())\", \"\", \"(())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpw4yx2lbt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976040
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa9l22xv6.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut current_paren_group = String::new();\n    let mut paren_groups =\
    \ Vec::new();\n    let mut paren_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_level += 1;\n\
    \                current_paren_group.push(c);\n            }\n            ')'\
    \ => {\n                if paren_level == 0 {\n                    panic!(\"Attempted\
    \ to close a paren group before opening one. Mis-matched parens?\");\n       \
    \         }\n                paren_level -= 1;\n                current_paren_group.push(c);\n\
    \                if paren_level == 0 {\n                    paren_groups.push(current_paren_group);\n\
    \                    current_paren_group = String::new();\n                }\n\
    \            }\n            _ => (),\n        }\n    }\n    if paren_level !=\
    \ 0 {\n        panic!(\"There are still parens open but the end of the input string\
    \ has been reached\");\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976040
