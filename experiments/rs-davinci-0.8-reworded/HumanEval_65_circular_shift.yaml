name: HumanEval_65_circular_shift
language: rs
prompt: "/// Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n/// and return the result as a string.\n/// If shift > number of digits,\
  \ return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\"\
  )\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x:\
  \ isize, shift: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100,\
  \ 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"\
  12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12,\
  \ 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"\
  11\"));\n}\n"
completions: ["    let number_of_digits = number_of_digits(x);\n    if shift > number_of_digits\
    \ {\n        // shift > number of digits, return digits reversed\n        reverse_digits(x)\n\
    \    } else {\n        // shift < number of digits, shift the digits right by\
    \ shift\n        let mut reversed_shifted_digits = String::new();\n        for\
    \ d in 0..number_of_digits {\n            // shift each digit\n            let\
    \ digit = x / pow10(d) % 10;\n            let shifted_digit = digit * pow10(number_of_digits\
    \ - shift) + digit * pow10(shift);\n            reversed_shifted_digits.push_str(&shifted_digit.to_string());\n\
    \        }\n        reverse_digits(reversed_shifted_digits.parse::<isize>().unwrap())\n\
    \    }", "    let s = format!(\"{}\", x);\n    let n = s.len();\n    let m = shift\
    \ % n;\n    let mut s = s.chars().rev().collect::<String>();\n    s.push_str(&s[..m].chars().rev().collect::<String>());\n\
    \    s.split_off(m)", "    let s = x.to_string();\n    let (l, r) = s.split_at(shift\
    \ as usize);\n    let res = format!(\"{}{}\", r, l);\n    res", "    let mut result\
    \ = String::new();\n    if shift > 0 {\n        let mut digits = digits(x);\n\
    \        let n = digits.len();\n        let mut n = n as isize;\n        while\
    \ n > 0 {\n            result.push_str(&format!(\"{}\", digits.pop().unwrap()));\n\
    \            n -= 1;\n        }\n    } else {\n        result = format!(\"{}\"\
    , x);\n    }\n    result", "    if shift >= num_digits(x) {\n        let mut x\
    \ = x;\n        let mut result = String::new();\n        while x > 0 {\n     \
    \       result.push(((x % 10) + '0' as isize) as u8 as char);\n            x /=\
    \ 10;\n        }\n        return result;\n    }\n    let mut x = x;\n    let mut\
    \ result = String::new();\n    while x > 0 {\n        result.push(((x % 10) +\
    \ '0' as isize) as u8 as char);\n        x /= 10;\n    }\n    result.pop();\n\
    \    let (left, right) = result.split_at(result.len() - shift as usize);\n   \
    \ let mut result = right.to_string();\n    result.push_str(left);\n    result",
  "    let mut s = x.to_string();\n    if shift >= s.len() as isize {\n        s.chars().rev().collect()\n\
    \    } else {\n        let n = shift as usize;\n        let (l, r) = s.split_at(n);\n\
    \        format!(\"{}{}\", r, l)\n    }", "    let mut x = x;\n    let mut y =\
    \ 0;\n    let mut digits = 0;\n    loop {\n        if x == 0 {\n            break;\n\
    \        }\n        digits += 1;\n        y *= 10;\n        y += x % 10;\n   \
    \     x /= 10;\n    }\n    let mut x = x;\n    let mut y = y;\n    if shift >=\
    \ digits {\n        x = y;\n        y = 0;\n        while x > 0 {\n          \
    \  y *= 10;\n            y += x % 10;\n            x /= 10;\n        }\n    }\
    \ else {\n        for _ in 0..shift {\n            x *= 10;\n            x +=\
    \ y % 10;\n            y /= 10;\n        }\n    }\n    x.to_string()", "    let\
    \ mut n = x;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut result\
    \ = String::new();\n    while n > 0 {\n        let new_last_digit = n % 10;\n\
    \        result.push_str(&new_last_digit.to_string());\n        n /= 10;\n   \
    \ }\n    result.push_str(&last_digit.to_string());\n    let result = result.chars().rev().collect::<String>();\n\
    \    let mut new_result = String::new();\n    for c in result.chars().skip(shift\
    \ as usize) {\n        new_result.push(c);\n    }\n    for c in result.chars().take(shift\
    \ as usize) {\n        new_result.push(c);\n    }\n    new_result", "    if shift\
    \ > num_digits(x) {\n        // shift more than number of digits\n        reverse_digits(x)\n\
    \    } else {\n        // shift less than number of digits\n        let midpoint\
    \ = num_digits(x) - shift;\n        let (left, right) = split_digits(x, midpoint);\n\
    \        right + &left\n    }", "    // shift is positive and by how many digits\
    \ to shift right\n    if shift == 0 {\n        return x.to_string();\n    }\n\
    \    if shift > num_digits(x) {\n        return reverse_string(&x.to_string());\n\
    \    }\n    let mut digits = to_digits(x);\n    for _ in 0..shift {\n        let\
    \ last = digits.pop().unwrap();\n        digits.insert(0, last);\n    }\n    digits_to_number(&digits)",
  "    let mut x = x;\n    let mut place = 1;\n    while x > 9 {\n        place *=\
    \ 10;\n        x /= 10;\n    }\n    let rev_x = x.to_string().chars().rev().collect::<String>();\n\
    \    let rev_x = rev_x.parse::<isize>().unwrap();\n    if shift >= place {\n \
    \       format!(\"{}\", rev_x)\n    } else {\n        let rev_shifted = rev_x\
    \ / place + rev_x % place * 10;\n        format!(\"{}\", rev_shifted)\n    }",
  "    let s = x.to_string();\n    let len = s.len();\n    if shift > len as isize\
    \ {\n        s.chars().rev().collect()\n    } else {\n        let index = len\
    \ - shift as usize;\n        s.chars().cycle().skip(index).take(len).collect()\n\
    \    }", "    let mut x = x;\n    let mut res = String::new();\n    let mut count\
    \ = 0;\n    while x > 0 {\n        let digit = x % 10;\n        res.push_str(&format!(\"\
    {}\", digit));\n        x /= 10;\n        count += 1;\n    }\n    res = res.chars().rev().collect();\n\
    \    if shift > count {\n        return res;\n    }\n    let res_len = res.len();\n\
    \    let left = &res[0..shift as usize];\n    let right = &res[shift as usize..res_len];\n\
    \    format!(\"{}{}\", right, left)", "    let digits = x.to_string();\n    let\
    \ len = digits.len();\n    if shift > len {\n        return digits.chars().rev().collect();\n\
    \    }\n    let (a, b) = digits.split_at(len - shift as usize);\n    format!(\"\
    {}{}\", b, a)", "    let mut x = x;\n    let mut res = String::new();\n    let\
    \ mut pos = 0;\n    while x != 0 {\n        let digit = x % 10;\n        x /=\
    \ 10;\n        res.insert(pos, (digit + 48 + shift) as u8 as char);\n        pos\
    \ += 1;\n    }\n    res", "    let mut s = String::new();\n    let num_digits\
    \ = (log10(x) + 1.0) as isize;\n    for i in 0..num_digits {\n        let mut\
    \ d = (x / pow(10, i)) % 10;\n        if i + shift < num_digits {\n          \
    \  d = (x / pow(10, i + shift)) % 10;\n        }\n        s.push_str(&d.to_string());\n\
    \    }\n    s", "    let mut x = x;\n    let mut shift = shift;\n    let mut res\
    \ = String::new();\n    let mut digits = Vec::new();\n    while x > 0 {\n    \
    \    digits.push(x % 10);\n        x /= 10;\n    }\n    while shift > digits.len()\
    \ as isize {\n        shift -= digits.len() as isize;\n    }\n    digits.reverse();\n\
    \    res.push_str(&digits.iter().map(|&x| (x + 48) as u8 as char).collect::<String>());\n\
    \    if shift > 0 {\n        let shifted = digits.into_iter().cycle().skip(shift\
    \ as usize).take(digits.len()).collect::<Vec<_>>();\n        res.clear();\n  \
    \      res.push_str(&shifted.iter().map(|&x| (x + 48) as u8 as char).collect::<String>());\n\
    \    }\n    res", "    if shift == 0 {\n        return format!(\"{}\", x);\n \
    \   }\n    let mut result = String::from(\"\");\n    let mut num_digits = 0;\n\
    \    let mut temp = x;\n    while temp > 0 {\n        temp /= 10;\n        num_digits\
    \ += 1;\n    }\n    if shift >= num_digits {\n        return format!(\"{}\", reverse_int(x));\n\
    \    }\n    for _ in 0..shift {\n        let digit = x % 10;\n        result.push_str(&digit.to_string());\n\
    \        let quotient = x / 10;\n        result.push_str(&quotient.to_string());\n\
    \        x = quotient;\n    }\n    result", "    let mut digits = x.to_string();\n\
    \    let len = digits.len();\n    let shift = shift % len;\n    if shift != 0\
    \ {\n        digits.push_str(&digits[..shift]);\n        digits.drain(..shift);\n\
    \    }\n    digits", "    let digits = format!(\"{}\", x);\n    let split_index\
    \ = digits.len() - (shift as usize);\n    if split_index > 0 {\n        format!(\"\
    {}{}\", &digits[split_index..], &digits[..split_index])\n    } else {\n      \
    \  let mut shifted_digits = digits.chars().rev().collect::<String>();\n      \
    \  shifted_digits.truncate(digits.len() - split_index.abs() as usize);\n     \
    \   shifted_digits\n    }"]
stop_tokens:
- "\n}"
