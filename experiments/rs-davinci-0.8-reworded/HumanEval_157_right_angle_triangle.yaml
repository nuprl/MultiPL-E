name: HumanEval_157_right_angle_triangle
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return true if the\
  \ three\n/// sides form a right-angled triangle, false otherwise.\n/// A right-angled\
  \ triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n\
  /// Example:\n/// >>> right_angle_triangle(3, 4, 5)\n/// true\n/// >>> right_angle_triangle(1,\
  \ 2, 3)\n/// false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3,\
  \ 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10,\
  \ 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7,\
  \ 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5,\
  \ 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48,\
  \ 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2,\
  \ 2, 10), false);\n}\n"
completions: ["    // Write your code here\n    let (a, b, c) = order_three(a, b,\
    \ c);\n    return a * a + b * b == c * c;", "    if a > 0 && b > 0 && c > 0 {\n\
    \        let mut v = vec![a, b, c];\n        v.sort();\n        v[0] * v[0] +\
    \ v[1] * v[1] == v[2] * v[2]\n    } else {\n        false\n    }", "    // Your\
    \ code here!\n    unimplemented!();", "    let a = a as f64;\n    let b = b as\
    \ f64;\n    let c = c as f64;\n    a.powi(2) + b.powi(2) == c.powi(2)", "    if\
    \ a > b && a > c {\n        a * a == b * b + c * c\n    } else if b > a && b >\
    \ c {\n        b * b == a * a + c * c\n    } else {\n        c * c == a * a +\
    \ b * b\n    }", "    if a.pow(2) + b.pow(2) == c.pow(2) {\n        return true;\n\
    \    } else if a.pow(2) + c.pow(2) == b.pow(2) {\n        return true;\n    }\
    \ else if b.pow(2) + c.pow(2) == a.pow(2) {\n        return true;\n    }\n   \
    \ return false;", "    // Hint: Pythagorean theorem states that in a right-angled\
    \ triangle, the sum\n    // of the squares of the two shorter sides must equal\
    \ the square of the\n    // hypotenuse.\n    unimplemented!();", '    unimplemented!()',
  '  unimplemented!()', "    let mut temp = 0;\n    let mut arr = [a, b, c];\n   \
    \ arr.sort();\n    let (a, b, c) = (arr[0], arr[1], arr[2]);\n    for i in 1..c\
    \ {\n        if (i * i) == (a * a + b * b) {\n            temp = 1;\n        }\n\
    \    }\n    temp == 1", '    (a.pow(2) + b.pow(2)) == c.pow(2)', "    let mut\
    \ sides = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] *\
    \ sides[1] == sides[2] * sides[2]", "    // PUT YOUR CODE HERE\n    unimplemented!();",
  "    let mut sides = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1]\
    \ * sides[1] == sides[2] * sides[2]", '    false', "    let mut array = [a, b,\
    \ c];\n    array.sort();\n    if (array[0] * array[0] + array[1] * array[1]) ==\
    \ array[2] * array[2] {\n        return true;\n    } else {\n        return false;\n\
    \    }", "    let sides = [a, b, c];\n    sides.iter().filter(|&x| x.pow(2) ==\
    \ a.pow(2) + b.pow(2)).count() == 1", '    (a*a + b*b == c*c) || (b*b + c*c ==
    a*a) || (c*c + a*a == b*b)', "    if (a.pow(2) + b.pow(2)) == c.pow(2) {\n   \
    \     return true;\n    }\n    return false;", '    unimplemented!()', '    unimplemented!()',
  "    let (a, b, c) = if a > b {\n        if a > c {\n            (a, b, c)\n   \
    \     } else {\n            (c, b, a)\n        }\n    } else {\n        if b >\
    \ c {\n            (b, a, c)\n        } else {\n            (c, a, b)\n      \
    \  }\n    };\n    a*a == b*b + c*c", "    // let hypotenuse: f64 = if a > b &&\
    \ a > c {\n    //     a as f64\n    // } else if b > a && b > c {\n    //    \
    \ b as f64\n    // } else {\n    //     c as f64\n    // };\n    // let cathetus_1:\
    \ f64 = if a > b && a > c {\n    //     b as f64\n    // } else if b > a && b\
    \ > c {\n    //     a as f64\n    // } else {\n    //     b as f64\n    // };\n\
    \    // let cathetus_2: f64 = if a > b && a > c {\n    //     c as f64\n    //\
    \ } else if b > a && b > c {\n    //     c as f64\n    // } else {\n    //   \
    \  a as f64\n    // };\n    // (hypotenuse * hypotenuse).round() == (cathetus_1\
    \ * cathetus_1 + cathetus_2 * cathetus_2).round()\n    a.pow(2) + b.pow(2) ==\
    \ c.pow(2) ||\n    a.pow(2) + c.pow(2) == b.pow(2) ||\n    b.pow(2) + c.pow(2)\
    \ == a.pow(2)", '    a*a + b*b == c*c', "    // max_c will be the side with the\
    \ largest length\n    let (mut max_c, mut min_a, mut min_b) = (a, b, c);\n   \
    \ if a > b && a > c {\n        max_c = a;\n        min_a = b;\n        min_b =\
    \ c;\n    } else if b > a && b > c {\n        max_c = b;\n        min_a = a;\n\
    \        min_b = c;\n    }\n    max_c * max_c == min_a * min_a + min_b * min_b",
  "    //\n    //\n    //\n    true", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", '    a.pow(2)
    + b.pow(2) == c.pow(2)', "    if a.pow(2) + b.pow(2) == c.pow(2) {\n        return\
    \ true;\n    }\n    false", "    let v = [a, b, c];\n    v.iter().max().unwrap()\
    \ == &v.iter().map(|&i| i * i).sum::<isize>().sqrt() as isize", '    unimplemented!();',
  "    // TODO\n    false", "    let mut sides = [a, b, c];\n    sides.sort();\n \
    \   sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    let\
    \ sides = vec![a, b, c];\n    sides.iter().max().unwrap() == &((a.pow(2) + b.pow(2)\
    \ + c.pow(2)) as f64).sqrt() as isize", "    // The three sides form a right-angled\
    \ triangle when a^2 + b^2 = c^2\n    (a * a + b * b) == (c * c)", "    let mut\
    \ sides = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] *\
    \ sides[1] == sides[2] * sides[2]", "    let a = a as f64;\n    let b = b as f64;\n\
    \    let c = c as f64;\n    if a.powi(2) + b.powi(2) == c.powi(2) {\n        return\
    \ true;\n    }\n    if a.powi(2) + c.powi(2) == b.powi(2) {\n        return true;\n\
    \    }\n    if b.powi(2) + c.powi(2) == a.powi(2) {\n        return true;\n  \
    \  }\n    false", "    let mut sides = [a, b, c];\n    sides.sort();\n    sides[0]\
    \ * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    if a < b {\n\
    \        if a * a + b * b == c * c {\n            return true;\n        }\n  \
    \  } else {\n        if b * b + a * a == c * c {\n            return true;\n \
    \       }\n    }\n    false", "    let mut s = [a, b, c];\n    s.sort();\n   \
    \ (s[0] * s[0] + s[1] * s[1]) == s[2] * s[2]", "    if a == 0 || b == 0 || c ==\
    \ 0 {\n        return false;\n    }\n    if a > b && a > c {\n        return a\
    \ * a == b * b + c * c;\n    }\n    if b > a && b > c {\n        return b * b\
    \ == a * a + c * c;\n    }\n    return c * c == a * a + b * b;", '    unimplemented!()',
  "    let mut nums = [a, b, c];\n    nums.sort();\n    nums[0] * nums[0] + nums[1]\
    \ * nums[1] == nums[2] * nums[2]", "    let max = max(a, max(b, c));\n    let\
    \ rest = a + b + c - max;\n    return max * max == rest * rest;", "    let (a,\
    \ b, c) = sort_three(a, b, c);\n    a * a + b * b == c * c", "  let long = (a\
    \ - b).abs();\n  let short = (a - c).abs();\n  let hypotenuse = (a - c).abs();\n\
    \  if long == short {\n    return false;\n  }\n  if long > short {\n    return\
    \ long * long + short * short == hypotenuse * hypotenuse;\n  }\n  else {\n   \
    \ return short * short + long * long == hypotenuse * hypotenuse;\n  }", "    if\
    \ a <= 0 || b <= 0 || c <= 0 {\n        return false;\n    }\n\n    (a * a) +\
    \ (b * b) == (c * c)", '    (a * a + b * b == c * c) || (a * a + c * c == b *
    b) || (b * b + c * c == a * a)', '    unimplemented!();', "    if a == 0 || b\
    \ == 0 || c == 0 {\n        return false;\n    }\n    if a < 0 || b < 0 || c <\
    \ 0 {\n        return false;\n    }\n    let sum = (a*a + b*b + c*c) as f64;\n\
    \    let s = f64::sqrt(sum);\n    (s - (a as f64)) < 1e-9 && (s - (b as f64))\
    \ < 1e-9 && (s - (c as f64)) < 1e-9", '    unimplemented!();', "    // Fill your\
    \ code here\n    a*a+b*b==c*c", "    let mut lst = [a, b, c];\n    lst.sort();\n\
    \    (lst[0] * lst[0] + lst[1] * lst[1]) == lst[2] * lst[2]", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    let (a, b, c) = (sides[0], sides[1], sides[2]);\n\
    \    a * a + b * b == c * c", "    if a == b || b == c || a == c {\n        return\
    \ false;\n    }\n\n    let mut arr = [a, b, c];\n    arr.sort();\n\n    let [a,\
    \ b, c] = arr;\n\n    if a.pow(2) + b.pow(2) == c.pow(2) {\n        return true;\n\
    \    }\n\n    false", "    let mut sides = [a, b, c];\n    sides.sort();\n   \
    \ let [shortest, middle, longest] = sides;\n    longest*longest == middle*middle\
    \ + shortest*shortest", "    let mut sides = [a, b, c];\n    sides.sort();\n \
    \   let (a, b, c) = (sides[0], sides[1], sides[2]);\n    (a.pow(2) + b.pow(2))\
    \ == c.pow(2)", "    let mut sides = [a, b, c];\n    sides.sort();\n    return\
    \ sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];", "    if\
    \ a.pow(2) + b.pow(2) == c.pow(2) {\n        return true;\n    }\n    false",
  '    return (a*a + b*b == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a);', " \
    \   // your code here\n    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    let\
    \ mut s = vec![a, b, c];\n    s.sort();\n    return (s[0] * s[0] + s[1] * s[1])\
    \ == s[2] * s[2];", "    let mut v: Vec<isize> = vec![a, b, c];\n    v.sort();\n\
    \    if v[0] * v[0] + v[1] * v[1] == v[2] * v[2] {\n        return true;\n   \
    \ }\n    false", "    let mut sides = [a, b, c];\n    sides.sort();\n    sides[0]\
    \ * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    if a < b {\n\
    \        if a < c {\n            return a * a + b * b == c * c;\n        } else\
    \ {\n            return c * c + b * b == a * a;\n        }\n    } else {\n   \
    \     if b < c {\n            return b * b + a * a == c * c;\n        } else {\n\
    \            return c * c + a * a == b * b;\n        }\n    }", "    if a > b\
    \ && a > c {\n        return a * a == b * b + c * c;\n    } else if b > a && b\
    \ > c {\n        return b * b == a * a + c * c;\n    } else {\n        return\
    \ c * c == a * a + b * b;\n    }", "    if a == 0 || b == 0 || c == 0 {\n    \
    \    return false;\n    }\n\n    let mut triangle = vec![a, b, c];\n    triangle.sort();\n\
    \n    let hypotenuse = triangle[2];\n    let cathetus_a = triangle[1];\n    let\
    \ cathetus_b = triangle[0];\n\n    // When a triangle is right-angled, then the\
    \ sum of the squares of the other\n    // two sides equals the square of the hypotenuse.\n\
    \    cathetus_a * cathetus_a + cathetus_b * cathetus_b == hypotenuse * hypotenuse",
  "    if a > 0 && b > 0 && c > 0 {\n        if (a * a) + (b * b) == (c * c) {\n \
    \           return true;\n        }\n    }\n    false", "    // Create a vec of\
    \ the sides and sort it in ascending order\n    let mut sides = vec![a, b, c];\n\
    \    sides.sort();\n\n    // Pythagorean theorem says that a^2 + b^2 = c^2\n \
    \   // where a and b are the smaller sides and c is the larger side.\n    // So\
    \ if a^2 + b^2 = c^2 then a^2 + b^2 - c^2 = 0\n    // which means c^2 - a^2 -\
    \ b^2 = 0\n    // which means that if c^2 - a^2 - b^2 == 0 then it is a right\
    \ triangle\n    let c_squared = sides[2] * sides[2];\n    let a_squared = sides[0]\
    \ * sides[0];\n    let b_squared = sides[1] * sides[1];\n    if c_squared - a_squared\
    \ - b_squared == 0 {\n        true\n    } else {\n        false\n    }", '    unimplemented!()',
  '    unimplemented!();', "    let ab = a * a + b * b;\n    let bc = b * b + c *\
    \ c;\n    let ac = a * a + c * c;\n    ab == c * c || bc == a * a || ac == b *\
    \ b", '    a*a + b*b == c*c', "    if a == 0 || b == 0 || c == 0 {\n        false\n\
    \    } else {\n        let max_index = find_index_of_max(a, b, c);\n        let\
    \ (c, a, b) = reorder_for_max(a, b, c, max_index);\n        // Now `c` is the\
    \ length of the hypotenuse, `a` and `b` are the lengths of the\n        // other\
    \ two sides.\n        c.pow(2) == a.pow(2) + b.pow(2)\n    }", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2]", "    // Check that all sides are positive\n    if a\
    \ <= 0 || b <= 0 || c <= 0 {\n        return false;\n    }\n\n    // Ensure a\
    \ <= b <= c\n    let (a, b, c) = if a > b {\n        if a > c {\n            (c,\
    \ b, a)\n        } else {\n            (b, a, c)\n        }\n    } else {\n  \
    \      if b > c {\n            (a, c, b)\n        } else {\n            (a, b,\
    \ c)\n        }\n    };\n\n    // The triangle inequalities state that the sum\
    \ of the lengths of any two\n    // sides must be greater than the length of the\
    \ third side.\n    // Let's check all three cases.\n    a + b > c && a + c > b\
    \ && b + c > a", '    (a.pow(2) + b.pow(2)) == c.pow(2)', "    // TODO: improve\
    \ the solution\n    a.pow(2) + b.pow(2) == c.pow(2)", "    if a + b <= c || a\
    \ + c <= b || b + c <= a {\n        return false;\n    }\n    let mut arr = [a,\
    \ b, c];\n    arr.sort();\n    let [a, b, c] = arr;\n    a.pow(2) + b.pow(2) ==\
    \ c.pow(2)", "    let hypotenuse = vec![a, b, c].iter().max().unwrap();\n    let\
    \ sum_others = vec![a, b, c].iter().filter(|x| **x != *hypotenuse).sum();\n  \
    \  **hypotenuse * **hypotenuse == sum_others * sum_others", "    if (a*a + b*b\
    \ == c*c) || (a*a + c*c == b*b) || (b*b + c*c == a*a) {\n        return true;\n\
    \    }\n    false", "    if a <= 0 || b <= 0 || c <= 0 {\n        return false;\n\
    \    }\n    if a.pow(2) + b.pow(2) == c.pow(2) {\n        return true;\n    }\n\
    \    if a.pow(2) + c.pow(2) == b.pow(2) {\n        return true;\n    }\n    if\
    \ b.pow(2) + c.pow(2) == a.pow(2) {\n        return true;\n    }\n    false",
  "    // TODO: implement the function here\n\n    unimplemented!();", "    // Step\
    \ 1: Sort the three sides according to their lengths\n    let mut sides = [a,\
    \ b, c];\n    sides.sort();\n\n    // Step 2: Square the three sides\n    let\
    \ squares = [sides[0] * sides[0], sides[1] * sides[1], sides[2] * sides[2]];\n\
    \n    // Step 3: Apply the Pythagorean theorem\n    // Specifically, the longest\
    \ side's square must be equal to the sum of the\n    // squares of the two shorter\
    \ sides.\n    squares[2] == squares[0] + squares[1]", '    unimplemented!();',
  "    if !is_triangle(a, b, c) {\n        return false;\n    }\n    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2]", "    if a * a + b * b == c * c {\n        return true;\n\
    \    }\n    if a * a + c * c == b * b {\n        return true;\n    }\n    if b\
    \ * b + c * c == a * a {\n        return true;\n    }\n    return false;", " \
    \   let mut vec = vec![a, b, c];\n    vec.sort();\n    vec[0] * vec[0] + vec[1]\
    \ * vec[1] == vec[2] * vec[2]", "    if a * a + b * b == c * c {\n        return\
    \ true;\n    }\n    false", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    //\
    \ TODO!\n    false", "    // Hint: a^2 + b^2 = c^2\n    unimplemented!();", '    unimplemented!()',
  "    if a == 0 || b == 0 || c == 0 {\n        return false;\n    }\n\n    if a ==\
    \ b && b == c {\n        return false;\n    }\n\n    let mut sides = vec![a, b,\
    \ c];\n    sides.sort();\n\n    return sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2];", "    if a > 0 && b > 0 && c > 0 {\n        if a.pow(2)\
    \ + b.pow(2) == c.pow(2) || a.pow(2) + c.pow(2) == b.pow(2) ||\n           b.pow(2)\
    \ + c.pow(2) == a.pow(2) {\n            return true;\n        }\n    }\n    false",
  "    let mut inputs = vec![a, b, c];\n    inputs.sort();\n    if inputs[0] > 0 &&\
    \ inputs[2] < inputs[0] + inputs[1] {\n        let hypotenuse = inputs[2];\n \
    \       let x = inputs[0];\n        let y = inputs[1];\n        let pythagoras\
    \ = x * x + y * y;\n        if hypotenuse * hypotenuse == pythagoras {\n     \
    \       return true;\n        }\n    }\n    false", "    let mut max = ::std::cmp::max(a,\
    \ b);\n    max = ::std::cmp::max(max, c);\n    let mut others = vec![a, b, c];\n\
    \    others.retain(|&x| x != max);\n    others[0] * others[0] + others[1] * others[1]\
    \ == max * max", "    let (x, y, z) = sort(a, b, c);\n    z*z == x*x + y*y", " \
    \   let l = [a, b, c];\n    let hypotenuse = l.iter().max().unwrap();\n    let\
    \ other_sides = l.iter().filter(|&n| n != hypotenuse).collect::<Vec<_>>();\n \
    \   *hypotenuse == other_sides[0].pow(2) + other_sides[1].pow(2)", '    a.pow(2)
    + b.pow(2) == c.pow(2)', "    // Hint: the Pythagorean theorem\n    //       if\
    \ a^2 + b^2 = c^2, then it is a right-angled triangle\n    //       more about\
    \ the Pythagorean theorem:\n    //       https://en.wikipedia.org/wiki/Pythagorean_theorem\n\
    \    if a * a + b * b == c * c {\n        return true;\n    }\n    return false;",
  '    unimplemented!();', "    (a.pow(2) + b.pow(2) == c.pow(2)) ||\n    (a.pow(2)\
    \ + c.pow(2) == b.pow(2)) ||\n    (b.pow(2) + c.pow(2) == a.pow(2))", "    let\
    \ mut sides = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1]\
    \ * sides[1] == sides[2] * sides[2]", "    // TODO: implement your solution here\n\
    \    if a == 0 || b == 0 || c == 0 {\n        return false;\n    }\n    if a*a\
    \ + b*b == c*c || b*b + c*c == a*a || a*a + c*c == b*b {\n        return true;\n\
    \    }\n    return false;", "    let mut l = [a, b, c];\n    l.sort();\n    let\
    \ (x, y, z) = (l[0], l[1], l[2]);\n    return x * x + y * y == z * z;", '    a
    * a + b * b == c * c', "    if a > b && a > c {\n        a * a == b * b + c *\
    \ c\n    } else if b > a && b > c {\n        b * b == a * a + c * c\n    } else\
    \ {\n        c * c == a * a + b * b\n    }", "    let mut sides = [a, b, c];\n\
    \    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1] == sides[2]\
    \ * sides[2]", '    unimplemented!()', "    // The longest side must be less than\
    \ the sum of the two shorter sides\n    let max_len = a.max(b).max(c);\n    let\
    \ sum_lens = a + b + c - max_len;\n    max_len < sum_lens", "    // TODO add code\
    \ here\n    false", "    // First, sort the numbers.\n    let mut sides = [a,\
    \ b, c];\n    sides.sort();\n\n    // Now, the Pythagorean theorem can be applied.\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", '    unimplemented!();',
  '    unimplemented!()', "    let mut sides = [a, b, c];\n    sides.sort();\n   \
    \ sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", '    unimplemented!();',
  "    if a > b && a > c {\n        a*a == b*b + c*c\n    } else if b > a && b > c\
    \ {\n        b*b == a*a + c*c\n    } else {\n        c*c == a*a + b*b\n    }",
  "    // TODO!\n    true", "    let square_a = a * a;\n    let square_b = b * b;\n\
    \    let square_c = c * c;\n    if square_a + square_b == square_c ||\n      \
    \ square_a + square_c == square_b ||\n       square_b + square_c == square_a {\n\
    \        return true;\n    }\n    false", "    // a^2 + b^2 = c^2\n    a.pow(2)\
    \ + b.pow(2) == c.pow(2)", "    // TODO: implement this function\n    let mut\
    \ angles = vec![a, b, c];\n    angles.sort();\n    let x = angles[0] * angles[0];\n\
    \    let y = angles[1] * angles[1];\n    let z = angles[2] * angles[2];\n    if\
    \ x + y == z {\n        return true;\n    }\n    return false;", "    let mut\
    \ sides = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] *\
    \ sides[1] == sides[2] * sides[2]", "    let largest = isize::max(a, isize::max(b,\
    \ c));\n    let sum = a + b + c;\n    let a_minus_b = (a - b).abs();\n    let\
    \ a_minus_c = (a - c).abs();\n    let b_minus_c = (b - c).abs();\n    let pythagoras\
    \ = sum - largest - largest;\n    let pythagoras_plus_one = pythagoras + 1;\n\
    \    largest == a_minus_b + a_minus_c + b_minus_c && pythagoras == pythagoras_plus_one",
  "    let pythagorean_triple = vec![(3, 4, 5), (5, 12, 13), (8, 15, 17), (7, 24,\
    \ 25),\n                                  (20, 21, 29), (12, 35, 37), (9, 40,\
    \ 41), (28, 45, 53),\n                                  (11, 60, 61), (16, 63,\
    \ 65), (33, 56, 65), (48, 55, 73),\n                                  (13, 84,\
    \ 85), (36, 77, 85), (39, 80, 89), (65, 72, 97)];\n    for &(x, y, z) in pythagorean_triple.iter()\
    \ {\n        if a == x * a && b == y * b && c == z * c {\n            return true;\n\
    \        }\n    }\n    false", "    if a > b && a > c {\n        a * a == b *\
    \ b + c * c\n    } else if b > a && b > c {\n        b * b == a * a + c * c\n\
    \    } else {\n        c * c == a * a + b * b\n    }", "    if a > b && a > c\
    \ {\n        a*a == b*b + c*c\n    } else if b > a && b > c {\n        b*b ==\
    \ a*a + c*c\n    } else {\n        c*c == a*a + b*b\n    }", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2]", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    let c_square = sides[2] * sides[2];\n    let c2_square = sides[1] * sides[1]\
    \ + sides[0] * sides[0];\n    c_square == c2_square", "    // write your code\
    \ here!\n    return false;", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    //\
    \ if a^2 + b^2 == c^2 then it is a right angled triangle\n    let a_sqr = a *\
    \ a;\n    let b_sqr = b * b;\n    let c_sqr = c * c;\n    return a_sqr + b_sqr\
    \ == c_sqr;", '    unimplemented!()', "    let side_arr = [a, b, c];\n    side_arr.iter().max().unwrap()\
    \ == &(side_arr.iter().min().unwrap() + side_arr.iter().skip(1).max().unwrap())",
  "    let sides = [a, b, c];\n    let max_side = sides.iter().max().unwrap();\n \
    \   let mut sides_without_max = sides.clone();\n    sides_without_max.retain(|&s|\
    \ s != *max_side);\n    let squares = sides_without_max.iter().map(|&s| s * s).sum::<isize>();\n\
    \    squares == max_side * max_side", "    // Given a right-angled triangle, the\
    \ square of its side that's\n    // opposite the right angle is the sum of the\
    \ squares of the two other sides\n    // Therefore, a^2 + b^2 = c^2\n    // This\
    \ can also be expressed as c^2 - (a^2 + b^2) = 0\n    let sum = a.pow(2) + b.pow(2);\n\
    \    let diff = c.pow(2) - sum;\n    diff == 0", "    let max = if a >= b && a\
    \ >= c { a } else if b >= a && b >= c { b } else { c };\n    let mut sum = 0;\n\
    \    if a != max { sum += a * a; }\n    if b != max { sum += b * b; }\n    if\
    \ c != max { sum += c * c; }\n    return sum == max * max;", '    a.pow(2) + b.pow(2)
    == c.pow(2)', '  unimplemented!();', "    let mut a = a;\n    let mut b = b;\n\
    \    let mut c = c;\n    let mut sides = [a, b, c];\n    sides.sort();\n    sides[0]\
    \ * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    (sides[0] * sides[0] + sides[1] * sides[1])\
    \ == sides[2] * sides[2]", "    if a > b && a > c {\n        return a * a == b\
    \ * b + c * c;\n    }\n    if b > a && b > c {\n        return b * b == a * a\
    \ + c * c;\n    }\n    return c * c == a * a + b * b;", "    // Determine if the\
    \ sides can be a triangle\n    if (a + b) <= c || (a + c) <= b || (b + c) <= a\
    \ {\n        return false;\n    }\n\n    // Convert all sides to floats\n    let\
    \ a_f: f64 = a as f64;\n    let b_f: f64 = b as f64;\n    let c_f: f64 = c as\
    \ f64;\n\n    // Determine the hypotenuse\n    let mut hypotenuse = if a_f.powi(2)\
    \ > b_f.powi(2) {\n        if a_f.powi(2) > c_f.powi(2) {\n            a_f\n \
    \       } else {\n            c_f\n        }\n    } else {\n        if b_f.powi(2)\
    \ > c_f.powi(2) {\n            b_f\n        } else {\n            c_f\n      \
    \  }\n    };\n\n    // Compare the hypotenuse to the other sides\n    if a_f.powi(2)\
    \ == hypotenuse.powi(2) {\n        hypotenuse = a_f;\n    } else if b_f.powi(2)\
    \ == hypotenuse.powi(2) {\n        hypotenuse = b_f;\n    } else if c_f.powi(2)\
    \ == hypotenuse.powi(2) {\n        hypotenuse = c_f;\n    } else {\n        return\
    \ false;\n    }\n\n    // Find the other two sides\n    let mut other1 = 0.0;\n\
    \    let mut other2 = 0.0;\n    if a_f == hypotenuse {\n        other1 = b_f;\n\
    \        other2 = c_f;\n    } else if b_f == hypotenuse {\n        other1 = a_f;\n\
    \        other2 = c_f;\n    } else if c_f == hypotenuse {\n        other1 = a_f;\n\
    \        other2 = b_f;\n    }\n\n    // Check the sum of the squares of the other\
    \ two sides\n    if (other1", "    // TODO code here\n    return false;", '    unimplemented!()',
  "    (a.pow(2) + b.pow(2) == c.pow(2))\n        || (a.pow(2) + c.pow(2) == b.pow(2))\n\
    \        || (b.pow(2) + c.pow(2) == a.pow(2))", '    false', "    let tri_sides\
    \ = [a, b, c];\n    let hypotenuse = tri_sides.iter().max().unwrap();\n    let\
    \ catheti = tri_sides.iter().filter(|&n| n != hypotenuse).sum::<isize>();\n  \
    \  let hypotenuse_sqr = hypotenuse * hypotenuse;\n    let catheti_sqr = catheti\
    \ * catheti;\n    hypotenuse_sqr == catheti_sqr", "    if a == 0 || b == 0 ||\
    \ c == 0 {\n        return false;\n    }\n    let mut sides = [a, b, c];\n   \
    \ sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]",
  "    if a + b > c && a + c > b && b + c > a {\n        // Law of cosines.\n    \
    \    let mut max = 0;\n        let mut med = 0;\n        let mut min = 0;\n  \
    \      if a > b && a > c {\n            max = a;\n            if b > c {\n   \
    \             med = b;\n                min = c;\n            } else {\n     \
    \           med = c;\n                min = b;\n            }\n        } else\
    \ if b > a && b > c {\n            max = b;\n            if a > c {\n        \
    \        med = a;\n                min = c;\n            } else {\n          \
    \      med = c;\n                min = a;\n            }\n        } else {\n \
    \           max = c;\n            if a > b {\n                med = a;\n     \
    \           min = b;\n            } else {\n                med = b;\n       \
    \         min = a;\n            }\n        }\n        (min * min + med * med ==\
    \ max * max)\n    } else {\n        false\n    }", "    // TODO: implement code\
    \ here\n    unimplemented!()", "    if a == 0 || b == 0 || c == 0 {\n        return\
    \ false;\n    }\n    a * a + b * b == c * c ||\n    a * a + c * c == b * b ||\n\
    \    b * b + c * c == a * a", "    let sides = vec![a, b, c];\n    let a: isize\
    \ = sides.iter().min().unwrap();\n    let c: isize = sides.iter().max().unwrap();\n\
    \    let b: isize = sides.iter().sum::<isize>() - a - c;\n    a * a + b * b ==\
    \ c * c", "    let mut sides = [a, b, c];\n    sides.sort();\n    let a = sides[0];\n\
    \    let b = sides[1];\n    let c = sides[2];\n    let pow2 = |x| x*x;\n    let\
    \ hypothesis = (pow2(a) + pow2(b)) == pow2(c);\n    hypothesis", "    let max_side\
    \ = *vec![a, b, c].iter().max().unwrap();\n    max_side * max_side == a * a +\
    \ b * b + c * c - max_side * max_side", "    let a_squared = a * a;\n    let b_squared\
    \ = b * b;\n    let c_squared = c * c;\n    a_squared + b_squared == c_squared\
    \ || a_squared + c_squared == b_squared || b_squared + c_squared == a_squared",
  "    let mut arr = [a, b, c];\n    arr.sort();\n    arr[0] * arr[0] + arr[1] * arr[1]\
    \ == arr[2] * arr[2]", '    unimplemented!()', "    let s = [a, b, c];\n    let\
    \ mut st = s.clone();\n    st.sort();\n    st[0] * st[0] + st[1] * st[1] == st[2]\
    \ * st[2]", "    if a > b && a > c {\n        a * a == b * b + c * c\n    } else\
    \ if b > a && b > c {\n        b * b == a * a + c * c\n    } else {\n        c\
    \ * c == a * a + b * b\n    }", "    // TODO!\n    if (a > 0) && (b > 0) && (c\
    \ > 0) {\n        if (a * a + b * b == c * c) || (a * a + c * c == b * b) || (b\
    \ * b + c * c == a * a) {\n            return true;\n        }\n    }\n    return\
    \ false;", "    let (a, b, c) = if a > b {\n        if a > c {\n            (a,\
    \ b, c)\n        } else {\n            (c, b, a)\n        }\n    } else {\n  \
    \      if b > c {\n            (b, a, c)\n        } else {\n            (c, a,\
    \ b)\n        }\n    };\n    a * a == b * b + c * c", "    if a == 0 || b == 0\
    \ || c == 0 {\n        return false;\n    }\n    let mut sides = [a, b, c];\n\
    \    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1] == sides[2]\
    \ * sides[2]", "    if a == 0 || b == 0 || c == 0 {\n        return false;\n \
    \   }\n    if a > b && a > c {\n        let sum = b*b + c*c;\n        return a*a\
    \ == sum;\n    } else if b > a && b > c {\n        let sum = a*a + c*c;\n    \
    \    return b*b == sum;\n    } else {\n        let sum = a*a + b*b;\n        return\
    \ c*c == sum;\n    }", "    if a < b {\n        return right_angle_triangle(b,\
    \ a, c);\n    }\n    if a < c {\n        return right_angle_triangle(c, b, a);\n\
    \    }\n    if a*a == b*b + c*c {\n        return true;\n    }\n    return false;",
  "    let mut triangle_sides = [a, b, c];\n    triangle_sides.sort();\n    let [a,\
    \ b, c] = triangle_sides;\n    // Assuming that the inputs are correct, if a squared\
    \ plus b squared is\n    // equal to c squared, then the triangle is a right-angled\
    \ triangle.\n    (a * a) + (b * b) == (c * c)", "    let a = a as f64;\n    let\
    \ b = b as f64;\n    let c = c as f64;\n    return (a * a + b * b == c * c) ||\
    \ (a * a + c * c == b * b) || (b * b + c * c == a * a);", "    match (a, b, c)\
    \ {\n        (x, y, z) if (x*x + y*y == z*z) || (x*x + z*z == y*y) || (z*z + y*y\
    \ == x*x) => true,\n        _ => false,\n    }", "    let sides = vec![a, b, c];\n\
    \    let sides = sides.iter().map(|&x| x*x).collect::<Vec<_>>();\n    sides.iter().max().unwrap()\
    \ == &(sides.iter().sum::<isize>() - *sides.iter().max().unwrap())", "    let\
    \ a = a.pow(2);\n    let b = b.pow(2);\n    let c = c.pow(2);\n    a + b == c\
    \ || a + c == b || b + c == a", "    if a == b {\n        if a == c {\n      \
    \      return false;\n        }\n    }\n    let mut triangle: Vec<isize> = vec![a,\
    \ b, c];\n    triangle.sort();\n    let hypotenuse = triangle[2];\n    let cathetus_sum\
    \ = triangle[0] + triangle[1];\n    hypotenuse * hypotenuse == cathetus_sum *\
    \ cathetus_sum", "    let mut sides = [a, b, c];\n    sides.sort();\n    let [a,\
    \ b, c] = sides;\n    a.pow(2) + b.pow(2) == c.pow(2)", "    if a > 0 && b > 0\
    \ && c > 0 {\n        if (a * a + b * b == c * c) || (a * a + c * c == b * b)\
    \ || (b * b + c * c == a * a) {\n            return true;\n        }\n    }\n\
    \    false", "    let mut sides = [a, b, c];\n    sides.sort();\n    sides[0]\
    \ * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1]\
    \ == sides[2] * sides[2]", "    // TODO Write your code here\n    true", '    false',
  "    let mut nums = [a, b, c];\n    nums.sort();\n    let (a, b, c) = (nums[0],\
    \ nums[1], nums[2]);\n    a * a + b * b == c * c", '    unimplemented!()', " \
    \   // Ok, I assume we have a right-angled triangle and check\n    // the theorem.\
    \ If it is not - the result will be false.\n    // I am not gonna check the input\
    \ in any way. If I get\n    // negative number as a side - I will not assume it\
    \ is a\n    // hypotenuse, but it still can be a right-angled triangle.\n    //\n\
    \    // Here we assume that a is the biggest side of the triangle.\n    // This\
    \ is important because according to the theorem a^2\n    // should be equal to\
    \ b^2 + c^2.\n    // We should also remember that the theorem does not say anything\n\
    \    // about the order of the sides.\n    //\n    // So I just go through the\
    \ sides and if the theorem is valid\n    // I return true.\n    let mut buf =\
    \ vec![a, b, c];\n    buf.sort();\n    buf.iter().fold(false, |acc, side| {\n\
    \        if !acc {\n            let a = buf[2];\n            let b = *side;\n\
    \            let c = buf[1];\n            let p = b * b + c * c;\n           \
    \ if a * a == p {\n                true\n            } else {\n              \
    \  false\n            }\n        } else {\n            true\n        }\n    })",
  '    ((a * a) + (b * b)) == (c * c)', "    let mut sorted = [a, b, c];\n    sorted.sort();\n\
    \    sorted[0] * sorted[0] + sorted[1] * sorted[1] == sorted[2] * sorted[2]",
  '    unimplemented!();', '    unimplemented!();', "    // We calculate the squared\
    \ lengths of the three sides and compare\n    // against the Pythagorean Theorem.\n\
    \    let a2 = a * a;\n    let b2 = b * b;\n    let c2 = c * c;\n    if a2 == b2\
    \ + c2 || b2 == a2 + c2 || c2 == a2 + b2 {\n        true\n    } else {\n     \
    \   false\n    }", "    // assert!(a > 0 && b > 0 && c > 0);\n\n    // let mut\
    \ v = vec![a, b, c];\n    // v.sort();\n    // (v[0] * v[0] + v[1] * v[1]) ==\
    \ v[2] * v[2]\n\n    // jinkang\n    let mut tmp;\n    if a > b {\n        tmp\
    \ = a;\n        a = b;\n        b = tmp;\n    }\n    if a > c {\n        tmp =\
    \ a;\n        a = c;\n        c = tmp;\n    }\n    if b > c {\n        tmp = b;\n\
    \        b = c;\n        c = tmp;\n    }\n    a * a + b * b == c * c", "    let\
    \ h = [a, b, c].iter().max().unwrap();\n    let a = a.pow(2);\n    let b = b.pow(2);\n\
    \    let c = c.pow(2);\n    if a + b == c || a + c == b || b + c == a {\n    \
    \    true\n    } else {\n        false\n    }", "    if a < b {\n        if c\
    \ * c == a * a + b * b {\n            return true;\n        }\n    }\n    if b\
    \ < c {\n        if a * a == b * b + c * c {\n            return true;\n     \
    \   }\n    }\n    if c < a {\n        if b * b == a * a + c * c {\n          \
    \  return true;\n        }\n    }\n    false", "    if (a*a + b*b == c*c) || (a*a\
    \ + c*c == b*b) || (b*b + c*c == a*a) {\n        return true;\n    } else {\n\
    \        return false;\n    }", '    unimplemented!()', "    if a == b || b ==\
    \ c || a == c {\n        return false;\n    }\n    let mut max = a;\n    let mut\
    \ others = b + c;\n    if b > max {\n        max = b;\n        others = a + c;\n\
    \    }\n    if c > max {\n        max = c;\n        others = a + b;\n    }\n \
    \   if max < others {\n        max * max == others * others - max * max\n    }\
    \ else {\n        false\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    assert!(a\
    \ > 0 && b > 0 && c > 0);\n    let max_side = if a > b {\n        if a > c {\n\
    \            a\n        } else {\n            c\n        }\n    } else {\n   \
    \     if b > c {\n            b\n        } else {\n            c\n        }\n\
    \    };\n    if max_side == a {\n        b * b + c * c == a * a\n    } else if\
    \ max_side == b {\n        a * a + c * c == b * b\n    } else {\n        a * a\
    \ + b * b == c * c\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", '    unimplemented!()',
  '    unimplemented!();', "    // your code here\n    unimplemented!()", "    let\
    \ d = (a * a + b * b).cmp(&(c * c));\n    d == std::cmp::Ordering::Equal", '    unimplemented!();',
  "    // return false;\n    // unimplemented!();\n    a*a + b*b == c*c"]
stop_tokens:
- "\n}"
