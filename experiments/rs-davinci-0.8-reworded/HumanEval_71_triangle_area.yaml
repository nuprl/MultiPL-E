name: HumanEval_71_triangle_area
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return the area of\n\
  /// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\
  \ \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum\
  \ of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>>\
  \ triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1\nfn triangle_area(a:\
  \ isize, b: isize, c: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3,\
  \ 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4,\
  \ 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1,\
  \ 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2,\
  \ 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2,\
  \ 2, 10), -1.0);\n}\n"
completions: ["    if !is_valid_triangle(a, b, c) {\n        return -1.0;\n    }\n\
    \    let s = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()", "    if a + b > c && a + c > b && b + c > a {\n \
    \       let s = (a + b + c) as f64 / 2.0;\n        return (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt();\n    } else {\n        return -1.0;\n\
    \    }", "    let mut area = -1f64;\n    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2f64;\n        area = (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n    }\n    area", '    unimplemented!();',
  "    if a + b > c && a + c > b && b + c > a {\n        // https://en.wikipedia.org/wiki/Heron%27s_formula\n\
    \        let p = (a + b + c) as f64 / 2f64;\n        let area = (p * (p - a as\
    \ f64) * (p - b as f64) * (p - c as f64)).sqrt();\n        return area.round()\
    \ / 100f64;\n    }\n    -1f64", "    if a + b > c && a + c > b && b + c > a {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <=\
    \ sides[2] {\n        return -1.0;\n    }\n    let s = (sides[0] + sides[1] +\
    \ sides[2]) as f64 / 2.0;\n    (s * (s - sides[0] as f64) * (s - sides[1] as f64)\
    \ * (s - sides[2] as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let [a, b, c] = sides;\n    let area = (a as f64 + b as f64 + c as f64) /\
    \ 2.0;\n    if area <= a as f64 || area <= b as f64 || area <= c as f64 {\n  \
    \      -1.0\n    } else {\n        area.sqrt() * (area - a as f64).sqrt() * (area\
    \ - b as f64).sqrt()\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n   \
    \ sides.sort();\n    let side_a = sides[0] as f64;\n    let side_b = sides[1]\
    \ as f64;\n    let side_c = sides[2] as f64;\n    if side_a + side_b > side_c\
    \ {\n        let s = (side_a + side_b + side_c) / 2.0;\n        let area = (s\
    \ * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n        area.round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    // Your code here\n    let\
    \ p = (a + b + c) as f64 / 2.0;\n    let area = (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt();\n    if area.is_nan() {\n        -1.0\n    }\
    \ else {\n        area\n    }", "    if a + b > c && a + c > b && b + c > a {\n\
    \        let s = 0.5 * (a + b + c) as f64;\n        (s * (s - a as f64) * (s -\
    \ b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  let perim: isize = a + b + c;\n    let s: f64 = perim as f64 / 2.0;\n    let\
    \ area: f64 = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n\
    \    if a + b > c && a + c > b && b + c > a {\n        return area;\n    }\n \
    \   return -1.0;", "    let p = (a as f64 + b as f64 + c as f64) / 2.0;\n    if\
    \ a < b + c && b < a + c && c < a + b {\n        (p * (p - a as f64) * (p - b\
    \ as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if\
    \ a < b + c && b < a + c && c < a + b {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  '    unimplemented!()', "    let p = (a + b + c) as f64 / 2.0;\n    if a + b > c\
    \ && a + c > b && b + c > a {\n        ((p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n\
    \    }", '    unimplemented!()', "    let mut arr = [a, b, c];\n    arr.sort();\n\
    \    if arr[0] + arr[1] > arr[2] {\n        return (arr[0] + arr[1] + arr[2])\
    \ as f64 / 2.0;\n    }\n    -1.0"]
stop_tokens:
- "\n}"
