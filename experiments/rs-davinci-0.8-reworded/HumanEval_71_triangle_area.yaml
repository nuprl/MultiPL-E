name: HumanEval_71_triangle_area
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return the area of\n\
  /// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\
  \ \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum\
  \ of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>>\
  \ triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1\nfn triangle_area(a:\
  \ isize, b: isize, c: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3,\
  \ 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4,\
  \ 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1,\
  \ 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2,\
  \ 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2,\
  \ 2, 10), -1.0);\n}\n"
completions: ["    if !is_valid_triangle(a, b, c) {\n        return -1.0;\n    }\n\
    \    let s = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()", "    if a + b > c && a + c > b && b + c > a {\n \
    \       let s = (a + b + c) as f64 / 2.0;\n        return (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt();\n    } else {\n        return -1.0;\n\
    \    }", "    let mut area = -1f64;\n    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2f64;\n        area = (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n    }\n    area", '    unimplemented!();',
  "    if a + b > c && a + c > b && b + c > a {\n        // https://en.wikipedia.org/wiki/Heron%27s_formula\n\
    \        let p = (a + b + c) as f64 / 2f64;\n        let area = (p * (p - a as\
    \ f64) * (p - b as f64) * (p - c as f64)).sqrt();\n        return area.round()\
    \ / 100f64;\n    }\n    -1f64", "    if a + b > c && a + c > b && b + c > a {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <=\
    \ sides[2] {\n        return -1.0;\n    }\n    let s = (sides[0] + sides[1] +\
    \ sides[2]) as f64 / 2.0;\n    (s * (s - sides[0] as f64) * (s - sides[1] as f64)\
    \ * (s - sides[2] as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let [a, b, c] = sides;\n    let area = (a as f64 + b as f64 + c as f64) /\
    \ 2.0;\n    if area <= a as f64 || area <= b as f64 || area <= c as f64 {\n  \
    \      -1.0\n    } else {\n        area.sqrt() * (area - a as f64).sqrt() * (area\
    \ - b as f64).sqrt()\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n   \
    \ sides.sort();\n    let side_a = sides[0] as f64;\n    let side_b = sides[1]\
    \ as f64;\n    let side_c = sides[2] as f64;\n    if side_a + side_b > side_c\
    \ {\n        let s = (side_a + side_b + side_c) / 2.0;\n        let area = (s\
    \ * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n        area.round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    // Your code here\n    let\
    \ p = (a + b + c) as f64 / 2.0;\n    let area = (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt();\n    if area.is_nan() {\n        -1.0\n    }\
    \ else {\n        area\n    }", "    if a + b > c && a + c > b && b + c > a {\n\
    \        let s = 0.5 * (a + b + c) as f64;\n        (s * (s - a as f64) * (s -\
    \ b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  let perim: isize = a + b + c;\n    let s: f64 = perim as f64 / 2.0;\n    let\
    \ area: f64 = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n\
    \    if a + b > c && a + c > b && b + c > a {\n        return area;\n    }\n \
    \   return -1.0;", "    let p = (a as f64 + b as f64 + c as f64) / 2.0;\n    if\
    \ a < b + c && b < a + c && c < a + b {\n        (p * (p - a as f64) * (p - b\
    \ as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if\
    \ a < b + c && b < a + c && c < a + b {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  '    unimplemented!()', "    let p = (a + b + c) as f64 / 2.0;\n    if a + b > c\
    \ && a + c > b && b + c > a {\n        ((p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n\
    \    }", '    unimplemented!()', "    let mut arr = [a, b, c];\n    arr.sort();\n\
    \    if arr[0] + arr[1] > arr[2] {\n        return (arr[0] + arr[1] + arr[2])\
    \ as f64 / 2.0;\n    }\n    -1.0", "    if a + b > c && a + c > b && b + c > a\
    \ {\n        let p = (a + b + c) as f64 / 2.0;\n        ((p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    let a = a as f64;\n    let b = b as f64;\n   \
    \ let c = c as f64;\n    if a + b > c && a + c > b && b + c > a {\n        (a\
    \ + b + c) / 2.0\n    } else {\n        -1.0\n    }", "    if is_valid_triangle(a,\
    \ b, c) {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    let area = 0.25 * ((a + b + c) as f64 * (b + c - a) as f64 * (c + a - b) as\
    \ f64 * (a + b - c) as f64).sqrt();\n    if area.is_nan() {\n        -1.0\n  \
    \  } else {\n        area\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] <= sides[2] {\n        return -1.0;\n    }\n    let\
    \ p = 0.5 * (a + b + c) as f64;\n    ((p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt() * 100.0).round() / 100.0", "    let temp = [a, b, c];\n\
    \    let mut max = a;\n    let mut aa = a;\n    let mut bb = b;\n    let mut cc\
    \ = c;\n    for i in &temp {\n        if *i > max {\n            max = *i;\n \
    \       }\n    }\n    if aa > max {\n        aa = b;\n        bb = c;\n      \
    \  cc = a;\n    }\n    if bb > max {\n        bb = a;\n        cc = b;\n    }\n\
    \    let s = aa + bb;\n    if s > cc {\n        ((s + cc) * (s - cc) * (s - aa)\
    \ * (s - bb)) as f64\n    } else {\n        -1 as f64\n    }", "    if (a + b\
    \ > c) && (a + c > b) && (b + c > a) {\n        let p = (a + b + c) as f64 / 2.0;\n\
    \        ((p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    if a + b <= c || a + c <= b || b + c <= a {\n\
    \        return -1.0;\n    }\n\n    let s = (a + b + c) as f64 / 2.0;\n    (s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()", "    let mut side_lengths\
    \ = [a, b, c];\n    side_lengths.sort();\n    let (a, b, c) = (side_lengths[0],\
    \ side_lengths[1], side_lengths[2]);\n    if c >= a + b {\n        return -1.0;\n\
    \    }\n\n    let s = (a + b + c) as f64 / 2.0;\n    ((s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)).sqrt()", "    let mut side = [a, b, c];\n    side.sort();\n\
    \    let [a, b, c] = side;\n    if a + b > c {\n        let p = (a + b + c) as\
    \ f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a + b <= c || a + c <= b || b + c\
    \ <= a {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n\
    \    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let\
    \ (a, b, c) = (a as f64, b as f64, c as f64);\n    if a + b > c && a + c > b &&\
    \ b + c > a {\n        let s = (a + b + c) / 2.0;\n        (s * (s - a) * (s -\
    \ b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <= sides[2] {\n\
    \        return -1.0;\n    }\n\n    let p = (a + b + c) as f64 / 2.0;\n    (p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  let\
    \ mut sides = [a, b, c];\n  sides.sort();\n  let s = sides[0] + sides[1];\n  if\
    \ s > sides[2] {\n    let x = (s * (s - sides[0]) * (s - sides[1]) * (s - sides[2]));\n\
    \    (x as f64).sqrt() / 4f64\n  } else {\n    -1f64\n  }", '    unimplemented!()',
  "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if is_valid_triangle(a, b, c) {\n  \
    \      area_of_triangle(a, b, c)\n    } else {\n        -1.0\n    }", "    use\
    \ std::f64;\n    let side_a = a as f64;\n    let side_b = b as f64;\n    let side_c\
    \ = c as f64;\n    if (side_a + side_b) > side_c &&\n        (side_a + side_c)\
    \ > side_b &&\n        (side_b + side_c) > side_a {\n        let s = (side_a +\
    \ side_b + side_c) / 2.0;\n        let area = s * (s - side_a) * (s - side_b)\
    \ * (s - side_c);\n        f64::sqrt(area)\n    } else {\n        -1.0\n    }",
  "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    let (a, b, c) = if a >\
    \ b { (b, a, c) } else { (a, b, c) };\n    let (a, b, c) = if a > c { (c, b, a)\
    \ } else { (a, b, c) };\n    if a + b <= c {\n        -1.0\n    } else {\n   \
    \     let p = (a + b + c) / 2.0;\n        (p * (p - a) * (p - b) * (p - c)).sqrt()\n\
    \    }", "    let sides = [a, b, c];\n    if sides.iter().any(|&x| x <= 0) {\n\
    \        return -1.0;\n    }\n    let (p, q, r) = (sides[0] as f64, sides[1] as\
    \ f64, sides[2] as f64);\n    let s = (p + q + r) / 2.0;\n    let area = (s *\
    \ (s - p) * (s - q) * (s - r)).sqrt();\n    if area.is_nan() {\n        -1.0\n\
    \    } else {\n        area\n    }", "    // Insert code here\n    -1.0", "  \
    \  if (a + b > c) && (a + c > b) && (b + c > a) {\n        let s = (a + b + c)\
    \ as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let sides = [a, b, c];\n    let max_side\
    \ = sides.iter().max().unwrap();\n    let sum_of_other_sides = sides.iter().fold(0,\
    \ |acc, x| acc + x) - max_side;\n    if sum_of_other_sides > *max_side {\n   \
    \     let perimeter = sides.iter().fold(0, |acc, x| acc + x) as f64;\n       \
    \ let semi_perimeter = perimeter / 2.0;\n        let area = semi_perimeter * (semi_perimeter\
    \ - a as f64) *\n            (semi_perimeter - b as f64) * (semi_perimeter - c\
    \ as f64);\n        return (area as f64).sqrt().round() / 100.0;\n    } else {\n\
    \        return -1.0;\n    }", "    if a + b > c && a + c > b && b + c > a {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        ((p * (p - a as f64) * (p\
    \ - b as f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n\
    \        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n       \
    \ let s = (a + b + c) as f64 / 2.0;\n        return s.sqrt() * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64);\n    }\n    -1.0", "    let mut v = vec![a,\
    \ b, c];\n    v.sort();\n    let (a, b, c) = (v[0], v[1], v[2]);\n    if a + b\
    \ <= c {\n        -1.0\n    } else {\n        let p = (a + b + c) as f64 / 2.0;\n\
    \        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    }",
  "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1f64;\n    }\n\
    \n    let p = (a + b + c) as f64 / 2f64;\n    let area = p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64);\n    (area.sqrt() * 100f64).round() / 100f64",
  "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\
    \    let p = (a + b + c) as f64 / 2.0;\n    let s = p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64);\n    (s.sqrt() * 100.0).round() / 100.0", "    let\
    \ mut v = vec![a, b, c];\n    v.sort();\n    let (a, b, c) = (v[0], v[1], v[2]);\n\
    \    if a + b <= c {\n        -1.0\n    } else {\n        let p = (a + b + c)\
    \ as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    }", "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b\
    \ + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64)).sqrt()\n    } else {\n        -1.0\n    }", "    // Try to make a triangle\n\
    \    // If triangle is valid return area\n    // If invalid return -1.0\n\n  \
    \  // Check if sides make a valid triangle\n    if a + b > c && a + c > b && b\
    \ + c > a {\n        // No zeros allowed\n        if a == 0 || b == 0 || c ==\
    \ 0 {\n            return -1.0;\n        }\n        // Sides are valid\n     \
    \   // Use Heron's formula to determine area\n        let s = (a + b + c) as f64\
    \ / 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)).sqrt();\n        return area;\n    } else {\n        return -1.0;\n  \
    \  }", "    let d: f64 = (a + b + c) as f64 / 2.0;\n    let e: f64 = d * (d -\
    \ a as f64) * (d - b as f64) * (d - c as f64);\n    if e < 0.0 {\n        -1.0\n\
    \    } else {\n        (e.sqrt() * 100.0).round() / 100.0\n    }", "    if a +\
    \ b > c && a + c > b && b + c > a {\n        let mut p = (a + b + c) as f64 /\
    \ 2.0;\n        return (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    }\n    -1.0", "    let area = (a + b + c) as f64 / 2.0;\n    if area > 0.0\
    \ { area.sqrt() * 2.0 } else { -1.0 }", "    let mut s = (a + b + c) as f64 /\
    \ 2.0;\n    let tri_area = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n\
    \    if tri_area <= 0.0 {\n        -1.0\n    } else {\n        (tri_area.sqrt()\
    \ * 100.0).round() / 100.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let s = (a + b + c) as f64 / 2.0;\n        ((s - a as f64) * (s\
    \ - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", " \
    \   let mut area: f64 = -1.0;\n    if a < b + c && b < a + c && c < a + b {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        area = p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64);\n        area = area.sqrt();\n    }\n   \
    \ area", "    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b\
    \ + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides = [a, b,\
    \ c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <= sides[2] {\n\
    \        return -1.0;\n    }\n    let s = (sides[0] + sides[1] + sides[2]) as\
    \ f64 / 2.0;\n    (s * (s - sides[0] as f64) * (s - sides[1] as f64) * (s - sides[2]\
    \ as f64)).sqrt()", "    let mut v = vec![a, b, c];\n    v.sort();\n    if v[0]\
    \ + v[1] > v[2] {\n        return (v[0] + v[1] + v[2]) as f64 * 0.5 * (v[2] -\
    \ v[0] + v[1] - v[0]) as f64;\n    }\n    -1.0", '    unimplemented!()', "   \
    \ if (a + b > c) && (a + c > b) && (b + c > a) {\n        let s = (a + b + c)\
    \ as f64 / 2.0;\n        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    if a + b\
    \ > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    let mut sides = vec![a, b,\
    \ c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a + b\
    \ > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64;\n     \
    \   let half_p = p / 2.0;\n        (half_p * (half_p - a as f64) * (half_p - b\
    \ as f64) * (half_p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", " \
    \   if a + b > c && a + c > b && b + c > a {\n        // the biggest side is c\n\
    \        let s = (a + b + c) as f64 / 2.0;\n        // Heron's formula\n     \
    \   (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    let s = 0.5 * (a + b + c) as f64;\n    let area\
    \ = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if area > 0.0 {\n\
    \        area.sqrt()\n    } else {\n        -1.0\n    }", "    // TODO: Implementation\
    \ goes here\n    return -1.0;", "    // your code here\n    unimplemented!()",
  "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let s = (a\
    \ + b + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt();\n    return area;", '    unimplemented!()', "    if\
    \ a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let total = a + b + c;\n    let semi_perimeter\
    \ = total / 2;\n    let area = (semi_perimeter * (semi_perimeter - a) * (semi_perimeter\
    \ - b) * (semi_perimeter - c)) as f64;\n    if area > 0.0 {\n        return (area\
    \ as f64).sqrt().round() / 100.0;\n    }\n    return -1.0;", '    unimplemented!()',
  "    // sort the sides\n    let mut v = vec![a, b, c];\n    v.sort();\n    let a\
    \ = v[0];\n    let b = v[1];\n    let c = v[2];\n\n    // check if the triangle\
    \ is valid\n    if a + b > c {\n        let p = (a + b + c) as f64 / 2.0;\n  \
    \      let s = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n       \
    \ return (s.sqrt() * 100.0).round() / 100.0;\n    }\n    -1.0", "    let s = (a\
    \ + b + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt();\n    if area.is_nan() {\n        -1.0\n    } else\
    \ {\n        area\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    let a = sides[0] as f64;\n    let b = sides[1] as f64;\n    let c = sides[2]\
    \ as f64;\n    if a + b > c {\n        let p = (a + b + c) / 2.0;\n        (p\
    \ * (p - a) * (p - b) * (p - c)).sqrt()\n    } else {\n        -1.0\n    }", " \
    \   let s = (a + b + c) as f64 / 2.0;\n    if a < s && b < s && c < s {\n    \
    \    s.powf(2.0) - a as f64 * s + b as f64 * s - c as f64 * s\n    } else {\n\
    \        -1.0\n    }", "    // TODO Complete this function so that it returns\
    \ the area of the triangle\n    // rounded to 2 decimal points.\n    if a + b\
    \ > c && a + c > b && b + c > a {\n        return ((a + b + c) as f64 / 2.0).sqrt()\
    \ * (0.5 * (a + b + c) as f64 / 2.0).sqrt();\n    }\n    -1.0", "    let sides\
    \ = vec![a, b, c];\n    sides.iter().max().unwrap() >= &(a + b + c - sides.iter().max().unwrap())\
    \ as &isize\n        && sides.iter().min().unwrap() > &0\n        && a + b + c\
    \ > 0\n        && a.is_positive()\n        && b.is_positive()\n        && c.is_positive()\n\
    \    {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    // Check if valid triangle\n    if a + b > c && a + c > b && b + c > a {\n\
    \        // Area of a triangle = sqrt(s(s-a)(s-b)(s-c)) where s = perimeter/2\n\
    \        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s -\
    \ b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  // TODO\n    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n\
    \    }\n    let p = (a + b + c) as f64 / 2.0;\n    return (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt();", "    // if triangle is impossible,\
    \ return -1\n    let max_side = a.max(b).max(c);\n    if a + b + c - max_side\
    \ <= max_side {\n        return -1.0;\n    }\n    // calculate area\n    let s\
    \ = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64) * (s -\
    \ c as f64)).sqrt()", "    let mut arr = [a, b, c];\n    arr.sort();\n    if arr[0]\
    \ + arr[1] > arr[2] {\n        arr[0] as f64 * arr[1] as f64 * f64::sin(f64::acos((arr[2]\
    \ as f64 * arr[2] as f64 - arr[0] as f64 * arr[0] as f64 - arr[1] as f64 * arr[1]\
    \ as f64) / (2.0 * arr[0] as f64 * arr[1] as f64))) / 2.0\n    } else {\n    \
    \    -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let\
    \ s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut output\
    \ = -1.0;\n    if a + b > c && a + c > b && b + c > a {\n        output = f64::from(a\
    \ * b) / 2f64;\n    }\n    output", "    let sum = a + b + c;\n    if a < 0 ||\
    \ b < 0 || c < 0 || sum <= 2 * (a.max(b).max(c)) {\n        -1.0\n    } else {\n\
    \        let p = (sum as f64) / 2.0;\n        (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt()\n    }", "    let mut arr = [a, b, c];\n    arr.sort();\n\
    \    let mut s = (arr[0] + arr[1] + arr[2]) as f64 / 2.0;\n    if arr[0] + arr[1]\
    \ > arr[2] {\n        s * (s - arr[0] as f64) * (s - arr[1] as f64) * (s - arr[2]\
    \ as f64)\n    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b\
    \ && b + c > a {\n        let s = 0.5 * (a + b + c) as f64;\n        ((s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.).round() / 100.\n\
    \    } else {\n        -1.\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    let mut side_vec = vec![a, b, c];\n    side_vec.sort();\n    if side_vec[0]\
    \ + side_vec[1] <= side_vec[2] {\n        return -1f64;\n    }\n    let p = (a\
    \ + b + c) as f64 / 2f64;\n    return (p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt();", '    unimplemented!()', "    //if a + b > c && a + c\
    \ > b && b + c > a {\n    //    let s = (a + b + c) as f64 / 2.0;\n    //    return\
    \ (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    //}\n   \
    \ //-1.0\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b\
    \ + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if (a + b) > c && (a\
    \ + c) > b && (b + c) > a {\n        let s = (a + b + c) as f64 / 2f64;\n    \
    \    (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else\
    \ {\n        -1f64\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    // Checks if the triangle is valid\n\
    \    if is_valid_triangle(a, b, c) {\n        let p = (a + b + c) as f64 / 2.0;\n\
    \        return p * (p - a as f64) * (p - b as f64) * (p - c as f64).sqrt();\n\
    \    }\n    // Return -1 if triangle is invalid\n    return -1.0;", "    // Your\
    \ code here\n    let mut arr = [a, b, c];\n    arr.sort();\n    if arr[0] + arr[1]\
    \ <= arr[2] {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64;\n\
    \    let p2 = p / 2.0;\n    let area = (p2 * (p2 - a as f64) * (p2 - b as f64)\
    \ * (p2 - c as f64)).sqrt();\n    let round = area.round();\n    return round;",
  "    if (a + b > c) && (a + c > b) && (b + c > a) {\n        let p = (a + b + c)\
    \ as f64 / 2.0;\n        return ((p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt() * 100.0).round() / 100.0;\n    }\n    return -1.0;", "    if\
    \ (a + b > c) && (a + c > b) && (b + c > a) {\n        let s = (a + b + c) as\
    \ f64 / 2.0;\n        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    if a <= 0\
    \ || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    if a + b > c && a +\
    \ c > b && b + c > a {\n        let s = (a + b + c) as f64;\n        let area\
    \ = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        return\
    \ (area * 100.0).round() / 100.0;\n    }\n    return -1.0;", "    // Calculate\
    \ the largest side\n    let max = if a > b {\n        if a > c { a } else { c\
    \ }\n    } else {\n        if b > c { b } else { c }\n    };\n\n    // Only calculate\
    \ area if the sum of the other two sides is greater than\n    // the max\n   \
    \ if a + b + c - max > max {\n        let p = (a + b + c) as f64 / 2.0;\n    \
    \    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n   \
    \     let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let\
    \ mut tmp = [a, b, c];\n    tmp.sort();\n    if tmp[0] + tmp[1] <= tmp[2] {\n\
    \        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p *\
    \ (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    if (a + b >\
    \ c) && (a + c > b) && (b + c > a) {\n        let p = (a + b + c) as f64 / 2f64;\n\
    \        let res = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n   \
    \     res.sqrt()\n    } else {\n        -1f64\n    }", "    let mut area: f64\
    \ = -1.0;\n    if (a + b > c) && (a + c > b) && (b + c > a) {\n        let s =\
    \ (a + b + c) as f64 / 2.0;\n        area = (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt();\n    }\n    area", "    if a < 0 || b < 0 || c < 0\
    \ {\n        return -1.0;\n    }\n    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let s = (sides[0] + sides[1]\
    \ + sides[2]) as f64 / 2.0;\n        (s * (s - sides[0] as f64) * (s - sides[1]\
    \ as f64) * (s - sides[2] as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    if (a > 0) && (b > 0) && (c > 0) && (a + b > c) && (a + c > b) && (b + c >\
    \ a) {\n        let s = (a + b + c) as f64 / 2.0;\n        let root = s * (s -\
    \ a as f64) * (s - b as f64) * (s - c as f64);\n        return root.sqrt();\n\
    \    } else {\n        return -1.0;\n    }", "  if a + b > c && a + c > b && b\
    \ + c > a {\n    ((a as f64) + (b as f64) + (c as f64)) / 2.0\n  } else {\n  \
    \  -1.0\n  }", "    // check validity of triangle\n    if a + b > c && a + c >\
    \ b && b + c > a {\n        // calculate area using Heron's formula\n        let\
    \ s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", '    unimplemented!();',
  "    if a > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a {\n     \
    \   let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if (a\
    \ + b > c) && (a + c > b) && (b + c > a) {\n        ((a as f64 + b as f64 + c\
    \ as f64) / 2.0).sqrt() * (((a as f64 + b as f64 + c as f64) / 2.0) - a as f64).sqrt()\
    \ * (((a as f64 + b as f64 + c as f64) / 2.0) - b as f64).sqrt()\n    } else {\n\
    \        -1.0\n    }", "  if (a + b > c) && (a + c > b) && (b + c > a) {\n   \
    \ let p = (a + b + c) as f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt() * 100.0).round() / 100.0\n  } else {\n    -1.0\n  }",
  "    match (a, b, c) {\n        (x, y, z) if x + y <= z => -1f64,\n        (x, y,\
    \ z) if x + z <= y => -1f64,\n        (x, y, z) if y + z <= x => -1f64,\n    \
    \    (x, y, z) => {\n            let s = (x + y + z) as f64 / 2f64;\n        \
    \    (s * (s - x as f64) * (s - y as f64) * (s - z as f64)).sqrt()\n        }\n\
    \    }", "    if (a + b) > c && (a + c) > b && (b + c) > a {\n        let p =\
    \ (a + b + c) as f64 / 2.0;\n        ((p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n \
    \   }", "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n\
    \    }\n\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p\
    \ - b as f64) * (p - c as f64)).sqrt()", "    if a + b > c && a + c > b && b +\
    \ c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    let mut nums = [a, b, c];\n    nums.sort();\n    if nums[0] + nums[1] <= nums[2]\
    \ {\n        return -1f64;\n    }\n    let s = (a + b + c) as f64 / 2f64;\n  \
    \  (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()", "    let area\
    \ = |a: isize, b: isize, c: isize| {\n        let (a, b, c) = sort3(a, b, c);\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    };\n    match (a, b, c) {\n        (a,\
    \ b, c) if a + b > c => area(a, b, c),\n        _ => -1.0,\n    }", "    let s\
    \ = (a + b + c) as f64 / 2.0;\n    let triangle_area = (s * (s - a as f64) * (s\
    \ - b as f64) * (s - c as f64)).sqrt();\n    if triangle_area.is_nan() {\n   \
    \     -1.0\n    } else {\n        triangle_area\n    }", "    let s = (a + b +\
    \ c) as f64 / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n        ((s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    let mut sides = [a, b, c];\n\
    \    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let s = (sides[0]\
    \ + sides[1] + sides[2]) as f64 / 2.0;\n        ((s * (s - sides[0] as f64) *\
    \ (s - sides[1] as f64) * (s - sides[2] as f64)).sqrt() * 100.0).round() / 100.0\n\
    \    } else {\n        -1.0\n    }", "    if a + b <= c || a + c <= b || b + c\
    \ <= a {\n        return -1.0;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n\
    \    (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()", "    if a\
    \ <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let p = (a + b\
    \ + c) as f64 / 2.0;\n    let a = (p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64)).sqrt();\n    a.round() / 100.0", "    let mut sides = [a, b, c];\n\
    \    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let p = (a\
    \ + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let s = (a + b +\
    \ c) as f64 / 2.0;\n    if s < a as f64 || s < b as f64 || s < c as f64 {\n  \
    \      return -1.0;\n    }\n    s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    let [a, b,\
    \ c] = sides;\n    if a + b > c {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    }\
    \ else {\n        -1.0\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        let area = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n\
    \        if area >= 0.0 {\n            (area.sqrt() * 100.0).round() / 100.0\n\
    \        } else {\n            -1.0\n        }\n    } else {\n        -1.0\n \
    \   }", "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n\
    \    }\n    let s = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s -\
    \ b as f64) * (s - c as f64)).sqrt()", "    if a + b > c && a + c > b && b + c\
    \ > a {\n        let s = (a + b + c) as f64 / 2.0;\n        let root = s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64);\n        return (root.sqrt()\
    \ * 100.0).round() / 100.0;\n    }\n    -1.0", "  if a + b > c && a + c > b &&\
    \ b + c > a {\n    let p = (a + b + c) as f64;\n    let s = p / 2.0;\n    (s *\
    \ (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n  } else {\n    -1.0\n\
    \  }", "    let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1]\
    \ > sides[2] {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let s = (sides[0] + sides[1] + sides[2]) as\
    \ f64 / 2.0;\n        s * (s - sides[0] as f64) * (s - sides[1] as f64) * (s -\
    \ sides[2] as f64)\n    } else {\n        -1.0\n    }", "    let mut v = vec![a,\
    \ b, c];\n    v.sort();\n    let a = v[0] as f64;\n    let b = v[1] as f64;\n\
    \    let c = v[2] as f64;\n    if a + b > c {\n        let p = (a + b + c) / 2.0;\n\
    \        (p * (p - a) * (p - b) * (p - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let square = |x: isize| -> f64 { x as f64 * x as f64 };\n    if\
    \ a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        (s * (s - square(a)) * (s - square(b)) * (s - square(c))).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let p = 0.5 * (a + b + c) as f64;\n\
    \    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let\
    \ area = ((a + b + c) as f64 / 2.0).sqrt();\n    if a + b > c && a + c > b &&\
    \ b + c > a {\n        area * area\n    } else {\n        -1.0\n    }", "    let\
    \ mut arr = [a, b, c];\n    arr.sort();\n    if arr[0] + arr[1] > arr[2] {\n \
    \       ((arr[0] + arr[1] + arr[2]) as f64 / 2.0 * (arr[0] + arr[1] + arr[2])\
    \ as f64 / 2.0\n            - arr[0] as f64 * arr[0] as f64\n            - arr[1]\
    \ as f64 * arr[1] as f64\n            - arr[2] as f64 * arr[2] as f64).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut triangle = vec![a, b, c];\n\
    \    triangle.sort();\n    let a = triangle[0] as f64;\n    let b = triangle[1]\
    \ as f64;\n    let c = triangle[2] as f64;\n    if a + b > c {\n        (a + b\
    \ + c) / 2.0 * ((a + b + c) / 2.0 - a) * ((a + b + c) / 2.0 - b) * ((a + b + c)\
    \ / 2.0 - c)\n    } else {\n        -1.0\n    }.sqrt()", "    if a > 0 && b >\
    \ 0 && c > 0 && a + b > c && a + c > b && b + c > a {\n        let p = (a + b\
    \ + c) as f64 / 2f64;\n        ((p - a as f64) * (p - b as f64) * (p - c as f64)\
    \ * p).sqrt()\n    } else {\n        -1f64\n    }", "    if a + b > c && a + c\
    \ > b && b + c > a {\n        let s = 0.5 * (a + b + c) as f64;\n        (s *\
    \ (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n   \
    \     -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let res =\
    \ (a + b + c) as f64 / 2.0;\n    if res * (res - a as f64) * (res - b as f64)\
    \ * (res - c as f64) <= 0.0 {\n        -1.0\n    } else {\n        let mut result\
    \ = (res * (res - a as f64) * (res - b as f64) * (res - c as f64)).sqrt();\n \
    \       let mut decimals = result.to_string().split(\".\").collect::<Vec<&str>>();\n\
    \        if decimals.len() == 2 {\n            let mut result_str = String::new();\n\
    \            let mut count = 2;\n            for char in decimals[1].chars() {\n\
    \                result_str.push(char);\n                count -= 1;\n       \
    \         if count == 0 {\n                    break;\n                }\n   \
    \         }\n            result = result_str.parse::<f64>().unwrap();\n      \
    \  }\n        result\n    }", "    let a: f64 = a as f64;\n    let b: f64 = b\
    \ as f64;\n    let c: f64 = c as f64;\n    let p = (a + b + c) / 2.0;\n    if\
    \ a + b > c && a + c > b && b + c > a {\n        (p * (p - a) * (p - b) * (p -\
    \ c)).sqrt()\n    } else {\n        -1.0\n    }", "    if is_valid_triangle(a,\
    \ b, c) {\n        let p = (a + b + c) as f64 / 2.0;\n        ((p - a as f64)\
    \ * (p - b as f64) * (p - c as f64) * p).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let s = (a + b + c) as f64 / 2.0;\n    let area = s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64);\n    if area > 0.0 {\n        area.sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut vec = vec![a, b, c];\n    vec.sort();\n\
    \    if vec[0] + vec[1] > vec[2] {\n        let p = (a + b + c) as f64 / 2.0;\n\
    \        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    }\
    \ else {\n        -1.0\n    }", "    let a = a as f64;\n    let b = b as f64;\n\
    \    let c = c as f64;\n    let p = (a + b + c) / 2.0;\n    if (a + b > c) &&\
    \ (a + c > b) && (b + c > a) {\n        (p * (p - a) * (p - b) * (p - c)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if (a > 0) && (b > 0) && (c > 0) &&\
    \ ((a + b) > c) && ((a + c) > b) && ((b + c) > a) {\n        let p = (a + b +\
    \ c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    let (a, b, c) = (sides[0], sides[1], sides[2]);\n    let p = (a + b + c)\
    \ as f64 / 2.0;\n    if a + b > c {\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let p = (a\
    \ + b + c) as f64 / 2.0;\n    let s = p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64);\n    if s > 0.0 { s.sqrt() } else { -1.0 }", "    let sum_ab =\
    \ a + b;\n    let sum_bc = b + c;\n    let sum_ac = a + c;\n    if sum_ab > c\
    \ && sum_bc > a && sum_ac > b {\n        let p = (sum_ab + sum_bc + sum_ac) as\
    \ f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut side_values = [a, b, c];\n \
    \   side_values.sort();\n    let a = side_values[0] as f64;\n    let b = side_values[1]\
    \ as f64;\n    let c = side_values[2] as f64;\n    if a + b <= c {\n        return\
    \ -1.0;\n    }\n    let p = (a + b + c) / 2.0;\n    let area = (p * (p - a) *\
    \ (p - b) * (p - c)).sqrt();\n    (area * 100.0).round() / 100.0", "    if a +\
    \ b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\n    let\
    \ s = (a + b + c) as f64 / 2.0;\n    let area = s * (s - a as f64) * (s - b as\
    \ f64) * (s - c as f64);\n    (area.sqrt() * 100.0).round() / 100.0", "    let\
    \ sides = [a, b, c];\n    sides.iter().sum::<isize>() - sides.iter().max().unwrap_or(&0)\
    \ > *sides.iter().max().unwrap_or(&0) &&\n        sides.iter().sum::<isize>()\
    \ > 0 &&\n        sides.iter().all(|x| x > &0)\n        && a != b\n        &&\
    \ b != c\n        && a != c\n        && *sides.iter().max().unwrap_or(&0) < sides.iter().sum::<isize>()\
    \ - *sides.iter().max().unwrap_or(&0)\n        && *sides.iter().max().unwrap_or(&0)\
    \ > 0\n    {\n        let s = sides.iter().sum::<isize>() as f64 / 2.0;\n    \
    \    (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt().round() / 100.0\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        ((a as f64 + b as f64 + c as f64) / 2.0).sqrt() * 2.0\n    } else\
    \ {\n        -1.0\n    }", "    let sum = (a + b + c) as f64;\n    let p = sum\
    \ / 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    if area > 0.0 { area } else { -1.0 }", "    let p = (a + b + c) as f64 /\
    \ 2f64;\n    if p * (p - a as f64) * (p - b as f64) * (p - c as f64) <= 0f64 {\n\
    \        -1f64\n    } else {\n        (p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt()\n    }", "    if a + b <= c || a + c <= b || b + c <= a\
    \ {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    let\
    \ area = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    (area.sqrt()\
    \ * 100.0).round() / 100.0", "    if a + b > c && a + c > b && b + c > a {\n \
    \       // Can find a formula for area of a triangle if you know the side lengths,\n\
    \        // but we don't need to actually calculate it. We just need to know if\n\
    \        // it's a triangle or not, so we can return the area of a valid triangle\n\
    \        // or -1 for an invalid triangle.\n        6.0\n    } else {\n      \
    \  -1.0\n    }", "  if !valid_triangle(a, b, c) {\n    return -1.0;\n  }\n  let\
    \ p = (a + b + c) as f64 / 2.0;\n  (p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64)).sqrt()", "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n\
    \    }\n\n    let s = (a + b + c) as f64 / 2.0;\n    let area = s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64);\n    if area <= 0.0 {\n        return\
    \ -1.0;\n    }\n\n    return (area.sqrt() * 100.0).round() / 100.0;", "    if\
    \ a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n\
    \        return area;\n    }\n    -1.0", "    let mut sides = [a, b, c];\n   \
    \ sides.sort();\n    let a = sides[0] as f64;\n    let b = sides[1] as f64;\n\
    \    let c = sides[2] as f64;\n    let s = (a + b + c) / 2.0;\n    if a + b >\
    \ c {\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n      \
    \  -1.0\n    }", "    let (x, y, z) = if a < b {\n        if a < c {\n       \
    \     (a, b, c)\n        } else {\n            (c, a, b)\n        }\n    } else\
    \ {\n        if b < c {\n            (b, a, c)\n        } else {\n           \
    \ (c, a, b)\n        }\n    };\n    let p = (x + y + z) as f64 / 2.0;\n    if\
    \ x + y <= z {\n        -1.0\n    } else {\n        (p * (p - x as f64) * (p -\
    \ y as f64) * (p - z as f64)).sqrt()\n    }", "    if (a + b <= c) || (a + c <=\
    \ b) || (b + c <= a) {\n        return -1.0;\n    }\n    let p = (a + b + c) as\
    \ f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0", "    let mut area: f64 = -1.0;\n    if is_valid_triangle(a,\
    \ b, c) {\n        let s = (a + b + c) as f64 / 2.0;\n        area = (s * (s -\
    \ a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    }\n    return area;",
  "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    if (a + b > c) && (a +\
    \ c > b) && (b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return\
    \ s.sqrt() * (s - a) * (s - b) * (s - c);\n    }\n    -1.0", "    let (a, b, c)\
    \ = (a as f64, b as f64, c as f64);\n    let s = (a + b + c) / 2.0;\n    if a\
    \ + b > c && a + c > b && b + c > a {\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let a: f64 = a as f64;\n    let b: f64\
    \ = b as f64;\n    let c: f64 = c as f64;\n    if a + b > c && a + c > b && b\
    \ + c > a {\n        let p = (a + b + c) / 2.0;\n        ((p * (p - a) * (p -\
    \ b) * (p - c)).sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n\
    \    }", "    let a = a as f64;\n    let b = b as f64;\n    let c = c as f64;\n\
    \    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) / 2.0;\n\
    \        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    if a + b <=\
    \ c || a + c <= b || b + c <= a {\n        -1.0\n    } else {\n        let p =\
    \ (a + b + c) / 2.0;\n        (p * (p - a) * (p - b) * (p - c)).sqrt()\n    }",
  "    let mut tr = vec![a, b, c];\n    tr.sort();\n    if tr[0] + tr[1] > tr[2] {\n\
    \        let s = (tr[0] + tr[1] + tr[2]) as f64 / 2.0;\n        (s * (s - tr[0]\
    \ as f64) * (s - tr[1] as f64) * (s - tr[2] as f64)).sqrt()\n    } else {\n  \
    \      -1.0\n    }", '    unimplemented!();', "    if a + b > c && a + c > b &&\
    \ b + c > a {\n        let perimeter = a + b + c;\n        let s = perimeter as\
    \ f64 / 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c\
    \ as f64)).sqrt();\n        return area;\n    } else {\n        return -1.0;\n\
    \    }", "    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b\
    \ + c) as f64 / 2.0;\n        let area = s * (s - a as f64) * (s - b as f64) *\
    \ (s - c as f64);\n        return (area.sqrt() * 100.0).round() / 100.0;\n   \
    \ }\n    -1.0", "    if a + b > c && a + c > b && b + c > a {\n        let p =\
    \ (a + b + c) as f64 / 2.0;\n        ((p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a < 1 || b < 1\
    \ || c < 1 {\n        return -1 as f64;\n    }\n    if a + b <= c || a + c <=\
    \ b || b + c <= a {\n        return -1 as f64;\n    }\n    let p = (a + b + c)\
    \ as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    let mut my_vec = vec![a, b, c];\n    my_vec.sort();\n    let p = my_vec[0]\
    \ + my_vec[1];\n    if p > my_vec[2] {\n        let s = (p as f64 + my_vec[2]\
    \ as f64) / 2.0;\n        return (s * (s - my_vec[0] as f64) * (s - my_vec[1]\
    \ as f64) * (s - my_vec[2] as f64)).sqrt();\n    }\n    -1.0", "    let mut s\
    \ = vec![a, b, c];\n    s.sort();\n    if s[0] + s[1] <= s[2] {\n        return\
    \ -1.0;\n    }\n    ((s[0] + s[1] + s[2]) as f64 / 2.0).sqrt() * ((s[0] + s[1]\
    \ + s[2]) as f64 / 2.0 - s[0] as f64).sqrt() * ((s[0] + s[1] + s[2]) as f64 /\
    \ 2.0 - s[1] as f64).sqrt()", "    let s = (a + b + c) as f64 / 2.0;\n    let\
    \ t = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if t <= 0.0 {\n\
    \        -1.0\n    } else {\n        t.sqrt()\n    }", "    let mut v = [a, b,\
    \ c];\n    v.sort();\n    if v[0] + v[1] > v[2] {\n        let s = (v[0] + v[1]\
    \ + v[2]) as f64 / 2.0;\n        (s * (s - v[0] as f64) * (s - v[1] as f64) *\
    \ (s - v[2] as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut\
    \ area = -1_f64;\n    let small = [a, b, c].into_iter().min().unwrap();\n    let\
    \ medium = [a, b, c].into_iter().max().unwrap();\n    let large = [a, b, c].into_iter().sum::<isize>()\
    \ - small - medium;\n    if small + medium > large {\n        let p = (a + b +\
    \ c) as f64 / 2_f64;\n        area = (p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt();\n    }\n    area", "    let (a, b, c) = (a as f64, b as\
    \ f64, c as f64);\n    let s = (a + b + c) / 2.0;\n    if s <= a || s <= b ||\
    \ s <= c {\n        -1.0\n    } else {\n        s * (s - a) * (s - b) * (s - c)\n\
    \    }", '    unimplemented!();', "    // FIXME\n    unimplemented!()", "    let\
    \ s = (a + b + c) as f64 / 2.0;\n    if s <= a as f64 && s <= b as f64 && s <=\
    \ c as f64 {\n        -1.0\n    } else {\n        s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)\n    }", "    let s = (a + b + c) as f64 / 2.0;\n \
    \   if a < 1 || b < 1 || c < 1 || a + b <= c || a + c <= b || b + c <= a {\n \
    \       -1.0\n    } else {\n        (s * (s - a as f64) * (s - b as f64) * (s\
    \ - c as f64)).sqrt()\n    }", "    let (s1, s2, s3) = (a as f64, b as f64, c\
    \ as f64);\n    let s = (s1 + s2 + s3) / 2.0;\n    if s > s1 && s > s2 && s >\
    \ s3 {\n        (s * (s - s1) * (s - s2) * (s - s3)).sqrt()\n    } else {\n  \
    \      -1.0\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let a = sides[0] as f64;\n    let b = sides[1] as f64;\n    let c = sides[2]\
    \ as f64;\n    if a + b <= c { return -1.0; }\n    let s = (a + b + c) / 2.0;\n\
    \    let area = (s * (s - a) * (s - b) * (s - c)).sqrt();\n    area.round() /\
    \ 100.0", "  if a + b <= c || a + c <= b || b + c <= a {\n    return -1.0;\n \
    \ }\n  let s = (a + b + c) as f64 / 2.0;\n  let area = s * (s - a as f64) * (s\
    \ - b as f64) * (s - c as f64);\n  (area.sqrt() * 100.0).round() / 100.0", " \
    \   if a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let f64_a = a as f64;\n    let f64_b\
    \ = b as f64;\n    let f64_c = c as f64;\n    let s = (f64_a + f64_b + f64_c)\
    \ / 2.0;\n    if f64_a >= s || f64_b >= s || f64_c >= s {\n        return -1.0;\n\
    \    }\n    (s * (s - f64_a) * (s - f64_b) * (s - f64_c)).sqrt()", "    // A valid\
    \ triangle's sum of two sides must be greater than the third\n    if a + b > c\
    \ && a + c > b && b + c > a {\n        // Heron's formula\n        let s = (a\
    \ + b + c) as f64 / 2.0;\n        let temp = s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64);\n        (temp.sqrt() * 100.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n    if a +\
    \ b > c && a + c > b && b + c > a {\n        (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides\
    \ = [a, b, c];\n    sides.sort();\n    let len = sides.len();\n    let (a, b,\
    \ c) = (sides[len - 1], sides[len - 2], sides[len - 3]);\n    if a < b + c {\n\
    \        (a + b + c) as f64 / 2.0\n    } else {\n        -1.0\n    }", "    if\
    \ (a + b) <= c || (a + c) <= b || (b + c) <= a {\n        return -1.0;\n    }\n\
    \n    let s = (a + b + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt();\n    let result = area.round() / 100.0;\n\
    \    return result;"]
stop_tokens:
- "\n}"
