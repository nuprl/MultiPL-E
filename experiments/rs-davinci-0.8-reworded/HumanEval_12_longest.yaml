name: HumanEval_12_longest
language: rs
prompt: "/// Out of vector of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
  a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n/// >>>\
  \ longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\
  /// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ["    let mut current_longest = None;\n    for s in strings {\n     \
    \   if current_longest.is_none() || s.len() > current_longest.unwrap().len() {\n\
    \            current_longest = Some(s);\n        }\n    }\n    current_longest",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ usize::min_value();\n    let mut max_len_idx = usize::min_value();\n    for\
    \ (idx, string) in strings.iter().enumerate() {\n        if string.len() > max_len\
    \ {\n            max_len = string.len();\n            max_len_idx = idx;\n   \
    \     }\n    }\n    return Some(strings[max_len_idx].clone());", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    // TODO: return the longest string\n   \
    \ let mut longest = &strings[0];\n    for string in &strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest.to_string())",
  "    if strings.is_empty() {\n        return None;\n    }\n    // This won't work.\
    \ `maximum` is never evaluated, because\n    // it is not used by the code.\n\
    \    // let maximum = strings.iter().max_by_key(|s| s.len());\n    // So we need\
    \ to do this:\n    let mut maximum = strings[0].clone();\n    for s in strings\
    \ {\n        if s.len() > maximum.len() {\n            maximum = s;\n        }\n\
    \    }\n    Some(maximum)", "    strings.into_iter().fold(None, |acc, s| match\
    \ acc {\n        None => Some(s),\n        Some(acc) => Some(match s.len().cmp(&acc.len())\
    \ {\n            Ordering::Greater => s,\n            _ => acc,\n        }),\n\
    \    })", "    let mut longest = None;\n    for s in strings {\n        match\
    \ longest {\n            None => longest = Some(s),\n            Some(ref l) =>\
    \ if s.len() > l.len() {\n                longest = Some(s);\n            },\n\
    \        }\n    }\n    longest", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())', "    let mut\
    \ strings = strings;\n    match strings.len() {\n        0 => None,\n        _\
    \ => {\n            let mut longest = strings.remove(0);\n            for string\
    \ in strings {\n                if string.len() > longest.len() {\n          \
    \          longest = string;\n                }\n            }\n            Some(longest)\n\
    \        }\n    }", "    let mut longest = None;\n    for s in strings {\n   \
    \     longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ current) => {\n                if s.len() > current.len() {\n              \
    \      Some(s)\n                } else {\n                    Some(current.clone())\n\
    \                }\n            }\n        }\n    }\n    longest", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = String::from(\"\");\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(longest)", '    unimplemented!()', "    let\
    \ mut max_len = 0;\n    let mut max_string = None;\n    for s in strings {\n \
    \       if s.len() > max_len {\n            max_len = s.len();\n            max_string\
    \ = Some(s);\n        }\n    }\n    max_string", "    // ...\n    None", "   \
    \ match strings.iter().max_by_key(|x| x.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }", '    strings.into_iter().max_by_key(|s| s.len()).map(|s|
    s.to_string())', '    strings.into_iter().max().map(|x| x.to_string())', "   \
    \ let mut longest_string: Option<String> = None;\n    for s in strings {\n   \
    \     longest_string = match longest_string {\n            None => Some(s),\n\
    \            Some(ref current_longest) => {\n                if s.len() > current_longest.len()\
    \ {\n                    Some(s)\n                } else {\n                 \
    \   Some(current_longest.clone())\n                }\n            }\n        }\n\
    \    }\n    longest_string", "    let mut longest = None;\n    for s in strings\
    \ {\n        match longest {\n            None => longest = Some(s),\n       \
    \     Some(ref mut cur) => {\n                if s.len() > cur.len() {\n     \
    \               *cur = s;\n                }\n            }\n        }\n    }\n\
    \    longest", "    // if strings.len() == 0 {\n    //     return None;\n    //\
    \ }\n    // let mut length = 0;\n    // let mut longest = &strings[0];\n    //\
    \ for s in strings {\n    //     if s.len() > length {\n    //         length\
    \ = s.len();\n    //         longest = &s;\n    //     }\n    // }\n    // Some(String::from(longest))\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())", "  \
    \  let mut max_len = 0;\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    match max_len {\n        0 => None,\n\
    \        _ => Some(strings[max_idx].clone()),\n    }", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max = strings[0].clone();\n    for\
    \ string in strings {\n        if string.len() > max.len() {\n            max\
    \ = string;\n        }\n    }\n    Some(max)", "    let mut max_len = 0;\n   \
    \ let mut longest_string = None;\n    for string in strings {\n        if string.len()\
    \ > max_len {\n            max_len = string.len();\n            longest_string\
    \ = Some(string);\n        }\n    }\n    longest_string", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > longest.len() {\n          \
    \  longest = string;\n        }\n    }\n    Some(longest.clone())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut ret = &strings[0];\n    for s in\
    \ &strings {\n        if s.len() > ret.len() {\n            ret = s;\n       \
    \ }\n    }\n    Some(ret.clone())", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    let mut max_len = 0;\n    let mut max_string = String::new();\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_string = s;\n        }\n    }\n    if max_len == 0 {\n      \
    \  None\n    } else {\n        Some(max_string)\n    }", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > longest.len() {\n          \
    \  longest = string;\n        }\n    }\n    Some(longest.clone())", "    let mut\
    \ max = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max {\n            max = s.len();\n            index\
    \ = i;\n        }\n    }\n    if strings.is_empty() {\n        None\n    } else\
    \ {\n        Some(strings[index].clone())\n    }", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = 0;\n    let mut max_idx\
    \ = 0;\n    for (i, s) in strings.iter().enumerate() {\n        if s.len() > max_len\
    \ {\n            max_len = s.len();\n            max_idx = i;\n        }\n   \
    \ }\n    return Some(strings[max_idx].clone());", "    if strings.is_empty() {\n\
    \        return None;\n    }\n    let mut longest_string = String::from(&strings[0]);\n\
    \    for string in strings {\n        if string.len() > longest_string.len() {\n\
    \            longest_string = string;\n        }\n    }\n    Some(longest_string)",
  "    let mut strings = strings;\n    if strings.is_empty() {\n        return None;\n\
    \    }\n    strings.sort_by(|a, b| b.len().cmp(&a.len()));\n    Some(strings[0].clone())",
  '    strings.into_iter().max_by_key(|x| x.len()).cloned()', "    let mut longest_string\
    \ = None;\n    for s in strings {\n        if let Some(longest) = longest_string\
    \ {\n            if s.len() > longest.len() {\n                longest_string\
    \ = Some(s);\n            }\n        } else {\n            longest_string = Some(s);\n\
    \        }\n    }\n    longest_string", "    strings.into_iter().fold(None, |acc,\
    \ s| match acc {\n        None => Some(s),\n        Some(acc) => Some(if acc.len()\
    \ > s.len() { acc } else { s }),\n    })", "    let mut long_str = String::new();\n\
    \    for s in strings {\n        if s.len() > long_str.len() {\n            long_str\
    \ = s;\n        }\n    }\n    if long_str.len() > 0 {\n        Some(long_str)\n\
    \    } else {\n        None\n    }", "    let mut output: Option<String> = None;\n\
    \    for string in strings {\n        match output {\n            None => output\
    \ = Some(string),\n            Some(curr_max) => {\n                if string.len()\
    \ > curr_max.len() {\n                    output = Some(string);\n           \
    \     }\n            }\n        }\n    }\n    output", "    let mut max_len =\
    \ 0;\n    let mut max_index = 0;\n    for (index, str) in strings.iter().enumerate()\
    \ {\n        if str.len() > max_len {\n            max_len = str.len();\n    \
    \        max_index = index;\n        }\n    }\n    if max_len == 0 {\n       \
    \ None\n    } else {\n        Some(strings[max_index].clone())\n    }", "    //\
    \ This is a simple `match` statement that looks at three cases:\n    //   1. If\
    \ the vector is empty, it returns None\n    //   2. If the vector has one element,\
    \ it returns it without further processing\n    //   3. If the vector has more\
    \ than one element, it looks at the first and the rest of the\n    //      vector\
    \ and returns whichever one is longest.\n    match strings.len() {\n        0\
    \ => None,\n        1 => Some(strings[0].clone()),\n        _ => {\n         \
    \   let mut tail = strings.clone();\n            let head = tail.remove(0);\n\
    \            let head_len = head.len();\n            match longest(tail) {\n \
    \               None => Some(head),\n                Some(s) => {\n          \
    \          if head_len > s.len() {\n                        Some(head)\n     \
    \               } else {\n                        Some(s)\n                  \
    \  }\n                }\n            }\n        }\n    }", "    let mut longest_string:\
    \ Option<String> = None;\n    for s in strings {\n        if longest_string.is_none()\
    \ || s.len() > longest_string.as_ref().unwrap().len() {\n            longest_string\
    \ = Some(s);\n        }\n    }\n    longest_string", "    strings.into_iter().fold(None,\
    \ |acc, s| {\n        match acc {\n            None => Some(s),\n            Some(acc_string)\
    \ => if acc_string.len() < s.len() {\n                Some(s)\n            } else\
    \ {\n                Some(acc_string)\n            }\n        }\n    })", "  \
    \  let mut iter = strings.iter();\n    let mut longest = match iter.next() {\n\
    \        Some(string) => string,\n        None => return None,\n    };\n    for\
    \ s in iter {\n        if s.len() > longest.len() {\n            longest = s;\n\
    \        }\n    }\n    Some(String::from(longest))", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = strings[0].len();\n  \
    \  let mut result = strings[0].clone();\n    for s in strings.iter() {\n     \
    \   if s.len() > max_len {\n            max_len = s.len();\n            result\
    \ = s.clone();\n        }\n    }\n    Some(result)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest_string = &strings[0];\n\
    \    for string in &strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    Some(longest_string.clone())",
  "    let mut longest = None;\n    for string in strings {\n        match longest\
    \ {\n            None => longest = Some(string),\n            Some(ref mut current)\
    \ => {\n                if string.len() > current.len() {\n                  \
    \  *current = string;\n                }\n            }\n        }\n    }\n  \
    \  longest", "    // this is what i did\n    // let mut lengths = Vec::new();\n\
    \    // for s in strings {\n    //     lengths.push(s.len());\n    // }\n    //\
    \ let max_length = lengths.iter().max();\n    // if let Some(max_length) = max_length\
    \ {\n    //     Some(strings[lengths.iter().position(|i| i == max_length).unwrap()].clone())\n\
    \    // } else {\n    //     None\n    // }\n\n    // this is how i could have\
    \ done it\n    let mut max_length = 0;\n    let mut max_idx = 0;\n    for (idx,\
    \ s) in strings.iter().enumerate() {\n        if s.len() > max_length {\n    \
    \        max_length = s.len();\n            max_idx = idx;\n        }\n    }\n\
    \    if max_length == 0 {\n        None\n    } else {\n        Some(strings[max_idx].clone())\n\
    \    }", "    if strings.is_empty() {\n        return None;\n    }\n    let mut\
    \ max_len = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    index = i;\n        }\n    }\n    Some(strings[index].clone())", "    if\
    \ strings.is_empty() {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(longest)", "    strings.into_iter().fold(None,\
    \ |longest, s| {\n        match longest {\n            None => Some(s),\n    \
    \        Some(l) => {\n                if l.len() > s.len() {\n              \
    \      Some(l)\n                } else {\n                    Some(s)\n      \
    \          }\n            }\n        }\n    })", "    let mut max_length = 0;\n\
    \    let mut max_string = None;\n    for string in strings {\n        if string.len()\
    \ > max_length {\n            max_length = string.len();\n            max_string\
    \ = Some(string);\n        }\n    }\n    max_string", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max = &strings[0];\n    for s in\
    \ &strings {\n        if s.len() > max.len() {\n            max = s;\n       \
    \ }\n    }\n    Some(max.clone())", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest = &strings[0];\n    for s in &strings {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    Some(longest.clone())", "    let mut longest_len = 0;\n    let mut\
    \ longest_str = String::new();\n    for string in strings {\n        if string.len()\
    \ > longest_len {\n            longest_len = string.len();\n            longest_str\
    \ = string;\n        }\n    }\n    if longest_len == 0 {\n        None\n    }\
    \ else {\n        Some(longest_str)\n    }", "    if strings.is_empty() {\n  \
    \      return None;\n    }\n    strings.iter().max_by_key(|s| s.len()).cloned()",
  "    // add code here\n    let mut max = 0;\n    let mut longest_string = String::new();\n\
    \    for s in strings {\n        if s.len() > max {\n            max = s.len();\n\
    \            longest_string = s;\n        }\n    }\n    if max > 0 {\n       \
    \ Some(longest_string)\n    } else {\n        None\n    }", "    match strings.is_empty()\
    \ {\n        true => None,\n        false => {\n            let mut longest =\
    \ &strings[0];\n            for s in &strings {\n                if s.len() >\
    \ longest.len() {\n                    longest = s;\n                }\n     \
    \       }\n            Some(longest.to_string())\n        }\n    }", '    strings.into_iter().max_by_key(|string|
    string.len()).map(|string| string.to_string())', "    if strings.is_empty() {\n\
    \        return None;\n    }\n    let mut max_len = 0;\n    let mut max_str =\
    \ String::new();\n    for s in strings {\n        if s.len() > max_len {\n   \
    \         max_len = s.len();\n            max_str = s;\n        }\n    }\n   \
    \ Some(max_str)", "    match strings.iter().max_by_key(|s| s.len()) {\n      \
    \  Some(s) => Some(s.to_string()),\n        None => None,\n    }", "    let mut\
    \ max_len = 0;\n    let mut max_idx = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_idx = i;\n        }\n    }\n    if max_len == 0 {\n        None\n   \
    \ } else {\n        Some(strings[max_idx].clone())\n    }", '    strings.into_iter().max_by_key(|s|
    s.len()).map(|s| s.to_string())', "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest = &strings[0];\n    for s in &strings {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    Some(longest.clone())", "    let len = strings.len();\n    if len ==\
    \ 0 {\n        return None;\n    }\n    let mut max_size = 0;\n    let mut max_size_index\
    \ = 0;\n    for i in 0..len {\n        let s = &strings[i];\n        if s.len()\
    \ > max_size {\n            max_size = s.len();\n            max_size_index =\
    \ i;\n        }\n    }\n    Some(strings[max_size_index].clone())", "    match\
    \ strings.len() {\n        0 => None,\n        _ => {\n            let mut max\
    \ = strings[0].clone();\n            for i in 1..strings.len() {\n           \
    \     if strings[i].len() > max.len() {\n                    max = strings[i].clone();\n\
    \                }\n            }\n            Some(max)\n        }\n    }", " \
    \   strings.into_iter().fold(None, |current, next| {\n        if let Some(ref\
    \ current) = current {\n            if current.len() >= next.len() {\n       \
    \         Some(current.clone())\n            } else {\n                Some(next)\n\
    \            }\n        } else {\n            Some(next)\n        }\n    })",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_length\
    \ = 0;\n    let mut longest_string = String::new();\n    for s in strings {\n\
    \        if s.len() > max_length {\n            max_length = s.len();\n      \
    \      longest_string = s;\n        }\n    }\n    Some(longest_string)", "   \
    \ match strings.len() {\n        0 => None,\n        1 => Some(strings[0].clone()),\n\
    \        _ => {\n            let mut max_str: String = strings[0].clone();\n \
    \           for str in strings.iter() {\n                if str.len() > max_str.len()\
    \ {\n                    max_str = str.clone();\n                }\n         \
    \   }\n            Some(max_str)\n        }\n    }", "    strings.into_iter().fold(None,\
    \ |max, string| {\n        match max {\n            None => Some(string),\n  \
    \          Some(s) => if s.len() < string.len() {\n                Some(string)\n\
    \            } else {\n                Some(s)\n            }\n        }\n   \
    \ })", "    if strings.is_empty() {\n        return None;\n    }\n    let mut\
    \ max_len = strings[0].len();\n    let mut longest_string = &strings[0];\n   \
    \ for s in &strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_string = s;\n        }\n    }\n    Some(longest_string.to_string())",
  "    let mut result = None;\n    let mut max_len = 0;\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            result\
    \ = Some(s);\n        }\n    }\n    result", "    if strings.is_empty() {\n  \
    \      return None;\n    }\n    let mut max = &strings[0];\n    for s in &strings\
    \ {\n        if s.len() > max.len() {\n            max = s;\n        }\n    }\n\
    \    Some(max.clone())", "    let mut longest = None;\n    for s in strings {\n\
    \        if longest.is_none() || longest.as_ref().unwrap().len() < s.len() {\n\
    \            longest = Some(s);\n        }\n    }\n    longest", "    strings.into_iter().fold(None,\
    \ |longest, string| {\n        match longest {\n            None => Some(string),\n\
    \            Some(ref longest) => if string.len() > longest.len() {\n        \
    \        Some(string)\n            } else {\n                Some(longest.clone())\n\
    \            }\n        }\n    })", "    let mut max_len = 0;\n    let mut longest_string\
    \ = None;\n    for s in strings {\n        if s.len() > max_len {\n          \
    \  max_len = s.len();\n            longest_string = Some(s);\n        }\n    }\n\
    \    longest_string", "    strings.into_iter().fold(None, |max, s| {\n       \
    \ match max {\n            None => Some(s),\n            Some(ref m) => if s.len()\
    \ > m.len() { Some(s) } else { max }\n        }\n    })", "    let mut result\
    \ = None;\n    for string in strings {\n        match result {\n            None\
    \ => result = Some(string),\n            Some(ref s) => if string.len() > s.len()\
    \ {\n                result = Some(string);\n            },\n        }\n    }\n\
    \    result", "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string.clone();\n        }\n    }\n\
    \    Some(longest)", "    let mut m = None;\n    for s in strings {\n        m\
    \ = match m {\n            None => Some(s),\n            Some(x) => if x.len()\
    \ > s.len() {\n                Some(x)\n            } else {\n               \
    \ Some(s)\n            }\n        }\n    }\n    m", "    let mut longest = None;\n\
    \    for s in strings {\n        match longest {\n            None => longest\
    \ = Some(s),\n            Some(ref l) => {\n                if s.len() > l.len()\
    \ {\n                    longest = Some(s);\n                }\n            }\n\
    \        }\n    }\n    longest", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest = &strings[0];\n    for s in &strings {\n\
    \        if s.len() > longest.len() {\n            longest = s;\n        }\n \
    \   }\n    Some(longest.clone())", "    let mut max_len = 0;\n    let mut max_len_string\
    \ = None;\n    for string in strings {\n        if string.len() > max_len {\n\
    \            max_len = string.len();\n            max_len_string = Some(string);\n\
    \        }\n    }\n    max_len_string", "    // TODO: implement this function\n\
    \    if strings.is_empty() {\n        return None;\n    }\n    let mut max_length\
    \ = 0;\n    let mut max_index = 0;\n    for (index, string) in strings.iter().enumerate()\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            max_index = index;\n        }\n    }\n    Some(strings[max_index].clone())",
  "    match strings.iter().max_by_key(|s| s.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }", "    let mut res = None;\n    let mut longest_len\
    \ = 0;\n    for string in strings {\n        if string.len() > longest_len {\n\
    \            res = Some(string);\n            longest_len = string.len();\n  \
    \      }\n    }\n    res", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut max = 0;\n    let mut longest = &strings[0];\n    for s in\
    \ &strings {\n        if s.len() > max {\n            max = s.len();\n       \
    \     longest = s;\n        }\n    }\n    Some(longest.clone())", "    strings.into_iter().fold(None,\
    \ |longest, string| {\n        match longest {\n            None => Some(string),\n\
    \            Some(ref long) => {\n                if long.len() < string.len()\
    \ {\n                    Some(string)\n                } else {\n            \
    \        Some(long.clone())\n                }\n            }\n        }\n   \
    \ })", "    if strings.is_empty() {\n        return None;\n    }\n    let mut\
    \ result = strings[0].clone();\n    for s in strings {\n        if s.len() > result.len()\
    \ {\n            result = s;\n        }\n    }\n    Some(result)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut result = strings[0].clone();\n \
    \   for i in 1..strings.len() {\n        if strings[i].len() > result.len() {\n\
    \            result = strings[i].clone();\n        }\n    }\n    Some(result)",
  "    strings.into_iter().fold(None, |acc, s| match acc {\n        None => Some(s),\n\
    \        Some(s1) => {\n            if s.len() > s1.len() {\n                Some(s)\n\
    \            } else {\n                Some(s1)\n            }\n        }\n  \
    \  })", '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())',
  "    match strings.len() {\n        0 => None,\n        n => {\n            let\
    \ mut max_idx = 0;\n            for (i, string) in strings.iter().enumerate()\
    \ {\n                if string.len() > strings[max_idx].len() {\n            \
    \        max_idx = i;\n                }\n            }\n            Some(strings[max_idx].clone())\n\
    \        }\n    }", "    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut result = strings[0].clone();\n    for s in strings {\n        if\
    \ s.len() > result.len() {\n            result = s;\n        }\n    }\n    Some(result)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    let\
    \ mut max_len = 0;\n    let mut res = None;\n    for s in strings {\n        if\
    \ s.len() > max_len {\n            max_len = s.len();\n            res = Some(s);\n\
    \        }\n    }\n    res", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut max = &strings[0];\n    for i in &strings {\n        if i.len()\
    \ > max.len() {\n            max = i;\n        }\n    }\n    Some(max.clone())",
  '    strings.into_iter().max_by_key(|s| s.len()).cloned()', '    strings.into_iter().max_by_key(|string|
    string.len()).map(|string| string.clone())', "    if strings.is_empty() {\n  \
    \      return None;\n    }\n    let mut longest_string = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > longest_string.len() {\n   \
    \         longest_string = string;\n        }\n    }\n    Some(longest_string.clone())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for string in strings {\n        if string.len() >\
    \ longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)",
  "    let mut max_len = 0;\n    let mut longest_string = None;\n    for s in strings\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    longest_string = Some(s);\n        }\n    }\n    longest_string", '    strings.into_iter().max_by_key(|s|
    s.len()).map(|s| s.clone())', "    let mut longest = &String::from(\"\");\n  \
    \  for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = &s;\n        }\n    }\n    if longest.len() == 0 {\n        None\n    } else\
    \ {\n        Some(String::from(longest))\n    }", "    match strings.len() {\n\
    \        0 => None,\n        1 => Some(strings[0].clone()),\n        _ => {\n\
    \            let mut strings = strings;\n            strings.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \            Some(strings[0].clone())\n        }\n    }", '    unimplemented!()',
  "    let mut max_string: Option<String> = None;\n    let mut max_len = 0;\n    for\
    \ s in strings {\n        if s.len() > max_len {\n            max_string = Some(s);\n\
    \            max_len = s.len();\n        }\n    }\n    max_string", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = &strings[0];\n    for\
    \ s in &strings {\n        if s.len() > longest.len() {\n            longest =\
    \ s;\n        }\n    }\n    Some(longest.clone())", '    strings.into_iter().max_by_key(|s|
    s.len()).map(|s| s.clone())', "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut max_length = strings[0].len();\n    let mut max_string = strings[0].clone();\n\
    \    for (i, string) in strings.iter().enumerate() {\n        if i == 0 {\n  \
    \          continue;\n        }\n        if string.len() > max_length {\n    \
    \        max_length = string.len();\n            max_string = string.clone();\n\
    \        }\n    }\n    Some(max_string)", "    // The implementation is intentionally\
    \ left blank.\n    let mut longest_string: Option<String> = None;\n    for string\
    \ in strings {\n        let current_longest = match longest_string {\n       \
    \     Some(ref s) => s.len(),\n            None => 0,\n        };\n        if\
    \ string.len() > current_longest {\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string", "    let mut max_length = 0;\n    let\
    \ mut max_string = None;\n    for s in strings {\n        if s.len() > max_length\
    \ {\n            max_length = s.len();\n            max_string = Some(s);\n  \
    \      }\n    }\n    max_string", "    let mut max = 0;\n    let mut longest =\
    \ None;\n    for string in strings {\n        if string.len() > max {\n      \
    \      max = string.len();\n            longest = Some(string);\n        }\n \
    \   }\n    longest", "    // (1)\n    // strings.iter().max_by_key(|s| s.len()).map(|s|\
    \ s.to_string())\n    // (2)\n    strings.into_iter().max_by_key(|s| s.len()).map(|s|\
    \ s)", "    match strings.first() {\n        Some(s) => strings.iter().fold(s.clone(),\
    \ |m, s| if s.len() > m.len() { s.clone() } else { m }),\n        None => None,\n\
    \    }", "    let mut max_len = 0;\n    let mut max_len_str = None;\n    for s\
    \ in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_len_str = Some(s);\n        }\n    }\n    max_len_str", "   \
    \ strings.into_iter().fold(None, |mut longest, s| {\n        if let Some(l) =\
    \ longest {\n            if s.len() > l.len() {\n                longest = Some(s);\n\
    \            }\n        } else {\n            longest = Some(s);\n        }\n\
    \        longest\n    })", "    let mut longest_string = String::new();\n    for\
    \ string in strings {\n        if string.len() > longest_string.len() {\n    \
    \        longest_string = string;\n        }\n    }\n    match longest_string.len()\
    \ {\n        0 => None,\n        _ => Some(longest_string),\n    }", "    let\
    \ mut max_len = 0;\n    let mut longest = None;\n    for string in strings {\n\
    \        if string.len() > max_len {\n            max_len = string.len();\n  \
    \          longest = Some(string);\n        }\n    }\n    longest", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for string in strings {\n        if string.len() > longest.len() {\n    \
    \        longest = string;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut current_longest = strings[0].clone();\n\
    \    for string in strings.iter() {\n        if string.len() > current_longest.len()\
    \ {\n            current_longest = string.clone();\n        }\n    }\n    Some(current_longest)",
  "    let mut max_length = 0;\n    let mut longest = None;\n    for s in strings\
    \ {\n        if s.len() > max_length {\n            max_length = s.len();\n  \
    \          longest = Some(s);\n        }\n    }\n    longest", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut ret = strings[0].clone();\n    for\
    \ s in strings.iter() {\n        if s.len() > ret.len() {\n            ret = s.clone();\n\
    \        }\n    }\n    Some(ret)", "    // `max` is a function of iterator traits.\
    \ It will iterate through the input list and \n    // return the greatest element.\n\
    \    // `max` takes a function, which takes two elements and returns the greatest\
    \ element.\n    // `max` will take the first two element from the list, call the\
    \ function to get the largest\n    // of the two, and store that as the max. Then\
    \ it will call the function again to compare the\n    // current max and the next\
    \ element of the list.\n    // In this case, the function is `|a, b| a.len() <\
    \ b.len()`, which takes two strings and return \n    // the length of the longer\
    \ one.\n    // This is called a closure. It's a function that doesn't have a name\
    \ or have to be defined\n    // elsewhere. It is an inline function.\n    // We\
    \ can define this closure as a variable and pass it to `max` instead.\n    //\
    \ The most important thing is to make sure the closure *captures* its environment.\n\
    \    // Let's see an example of what happens if the closure doesn't capture its\
    \ environment:\n    //\n    // fn main() {\n    //     let n = 10;\n    //   \
    \  let s = max(strings, |a, b| a.len() < b.len());\n    // }\n    //\n    // fn\
    \ max<T>(strings: Vec<T>, closure: &Fn(T, T) -> T) -> Option<T> {\n    //    \
    \ strings.iter().max().map(|s| s.clone())\n    // }\n    //\n    // Here the parameter\
    \ of the closure is `&T`, which means the closure takes references to\n    //\
    \ elements of the vector. The closure will try to dereference `s`, which is also\
    \ a reference,\n    // and return the dereferenced element.\n    // However, `s`\
    \ is a *mutable* reference, and we can't dereference it. Here is a different error:\n\
    \    //\n    // error[E0506]: cannot assign to `s` because it is borrowed\n  \
    \  //  --> src/main.rs:7:9\n    //   |\n    // 5 |     let s = max(strings, |a,\
    \ b| a.len() < b.", "    let mut longest = String::new();\n    for string in strings\
    \ {\n        if string.len() > longest.len() {\n            longest = string;\n\
    \        }\n    }\n    if longest.is_empty() {\n        None\n    } else {\n \
    \       Some(longest)\n    }", "    let mut result = None;\n    for string in\
    \ strings {\n        if let Some(current) = result {\n            if string.len()\
    \ > current.len() {\n                result = Some(string);\n            }\n \
    \       } else {\n            result = Some(string);\n        }\n    }\n    result",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut long_string\
    \ = &strings[0];\n    for string in &strings {\n        if string.len() > long_string.len()\
    \ {\n            long_string = string;\n        }\n    }\n    Some(long_string.to_string())",
  '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())', "    //\
    \ When you're looking to find the largest or smallest value in a collection, you\
    \ can use the\n    // max or min method. This method takes a closure that compares\
    \ two values, and returns the\n    // largest or smallest one.\n    //\n    //\
    \ The following demonstrates how to find the largest value in a collection of\
    \ integers:\n    //\n    // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n   \
    \ // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n    //\n\
    \    // println!(\"The largest number is {}\", largest);\n    //\n    // You can\
    \ also use the max method with two or more arguments, like this:\n    //\n   \
    \ // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n    // let c = a.iter();\n\
    \    //\n    // let largest = a.iter().max();\n    //\n    // println!(\"The largest\
    \ number is {}\", largest);\n    //\n    // You can also use the max method with\
    \ two or more arguments, like this:\n    //\n    // let a = [1, 2, 3, 4, 5];\n\
    \    // let b = &a;\n    // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n\
    \    //\n    // println!(\"The largest number is {}\", largest);\n    //\n   \
    \ // You can also use the max method with two or more arguments, like this:\n\
    \    //\n    // let a = [1, 2, 3, 4, 5];\n    // let b = &a;\n    // let c = a.iter();\n\
    \    //\n    // let largest = a.iter().max();\n    //\n    // println!(\"The largest\
    \ number is {}\", largest);\n    //\n    // You can also use the max method with\
    \ two or more arguments, like this:\n    //\n    // let a = [1, 2, 3, 4, 5];\n\
    \    // let b = &a;\n    // let c = a.iter();\n    //\n    // let largest = a.iter().max();\n\
    \    //\n    // println!(\"The largest number is {}", "    // Filling the blanks\
    \ with your code\n    let mut longest_string = None;\n    for current_string in\
    \ strings {\n        longest_string = match longest_string {\n            None\
    \ => Some(current_string),\n            Some(string) => {\n                if\
    \ string.len() > current_string.len() {\n                    Some(string)\n  \
    \              } else {\n                    Some(current_string)\n          \
    \      }\n            }\n        };\n    }\n    longest_string", '    strings.into_iter().max().cloned()',
  '    strings.into_iter().max_by_key(|x| x.len()).or(None)', "    let mut longest_str\
    \ = None;\n    let mut longest_len = 0;\n    for s in strings {\n        if s.len()\
    \ > longest_len {\n            longest_str = Some(s);\n            longest_len\
    \ = s.len();\n        }\n    }\n    longest_str", '    strings.into_iter().max_by_key(|s|
    s.len()).cloned()', '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    let mut max_index = 0;\n    let mut max_length = 0;\n    for (i, string) in\
    \ strings.iter().enumerate() {\n        if string.len() > max_length {\n     \
    \       max_index = i;\n            max_length = string.len();\n        }\n  \
    \  }\n    if max_length == 0 {\n        None\n    } else {\n        Some(strings[max_index].clone())\n\
    \    }", '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())',
  "    match strings.is_empty() {\n        true => None,\n        false => {\n   \
    \         let mut longest = &strings[0];\n            for string in &strings {\n\
    \                if string.len() > longest.len() {\n                    longest\
    \ = string;\n                }\n            }\n            Some(longest.to_string())\n\
    \        }\n    }", "    // code here\n    None", "    if strings.is_empty() {\n\
    \        return None;\n    }\n    let mut longest = strings[0].clone();\n    for\
    \ string in strings {\n        if string.len() > longest.len() {\n           \
    \ longest = string;\n        }\n    }\n    Some(longest)", "    let mut max_length\
    \ = 0;\n    let mut max_idx = None;\n    for (idx, string) in strings.iter().enumerate()\
    \ {\n        if string.len() > max_length {\n            max_length = string.len();\n\
    \            max_idx = Some(idx);\n        }\n    }\n    match max_idx {\n   \
    \     Some(idx) => Some(strings[idx].clone()),\n        None => None,\n    }",
  "    strings.into_iter().fold(None, |longest, string| {\n        match longest {\n\
    \            None => Some(string),\n            Some(current_longest) => {\n \
    \               if string.len() > current_longest.len() {\n                  \
    \  Some(string)\n                } else {\n                    Some(current_longest)\n\
    \                }\n            }\n        }\n    })", "    let max_length = match\
    \ strings.iter().max_by_key(|s| s.len()) {\n        Some(s) => s.len(),\n    \
    \    None => return None,\n    };\n    let strs = strings.iter().filter(|s| s.len()\
    \ == max_length);\n    strs.fold(None, |acc, s| match acc {\n        Some(_) =>\
    \ acc,\n        None => Some(s.to_string()),\n    })", "    let mut longest =\
    \ None;\n    for s in strings {\n        match longest {\n            None =>\
    \ longest = Some(s),\n            Some(ref l) => if s.len() > l.len() {\n    \
    \            longest = Some(s);\n            },\n        }\n    }\n    longest",
  "    let mut strings = strings;\n    strings.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    strings.first().cloned()", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut max_len = strings[0].len();\n    let mut max_idx = 0;\n  \
    \  for (i, s) in strings.iter().enumerate() {\n        if s.len() > max_len {\n\
    \            max_len = s.len();\n            max_idx = i;\n        }\n    }\n\
    \    Some(strings[max_idx].clone())", "    let mut longest = strings.first().clone();\n\
    \    for s in strings {\n        if longest.as_ref().map_or(true, |l| l.len()\
    \ < s.len()) {\n            longest = Some(s);\n        }\n    }\n    longest",
  "    // Extracting the length.\n    let length = |s: &String| s.len();\n    // Defining\
    \ the \"longest\" function.\n    let longest = |a: &String, b: &String| {\n  \
    \      if length(a) > length(b) { a } else { b }\n    };\n    // Applying the\
    \ fold method.\n    strings.iter().fold(None, |acc, s| {\n        match acc {\n\
    \            Some(old) => Some(longest(s, &old)),\n            None => Some(s.clone())\n\
    \        }\n    })", '    strings.into_iter().max_by_key(|s| s.len()).map(|s|
    s.to_string())', "    if strings.is_empty() {\n        return None;\n    }\n \
    \   let mut longest = String::from(\"\");\n    for s in strings {\n        if\
    \ s.len() > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  '    strings.into_iter().max_by_key(|string| string.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = &strings[0];\n    for\
    \ string in &strings {\n        if string.len() > longest.len() {\n          \
    \  longest = string;\n        }\n    }\n    Some(longest.clone())", "    strings.into_iter().fold(None,\
    \ |acc, s| {\n        match acc {\n            None => Some(s),\n            Some(acc_s)\
    \ => Some(if acc_s.len() < s.len() { s } else { acc_s }),\n        }\n    })",
  '    strings.into_iter().max().map(|s| s.to_string())', "    // I guess this is\
    \ the \"idiomatic way\" of doing it.\n    strings.into_iter().max_by_key(|s| s.len()).cloned()",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ &strings[0];\n    for string in &strings {\n        if string.len() > longest.len()\
    \ {\n            longest = string;\n        }\n    }\n    Some(longest.clone())",
  '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())', '    strings.into_iter().max_by_key(|string|
    string.len()).map(|string| string.to_string())', "    match strings.len() {\n\
    \        0 => None,\n        1 => Some(strings[0].clone()),\n        _ => {\n\
    \            let mut strings = strings;\n            strings.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \            Some(strings.pop().unwrap())\n        }\n    }", '    strings.into_iter().max_by_key(|s|
    s.len()).map(|s| s.to_string())', "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest_string = String::from(\"\");\n    for string\
    \ in strings {\n        if string.len() > longest_string.len() {\n           \
    \ longest_string = string;\n        }\n    }\n    Some(longest_string)", "   \
    \ if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s.clone();\n        }\n    }\n    Some(longest)", " \
    \   let mut max_str = None;\n    for s in strings {\n        if max_str.is_none()\
    \ || s.len() > max_str.as_ref().unwrap().len() {\n            max_str = Some(s);\n\
    \        }\n    }\n    max_str", "    let mut longest_so_far = String::new();\n\
    \    for string in strings {\n        if string.len() > longest_so_far.len() {\n\
    \            longest_so_far = string;\n        }\n    }\n    if longest_so_far.is_empty()\
    \ {\n        None\n    } else {\n        Some(longest_so_far)\n    }", "    if\
    \ strings.is_empty() {\n        return None;\n    }\n    let mut result = &strings[0];\n\
    \    for s in &strings {\n        if s.len() > result.len() {\n            result\
    \ = s;\n        }\n    }\n    Some(result.to_string())", "    let mut res = None;\n\
    \    let mut max_len = 0;\n    for string in strings {\n        if string.len()\
    \ > max_len {\n            max_len = string.len();\n            res = Some(string);\n\
    \        }\n    }\n    res", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut res = strings[0].clone();\n    for s in strings {\n      \
    \  if s.len() > res.len() {\n            res = s;\n        }\n    }\n    Some(res)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut ret = strings[0].clone();\n\
    \    for s in strings {\n        if s.len() > ret.len() {\n            ret = s;\n\
    \        }\n    }\n    Some(ret)", "    let mut r = strings.into_iter().peekable();\n\
    \    let mut l = r.peek().cloned();\n    let mut f = l.clone();\n    while let\
    \ Some(s) = r.next() {\n        l = l.and_then(|l| match l.len().cmp(&s.len())\
    \ {\n            Ordering::Less => Some(s),\n            Ordering::Equal => {\n\
    \                f = Some(s);\n                Some(l)\n            }\n      \
    \      Ordering::Greater => Some(l),\n        });\n    }\n    l.or(f)", "    let\
    \ mut iterator = strings.iter();\n    if let Some(max) = iterator.next() {\n \
    \       let mut longest = max;\n        for string in iterator {\n           \
    \ if string.len() > longest.len() {\n                longest = string;\n     \
    \       }\n        }\n        Some(longest.to_string())\n    } else {\n      \
    \  None\n    }", "    let mut max = 0;\n    let mut result = None;\n    for s\
    \ in strings {\n        if s.len() > max {\n            max = s.len();\n     \
    \       result = Some(s);\n        }\n    }\n    result", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest_index = 0;\n    for i in\
    \ 1..strings.len() {\n        if strings[i].len() > strings[longest_index].len()\
    \ {\n            longest_index = i;\n        }\n    }\n    Some(strings[longest_index].clone())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut res = &strings[0];\n\
    \    for s in &strings {\n        if s.len() > res.len() {\n            res =\
    \ s;\n        }\n    }\n    Some(res.clone())", "    let mut longest = None;\n\
    \    for s in strings {\n        longest = match longest {\n            None =>\
    \ Some(s),\n            Some(l) => if s.len() > l.len() { Some(s) } else { Some(l)\
    \ },\n        }\n    }\n    longest", "    strings.into_iter().fold(None, |acc,\
    \ s| match acc {\n        None => Some(s),\n        Some(acc) => if acc.len()\
    \ < s.len() { Some(s) } else { Some(acc) },\n    })", '    strings.into_iter().max_by_key(|s|
    s.len()).cloned()', "    let mut result = None;\n    for s in strings {\n    \
    \    result = match result {\n            None => Some(s),\n            Some(x)\
    \ => {\n                if x.len() < s.len() {\n                    Some(s)\n\
    \                } else {\n                    Some(x)\n                }\n  \
    \          }\n        }\n    }\n    result", "    let mut result = None;\n   \
    \ let mut max_len = 0;\n    for string in strings {\n        if string.len() >\
    \ max_len {\n            max_len = string.len();\n            result = Some(string);\n\
    \        }\n    }\n    result", '    strings.into_iter().max_by_key(|x| x.len()).map(|x|
    x.to_string())', "    let mut max_len = 0;\n    let mut max_string = None;\n \
    \   for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ &strings[0];\n    for s in &strings {\n        if s.len() > longest.len() {\n\
    \            longest = s;\n        }\n    }\n    Some(longest.clone())", "   \
    \ let mut longest = None;\n    for x in strings {\n        match longest {\n \
    \           None => longest = Some(x),\n            Some(ref mut longest_str)\
    \ => {\n                if x.len() > longest_str.len() {\n                   \
    \ *longest_str = x;\n                }\n            }\n        }\n    }\n    longest",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest_string\
    \ = strings[0].clone();\n    for s in strings {\n        if s.len() > longest_string.len()\
    \ {\n            longest_string = s;\n        }\n    }\n    Some(longest_string)",
  "    let mut iter = strings.iter();\n    if let Some(initial) = iter.next() {\n\
    \        let mut max = initial;\n        for string in iter {\n            if\
    \ string.len() > max.len() {\n                max = string;\n            }\n \
    \       }\n        Some(max.to_string())\n    } else {\n        None\n    }",
  "    let mut res = None;\n    let mut max_len = 0;\n    for s in strings {\n   \
    \     if s.len() > max_len {\n            max_len = s.len();\n            res\
    \ = Some(s);\n        }\n    }\n    res", '    unimplemented!()', '    unimplemented!();',
  '    strings.into_iter().max_by_key(|x| x.len()).map(String::from)', "    let mut\
    \ first = true;\n    let mut max_len = 0;\n    let mut max_str = None;\n    for\
    \ s in strings {\n        if first {\n            max_len = s.len();\n       \
    \     max_str = Some(s);\n            first = false;\n        } else {\n     \
    \       if s.len() > max_len {\n                max_len = s.len();\n         \
    \       max_str = Some(s);\n            }\n        }\n    }\n    max_str", '    strings.into_iter().max_by_key(|s|
    s.len()).map(String::from)', "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut longest = strings[0].clone();\n    for s in strings {\n  \
    \      if s.len() > longest.len() {\n            longest = s;\n        }\n   \
    \ }\n    Some(longest)", "    let mut max_len = 0;\n    let mut res: Option<String>\
    \ = None;\n    for s in strings {\n        if s.len() > max_len {\n          \
    \  max_len = s.len();\n            res = Some(s);\n        }\n    }\n    res",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut l = strings[0].clone();\n\
    \    for s in strings.iter() {\n        if s.len() > l.len() {\n            l\
    \ = s.clone();\n        }\n    }\n    Some(l)", "    let mut result = None;\n\
    \    for s in strings {\n        match result {\n            None => result =\
    \ Some(s),\n            Some(ref mut r) => {\n                if r.len() < s.len()\
    \ {\n                    *r = s;\n                }\n            }\n        }\n\
    \    }\n    result", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  '    strings.into_iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_string = strings[0].clone();\n\
    \    for s in strings {\n        if s.len() > max_string.len() {\n           \
    \ max_string = s;\n        }\n    }\n    Some(max_string)", "    let mut max_len\
    \ = 0;\n    let mut longest = None;\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n            longest = Some(s);\n\
    \        }\n    }\n    longest", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max = &strings[0];\n    for s in &strings {\n    \
    \    if s.len() > max.len() {\n            max = s;\n        }\n    }\n    Some(max.clone())",
  "    let mut longest = None;\n    for s in strings {\n        longest = match longest\
    \ {\n            None => Some(s),\n            Some(l) => if s.len() > l.len()\
    \ { Some(s) } else { Some(l) },\n        }\n    }\n    longest", "    strings.into_iter().fold(None,\
    \ |acc, x| {\n        match acc {\n            None => Some(x),\n            Some(y)\
    \ => if x.len() > y.len() { Some(x) } else { Some(y) }\n        }\n    })", " \
    \   if strings.is_empty() {\n        return None;\n    }\n    let mut longest\
    \ = strings[0].clone();\n    for string in strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest)"]
stop_tokens:
- "\n}"
