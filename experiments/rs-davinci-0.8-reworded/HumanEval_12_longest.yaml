name: HumanEval_12_longest
language: rs
prompt: "/// Out of vector of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
  a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"a\")\n/// >>>\
  \ longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n\
  /// String::from(\"ccc\")\nfn longest(strings: Vec<String>) -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ["    let mut current_longest = None;\n    for s in strings {\n     \
    \   if current_longest.is_none() || s.len() > current_longest.unwrap().len() {\n\
    \            current_longest = Some(s);\n        }\n    }\n    current_longest",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ usize::min_value();\n    let mut max_len_idx = usize::min_value();\n    for\
    \ (idx, string) in strings.iter().enumerate() {\n        if string.len() > max_len\
    \ {\n            max_len = string.len();\n            max_len_idx = idx;\n   \
    \     }\n    }\n    return Some(strings[max_len_idx].clone());", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    // TODO: return the longest string\n   \
    \ let mut longest = &strings[0];\n    for string in &strings {\n        if string.len()\
    \ > longest.len() {\n            longest = string;\n        }\n    }\n    Some(longest.to_string())",
  "    if strings.is_empty() {\n        return None;\n    }\n    // This won't work.\
    \ `maximum` is never evaluated, because\n    // it is not used by the code.\n\
    \    // let maximum = strings.iter().max_by_key(|s| s.len());\n    // So we need\
    \ to do this:\n    let mut maximum = strings[0].clone();\n    for s in strings\
    \ {\n        if s.len() > maximum.len() {\n            maximum = s;\n        }\n\
    \    }\n    Some(maximum)", "    strings.into_iter().fold(None, |acc, s| match\
    \ acc {\n        None => Some(s),\n        Some(acc) => Some(match s.len().cmp(&acc.len())\
    \ {\n            Ordering::Greater => s,\n            _ => acc,\n        }),\n\
    \    })", "    let mut longest = None;\n    for s in strings {\n        match\
    \ longest {\n            None => longest = Some(s),\n            Some(ref l) =>\
    \ if s.len() > l.len() {\n                longest = Some(s);\n            },\n\
    \        }\n    }\n    longest", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  '    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.clone())', "    let mut\
    \ strings = strings;\n    match strings.len() {\n        0 => None,\n        _\
    \ => {\n            let mut longest = strings.remove(0);\n            for string\
    \ in strings {\n                if string.len() > longest.len() {\n          \
    \          longest = string;\n                }\n            }\n            Some(longest)\n\
    \        }\n    }", "    let mut longest = None;\n    for s in strings {\n   \
    \     longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ current) => {\n                if s.len() > current.len() {\n              \
    \      Some(s)\n                } else {\n                    Some(current.clone())\n\
    \                }\n            }\n        }\n    }\n    longest", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = String::from(\"\");\n\
    \    for s in strings {\n        if s.len() > longest.len() {\n            longest\
    \ = s;\n        }\n    }\n    Some(longest)", '    unimplemented!()', "    let\
    \ mut max_len = 0;\n    let mut max_string = None;\n    for s in strings {\n \
    \       if s.len() > max_len {\n            max_len = s.len();\n            max_string\
    \ = Some(s);\n        }\n    }\n    max_string", "    // ...\n    None", "   \
    \ match strings.iter().max_by_key(|x| x.len()) {\n        Some(s) => Some(s.to_string()),\n\
    \        None => None,\n    }", '    strings.into_iter().max_by_key(|s| s.len()).map(|s|
    s.to_string())', '    strings.into_iter().max().map(|x| x.to_string())', "   \
    \ let mut longest_string: Option<String> = None;\n    for s in strings {\n   \
    \     longest_string = match longest_string {\n            None => Some(s),\n\
    \            Some(ref current_longest) => {\n                if s.len() > current_longest.len()\
    \ {\n                    Some(s)\n                } else {\n                 \
    \   Some(current_longest.clone())\n                }\n            }\n        }\n\
    \    }\n    longest_string", "    let mut longest = None;\n    for s in strings\
    \ {\n        match longest {\n            None => longest = Some(s),\n       \
    \     Some(ref mut cur) => {\n                if s.len() > cur.len() {\n     \
    \               *cur = s;\n                }\n            }\n        }\n    }\n\
    \    longest", "    // if strings.len() == 0 {\n    //     return None;\n    //\
    \ }\n    // let mut length = 0;\n    // let mut longest = &strings[0];\n    //\
    \ for s in strings {\n    //     if s.len() > length {\n    //         length\
    \ = s.len();\n    //         longest = &s;\n    //     }\n    // }\n    // Some(String::from(longest))\n\
    \    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())"]
stop_tokens:
- "\n}"
