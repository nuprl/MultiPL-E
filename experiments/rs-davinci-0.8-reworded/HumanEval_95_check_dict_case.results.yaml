language: rs
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for (key, _) in dict {\n        if !key.is_lowercase()\
    \ {\n            lowercase = false;\n        }\n        if !key.is_uppercase()\
    \ {\n            uppercase = false;\n        }\n    }\n    lowercase || uppercase\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp2xlekh6o.rs:21:17\n   |\n21 |         if\
    \ !key.is_lowercase() {\n   |                 ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp2xlekh6o.rs:24:17\n\
    \   |\n24 |         if !key.is_uppercase() {\n   |                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut low = true;\n    let mut up\
    \ = true;\n    for key in dict.keys() {\n        low = low && key.chars().next().unwrap().is_lowercase();\n\
    \        up = up && key.chars().next().unwrap().is_uppercase();\n    }\n    low\
    \ || up\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9x6q4t18.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut count = 0;\n    for key in dict.keys() {\n      \
    \  if key.to_uppercase() == key {\n            count += 1;\n        }\n    }\n\
    \    if count == dict.len() || count == 0 {\n        return true;\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp4tcemypb.rs:23:31\n\
    \   |\n23 |         if key.to_uppercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            uppercase = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            lowercase = false;\n        }\n    }\n    lowercase\
    \ || uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpplnf3r4s.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\tif dict.len() > 0 {\n\t\tlet (first_key,\
    \ first_val) = dict.iter().next().unwrap();\n\t\tlet first_key_is_uppercase =\
    \ first_key.chars().all(|c| c.is_uppercase());\n\t\tlet first_key_is_lowercase\
    \ = first_key.chars().all(|c| c.is_lowercase());\n\t\tlet all_keys_are_uppercase\
    \ = dict.keys().all(|k| k.chars().all(|c| c.is_uppercase()));\n\t\tlet all_keys_are_lowercase\
    \ = dict.keys().all(|k| k.chars().all(|c| c.is_lowercase()));\n\t\tlet keys_have_same_case\
    \ = dict.keys().all(|k| k.chars().all(|c| first_key_is_uppercase == c.is_uppercase()));\n\
    \t\t(first_key_is_uppercase && all_keys_are_uppercase) || (first_key_is_lowercase\
    \ && all_keys_are_lowercase) && keys_have_same_case\n\t} else {\n\t\tfalse\n\t\
    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // implement your code here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp1xsgq_xl.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO\n    true\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkxccvcjk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let mut\
    \ lower = true;\n    let mut upper = true;\n    for key in keys {\n        let\
    \ v = key.chars().next().unwrap();\n        lower = lower && v.is_lowercase();\n\
    \        upper = upper && v.is_uppercase();\n    }\n    lower || upper\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp40m5knxm.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut case_upper = true;\n    let\
    \ mut case_lower = true;\n    for key in dict.keys() {\n        if !key.is_empty()\
    \ {\n            case_upper = case_upper && key.chars().all(|c| c.is_uppercase());\n\
    \            case_lower = case_lower && key.chars().all(|c| c.is_lowercase());\n\
    \        }\n    }\n    case_upper || case_lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmputoc9mpa.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| key.chars().all(|c|\
    \ c.is_lowercase())) ||\n    dict.keys().all(|key| key.chars().all(|c| c.is_uppercase()))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphj33hhem.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxasalzkb.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut uppercase = true;\n    let mut\
    \ lowercase = true;\n    for key in dict.keys() {\n        if key.is_uppercase()\
    \ {\n            lowercase = false;\n        } else if key.is_lowercase() {\n\
    \            uppercase = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    if dict.len() == 0 {\n        return false;\n    }\n  \
    \  return uppercase || lowercase;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpbmx8_kve.rs:21:16\n   |\n21 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmpbmx8_kve.rs:23:23\n\
    \   |\n23 |         } else if key.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgqkldqpc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|k| k.is_ascii() &&\
    \ (k.is_ascii_lowercase() || k.is_ascii_uppercase()))\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp7_s2ec38.rs:18:44\n   |\n18 |\
    \     dict.keys().all(|k| k.is_ascii() && (k.is_ascii_lowercase() || k.is_ascii_uppercase()))\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmp7_s2ec38.rs:18:70\n   |\n18 |     dict.keys().all(|k| k.is_ascii()\
    \ && (k.is_ascii_lowercase() || k.is_ascii_uppercase()))\n   |               \
    \                                                       ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = None;\n    for (key,\
    \ _) in dict {\n        let mut is_lower = true;\n        let mut is_upper = true;\n\
    \        for c in key.chars() {\n            is_lower = is_lower && c.is_lowercase();\n\
    \            is_upper = is_upper && c.is_uppercase();\n        }\n        let\
    \ is_string = is_lower || is_upper;\n        if let Some(prev_is_string) = result\
    \ {\n            if is_string != prev_is_string {\n                return false;\n\
    \            }\n        } else {\n            result = Some(is_string);\n    \
    \    }\n    }\n    result.unwrap_or(false)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphd0kshx8.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        let mut lower = true;\n     \
    \   let mut upper = true;\n        for character in key.chars() {\n          \
    \  if character.is_lowercase() {\n                upper = false;\n           \
    \ } else if character.is_uppercase() {\n                lower = false;\n     \
    \       } else {\n                lower = false;\n                upper = false;\n\
    \            }\n        }\n        if !lower && !upper {\n            return false;\n\
    \        }\n    }\n    if lower || upper {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph3ug23i4.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\tif dict.is_empty() {\n\t\treturn false;\n\
    \t}\n\tlet mut case_lower = true;\n\tlet mut case_upper = true;\n\tfor (key, _)\
    \ in dict {\n\t\tif !key.chars().all(|x| x.is_uppercase()) {\n\t\t\tcase_upper\
    \ = false;\n\t\t}\n\t\tif !key.chars().all(|x| x.is_lowercase()) {\n\t\t\tcase_lower\
    \ = false;\n\t\t}\n\t}\n\treturn case_lower || case_upper;\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_all_upper = true;\n    let\
    \ mut is_all_lower = true;\n    for k in dict.keys() {\n        if k.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_all_lower = false;\n        } else {\n \
    \           is_all_upper = false;\n        }\n    }\n    is_all_lower || is_all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy19ke548.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for (key, _) in dict {\n        for c in key.chars()\
    \ {\n            if c.is_lowercase() {\n                uppercase = false;\n \
    \           } else if c.is_uppercase() {\n                lowercase = false;\n\
    \            } else {\n                lowercase = false;\n                uppercase\
    \ = false;\n            }\n        }\n    }\n    if lowercase || uppercase {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuf19_ne9.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_upper = true;\n    let mut\
    \ all_lower = true;\n    for key in dict.keys() {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            all_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        }\n    }\n    all_upper\
    \ || all_lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmh0_vi_e.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut case_type: Option<CaseType>\
    \ = None;\n    for (key, _) in dict {\n        if let Some(type_) = &case_type\
    \ {\n            if type_ != &key.case_type() {\n                return false;\n\
    \            }\n        } else {\n            case_type = Some(key.case_type());\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `CaseType` in this scope\n  --> /tmp/tmpq2bd6bef.rs:18:31\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                   - help: you might be missing a type parameter: `<CaseType>`\n\
    18 |     let mut case_type: Option<CaseType> = None;\n   |                   \
    \            ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `case_type` found for struct `String` in the current scope\n  --> /tmp/tmpq2bd6bef.rs:21:30\n\
    \   |\n21 |             if type_ != &key.case_type() {\n   |                 \
    \             ^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `case_type` found for struct `String` in the current scope\n  --> /tmp/tmpq2bd6bef.rs:25:34\n\
    \   |\n25 |             case_type = Some(key.case_type());\n   |             \
    \                     ^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0412, E0599.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \    for (key, _value) in dict {\n        if !key.chars().all(|c| c.is_uppercase())\
    \ {\n            all_upper = false;\n        }\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            all_lower = false;\n        }\n    }\n    if\
    \ all_lower || all_upper {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let first_key = dict.keys().nth(0).unwrap();\n    let first_key_is_lower_case\
    \ = first_key.chars().all(|c| c.is_lowercase());\n    let first_key_is_upper_case\
    \ = first_key.chars().all(|c| c.is_uppercase());\n\n    if first_key_is_lower_case\
    \ {\n        dict.keys().all(|k| k.chars().all(|c| c.is_lowercase()))\n    } else\
    \ if first_key_is_upper_case {\n        dict.keys().all(|k| k.chars().all(|c|\
    \ c.is_uppercase()))\n    } else {\n        false\n    }\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let (m, n) = dict.iter().map(|(k, _)| k.is_uppercase()).partition(|&b|\
    \ b);\n    m.len() == dict.len() || n.len() == dict.len()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpl12h1zo1.rs:21:45\n   |\n21 |     let (m,\
    \ n) = dict.iter().map(|(k, _)| k.is_uppercase()).partition(|&b| b);\n   |   \
    \                                          ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_all_upper = true;\n    let mut is_all_lower =\
    \ true;\n    for (key, _value) in dict {\n        if key.to_lowercase() != key\
    \ {\n            is_all_lower = false;\n        }\n        if key.to_uppercase()\
    \ != key {\n            is_all_upper = false;\n        }\n    }\n    is_all_lower\
    \ || is_all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpab9xtx8a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    return true;\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9hshr8o0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_case = true;\n    let\
    \ mut upper_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_case = false;\n        } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    if lower_case || upper_case {\n        return true;\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmph6cgp3w9.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    //create two hashmaps\n    let mut lower\
    \ = HashMap::new();\n    let mut upper = HashMap::new();\n    // add all lowercase\
    \ characters to the lower map\n    // add all uppercase characters to the upper\
    \ map\n    for (&key, &value) in &dict {\n        if key.chars().all(char::is_lowercase)\
    \ {\n            lower.insert(key, value);\n        } else if key.chars().all(char::is_uppercase)\
    \ {\n            upper.insert(key, value);\n        }\n    }\n    // compare lengths,\
    \ if the lengths are the same return true, else return false\n    lower.len()\
    \ == dict.len() || upper.len() == dict.len()\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpxup0ycv2.rs:23:27\n\
    \   |\n23 |     for (&key, &value) in &dict {\n   |           ---            \
    \ ^^^^^\n   |           |\n   |           data moved here\n   |           move\
    \ occurs because `key` has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpxup0ycv2.rs:23:27\n\
    \   |\n23 |     for (&key, &value) in &dict {\n   |                 -----    \
    \ ^^^^^\n   |                 |\n   |                 data moved here\n   |  \
    \               move occurs because `value` has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = true;\n    let mut\
    \ case_is_lower = None;\n    for (key, _value) in dict {\n        match key.to_lowercase().eq(&key)\
    \ {\n            true => {\n                if case_is_lower.is_none() {\n   \
    \                 case_is_lower = Some(true);\n                } else if case_is_lower.unwrap()\
    \ == false {\n                    result = false;\n                    break;\n\
    \                }\n            },\n            false => {\n                if\
    \ case_is_lower.is_none() {\n                    case_is_lower = Some(false);\n\
    \                } else if case_is_lower.unwrap() == true {\n                \
    \    result = false;\n                    break;\n                }\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx3klpsti.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \    for key in dict.keys() {\n        if !key.is_empty() {\n            all_lower\
    \ = all_lower && key.to_lowercase() == *key;\n            all_upper = all_upper\
    \ && key.to_uppercase() == *key;\n        }\n    }\n    return all_lower || all_upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1y4h9hlv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \    for key in dict.keys() {\n        if key.chars().any(|c| c.is_uppercase())\
    \ {\n            all_lower = false;\n        }\n        if key.chars().any(|c|\
    \ c.is_lowercase()) {\n            all_upper = false;\n        }\n    }\n    return\
    \ all_lower || all_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnq1sruab.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt043fpxw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    for (k, _) in dict.iter() {\n      \
    \  if k.chars().next().map(|c| c.is_uppercase()).unwrap_or(false) !=\n       \
    \     k.chars().next().map(|c| c.is_lowercase()).unwrap_or(false) {\n        \
    \    return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpitp0vx5r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // your code here\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpupa4kobu.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut num_uppercase = 0;\n    let mut num_lowercase = 0;\n\
    \    for (key, _) in dict {\n        if key.chars().all(char::is_uppercase) {\n\
    \            num_uppercase += 1;\n        } else if key.chars().all(char::is_lowercase)\
    \ {\n            num_lowercase += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    if num_uppercase == 0 || num_lowercase == 0 {\n       \
    \ return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Implement this function\n \
    \   unimplemented!()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvuvbzdgk.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    for key in dict.keys() {\n        for ch in key.chars() {\n            if\
    \ ch.is_lowercase() {\n                if !is_lower {\n                    return\
    \ false;\n                }\n            } else if ch.is_uppercase() {\n     \
    \           if is_lower {\n                    return false;\n               \
    \ }\n            } else {\n                return false;\n            }\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_count = 0;\n    let mut\
    \ upper_count = 0;\n    for k in dict.keys() {\n        if k.to_string().contains(\"\
    [A-Z]\") {\n            upper_count += 1;\n        } else if k.to_string().contains(\"\
    [a-z]\") {\n            lower_count += 1;\n        }\n    }\n    if upper_count\
    \ == dict.len() || lower_count == dict.len() {\n        return true;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjzeqw0_j.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().fold((None, None), |acc,\
    \ (k, _)| {\n        let k_lower = k.to_lowercase();\n        let k_upper = k.to_uppercase();\n\
    \        match acc {\n            (None, None) => {\n                if k_lower\
    \ == k {\n                    (Some(true), None)\n                } else if k_upper\
    \ == k {\n                    (None, Some(true))\n                } else {\n \
    \                   (Some(false), Some(false))\n                }\n          \
    \  },\n            (Some(l), None) if l => {\n                if k_lower == k\
    \ {\n                    (Some(true), None)\n                } else {\n      \
    \              (Some(false), Some(false))\n                }\n            },\n\
    \            (None, Some(u)) if u => {\n                if k_upper == k {\n  \
    \                  (None, Some(true))\n                } else {\n            \
    \        (Some(false), Some(false))\n                }\n            },\n     \
    \       _ => (Some(false), Some(false))\n        }\n    }) == (Some(true), None)\
    \ || (dict.iter().fold((None, None), |acc, (k, _)| {\n        let k_lower = k.to_lowercase();\n\
    \        let k_upper = k.to_uppercase();\n        match acc {\n            (None,\
    \ None) => {\n                if k_lower == k {\n                    (Some(true),\
    \ None)\n                } else if k_upper == k {\n                    (None,\
    \ Some(true))\n                } else {\n                    (Some(false), Some(false))\n\
    \                }\n            },\n            (Some(l), None) if l => {\n  \
    \              if k_lower == k {\n                    (Some(true), None)\n   \
    \             } else {\n                    (Some(false), Some(false))\n     \
    \           }\n            },\n            (None, Some(u)) if u => {\n       \
    \         if k_upper == k {\n                    (None, Some(true))\n        \
    \        } else {\n                    (Some(false), Some(false))\n          \
    \      }\n            },\n            _ => (Some(false), Some(false))\n      \
    \  }\n    }) == (None, Some(\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp8mfzltul.rs:76:22\n\
    \   |\n17 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |\
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n76 |     }) == (None, Some(\n   |            \
    \          ^ unclosed delimiter\n77 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp8mfzltul.rs:23:28\n\
    \   |\n23 |                 if k_lower == k {\n   |                          \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp8mfzltul.rs:25:35\n   |\n25 |                 } else if k_upper\
    \ == k {\n   |                                   ^^ no implementation for `String\
    \ == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmp8mfzltul.rs:32:28\n   |\n32 |       \
    \          if k_lower == k {\n   |                            ^^ no implementation\
    \ for `String "
  stdout: ''
  timestamp: 1660010779
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_upper: bool = true;\n    let mut all_lower: bool\
    \ = true;\n    for (key, _) in dict {\n        let mut chars: Vec<char> = key.chars().collect();\n\
    \        let char_type: char = chars[0];\n        if char_type.is_ascii_uppercase()\
    \ {\n            all_lower = false;\n        } else if char_type.is_ascii_lowercase()\
    \ {\n            all_upper = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    all_upper || all_lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8te4uqx7.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if let Some(c) = key.chars().next()\
    \ {\n            if c.is_uppercase() {\n                lower = false;\n     \
    \       } else if c.is_lowercase() {\n                upper = false;\n       \
    \     } else {\n                return false;\n            }\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvq1j_snb.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut case_is_known = false;\n   \
    \ let mut dict_is_all_lower = false;\n    for key in dict.keys() {\n        if\
    \ key.chars().all(|c| c.is_lowercase()) {\n            if case_is_known && !dict_is_all_lower\
    \ {\n                return false;\n            }\n            case_is_known =\
    \ true;\n            dict_is_all_lower = true;\n        } else if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            if case_is_known && dict_is_all_lower {\n \
    \               return false;\n            }\n            case_is_known = true;\n\
    \            dict_is_all_lower = false;\n        } else {\n            return\
    \ false;\n        }\n    }\n    return case_is_known;\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = None;\n    for i in\
    \ dict.keys() {\n        let a = i.chars().next().unwrap().is_uppercase();\n \
    \       if result == None {\n            result = Some(a);\n        } else if\
    \ result != Some(a) {\n            return false;\n        }\n    }\n    return\
    \ result.unwrap();\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprio4x0us.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut flag = false;\n    let is_upper\
    \ = dict.keys().all(|s| s.is_uppercase());\n    let is_lower = dict.keys().all(|s|\
    \ s.is_lowercase());\n    if is_upper || is_lower {\n        flag = true;\n  \
    \  }\n    flag\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpoous0qmh.rs:19:42\n   |\n19 |     let is_upper\
    \ = dict.keys().all(|s| s.is_uppercase());\n   |                             \
    \             ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror[E0599]: no method named `is_lowercase` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpoous0qmh.rs:20:42\n\
    \   |\n20 |     let is_lower = dict.keys().all(|s| s.is_lowercase());\n   |  \
    \                                        ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut is_lower = false;\n    let mut is_upper = false;\n\
    \    for (key, _value) in dict {\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            is_lower = true;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            is_upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    return is_lower || is_upper;\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpshnz_1aj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        match key.chars().next() {\n\
    \            Some(c) => {\n                if !c.is_lowercase() {\n          \
    \          lower = false;\n                }\n                if !c.is_uppercase()\
    \ {\n                    upper = false;\n                }\n            },\n \
    \           None => return false,\n        }\n    }\n    if lower || upper {\n\
    \        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7hzckjol.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut count_lower_case: u32 = 0;\n\
    \    let mut count_upper_case: u32 = 0;\n    for key in dict.keys() {\n      \
    \  if key.is_empty() {\n            return false;\n        }\n        if key.chars().all(char::is_uppercase)\
    \ {\n            count_upper_case += 1;\n        } else if key.chars().all(char::is_lowercase)\
    \ {\n            count_lower_case += 1;\n        } else {\n            return\
    \ false;\n        }\n    }\n    return dict.len() as u32 == count_lower_case ||\
    \ dict.len() as u32 == count_upper_case;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3c_n_7j7.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Implement check_dict_case.\n\
    \    let mut lower_case = true;\n    let mut upper_case = true;\n    for s in\
    \ dict.keys() {\n        for c in s.chars() {\n            if c.is_uppercase()\
    \ {\n                lower_case = false;\n            } else if c.is_lowercase()\
    \ {\n                upper_case = false;\n            }\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp417impkd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = dict.keys().next().map_or(false,\
    \ String::is_uppercase);\n    for key in dict.keys() {\n        if String::is_uppercase(key)\
    \ != is_upper {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `is_uppercase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpdkf4j2m2.rs:18:65\n\
    \   |\n18 |     let mut is_upper = dict.keys().next().map_or(false, String::is_uppercase);\n\
    \   |                                                                 ^^^^^^^^^^^^\
    \ function or associated item not found in `String`\n\nerror[E0599]: no function\
    \ or associated item named `is_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdkf4j2m2.rs:20:20\n   |\n20 |         if String::is_uppercase(key)\
    \ != is_upper {\n   |                    ^^^^^^^^^^^^ function or associated item\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    //let mut upper = true;\n    //let mut\
    \ lower = true;\n    //let mut mixed = false;\n    let mut strings = vec![];\n\
    \    for (key, value) in dict {\n        //let skey = String::from(key);\n   \
    \     let lowercase = key.to_lowercase();\n        let uppercase = key.to_uppercase();\n\
    \        let mixedcase = key.to_string();\n        if mixedcase != lowercase &&\
    \ mixedcase != uppercase {\n            return false;\n        }\n        strings.push(key);\n\
    \    }\n    let mut mixed = false;\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    let mut all_upper = true;\n    let mut all_lower = true;\n    for\
    \ key in strings {\n        let skey = String::from(key);\n        let lowercase\
    \ = skey.to_lowercase();\n        let uppercase = skey.to_uppercase();\n     \
    \   let mixedcase = skey.to_string();\n        if mixedcase != lowercase && mixedcase\
    \ != uppercase {\n            mixed = true;\n        }\n        if mixedcase !=\
    \ lowercase {\n            all_lower = false;\n        }\n        if mixedcase\
    \ != uppercase {\n            all_upper = false;\n        }\n    }\n    if mixed\
    \ == true {\n        return false;\n    }\n    if all_lower == true {\n      \
    \  lower = true;\n        upper = false;\n    }\n    if all_upper == true {\n\
    \        lower = false;\n        upper = true;\n    }\n    if upper == false &&\
    \ lower == false {\n        return false;\n    }\n    else {\n        return true;\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp81vd2xtm.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_uppercase = true;\n    let\
    \ mut all_lowercase = true;\n    for (key, _) in dict {\n        let mut character_vec:\
    \ Vec<char> = key.chars().collect();\n        if character_vec[0].is_uppercase()\
    \ {\n            all_lowercase = false;\n        } else {\n            all_uppercase\
    \ = false;\n        }\n    }\n    if all_uppercase || all_lowercase {\n      \
    \  return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjdyow4b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lower = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_upper = false;\n        } else {\n     \
    \       return false;\n        }\n    }\n    !(is_lower && is_upper)\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmjlvi6qx.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut count_lower = 0;\n    let mut\
    \ count_upper = 0;\n    for key in dict.keys() {\n        let mut contains_non_alphabetic\
    \ = false;\n        for c in key.chars() {\n            if !c.is_alphabetic()\
    \ {\n                contains_non_alphabetic = true;\n                break;\n\
    \            }\n        }\n        if contains_non_alphabetic {\n            return\
    \ false;\n        }\n        if key.chars().all(|c| c.is_lowercase()) {\n    \
    \        count_lower += 1;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            count_upper += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    if count_lower == 0 && count_upper == 0 {\n        return\
    \ false;\n    }\n    return (count_lower == 0) || (count_upper == 0);\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4xsy1boa.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut uppercase_keys = true;\n   \
    \ let mut lowercase_keys = true;\n    for key in dict.keys() {\n        uppercase_keys\
    \ = uppercase_keys && key.chars().all(|c| c.is_uppercase());\n        lowercase_keys\
    \ = lowercase_keys && key.chars().all(|c| c.is_lowercase());\n    }\n    uppercase_keys\
    \ || lowercase_keys\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjvrwx9u4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.iter().all(|(k, _)| k.is_ascii()\
    \ && k.to_lowercase() == k || k.is_ascii() && k.to_uppercase() == k)\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpzbvh0fhr.rs:18:63\n\
    \   |\n18 |     dict.iter().all(|(k, _)| k.is_ascii() && k.to_lowercase() == k\
    \ || k.is_ascii() && k.to_uppercase() == k)\n   |                            \
    \                                   ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpzbvh0fhr.rs:18:104\n   |\n18 |     dict.iter().all(|(k,\
    \ _)| k.is_ascii() && k.to_lowercase() == k || k.is_ascii() && k.to_uppercase()\
    \ == k)\n   |                                                                \
    \                                        ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut check_case = None;\n    for\
    \ (key, _) in dict {\n        let lower_case = key.to_lowercase() == key;\n  \
    \      let upper_case = key.to_uppercase() == key;\n        if !lower_case &&\
    \ !upper_case {\n            return false;\n        }\n        let curr_case =\
    \ if lower_case { 0 } else { 1 };\n        if check_case == None {\n         \
    \   check_case = Some(curr_case);\n        } else if check_case != Some(curr_case)\
    \ {\n            return false;\n        }\n    }\n    match check_case {\n   \
    \     None => false,\n        _ => true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp87rutzcg.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if let Some(string) = key.to_str()\
    \ {\n            if string.chars().any(|x| x.is_uppercase()) {\n             \
    \   lower = false;\n            }\n            if string.chars().any(|x| x.is_lowercase())\
    \ {\n                upper = false;\n            }\n        } else {\n       \
    \     lower = false;\n            upper = false;\n        }\n    }\n    return\
    \ lower || upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_str` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpimlh63dj.rs:21:35\n   |\n21 |         if let\
    \ Some(string) = key.to_str() {\n   |                                   ^^^^^^\
    \ help: there is an associated function with a similar name: `as_str`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut state = false;\n    for (key,\
    \ _) in dict {\n        if key.chars().all(|c| c.is_lowercase()) {\n         \
    \   if state == true {\n                return false;\n            }\n       \
    \     state = true;\n        } else if key.chars().all(|c| c.is_uppercase()) {\n\
    \            if state == true {\n                return false;\n            }\n\
    \            state = true;\n        } else {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoh55ufb_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Fix this method\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzodl65ga.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        let mut is_lower = true;\n    \
    \    let mut is_upper = true;\n        for ch in key.chars() {\n            if\
    \ !ch.is_ascii_lowercase() {\n                is_lower = false;\n            }\n\
    \            if !ch.is_ascii_uppercase() {\n                is_upper = false;\n\
    \            }\n        }\n        if !is_lower {\n            lower = false;\n\
    \        }\n        if !is_upper {\n            upper = false;\n        }\n  \
    \  }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbrca43hv.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut keys_lower_case = true;\n    let mut keys_upper_case\
    \ = true;\n\n    for k in dict.keys() {\n        let all_lower = k.chars().all(|c|\
    \ c.is_lowercase());\n        let all_upper = k.chars().all(|c| c.is_uppercase());\n\
    \n        if !all_lower {\n            keys_lower_case = false;\n        }\n\n\
    \        if !all_upper {\n            keys_upper_case = false;\n        }\n  \
    \  }\n\n    keys_lower_case || keys_upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut char_case: Vec<bool> = Vec::new();\n    for (key,\
    \ _) in dict.iter() {\n        if key.is_ascii() {\n            let mut lower:\
    \ bool = true;\n            let mut upper: bool = true;\n            for c in\
    \ key.chars() {\n                if c.is_lowercase() {\n                    upper\
    \ = false;\n                } else if c.is_uppercase() {\n                   \
    \ lower = false;\n                } else {\n                    return false;\n\
    \                }\n            }\n            if lower {\n                char_case.push(true);\n\
    \            } else if upper {\n                char_case.push(false);\n     \
    \       } else {\n                return false;\n            }\n        } else\
    \ {\n            return false;\n        }\n    }\n    char_case.dedup();\n   \
    \ char_case.len() == 1\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \n    for (key, _) in dict {\n        for c in key.chars() {\n            if c.is_lowercase()\
    \ {\n                all_upper = false;\n            } else if c.is_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = false;\n    let mut\
    \ upper = false;\n    for key in dict.keys() {\n        if key.is_empty() {\n\
    \            return false;\n        }\n        if key.chars().all(|c| c.is_ascii_lowercase())\
    \ {\n            lower = true;\n        } else if key.chars().all(|c| c.is_ascii_uppercase())\
    \ {\n            upper = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    lower ^ upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_ascii() {\n      \
    \      return false;\n        }\n        if !key.chars().all(|x| x.is_lowercase())\
    \ {\n            lower = false;\n        }\n        if !key.chars().all(|x| x.is_uppercase())\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqytyvg6c.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut check_lower = true;\n    let\
    \ mut check_upper = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            check_lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            check_upper = false;\n        }\n    }\n    if check_lower ||\
    \ check_upper {\n        return true;\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpmkeo6_c0.rs:21:17\n   |\n21 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpmkeo6_c0.rs:24:17\n   |\n24 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() { return false; }\n\
    \    let dict_keys: Vec<String> = dict.keys().map(|key| key.to_string()).collect();\n\
    \    let first_key = dict_keys[0].clone();\n    match first_key.chars().next()\
    \ {\n        Some(c) => {\n            if c.is_uppercase() {\n               \
    \ dict_keys.iter().all(|key| key.chars().all(|c| c.is_uppercase()))\n        \
    \    } else {\n                dict_keys.iter().all(|key| key.chars().all(|c|\
    \ c.is_lowercase()))\n            }\n        },\n        None => false\n    }\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    //for each key\n    //take one random\
    \ and see if the first char is uppercase\n    //then convert the other chars to\
    \ lowercase and compare\n    //if keys are in lowercase, convert them to uppercase\
    \ and compare\n    for (key, value) in dict.iter() {\n        let mut first_char_upper\
    \ = false;\n        if key.chars().next().unwrap().is_uppercase() {\n        \
    \    first_char_upper = true;\n        }\n        //println!(\"{:?}\", first_char_upper);\n\
    \        let lowercase_key = key.to_lowercase();\n        let uppercase_key =\
    \ key.to_uppercase();\n        //println!(\"{:?} {:?}\", lowercase_key, uppercase_key);\n\
    \        if lowercase_key != uppercase_key {\n            return false;\n    \
    \    }\n        //println!(\"{:?}\", first_char_upper);\n        //for each key,\
    \ check if there is a key with first letter uppercase\n        for (temp_key,\
    \ temp_value) in dict.iter() {\n            if temp_key.chars().next().unwrap().is_uppercase()\
    \ != first_char_upper {\n                return false;\n            }\n      \
    \  }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpeqrmdpca.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgqkldqpc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = true;\n    let mut\
    \ upper = true;\n    let mut lower = true;\n    for (key, _value) in dict {\n\
    \        if key.chars().next().unwrap().is_ascii_uppercase() {\n            lower\
    \ = false;\n        } else {\n            upper = false;\n        }\n    }\n \
    \   if !upper && !lower {\n        result = false;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbrgrqz9o.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        for c in key.chars()\
    \ {\n            if c.is_lowercase() {\n                all_upper = false;\n \
    \           } else if c.is_uppercase() {\n                all_lower = false;\n\
    \            } else {\n                all_lower = false;\n                all_upper\
    \ = false;\n            }\n        }\n    }\n    all_lower || all_upper\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpabdiucw2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_ascii_lowercase())\
    \ {\n            lower = false;\n        }\n        if !key.chars().all(|c| c.is_ascii_uppercase())\
    \ {\n            upper = false;\n        }\n    }\n    upper || lower\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn_8oxt5r.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    return false;\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt043fpxw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut is_upper = dict.keys().next().unwrap().chars().next().unwrap().is_uppercase();\n\
    \    let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    if is_upper || is_lower {\n        for key in dict.keys() {\n           \
    \ for c in key.chars() {\n                if c.is_lowercase() {\n            \
    \        is_lower = false;\n                }\n                if c.is_uppercase()\
    \ {\n                    is_upper = false;\n                }\n            }\n\
    \        }\n    }\n    is_upper || is_lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm9a6sza8.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    // TODO: implement me!\n    let mut upper = true;\n    let\
    \ mut lower = true;\n    for (key, _) in dict.iter() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower = false;\n        } else {\n            upper = false;\n\
    \        }\n    }\n    return upper || lower;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbxc8pcdo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() { return false }\n\
    \    let mut result: bool = false;\n    let mut lower_case_keys: i32 = 0;\n  \
    \  let mut upper_case_keys: i32 = 0;\n    for key in dict.keys() {\n        let\
    \ upper_case = key.clone().to_uppercase();\n        let lower_case = key.clone().to_lowercase();\n\
    \        if upper_case == key.to_string() {\n            upper_case_keys += 1;\n\
    \        } else if lower_case == key.to_string() {\n            lower_case_keys\
    \ += 1;\n        }\n    }\n    if (lower_case_keys == dict.len() as i32) || (upper_case_keys\
    \ == dict.len() as i32) {\n        result = true;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper_dict = true;\n    let\
    \ mut lower_dict = true;\n    for k in dict.keys() {\n        if k.chars().next().unwrap().is_lowercase()\
    \ {\n            upper_dict = false;\n        } else {\n            lower_dict\
    \ = false;\n        }\n    }\n    upper_dict || lower_dict\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplh43ybpb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lowercase_keys = true;\n    let mut key_casing =\
    \ Case::Mixed;\n    for (key, _) in dict.iter() {\n        if key.chars().next().unwrap().is_ascii_lowercase()\
    \ {\n            lowercase_keys = true;\n            key_casing = Case::Lowercase;\n\
    \        } else if key.chars().next().unwrap().is_ascii_uppercase() {\n      \
    \      lowercase_keys = false;\n            key_casing = Case::Uppercase;\n  \
    \      } else {\n            return false;\n        }\n    }\n    for (key, _)\
    \ in dict.iter() {\n        if lowercase_keys && key.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n            return false;\n        } else if !lowercase_keys && key.chars().next().unwrap().is_ascii_lowercase()\
    \ {\n            return false;\n        }\n    }\n    return key_casing != Case::Mixed;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Case`\n  --> /tmp/tmp1egjn0sy.rs:22:26\n\
    \   |\n22 |     let mut key_casing = Case::Mixed;\n   |                      \
    \    ^^^^ use of undeclared type `Case`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Case`\n  --> /tmp/tmp1egjn0sy.rs:26:26\n   |\n26 |     \
    \        key_casing = Case::Lowercase;\n   |                          ^^^^ use\
    \ of undeclared type `Case`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Case`\n  --> /tmp/tmp1egjn0sy.rs:29:26\n   |\n29 |             key_casing\
    \ = Case::Uppercase;\n   |                          ^^^^ use of undeclared type\
    \ `Case`\n\nerror[E0433]: failed to resolve: use of undeclared type `Case`\n \
    \ --> /tmp/tmp1egjn0sy.rs:41:26\n   |\n41 |     return key_casing != Case::Mixed;\n\
    \   |                          ^^^^ use of undeclared type `Case`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Implement the solution here\n\
    \    return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw747gy9b.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // YOUR CODE HERE\n    let mut upper\
    \ = false;\n    let mut lower = false;\n    for (k,_) in dict.iter() {\n     \
    \   if k.chars().next().unwrap().is_uppercase() {\n            upper = true;\n\
    \        } else {\n            lower = true;\n        }\n    }\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    if upper && lower {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplcg25q0t.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_upper = dict.keys().next().unwrap().is_uppercase();\n\
    \    dict.keys().all(|key| {\n        key.is_uppercase() == is_upper\n    })\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpx7efhueu.rs:18:52\n   |\n18 |     let mut\
    \ is_upper = dict.keys().next().unwrap().is_uppercase();\n   |               \
    \                                     ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpx7efhueu.rs:20:13\n\
    \   |\n20 |         key.is_uppercase() == is_upper\n   |             ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.keys().all(|key| {\n    \
    \    key.chars().all(|c| c.is_lowercase())\n    }) {\n        true => dict.keys().all(|key|\
    \ {\n            key.chars().all(|c| c.is_uppercase())\n        }),\n        false\
    \ => false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxxabv__d.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for (key, _) in dict {\n        upper = upper && key.chars().all(|c|\
    \ c.is_uppercase());\n        lower = lower && key.chars().all(|c| c.is_lowercase());\n\
    \    }\n    upper || lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkxyy5cfo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\ttrue\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprlavmube.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_all_lower = true;\n    let\
    \ mut is_all_upper = true;\n    for (key, _) in dict {\n        if key.chars().any(|c|\
    \ c.is_uppercase()) {\n            is_all_lower = false;\n        }\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            is_all_upper = false;\n\
    \        }\n    }\n    if is_all_lower {\n        return true;\n    }\n    if\
    \ is_all_upper {\n        return true;\n    }\n    false\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5jbxdj6e.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // true if all keys are uppercase, false\
    \ if all keys are lowercase\n    let mut upper_key_state = true;\n    let mut\
    \ lower_key_state = true;\n    let mut is_key_string = true;\n    let mut is_value_string\
    \ = true;\n    let mut all_keys_are_same_case = true;\n    for (key, value) in\
    \ dict {\n        if key.chars().any(|c| c.is_uppercase()) {\n            lower_key_state\
    \ = false;\n        } else if key.chars().any(|c| c.is_lowercase()) {\n      \
    \      upper_key_state = false;\n        } else {\n            is_key_string =\
    \ false;\n        }\n        if !value.chars().any(|c| c.is_alphabetic()) {\n\
    \            is_value_string = false;\n        }\n        if (!lower_key_state\
    \ && !upper_key_state) || (!is_key_string && !is_value_string) {\n           \
    \ all_keys_are_same_case = false;\n        }\n    }\n    all_keys_are_same_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeymux83x.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    //unimplemented!()\n    return false;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprz63qkzf.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().filter(|&k| k.to_uppercase()\
    \ == *k).count() == dict.len() || dict.keys().filter(|&k| k.to_lowercase() ==\
    \ *k).count() == dict.len()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpibbsq00t.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for s in dict.keys() {\n        if s.is_ascii_lowercase()\
    \ {\n            is_lower = true;\n        } else if s.is_ascii_uppercase() {\n\
    \            is_upper = true;\n        } else {\n            return false;\n \
    \       }\n    }\n    if is_lower && is_upper {\n        return false;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp18w9berl.rs:21:14\n   |\n21 |\
    \         if s.is_ascii_lowercase() {\n   |              ^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_ascii_lowercase`\n\n\
    error[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp18w9berl.rs:23:21\n   |\n23 |         }\
    \ else if s.is_ascii_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lowercase = true;\n    let mut uppercase = true;\n\
    \    for key in dict.keys() {\n        lowercase = lowercase && key.chars().all(|c|\
    \ c.is_lowercase());\n        uppercase = uppercase && key.chars().all(|c| c.is_uppercase());\n\
    \    }\n    lowercase || uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    let mut empty = true;\n    for (key, _value) in dict\
    \ {\n        if empty {\n            empty = false;\n        }\n        if !key.is_ascii_lowercase()\
    \ {\n            lowercase = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            uppercase = false;\n        }\n    }\n    if empty {\n      \
    \  return false;\n    }\n    lowercase || uppercase\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpnhqpbk8w.rs:25:17\n   |\n25 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpnhqpbk8w.rs:28:17\n   |\n28 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let (a, b) = dict.keys().fold((true,\
    \ true), |(mut a, mut b), k| {\n        if k.chars().next().unwrap().is_uppercase()\
    \ {\n            a = false;\n        } else {\n            b = false;\n      \
    \  }\n        (a, b)\n    });\n    a ^ b\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7d0mlxci.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.keys().next() {\n       \
    \ Some(val) => {\n            let is_lower = val.chars().all(|c| c.is_lowercase());\n\
    \            let is_upper = val.chars().all(|c| c.is_uppercase());\n         \
    \   is_lower || is_upper\n        },\n        None => false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprhncmyes.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_count = 0;\n    let mut upper_count = 0;\n\
    \    for (key, value) in dict {\n        if key.is_empty() {\n            continue;\n\
    \        }\n        if key.chars().all(char::is_uppercase) {\n            upper_count\
    \ += 1;\n        } else if key.chars().all(char::is_lowercase) {\n           \
    \ lower_count += 1;\n        } else {\n            return false;\n        }\n\
    \    }\n    return (lower_count == 0 || upper_count == 0) && dict.len() == lower_count\
    \ + upper_count;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `value`\n  --> /tmp/tmprrb931oi.rs:23:15\n  \
    \ |\n23 |     for (key, value) in dict {\n   |               ^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_value`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmprrb931oi.rs:35:54\n\
    \    |\n17  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n23  |     for (key,\
    \ value) in dict {\n    |                         ---- `dict` moved due to this\
    \ implicit call to `.into_iter()`\n...\n35  |     return (lower_count == 0 ||\
    \ upper_count == 0) && dict.len() == lower_count + upper_count;\n    |       \
    \                                               ^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `dict`\nhelp: consider iterating over a slice of the `HashMap<String,\
    \ String>`'s content to avoid moving into the `for` loop\n    |\n23  |     for\
    \ (key, value) in &dict {\n    |                         +\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict {\n        match key.chars().next()\
    \ {\n            Some(c) => {\n                if c.is_lowercase() {\n       \
    \             is_lower = true;\n                } else if c.is_uppercase() {\n\
    \                    is_upper = true;\n                }\n            },\n   \
    \         None => ()\n        }\n    }\n    is_lower ^ is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu25oet7v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() > 0 {\n        let mut\
    \ is_lower = false;\n        let mut is_upper = false;\n        for key in dict.keys()\
    \ {\n            if key.chars().next().unwrap().is_lowercase() {\n           \
    \     is_lower = true;\n            } else if key.chars().next().unwrap().is_uppercase()\
    \ {\n                is_upper = true;\n            } else {\n                return\
    \ false;\n            }\n        }\n        is_lower != is_upper\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppcd9jtyp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4xsy1boa.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper = true;\n    let mut lower\
    \ = true;\n    for (key, _) in dict {\n        let upper_key = key.to_uppercase();\n\
    \        let lower_key = key.to_lowercase();\n        if key != upper_key {\n\
    \            upper = false;\n        }\n        if key != lower_key {\n      \
    \      lower = false;\n        }\n    }\n    upper || lower\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxmdbry_v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4xsy1boa.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7ceipkae.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut lower = true;\n    let mut upper = true;\n    for\
    \ key in dict.keys() {\n        if key.to_uppercase() != *key {\n            upper\
    \ = false;\n        }\n        if key.to_lowercase() != *key {\n            lower\
    \ = false;\n        }\n    }\n    return lower || upper;\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnbwpayse.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|x| x.as_str().chars().all(|c|\
    \ c.is_uppercase())) || dict.keys().all(|x| x.as_str().chars().all(|c| c.is_lowercase()))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb1d6oshl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    return dict.keys().all(|key| key.is_ascii()\
    \ && (key.as_str().is_ascii_lowercase() || key.as_str().is_ascii_uppercase()));\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpr4erj07z.rs:18:66\n   |\n18 |   \
    \  return dict.keys().all(|key| key.is_ascii() && (key.as_str().is_ascii_lowercase()\
    \ || key.as_str().is_ascii_uppercase()));\n   |                              \
    \                                    ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `is_ascii_uppercase` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpr4erj07z.rs:18:103\n   |\n18 |     return dict.keys().all(|key|\
    \ key.is_ascii() && (key.as_str().is_ascii_lowercase() || key.as_str().is_ascii_uppercase()));\n\
    \   |                                                                        \
    \                               ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| key.as_str().starts_with(char::is_lowercase))\
    \ || dict.keys().all(|key| key.as_str().starts_with(char::is_uppercase))\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy2ax1orn.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    match dict.keys().next() {\n       \
    \ Some(k) => {\n            let caps_check: bool = k.chars().all(|c| c.is_uppercase());\n\
    \            let lower_check: bool = k.chars().all(|c| c.is_lowercase());\n  \
    \          if caps_check {\n                dict.keys().all(|k| k.chars().all(|c|\
    \ c.is_uppercase()))\n            } else if lower_check {\n                dict.keys().all(|k|\
    \ k.chars().all(|c| c.is_lowercase()))\n            } else {\n               \
    \ false\n            }\n        },\n        None => false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_uppercase: bool = true;\n\
    \    let mut is_lowercase: bool = true;\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for (key, value) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            is_lowercase = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_uppercase = false;\n        } else {\n \
    \           return false;\n        }\n    }\n    is_uppercase || is_lowercase\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut result: bool = true;\n    let mut upper: bool = dict.keys().next().unwrap().chars().next().unwrap().is_uppercase();\n\
    \    for key in dict.keys() {\n        for c in key.chars() {\n            if\
    \ c.is_uppercase() != upper {\n                result = false;\n             \
    \   break;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdsfuou99.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcg7uti7r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgqkldqpc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|s| s.to_lowercase()\
    \ == s) || dict.keys().all(|s| s.to_uppercase() == s)\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpiahahzft.rs:18:42\n\
    \   |\n18 |     dict.keys().all(|s| s.to_lowercase() == s) || dict.keys().all(|s|\
    \ s.to_uppercase() == s)\n   |                                          ^^ no\
    \ implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpiahahzft.rs:18:88\n   |\n18 |     dict.keys().all(|s| s.to_lowercase()\
    \ == s) || dict.keys().all(|s| s.to_uppercase() == s)\n   |                  \
    \                                                                      ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut result = true;\n    for (key,\
    \ _) in dict {\n        match key.to_lowercase().eq(&key) {\n            true\
    \ => match result {\n                true => result = true,\n                false\
    \ => result = false,\n            },\n            false => match result {\n  \
    \              true => result = true,\n                false => result = false,\n\
    \            },\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_l3ncy7s.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    if dict.is_empty() {\n        return false;\n    }\n\
    \    for key in dict.keys() {\n        all_lower = all_lower && key.chars().all(|c|\
    \ c.is_lowercase());\n        all_upper = all_upper && key.chars().all(|c| c.is_uppercase());\n\
    \    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // check if HashMap is empty\n    if\
    \ dict.is_empty() {\n        return false;\n    }\n\n    // create a tuple of\
    \ all-upper-case and all-lower-case\n    let case = (\n        dict.keys().all(|x|\
    \ x.chars().all(|x| x.is_uppercase())),\n        dict.keys().all(|x| x.chars().all(|x|\
    \ x.is_lowercase()))\n    );\n\n    // return true if the tuple evaluates to (true,\
    \ false) or (false, true)\n    case == (true, false) || case == (false, true)\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // return false if HashMap is empty\n\
    \    if dict.is_empty() {\n        return false;\n    }\n\n    // retrieve first\
    \ key\n    let key: String = dict.keys().next().unwrap().to_owned();\n\n    //\
    \ is the first key all lowercase?\n    let is_lowercase: bool = key.chars().all(|c|\
    \ c.is_lowercase());\n\n    // is the first key all uppercase?\n    let is_uppercase:\
    \ bool = key.chars().all(|c| c.is_uppercase());\n\n    // do all keys match the\
    \ first key in case?\n    let all_keys_match_case: bool = dict.keys().all(|k|\
    \ k.eq(&key) || (is_lowercase && k.chars().all(|c| c.is_lowercase())) || (is_uppercase\
    \ && k.chars().all(|c| c.is_uppercase())));\n\n    // return whether all keys\
    \ match the first key in case\n    all_keys_match_case\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // return true;\n    if dict.len() ==\
    \ 0 {\n        return false;\n    }\n\n    let mut case_type = None;\n    for\
    \ key in dict.keys() {\n        let cased = key.chars().all(|x| x.is_uppercase());\n\
    \        if case_type == None {\n            case_type = Some(cased);\n      \
    \  } else if case_type != Some(cased) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7j70b2df.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Your code here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8bx75xk_.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|k| k.chars().all(|c|\
    \ c.is_lowercase())) ||\n    dict.keys().all(|k| k.chars().all(|c| c.is_uppercase()))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1aetfyhn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut tmp: HashMap<bool, String> = HashMap::new();\n  \
    \  for (k, v) in dict {\n        if k.is_empty() {\n            return false;\n\
    \        }\n        let is_lower = k.chars().all(|c| c.is_ascii_lowercase());\n\
    \        let is_upper = k.chars().all(|c| c.is_ascii_uppercase());\n        if\
    \ !is_lower && !is_upper {\n            return false;\n        }\n        tmp.insert(is_lower,\
    \ v);\n    }\n    match tmp.len() {\n        0 => true,\n        1 => true,\n\
    \        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_all_lower = true;\n    let\
    \ mut is_all_upper = true;\n    for (key, _) in dict {\n        if key.is_ascii_lowercase()\
    \ {\n            is_all_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_all_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    if is_all_lower || is_all_upper {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp_kki2d1v.rs:21:16\n   |\n21 |         if\
    \ key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp_kki2d1v.rs:23:23\n   |\n23 |         } else if key.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Unimplemented!\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxcrp1ubv.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Return the appropriate boolean\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp74su9qfi.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().all(|key| key.is_empty()\
    \ || key.as_str().chars().all(|c| c.is_uppercase())) || dict.keys().all(|key|\
    \ key.is_empty() || key.as_str().chars().all(|c| c.is_lowercase()))\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp3bprzm1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_uppercase = true;\n    for key in dict.keys()\
    \ {\n        if !key.chars().all(|c| c.is_uppercase()) {\n            is_uppercase\
    \ = false;\n            break;\n        }\n    }\n    let mut is_lowercase = true;\n\
    \    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase())\
    \ {\n            is_lowercase = false;\n            break;\n        }\n    }\n\
    \    is_uppercase || is_lowercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower: bool = true;\n   \
    \ let mut is_upper: bool = true;\n    for key in dict.keys() {\n        if key.to_uppercase()\
    \ != *key {\n            is_upper = false;\n        }\n        if key.to_lowercase()\
    \ != *key {\n            is_lower = false;\n        }\n    }\n    is_lower ||\
    \ is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcgfwuaw3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower: bool = false;\n  \
    \  let mut is_upper: bool = false;\n    for key in dict.keys() {\n        if key.len()\
    \ != 0 {\n            let first_char = &key[0..1];\n            if first_char.is_uppercase()\
    \ {\n                is_upper = true;\n            } else if first_char.is_lowercase()\
    \ {\n                is_lower = true;\n            }\n        }\n    }\n    return\
    \ is_lower ^ is_upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpvnjgcl89.rs:23:27\n   |\n23 |          \
    \   if first_char.is_uppercase() {\n   |                           ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error[E0599]: no method named `is_lowercase` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpvnjgcl89.rs:25:34\n   |\n25 |             } else\
    \ if first_char.is_lowercase() {\n   |                                  ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower = false;\n    let mut is_upper = false;\n\
    \    for (key, _) in dict {\n        if key.is_lowercase() {\n            is_lower\
    \ = true;\n        } else if key.is_uppercase() {\n            is_upper = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    !(is_lower\
    \ && is_upper)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp15e12q6x.rs:24:16\n   |\n24 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmp15e12q6x.rs:26:23\n\
    \   |\n26 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_upper = true;\n    let mut\
    \ all_lower = true;\n    for (key, _value) in dict {\n        let key_chars: Vec<char>\
    \ = key.chars().collect();\n        for c in key_chars {\n            if c.is_ascii_lowercase()\
    \ {\n                all_upper = false;\n            } else if c.is_ascii_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n    }\n    return (all_upper || all_lower)\
    \ && !dict.is_empty();\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmpjzmzc8t2.rs:32:41\n\
    \    |\n17  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n20  |     for (key,\
    \ _value) in dict {\n    |                          ---- `dict` moved due to this\
    \ implicit call to `.into_iter()`\n...\n32  |     return (all_upper || all_lower)\
    \ && !dict.is_empty();\n    |                                         ^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `dict`\nhelp: consider iterating over a slice\
    \ of the `HashMap<String, String>`'s content to avoid moving into the `for` loop\n\
    \    |\n20  |     for (key, _value) in &dict {\n    |                        \
    \  +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Write function code\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3i_gg1qe.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    for key in dict.keys() {\n        let key_lower = key.to_lowercase();\n\
    \        let key_upper = key.to_uppercase();\n        if key != &key_lower &&\
    \ key != &key_upper {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvjtoxwu_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_flag = false;\n    let\
    \ mut upper_flag = false;\n    for key in dict.keys() {\n        if let Some(ch)\
    \ = key.chars().next() {\n            if ch.is_ascii_lowercase() {\n         \
    \       lower_flag = true;\n            } else if ch.is_ascii_uppercase() {\n\
    \                upper_flag = true;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    !(lower_flag && upper_flag)\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_9gj0ab.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcg7uti7r.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4xsy1boa.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010780
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().map(|s| s.chars().next().unwrap().is_lowercase()).all(|b|\
    \ b)\n        || dict.keys().map(|s| s.chars().next().unwrap().is_uppercase()).all(|b|\
    \ b)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn1528z81.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() { return false }\n\
    \    let mut uppercase = true;\n    let mut lowercase = true;\n    for key in\
    \ dict.keys() {\n        if key.is_empty() { continue }\n        uppercase = uppercase\
    \ && key.chars().all(|c| c.is_uppercase());\n        lowercase = lowercase &&\
    \ key.chars().all(|c| c.is_lowercase());\n    }\n    uppercase || lowercase\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut upper_keys = true;\n    let\
    \ mut lower_keys = true;\n    if dict.len() == 0 {\n        return false;\n  \
    \  }\n    for key in dict.keys() {\n        if key.is_ascii_uppercase() {\n  \
    \          lower_keys = false;\n        } else if key.is_ascii_lowercase() {\n\
    \            upper_keys = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    return upper_keys || lower_keys;\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp0f3t_gp3.rs:24:16\n   |\n24 |\
    \         if key.is_ascii_uppercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp0f3t_gp3.rs:26:23\n   |\n26 |         }\
    \ else if key.is_ascii_lowercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // your code here\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n\n    let mut is_lower = dict.keys().nth(0).unwrap().is_lowercase();\n\
    \    for k in dict.keys() {\n        if k.is_lowercase() != is_lower {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp22dh2tgy.rs:23:52\n   |\n23 |     let mut\
    \ is_lower = dict.keys().nth(0).unwrap().is_lowercase();\n   |               \
    \                                     ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmp22dh2tgy.rs:25:14\n\
    \   |\n25 |         if k.is_lowercase() != is_lower {\n   |              ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower_case = true;\n    let mut is_upper_case\
    \ = true;\n    for (key, _value) in dict {\n        is_lower_case = is_lower_case\
    \ && key.chars().all(|x| x.is_lowercase());\n        is_upper_case = is_upper_case\
    \ && key.chars().all(|x| x.is_uppercase());\n    }\n    is_lower_case || is_upper_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower_count = 0;\n    let mut\
    \ upper_count = 0;\n    for key in dict.keys() {\n        if key.to_uppercase()\
    \ == *key {\n            upper_count += 1;\n        } else if key.to_lowercase()\
    \ == *key {\n            lower_count += 1;\n        }\n    }\n    upper_count\
    \ == 0 || lower_count == 0\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplqsfoysl.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if !key.is_empty() {\n\
    \            if key.to_lowercase() != key {\n                all_lower = false;\n\
    \            }\n            if key.to_uppercase() != key {\n                all_upper\
    \ = false;\n            }\n        }\n    }\n    all_lower || all_upper\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4zyf2oeg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut uppers: i32 = 0;\n    let mut lowers: i32 = 0;\n\
    \    for (key, _) in dict {\n        if key.chars().all(char::is_uppercase) {\n\
    \            uppers += 1;\n        } else if key.chars().all(char::is_lowercase)\
    \ {\n            lowers += 1;\n        } else {\n            return false;\n \
    \       }\n    }\n    if uppers == 0 || lowers == 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Implement this function\n \
    \   unimplemented!();\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2hhyh543.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\ttrue\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprlavmube.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut is_all_lower: bool = true;\n    let mut is_all_upper:\
    \ bool = true;\n\n    for key in dict.keys() {\n        if !key.chars().all(|c|\
    \ c.is_lowercase()) {\n            is_all_lower = false;\n        }\n\n      \
    \  if !key.chars().all(|c| c.is_uppercase()) {\n            is_all_upper = false;\n\
    \        }\n    }\n\n    if is_all_lower || is_all_upper {\n        return true;\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let first_key = dict.keys().nth(0).unwrap();\n    let first_key_str\
    \ = &first_key[..];\n    let mut case = if first_key_str.is_ascii_lowercase()\
    \ {\n        true\n    } else if first_key_str.is_ascii_uppercase() {\n      \
    \  false\n    } else {\n        return false;\n    };\n    for (key, _) in dict.iter()\
    \ {\n        let key_str = &key[..];\n        if key_str.is_ascii_lowercase()\
    \ && !case {\n            return false;\n        } else if key_str.is_ascii_uppercase()\
    \ && case {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpbmz1_rre.rs:23:37\n   |\n23 |   \
    \  let mut case = if first_key_str.is_ascii_lowercase() {\n   |              \
    \                       ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpbmz1_rre.rs:25:29\n\
    \   |\n25 |     } else if first_key_str.is_ascii_uppercase() {\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror[E0599]: no method named `is_ascii_lowercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpbmz1_rre.rs:32:20\n\
    \   |\n32 |         if key_str.is_ascii_lowercase() && !case {\n   |         \
    \           ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpbmz1_rre.rs:34:27\n\
    \   |\n34 |         } else if key_str.is_ascii_uppercase() && case {\n   |   \
    \                        ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // This function will return true if\
    \ all keys are in upper case or\n    // all keys are in lower case, else it will\
    \ return false.\n    // \n    // HashMap::new() will create an empty HashMap.\n\
    \    // dict.keys() will return an Iterator over HashMap keys.\n    // String::to_uppercase()\
    \ will convert a String to upper case.\n    // String::to_lowercase() will convert\
    \ a String to lower case.\n    // dict.keys().all(|x| x.is_uppercase()) && dict.keys().all(|x|\
    \ x.is_lowercase())\n    // will return true if all keys are in upper case and\
    \ all keys are in lower case.\n    // dict.keys().all(|x| x.is_uppercase()) will\
    \ return true if all keys are in upper case.\n    // dict.keys().all(|x| x.is_lowercase())\
    \ will return true if all keys are in lower case.\n    // dict.is_empty() will\
    \ return true if the given HashMap is empty.\n    dict.is_empty() || dict.keys().all(|x|\
    \ x.is_uppercase()) && dict.keys().all(|x| x.is_lowercase())\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmprj6n1vn3.rs:30:46\n   |\n30 |     dict.is_empty()\
    \ || dict.keys().all(|x| x.is_uppercase()) && dict.keys().all(|x| x.is_lowercase())\n\
    \   |                                              ^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_uppercase`\n\nerror[E0599]:\
    \ no method named `is_lowercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmprj6n1vn3.rs:30:87\n   |\n30 |     dict.is_empty() || dict.keys().all(|x|\
    \ x.is_uppercase()) && dict.keys().all(|x| x.is_lowercase())\n   |           \
    \                                                                            ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcnag6z2b.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut is_lower_case = None;\n    for (key, _value) in dict\
    \ {\n        let is_lower = key.to_lowercase() == key;\n        match is_lower_case\
    \ {\n            None => is_lower_case = Some(is_lower),\n            Some(lower)\
    \ => {\n                if lower != is_lower {\n                    return false;\n\
    \                }\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfnmhzfzy.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Unimplemented!()\n    dict.keys().all(|k|\
    \ k.is_ascii_lowercase()) || dict.keys().all(|k| k.is_ascii_uppercase())\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp0j3eyaad.rs:19:27\n   |\n19 |\
    \     dict.keys().all(|k| k.is_ascii_lowercase()) || dict.keys().all(|k| k.is_ascii_uppercase())\n\
    \   |                           ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method\
    \ named `is_ascii_uppercase` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmp0j3eyaad.rs:19:74\n   |\n19 |     dict.keys().all(|k| k.is_ascii_lowercase())\
    \ || dict.keys().all(|k| k.is_ascii_uppercase())\n   |                       \
    \                                                   ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: your code here\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6ksodx9b.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_keys_lower = true;\n   \
    \ let mut all_keys_upper = true;\n    for key in dict.keys() {\n        if key.is_empty()\
    \ {\n            return false;\n        }\n        if key.chars().next().unwrap().is_ascii_lowercase()\
    \ {\n            all_keys_upper = false;\n        } else if key.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n            all_keys_lower = false;\n        } else {\n            return\
    \ false;\n        }\n    }\n    all_keys_lower || all_keys_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_176i79_.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 { return false; }\n\
    \    let mut is_lower = false;\n    let mut is_upper = false;\n    for (key, _)\
    \ in dict.iter() {\n        if key.len() == 0 { continue; }\n        if is_lower\
    \ && is_upper { return false; }\n        let key_vec: Vec<_> = key.chars().collect();\n\
    \        let first_char = key_vec[0];\n        if first_char.is_lowercase() {\n\
    \            is_lower = true;\n        } else if first_char.is_uppercase() {\n\
    \            is_upper = true;\n        } else {\n            return false;\n \
    \       }\n    }\n    if is_lower && is_upper { return false; }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvpxvbarb.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if key.to_uppercase()\
    \ != key {\n            all_upper = false;\n        }\n        if key.to_lowercase()\
    \ != key {\n            all_lower = false;\n        }\n    }\n    all_lower ||\
    \ all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2an01mwv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\tdict.keys().all(|k| k.chars().all(|c|\
    \ c.is_lowercase())) ||\n\tdict.keys().all(|k| k.chars().all(|c| c.is_uppercase()))\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgn9vq7v2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Checks if the HashMap is empty.\n\
    \    if dict.is_empty() {\n        return false;\n    }\n\n    // Checks if all\
    \ keys are lower case or all keys are upper case.\n    for key in dict.keys()\
    \ {\n        if key.chars().any(|x| x.is_lowercase()) {\n            if key.chars().any(|x|\
    \ x.is_uppercase()) {\n                return false;\n            }\n        }\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnil7rttx.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut key_set: HashSet<char> = HashSet::new();\n\
    \    for key in dict.keys() {\n        let key = key.to_lowercase();\n       \
    \ for ch in key.chars() {\n            key_set.insert(ch);\n        }\n    }\n\
    \    // println!(\"{:?}\", key_set);\n    if key_set.len() == 1 {\n        if\
    \ key_set.contains(&'a') {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnb84chjc.rs:18:22\n\
    \   |\n18 |     let mut key_set: HashSet<char> = HashSet::new();\n   |       \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnb84chjc.rs:18:38\n\
    \   |\n18 |     let mut key_set: HashSet<char> = HashSet::new();\n   |       \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_upper = true;\n    let mut all_lower = true;\n\
    \    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            all_upper =\
    \ false;\n        }\n    }\n    if all_upper || all_lower {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbk8nibtm.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // YOUR CODE HERE\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwgo9vzoe.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010782
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \n    for key in dict.keys() {\n        if !key.chars().all(|c| c.is_lowercase())\
    \ {\n            all_lower = false;\n        }\n        if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n            all_upper = false;\n        }\n    }\n\n  \
    \  all_lower || all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut all_lower: bool = true;\n  \
    \  let mut all_upper: bool = true;\n    for key in dict.keys() {\n        let\
    \ key_str: &str = key.as_str();\n        if !key_str.is_ascii() {\n          \
    \  return false;\n        }\n        if !key_str.is_ascii_uppercase() {\n    \
    \        all_upper = false;\n        }\n        if !key_str.is_ascii_lowercase()\
    \ {\n            all_lower = false;\n        }\n    }\n    all_lower || all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpj0fr7wvb.rs:25:21\n   |\n25 |   \
    \      if !key_str.is_ascii_uppercase() {\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpj0fr7wvb.rs:28:21\n   |\n28 |         if\
    \ !key_str.is_ascii_lowercase() {\n   |                     ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            all_lower = false;\n        } else {\n            all_upper =\
    \ false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp66racmkc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgqkldqpc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO - you fill in here.\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpadgx0y0h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut lower = false;\n    let mut\
    \ upper = false;\n    for (key, _) in dict {\n        if key.to_uppercase() ==\
    \ key {\n            upper = true;\n        } else if key.to_lowercase() == key\
    \ {\n            lower = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    if (lower && upper) || (!lower && !upper) {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut map_copy = dict.clone();\n \
    \   let mut val = map_copy.remove(&\"a\".to_string());\n    val.is_some()\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqcanysfu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // Write your code here\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_7ni7sz3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut lower_case_set = HashSet::new();\n    let mut upper_case_set\
    \ = HashSet::new();\n    for (key, _value) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            upper_case_set.insert(key);\n        } else {\n            lower_case_set.insert(key);\n\
    \        }\n    }\n    if lower_case_set.is_empty() {\n        return true;\n\
    \    } else if upper_case_set.is_empty() {\n        return true;\n    } else {\n\
    \        return false;\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyn_s5wua.rs:21:30\n   |\n21 |     let mut lower_case_set = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpyn_s5wua.rs:22:30\n   |\n22 |     let mut upper_case_set = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_lower = true;\n    let mut\
    \ is_upper = true;\n    for key in dict.keys() {\n        is_lower = is_lower\
    \ && key.chars().all(|c| c.is_lowercase());\n        is_upper = is_upper && key.chars().all(|c|\
    \ c.is_uppercase());\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfpsu3b_y.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let mut is_first_iter = true;\n    let\
    \ mut is_all_caps = false;\n    for (_, v) in dict {\n        if is_first_iter\
    \ {\n            let first_char = v.chars().next().unwrap();\n            is_all_caps\
    \ = first_char.is_uppercase();\n            is_first_iter = false;\n        }\n\
    \        if !v.chars().all(|x| x.is_uppercase() || x.is_lowercase()) {\n     \
    \       return false;\n        }\n        if !is_all_caps && !v.chars().all(|x|\
    \ x.is_lowercase()) {\n            return false;\n        }\n        if is_all_caps\
    \ && !v.chars().all(|x| x.is_uppercase()) {\n            return false;\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpycibwjbn.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 { return false; }\n\
    \    let mut answer = true;\n    let mut first_key_is_lower = false;\n    let\
    \ mut first_key_is_upper = false;\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for (key, _) in dict.iter() {\n        if !key.is_ascii()\
    \ {\n            answer = false;\n            break;\n        } else {\n     \
    \       if !first_key_is_lower && !first_key_is_upper {\n                is_lower\
    \ = key.is_lowercase();\n                is_upper = key.is_uppercase();\n    \
    \            if is_lower {\n                    first_key_is_lower = true;\n \
    \               } else if is_upper {\n                    first_key_is_upper =\
    \ true;\n                } else {\n                    answer = false;\n     \
    \               break;\n                }\n            } else {\n            \
    \    if (key.is_lowercase() && !is_lower) || (key.is_uppercase() && !is_upper)\
    \ {\n                    answer = false;\n                    break;\n       \
    \         }\n            }\n        }\n    }\n    answer\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpfsha99tc.rs:30:32\n   |\n30 |          \
    \       is_lower = key.is_lowercase();\n   |                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpfsha99tc.rs:31:32\n   |\n31 |             \
    \    is_upper = key.is_uppercase();\n   |                                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error[E0599]: no method named `is_lowercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpfsha99tc.rs:41:25\n   |\n41 |             \
    \    if (key.is_lowercase() && !is_lower) || (key.is_uppercase() && !is_upper)\
    \ {\n   |                         ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpfsha99tc.rs:41:62\n\
    \   |\n41 |                 if (key.is_lowercase() && !is_lower) || (key.is_uppercase()\
    \ && !is_upper) {\n   |                                                      \
    \        ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    dict.keys().map(|key| key.chars().next().unwrap()).collect::<Vec<char>>().into_iter().all(|c|\
    \ c.is_uppercase()) || dict.keys().map(|key| key.chars().next().unwrap()).collect::<Vec<char>>().into_iter().all(|c|\
    \ c.is_lowercase())\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdy2dn6qv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    // TODO: Find out why HashMap doesn't\
    \ implement IntoIterator\n    let mut case = None;\n    for (key, _) in dict {\n\
    \        if case.is_none() {\n            case = Some(key.is_lowercase());\n \
    \       } else if key.is_lowercase() != case.unwrap() {\n            return false;\n\
    \        }\n    }\n    case.is_some()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpsobjry_2.rs:22:29\n   |\n22 |          \
    \   case = Some(key.is_lowercase());\n   |                             ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_lowercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsobjry_2.rs:23:23\n   |\n23 |         } else if\
    \ key.is_lowercase() != case.unwrap() {\n   |                       ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut lower_count = 0;\n    let mut upper_count = 0;\n\
    \n    for key in dict.keys() {\n        if key.to_lowercase() == *key {\n    \
    \        lower_count += 1;\n        } else if key.to_uppercase() == *key {\n \
    \           upper_count += 1;\n        }\n    }\n\n    if lower_count == dict.len()\
    \ || upper_count == dict.len() {\n        return true;\n    }\n\n    false\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpidy8_x52.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvh80d5e3.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n    let uppercase\
    \ = keys.all(|k| k.chars().all(|c| c.is_uppercase()));\n    let lowercase = keys.all(|k|\
    \ k.chars().all(|c| c.is_lowercase()));\n    !keys.is_empty() && (uppercase ||\
    \ lowercase)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'exact_size_is_empty'\n \
    \ --> /tmp/tmp2xk03qg1.rs:21:11\n   |\n21 |     !keys.is_empty() && (uppercase\
    \ || lowercase)\n   |           ^^^^^^^^\n   |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n    if dict.len() == 0 {\n        return\
    \ false;\n    }\n    // return false if the keys are not all strings\n    let\
    \ keys: Vec<&String> = dict.keys().collect();\n    if keys.iter().any(|x| !x.is_ascii())\
    \ {\n        return false;\n    }\n    // return false if any key is not all lower\
    \ case\n    if keys.iter().any(|x| !x.is_ascii_lowercase()) {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&&String` in the current scope\n  --> /tmp/tmp2dqkul9g.rs:27:31\n   |\n27 |\
    \     if keys.iter().any(|x| !x.is_ascii_lowercase()) {\n   |                \
    \               ^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_lowercase`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a HashMap, return true if\
    \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
    \ else return false.\n/// The function should return false is the given HashMap\
    \ is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"),\
    \ String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"\
    a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>>\
    \ check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\"\
    )), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict:\
    \ HashMap<String, String>) -> bool {\n\tlet mut lower = true;\n\tlet mut upper\
    \ = true;\n\tfor key in dict.keys() {\n\t\tif key.chars().next().unwrap().is_lowercase()\
    \ {\n\t\t\tupper = false;\n\t\t} else if key.chars().next().unwrap().is_uppercase()\
    \ {\n\t\t\tlower = false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ lower || upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp32xx2e_6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010782
