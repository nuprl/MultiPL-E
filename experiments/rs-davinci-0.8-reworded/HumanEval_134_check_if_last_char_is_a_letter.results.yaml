language: rs
name: HumanEval_134_check_if_last_char_is_a_letter
results:
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  txt.split_whitespace().last().unwrap().chars().last().unwrap().is_alphabetic()\n\
    }\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp74vu2jkp.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  let txt = txt.trim();\n    if txt.is_empty() {\n        return false;\n   \
    \ }\n    txt.chars().last().unwrap().is_alphabetic() && !txt.contains(' ')\n}\n\
    \nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps_bswe2k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  let mut current_word = false;\n    let mut previous_character = ' ';\n    let\
    \ mut current_character;\n    for (index, character) in txt.chars().enumerate()\
    \ {\n        current_character = character;\n        if current_character == '\
    \ ' {\n            if previous_character.is_alphabetic() && current_word == false\
    \ {\n                return true;\n            }\n            current_word = false;\n\
    \        } else {\n            current_word = true;\n        }\n        if index\
    \ == txt.len() - 1 {\n            if current_character.is_alphabetic() && current_word\
    \ == false {\n                return true;\n            }\n        }\n       \
    \ previous_character = current_character;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz2yovwxk.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  txt.chars().last().unwrap().is_alphabetic() && !txt.contains(\" \")\n}\n\n\
    fn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgob_kx5l.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  for (i, c) in txt.chars().enumerate().rev() {\n        if !c.is_alphabetic()\
    \ {\n            if i == 0 {\n                return false;\n            } else\
    \ {\n                return txt.chars().rev().nth(i - 1).unwrap().is_alphabetic();\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpnapvwayj.rs:15:43\n   |\n15 |     for (i, c) in txt.chars().enumerate().rev()\
    \ {\n   |                                           ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpnapvwayj.rs:15:19\n    |\n15  |     for (i, c) in txt.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  let mut vec: Vec<char> = txt.chars().collect();\n    let mut first = true;\n\
    \    let mut last_char: char = ' ';\n    while let Some(c) = vec.pop() {\n   \
    \     if first {\n            last_char = c;\n            first = false;\n   \
    \     } else if c == ' ' {\n            break;\n        }\n    }\n    if last_char\
    \ == ' ' {\n        return false;\n    }\n    last_char.is_alphabetic()\n}\n\n\
    fn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4q6actlm.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  if txt.is_empty() {\n        return false;\n    }\n    let mut vec = txt.chars().collect::<Vec<char>>();\n\
    \    let c = vec.pop().unwrap();\n    match c {\n        'a' | 'b' | 'c' | 'd'\
    \ | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o'\n        |\
    \ 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => true,\n \
    \       _ => false,\n    }\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgtum7ll4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!(\"{}\", txt)\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: apple'', /tmp/tmpvs5320iy.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  if txt.len() > 0 {\n        let txt_vec: Vec<char> = txt.chars().collect();\n\
    \        let last_char = txt_vec[txt.len() - 1];\n        last_char.is_alphabetic()\
    \ && txt.chars().rev().next().unwrap().is_whitespace()\n    } else {\n       \
    \ false\n    }\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppslkbw6k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  let txt = txt.trim();\n    if txt.is_empty() {\n        return false;\n   \
    \ }\n    let last_char = txt.chars().last().unwrap();\n    if last_char.is_alphabetic()\
    \ {\n        return !txt.contains(&last_char.to_string());\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk7983w39.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  // TODO: Make this return the correct value\n    true\n}\n\nfn main() {\n \
    \   let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgge6ify8.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  txt.chars().rev().skip_while(|&c| c.is_whitespace()).next().unwrap().is_alphabetic()\n\
    }\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxje7up1t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  // YOUR CODE HERE\n    if txt.len() == 0 {\n        return false;\n    }\n\
    \    let mut check = true;\n    for c in txt.chars() {\n        if c == ' ' {\n\
    \            check = true;\n        } else if check {\n            if c.is_alphabetic()\
    \ {\n                return true;\n            }\n            check = false;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbv4ylcox.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n\
    \    assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
    \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
    Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie\
    \ 1\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpw3s6u9o_.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// Create a function that returns true if the last character\n/// of\
    \ a given string is an alphabetical character and is not\n/// a part of a word,\
    \ and false otherwise.\n/// Note: \"word\" is a group of characters separated\
    \ by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\
    \"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n  \
    \  if txt.len() == 0 {\n        return false;\n    }\n    for _ in 0..txt.len()\
    \ {\n        if txt.ends_with(' ') {\n            txt.trim_end_matches(' ');\n\
    \        }\n    }\n    let ch = txt.chars().last().unwrap();\n    ch.is_alphabetic()\n\
    }\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n    assert_eq!(candidate(String::from(\"\
    apple\")), false);\n    assert_eq!(candidate(String::from(\"apple pi e\")), true);\n\
    \    assert_eq!(candidate(String::from(\"eeeee\")), false);\n    assert_eq!(candidate(String::from(\"\
    A\")), true);\n    assert_eq!(candidate(String::from(\"Pumpkin pie \")), false);\n\
    \    assert_eq!(candidate(String::from(\"Pumpkin pie 1\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"eeeee e \")), false);\n\
    \    assert_eq!(candidate(String::from(\"apple pie\")), false);\n    assert_eq!(candidate(String::from(\"\
    apple pi e \")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnlnbc14n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
