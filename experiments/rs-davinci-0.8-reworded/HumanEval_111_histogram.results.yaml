name: HumanEval_111_histogram
language: rs
results:
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for c in test.split_whitespace() {\n\
    \        let counter = map.entry(c.to_string()).or_insert(0);\n        *counter\
    \ += 1;\n    }\n    map\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmps9tc0s58.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut output: HashMap<String, isize> = HashMap::new();\n    for x in\
    \ test.split_whitespace() {\n        let count = output.entry(x.to_string()).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut max_count = 0;\n    for value in output.values()\
    \ {\n        if *value > max_count {\n            max_count = *value;\n      \
    \  }\n    }\n    let mut result: HashMap<String, isize> = HashMap::new();\n  \
    \  for (key, value) in output {\n        if value == max_count {\n           \
    \ result.insert(key, value);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut res: HashMap<String, isize> = HashMap::new();\n    for item in\
    \ test.split_whitespace() {\n        let counter = res.entry(item.to_string()).or_insert(0);\n\
    \        *counter += 1;\n    }\n    let mut max_count = 0;\n    for (_, value)\
    \ in res.iter() {\n        if *value > max_count {\n            max_count = *value;\n\
    \        }\n    }\n    res.retain(|_, val| *val == max_count);\n    res\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let letters: Vec<_> = test.split(\" \").collect();\n    let mut table:\
    \ HashMap<String, isize> = HashMap::new();\n    for letter in letters {\n    \
    \    let count = table.entry(letter.to_string()).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let most = table.values().max().unwrap();\n    let mut result:\
    \ HashMap<String, isize> = HashMap::new();\n    for (letter, count) in table {\n\
    \        if count == *most {\n            result.insert(letter, count);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `table` because it is borrowed\n  -->\
    \ /tmp/tmpt8fc7hfe.rs:26:28\n   |\n24 |     let most = table.values().max().unwrap();\n\
    \   |                -------------- borrow of `table` occurs here\n25 |     let\
    \ mut result: HashMap<String, isize> = HashMap::new();\n26 |     for (letter,\
    \ count) in table {\n   |                            ^^^^^ move out of `table`\
    \ occurs here\n27 |         if count == *most {\n   |                     -----\
    \ borrow later used here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // put each entry in a hashmap, then filter to the ones which have the\
    \ highest value\n    // unwrap is safe because we're iterating over a single value\n\
    \    let mut map = hashmap!(test.split_whitespace().map(|x| (x.to_string(), 0)).collect::<HashMap<String,\
    \ isize>>());\n    for x in test.split_whitespace() {\n        map.entry(x.to_string()).and_modify(|e|\
    \ *e += 1);\n    }\n    let max = map.values().max().unwrap();\n    map.iter().filter(|(_k,\
    \ v)| *v == max).map(|(k, v)| (k.to_string(), *v)).collect()\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `hashmap` in this scope\n  --> /tmp/tmpp07e0z20.rs:20:19\n\
    \   |\n20 |     let mut map = hashmap!(test.split_whitespace().map(|x| (x.to_string(),\
    \ 0)).collect::<HashMap<String, isize>>());\n   |                   ^^^^^^^\n\n\
    error: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut hm: HashMap<String, isize> = HashMap::new();\n    for c in test.split(\"\
    \ \") {\n        let counter = hm.entry(c.to_string()).or_insert(0);\n       \
    \ *counter += 1;\n    }\n    hm\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \"c\": 1}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpowg03w7q.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut freq = HashMap::new();\n    let mut max = 0;\n    for c in test.split(\"\
    \ \") {\n        let count = freq.entry(c.to_string()).or_insert(0);\n       \
    \ *count += 1;\n        if *count > max {\n            max = *count;\n       \
    \ }\n    }\n    let mut results = HashMap::new();\n    for (key, value) in freq\
    \ {\n        if value == max {\n            results.insert(key, value);\n    \
    \    }\n    }\n    results\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmp02eip64_.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // Complete the function!\n    let mut hm: HashMap<String, isize> = HashMap::new();\n\
    \    let mut max_val: isize = 0;\n    for l in test.split(\" \") {\n        *hm.entry(l.to_string()).or_insert(0)\
    \ += 1;\n        if *hm.get(l).unwrap() > max_val {\n            max_val = *hm.get(l).unwrap();\n\
    \        }\n    }\n    let mut hm_result: HashMap<String, isize> = HashMap::new();\n\
    \    for (key, val) in hm {\n        if val == max_val {\n            hm_result.insert(key,\
    \ val);\n        }\n    }\n    hm_result\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmpunn2qe4v.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for word in test.split_whitespace()\
    \ {\n        let count = histogram.entry(word.to_string()).or_insert(0);\n   \
    \     *count += 1;\n    }\n    let mut max_count: isize = 0;\n    for (_key, value)\
    \ in &histogram {\n        if *value > max_count {\n            max_count = *value;\n\
    \        }\n    }\n    let mut result = HashMap::new();\n    for (key, value)\
    \ in &histogram {\n        if *value == max_count {\n            result.insert(key.to_string(),\
    \ *value);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    for c in test.split_whitespace() {\n\
    \        let counter = map.entry(c.to_string()).or_insert(0);\n        *counter\
    \ += 1;\n    }\n    let max_value = match map.values().max() {\n        Some(max)\
    \ => *max,\n        None => 0,\n    };\n    let mut res: HashMap<String, isize>\
    \ = HashMap::new();\n    for (k, v) in map {\n        if v == max_value {\n  \
    \          res.insert(k, v);\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuabbrozz.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut hist = HashMap::new();\n    for c in test.split_whitespace()\
    \ {\n        hist.entry(c.to_string()).and_modify(|count| *count += 1).or_insert(1);\n\
    \    }\n    let mut max = 0;\n    let mut result = HashMap::new();\n    for (key,\
    \ val) in hist.iter() {\n        if val > &max {\n            max = *val;\n  \
    \          result.clear();\n            result.insert(key.to_string(), *val);\n\
    \        } else if val == &max {\n            result.insert(key.to_string(), *val);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    if test.is_empty() {\n        return HashMap::new();\n    }\n    let\
    \ mut map = HashMap::new();\n    let mut max = 0;\n    let words = test.split_whitespace();\n\
    \    for w in words {\n        let word = String::from(w);\n        let count\
    \ = map.entry(word).or_insert(0);\n        *count += 1;\n        if *count > max\
    \ {\n            max = *count;\n        }\n    }\n    let mut to_return = HashMap::new();\n\
    \    for (k, v) in map {\n        if v == max {\n            to_return.insert(k,\
    \ v);\n        }\n    }\n    to_return\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let words = test.split_whitespace();\n\
    \    for i in words {\n        let count = map.entry(i.to_string()).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut filtered_map = HashMap::new();\n   \
    \ let mut high = 0;\n    for (key, val) in map.iter() {\n        if val > &high\
    \ {\n            high = *val;\n        }\n    }\n    for (key, val) in map.iter()\
    \ {\n        if val == &high {\n            filtered_map.insert(key.to_string(),\
    \ *val);\n        }\n    }\n    filtered_map\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    // let mut hm: HashMap<String, isize> = HashMap::new();\n    // let mut\
    \ max: isize = 0;\n    // let mut max_keys: Vec<String> = Vec::new();\n    //\
    \ for word in test.split_whitespace() {\n    //     let word = String::from(word);\n\
    \    //     let count = hm.entry(word).or_insert(0);\n    //     *count += 1;\n\
    \    //     if *count > max {\n    //         max = *count;\n    //         max_keys\
    \ = vec![word];\n    //     } else if *count == max {\n    //         max_keys.push(word);\n\
    \    //     }\n    // }\n    // let mut result: HashMap<String, isize> = HashMap::new();\n\
    \    // for key in max_keys {\n    //     result.insert(key, max);\n    // }\n\
    \    // result\n    let mut hm: HashMap<String, isize> = HashMap::new();\n   \
    \ let mut max: isize = 0;\n    for word in test.split_whitespace() {\n       \
    \ let word = String::from(word);\n        let count = hm.entry(word).or_insert(0);\n\
    \        *count += 1;\n        if *count > max {\n            max = *count;\n\
    \        }\n    }\n    hm.iter().filter(|&(_, v)| *v == max).map(|(k, v)| (k.clone(),\
    \ *v)).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut hm: HashMap<String, isize> = HashMap::new();\n    for letter\
    \ in test.split_whitespace() {\n        let count = hm.entry(letter.to_string()).or_insert(0);\n\
    \        *count += 1;\n    }\n    hm\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2, \"a\": 2, \"c\": 1}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpf6ypvf_c.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut map = HashMap::new();\n    let mut max = 0;\n    let words =\
    \ test.split_whitespace();\n    for word in words {\n        let count = map.entry(word.to_string()).or_insert(0);\n\
    \        *count += 1;\n        if *count > max {\n            max = *count;\n\
    \        }\n    }\n    let mut result = HashMap::new();\n    for (key, val) in\
    \ map {\n        if val == max {\n            result.insert(key, val);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let words: Vec<&str> = test.split(\" \").collect();\n    let mut h =\
    \ HashMap::new();\n    let mut max = 0;\n    for word in words {\n        let\
    \ counter = h.entry(word.to_string()).or_insert(0);\n        *counter += 1;\n\
    \        if *counter > max {\n            max = *counter;\n        }\n    }\n\
    \    let mut h2 = HashMap::new();\n    for (k, v) in h {\n        if v == max\
    \ {\n            h2.insert(k, v);\n        }\n    }\n    h2\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmpmb4cs0r8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    unimplemented!(\"I am TODO: write me!\");\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented: I am TODO: write me!', /tmp/tmp38b3aqvq.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a HashMap\n/// of the letter with the most\
    \ repetition and containing the corresponding count.\n/// If several letters have\
    \ the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut h: HashMap<String, isize> = HashMap::new();\n    for word in\
    \ test.split_whitespace() {\n        *h.entry(word.to_string()).or_insert(0) +=\
    \ 1;\n    }\n    h\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"c\": 1, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpdiagc8x4.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
