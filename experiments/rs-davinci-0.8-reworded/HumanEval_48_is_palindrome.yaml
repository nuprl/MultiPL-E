name: HumanEval_48_is_palindrome
language: rs
prompt: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
  \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
  \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
  zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
  \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
  aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n \
  \   assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
  xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
  }\n"
completions: ["    let text_vec: Vec<char> = text.chars().collect();\n    for (i,\
    \ c) in text_vec.iter().enumerate() {\n        if *c != text_vec[text_vec.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true", '    text.chars().eq(text.chars().rev())',
  "    let text = text.to_lowercase();\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)", "    let mut chars = text.chars();\n    let mut reversed_chars\
    \ = text.chars().rev();\n    loop {\n        let (f, r) = match (chars.next(),\
    \ reversed_chars.next()) {\n            (Some(f), Some(r)) => (f, r),\n      \
    \      _ => break,\n        };\n        if f != r {\n            return false;\n\
    \        }\n    }\n    true", "    let mut i = 0;\n    let mut j = text.len()\
    \ - 1;\n    let text_chars: Vec<char> = text.chars().collect();\n    while i <\
    \ j {\n        if text_chars[i] != text_chars[j] {\n            return false;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    true", "    let text\
    \ = text.to_lowercase();\n    let mut text_chars = text.chars();\n    loop {\n\
    \        match (text_chars.next(), text_chars.next_back()) {\n            (Some(a),\
    \ Some(b)) => {\n                if a != b {\n                    return false;\n\
    \                }\n            }\n            (None, None) => {\n           \
    \     return true;\n            }\n            _ => {\n                return\
    \ false;\n            }\n        }\n    }", "    text.len() <= 1 ||\n    (text.chars().next().unwrap()\
    \ == text.chars().last().unwrap() &&\n     is_palindrome(text[1..text.len() -\
    \ 1].to_string()))", "    let len = text.len();\n    let mid = len / 2;\n    let\
    \ forward: String = text.chars().take(mid).collect();\n    let backward: String\
    \ = text.chars().rev().take(mid).collect();\n    forward == backward", "    let\
    \ n = text.len();\n    if n == 0 {\n        return true;\n    }\n    let mut i\
    \ = 0;\n    let mut j = n - 1;\n    while i < j {\n        if text.chars().nth(i)\
    \ != text.chars().nth(j) {\n            return false;\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    true", '    text.chars().rev().eq(text.chars())',
  '    unimplemented!()', "    let chars: Vec<char> = text.chars().collect();\n  \
    \  let len = chars.len();\n    for i in 0..len / 2 {\n        if chars[i] != chars[len\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true", "    //\
    \ split string to Vec<char>\n    let chars: Vec<char> = text.chars().collect();\n\
    \    let len = chars.len();\n    // check equality of first and last char\n  \
    \  // if not equal - return false\n    if len == 0 || len == 1 {\n        return\
    \ true;\n    } else if chars[0] != chars[len - 1] {\n        return false;\n \
    \   }\n    // recursively check equality of first and last char\n    // of the\
    \ rest of string\n    is_palindrome(chars[1..len - 1].iter().collect())", "  \
    \  let text_len = text.len();\n    if text_len <= 1 {\n        return true;\n\
    \    }\n    if text.chars().nth(0).unwrap() != text.chars().nth(text_len - 1).unwrap()\
    \ {\n        return false;\n    }\n    return is_palindrome(text[1..text_len -\
    \ 1].to_string());", "    let mut chars = text.chars();\n    for _ in 0..text.len()\
    \ / 2 {\n        let (first, second) = (chars.next(), chars.next_back());\n  \
    \      if first != second {\n            return false;\n        }\n    }\n   \
    \ true", "    let length = text.len();\n    let half_length = length / 2;\n  \
    \  text.chars().take(half_length).eq(text.chars().rev().take(half_length))", '    text.chars().zip(text.chars().rev()).all(|(a,
    b)| a == b)', "    let mut chars = text.chars();\n    let mut v = Vec::new();\n\
    \    while let Some(c) = chars.next() {\n        v.push(c);\n    }\n    let v\
    \ = v;\n    for i in 0..v.len() {\n        if v[i] != v[v.len() - i - 1] {\n \
    \           return false;\n        }\n    }\n    true", "    // TODO\n    true",
  '    text.chars().zip(text.chars().rev()).all(|(l, r)| l == r)']
stop_tokens:
- "\n}"
