language: rs
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number.fract() * 10_f64).round() / 10_f64\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.3`,\n right: `0.25`', /tmp/tmp_nzd24y7.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.trunc() {\n        num if num > number => num - 1.0,\n\
    \        num => num,\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpgkn35jai.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return (number as i64) as f64;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp_y4alghv.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    number - int_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let s = number.to_string();\n    let f64_length = s.len() as i32;\n\
    \    let decimal_index = s.find('.').unwrap_or(f64_length);\n    let decimal_part_length\
    \ = f64_length - decimal_index - 1;\n    if decimal_part_length == 0 {\n     \
    \   0.0\n    } else {\n        number.fract()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm93yhy50.rs:10:47\n   |\n\
    10 |     let decimal_index = s.find('.').unwrap_or(f64_length);\n   |        \
    \                                       ^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |     let decimal_index = s.find('.').unwrap_or(f64_length.try_into().unwrap());\n\
    \   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm93yhy50.rs:11:44\n   |\n11 |\
    \     let decimal_part_length = f64_length - decimal_index - 1;\n   |        \
    \                                    ^^^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `i32`\n  --> /tmp/tmpm93yhy50.rs:11:42\n\
    \   |\n11 |     let decimal_part_length = f64_length - decimal_index - 1;\n  \
    \ |                                          ^ no implementation for `i32 - usize`\n\
    \   |\n   = help: the trait `Sub<usize>` is not implemented for `i32`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = split_integer_decimal(number);\n    decimal\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `split_integer_decimal` in this scope\n\
    \ --> /tmp/tmpek7l3yay.rs:8:30\n  |\n8 |     let (integer, decimal) = split_integer_decimal(number);\n\
    \  |                              ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number_truncated = number.trunc();\n    number - number_truncated\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
