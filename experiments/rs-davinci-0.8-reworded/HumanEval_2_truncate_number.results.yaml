language: rs
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number.fract() * 10_f64).round() / 10_f64\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.3`,\n right: `0.25`', /tmp/tmp_nzd24y7.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.trunc() {\n        num if num > number => num - 1.0,\n\
    \        num => num,\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpgkn35jai.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return (number as i64) as f64;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp_y4alghv.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    number - int_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let s = number.to_string();\n    let f64_length = s.len() as i32;\n\
    \    let decimal_index = s.find('.').unwrap_or(f64_length);\n    let decimal_part_length\
    \ = f64_length - decimal_index - 1;\n    if decimal_part_length == 0 {\n     \
    \   0.0\n    } else {\n        number.fract()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm93yhy50.rs:10:47\n   |\n\
    10 |     let decimal_index = s.find('.').unwrap_or(f64_length);\n   |        \
    \                                       ^^^^^^^^^^ expected `usize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n10 |     let decimal_index = s.find('.').unwrap_or(f64_length.try_into().unwrap());\n\
    \   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm93yhy50.rs:11:44\n   |\n11 |\
    \     let decimal_part_length = f64_length - decimal_index - 1;\n   |        \
    \                                    ^^^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \nerror[E0277]: cannot subtract `usize` from `i32`\n  --> /tmp/tmpm93yhy50.rs:11:42\n\
    \   |\n11 |     let decimal_part_length = f64_length - decimal_index - 1;\n  \
    \ |                                          ^ no implementation for `i32 - usize`\n\
    \   |\n   = help: the trait `Sub<usize>` is not implemented for `i32`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = split_integer_decimal(number);\n    decimal\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `split_integer_decimal` in this scope\n\
    \ --> /tmp/tmpek7l3yay.rs:8:30\n  |\n8 |     let (integer, decimal) = split_integer_decimal(number);\n\
    \  |                              ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number_truncated = number.trunc();\n    number - number_truncated\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number.is_sign_positive() {\n        number.fract()\n    }\
    \ else {\n        number.fract() + 1.0\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - number.floor())\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa53ggln1.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int = number.floor();\n    number - int\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let _integer_part = number.trunc();\n    let _decimal_part = number\
    \ - _integer_part;\n    _decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number.is_sign_positive() {\n        number.fract()\n    }\
    \ else {\n        1.0 - (number.abs().fract())\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    loop {\n        if number < 1.0\
    \ {\n            return number;\n        }\n        number -= 1.0;\n    }\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number * 10.0).trunc() / 10.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpj2yb3rp2.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    let decimal_part = number\
    \ - integer_part;\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    number - int_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    let mut res = 0f64;\n    while number\
    \ > 1f64 {\n        number -= 1f64;\n    }\n    res = number;\n    res\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpv9o9bkis.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - number.floor())\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    return number - integer_part;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.0 {\n        number - (number as i64) as f64\n \
    \   } else {\n        number - (number as i64 - 1) as f64\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number % 1.0).abs()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO: replace println! with the correct return value\n    if\
    \ number > 0.0 {\n        let decimal = number - number.floor();\n        decimal\n\
    \    } else {\n        let decimal = number - number.ceil();\n        decimal\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return (number * 10.0).trunc() / 10.0;\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmptufqnjp9.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.floor();\n    number - integer\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        1.0 + (number - number.floor())\n \
    \   } else {\n        number - number.floor()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - (number as i64) as f64;\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO\n    return 0.0;\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmphnrk893b.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    let float_part = number -\
    \ int_part;\n    float_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        panic!(\"Number must be positive\"\
    );\n    }\n\n    number - number.floor()\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.floor();\n    let decimal = number - integer;\n\
    \    return decimal;\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number_int = number.floor();\n    number - number_int\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = number.trunc();\n    if number > 0.0 {\n \
    \       truncated = number.trunc() - 1.0;\n    }\n    number - truncated\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.5`,\n right: `0.5`', /tmp/tmpys1ry98d.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integral: i64 = number.trunc() as i64;\n    number - integral\
    \ as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // We cannot take modulo of floating point numbers\n    // so\
    \ we must make use of the property that\n    // (number - (number as integer))\
    \ is the left over part\n    number - number.floor()\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = number.modf();\n    return decimal;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `modf` found for type `f64` in the current\
    \ scope\n --> /tmp/tmp8tsivrw9.rs:8:37\n  |\n8 |     let (integer, decimal) =\
    \ number.modf();\n  |                                     ^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (int_part, dec_part) = decompose_number(number);\n    dec_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `decompose_number` in this scope\n -->\
    \ /tmp/tmplst207ht.rs:8:32\n  |\n8 |     let (int_part, dec_part) = decompose_number(number);\n\
    \  |                                ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let trunc = number.trunc();\n    number - trunc\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let i = number.floor();\n    number - i\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    let negative = number < 0.0;\n \
    \   if negative {\n        number = -number;\n    }\n    let mut int_part = number\
    \ as u64;\n    let decimals = number - (int_part as f64);\n    if negative {\n\
    \        -decimals\n    } else {\n        decimals\n    }\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 0.0 {\n        number - number.floor()\n    } else\
    \ {\n        number - number.ceil()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // TODO: complete\n    number.fract()\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number.is_sign_positive() {\n        number - number.floor()\n\
    \    } else {\n        number - number.ceil()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut number = number;\n    while number >= 1.0 {\n        number\
    \ -= 1.0;\n    }\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let decimals = number.fract();\n    decimals\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let abs_number = number.abs();\n    let result = abs_number -\
    \ abs_number.floor();\n    number.signum() * result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number = number.abs();\n    let rounded = number.round();\n\
    \    let integer = rounded.floor();\n    return number - integer;\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-0.5`,\n right: `0.5`', /tmp/tmphlk5a3rq.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let fraction = number.fract();\n    if fraction > 0.0 {\n    \
    \    return fraction;\n    }\n    1.0 + fraction\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpmkpyvpm2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number.is_sign_positive() {\n        return number - (number\
    \ as i64) as f64;\n    }\n    number - (number as i64) as f64 + 1.0\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        panic!(\"Cannot truncate negative number\"\
    );\n    }\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (integer, decimal) = get_integer_and_decimal(number);\n  \
    \  if integer < 0.0 {\n        (integer - 1.0) + decimal\n    } else {\n     \
    \   decimal\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_integer_and_decimal` in this scope\n\
    \ --> /tmp/tmp191j0r2x.rs:8:30\n  |\n8 |     let (integer, decimal) = get_integer_and_decimal(number);\n\
    \  |                              ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer = number.floor();\n    let decimal = number - integer;\n\
    \    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let rounded_number = number.round();\n    if rounded_number >\
    \ number {\n        rounded_number - number\n    } else {\n        number - rounded_number\n\
    \    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    return number - int_part;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - number.floor();\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number < 0.0 {\n        number.abs() % 1.0\n    } else {\n\
    \        number % 1.0\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 0.0 {\n        number.fract()\n    } else {\n   \
    \     1.0 + number.fract()\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    match number.fract() {\n        f if f > 0.0 => f,\n        _\
    \ => 0.0,\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    return number - integer_part;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // define a number always greater than 1\n    let ten = 10.0;\n\
    \    // truncate the integer part of the number\n    let int_part = number.trunc();\n\
    \    // remove the integer part of the number\n    let dec_part = number - int_part;\n\
    \    // power of 10 that makes the decimal part an integer\n    let dec_mult =\
    \ ten.powf(dec_part.abs().log10().ceil());\n    // round decimals to integer to\
    \ avoid floating point issues\n    let dec_int = (dec_part * dec_mult).round();\n\
    \    // return decimal part of number\n    return dec_int / dec_mult;\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `powf` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmptd9izr0j.rs:15:24\n   |\n15 |     let dec_mult = ten.powf(dec_part.abs().log10().ceil());\n\
    \   |                        ^^^^\n   |\nhelp: you must specify a type for this\
    \ binding, like `f32`\n   |\n9  |     let ten: f32 = 10.0;\n   |         ~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let trunc_part = (number as u64) as f64;\n    number - trunc_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    number - int_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    // truncate_number(3.5) -> 3\n    let truncate_number = number.trunc();\n\
    \    // 3.5 - 3 -> 0.5\n    number - truncate_number\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let remainder = number.fract();\n    if remainder < 0.0 {\n  \
    \      1.0 + remainder\n    } else {\n        remainder\n    }\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.0 {\n        number - number.floor()\n    } else\
    \ {\n        number - number.ceil()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let (int_part, dec_part) = number.modf();\n    dec_part\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `modf` found for type `f64` in the current\
    \ scope\n --> /tmp/tmpxi723fed.rs:8:39\n  |\n8 |     let (int_part, dec_part)\
    \ = number.modf();\n  |                                       ^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number_truncated = number.trunc();\n    return number - number_truncated;\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 0.0 {\n        number - number.floor()\n    } else\
    \ {\n        number - number.ceil()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let i_part = number.trunc();\n    number - i_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let number_int = number.floor();\n    number - number_int\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - number.floor())\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    number - integer_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number >= 0.0 {\n        number.fract()\n    } else {\n   \
    \     1.0 + number.fract()\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    if number > 0.0 {\n        (number - number.floor())\n    } else\
    \ {\n        (number - number.ceil())\n    }\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let num_string = number.to_string();\n    let split: Vec<&str>\
    \ = num_string.split(\".\").collect();\n    match split.len() {\n        2 =>\
    \ split[1].parse::<f64>().unwrap() / 10.0_f64.powf(split[1].len() as f64),\n \
    \       _ => 0.0,\n    }\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.trunc()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpcracoqzh.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - (number as i64) as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    (number - (number as i64) as f64)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let int_part = number.floor();\n    number - int_part\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let decimal_part = number - number.floor();\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let integer_part = number.floor();\n    let decimal_part = number\
    \ - integer_part;\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number - (number as i64) as f64;\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let truncated = number.trunc();\n    number - truncated\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number.fract()\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    number - number.floor()\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
- exit_code: 0
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    return number.fract();\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822558
