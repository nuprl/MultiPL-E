name: HumanEval_101_words_string
language: rs
prompt: "/// You will be given a string of words separated by commas or spaces. Your\
  \ task is\n/// to split the string into words and return a vector of the words.\n\
  /// For example:\n/// >>> words_string(String::from(\"Hi, my name is John\"))\n\
  /// vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"\
  is\"), String::from(\"John\")]\n/// >>> words_string(String::from(\"One, two, three,\
  \ four, five, six\"))\n/// vec![String::from(\"One\"), String::from(\"two\"), String::from(\"\
  three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\n\
  fn words_string(s: String) -> Vec<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = words_string;\n    assert_eq!(candidate(String::from(\"\
  Hi, my name is John\")), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"\
  name\"), String::from(\"is\"), String::from(\"John\")]);\n    assert_eq!(candidate(String::from(\"\
  One, two, three, four, five, six\")), vec![String::from(\"One\"), String::from(\"\
  two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"),\
  \ String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"Hi, my name\"\
  )), vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\")]);\n\
  \    assert_eq!(candidate(String::from(\"One,, two, three, four, five, six,\")),\
  \ vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"\
  four\"), String::from(\"five\"), String::from(\"six\")]);\n    assert_eq!(candidate(String::from(\"\
  \")), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"ahmed    \
  \ , gamal\")), vec![String::from(\"ahmed\"), String::from(\"gamal\")]);\n}\n"
completions: ["    let words: Vec<String> = s.split(|c: char| !c.is_alphanumeric()).map(|s|\
    \ s.to_string()).collect();\n    words", "    let mut res = Vec::new();\n    let\
    \ mut st = String::new();\n    for c in s.chars() {\n        if c == ' ' || c\
    \ == ',' {\n            if !st.is_empty() {\n                res.push(st);\n \
    \               st = String::new();\n            }\n        } else {\n       \
    \     st.push(c);\n        }\n    }\n    if !st.is_empty() {\n        res.push(st);\n\
    \    }\n    res", '    unimplemented!()', "    s.split(|c: char| c == ' ' || c\
    \ == ',').map(|s| s.to_string()).collect()", '    unimplemented!()', '    s.split(|c:
    char| !c.is_alphanumeric()).map(|x| x.to_string()).collect()', '    unimplemented!()',
  "    // TODO!\n    unimplemented!();", "    s.split(|c: char| c == ' ' || c == ',').map(|s|\
    \ s.to_string()).collect()", "    // Convert the string to a vector of chars so\
    \ we can iterate over them\n    let chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut words = Vec::new();\n\n    // Our words vector stores character slices,\
    \ so we need a start and end\n    // index to slice the chars vector.\n    let\
    \ mut start = 0;\n    let mut end = 0;\n\n    // Iterate over the chars and track\
    \ the current word. We do this by\n    // incrementing the end index until we\
    \ reach a space or comma and then\n    // we can slice the chars vector to get\
    \ the current word.\n    for i in 0..chars.len() {\n        end = i;\n\n     \
    \   // If the character is a space or comma, we can add a word to the words\n\
    \        // vector.\n        if chars[i] == ' ' || chars[i] == ',' {\n       \
    \     words.push(chars[start..end].iter().collect::<String>());\n            start\
    \ = end + 1;\n        }\n    }\n\n    // Return the words vector\n    words",
  "    s.split(|c: char| c == ' ' || c == ',').map(|x| x.to_string()).collect()",
  '    unimplemented!()', "    let v: Vec<&str> = s.split(|c: char| c == ' ' || c\
    \ == ',').collect();\n    v.iter().map(|s| String::from(*s)).collect()", "   \
    \ s.split(|c: char| c == ' ' || c == ',').map(|s| s.to_string()).collect()", '    unimplemented!();',
  '    s.split(|c: char| !c.is_alphanumeric()).map(|s| s.to_string()).collect()',
  '    unimplemented!();', "    let c = &s[..];\n    c.split_whitespace().map(|x|\
    \ x.to_string()).collect()", "    s.split(|c: char| c == ' ' || c == ',').map(|s|\
    \ s.to_string()).collect()", "    let v: Vec<&str> = s.split(|c: char| c == '\
    \ ' || c == ',').collect();\n    v.iter().map(|s| String::from(*s)).collect()"]
stop_tokens:
- "\n}"
