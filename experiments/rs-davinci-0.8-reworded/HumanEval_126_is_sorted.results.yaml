language: rs
name: HumanEval_126_is_sorted
results:
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for item in lst {\n        if let Some(p) = prev {\n     \
    \       if item < p {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        prev = Some(item);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps_fzfwgl.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut result = true;\n    let mut\
    \ i = 0;\n    while i < lst.len() - 1 {\n        if lst[i] < lst[i + 1] {\n  \
    \          i += 1;\n        } else {\n            result = false;\n          \
    \  break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmg0xog_x.rs:24:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut cur_max = -1;\n    for num\
    \ in lst {\n        if num < cur_max {\n            return false;\n        }\n\
    \        cur_max = num;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3jjzcpvf.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    for i in 0..lst.len()-1 {\n        if lst[i] >= lst[i+1] {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8ija1s9b.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i +\
    \ 1] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpufo6z3c_.rs:26:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    for i\
    \ in 0..lst.len()-1 {\n        if lst[i] > lst[i+1] {\n            sorted = false;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpl_o5lh0y.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    is_sorted_helper(lst, 0, None)\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_sorted_helper` in this scope\n \
    \ --> /tmp/tmp5s_no1rc.rs:22:5\n   |\n22 |     is_sorted_helper(lst, 0, None)\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = None;\n    for i in lst {\n        match prev {\n            Some(v)\
    \ => {\n                if i <= v {\n                    sorted = false;\n   \
    \                 break;\n                }\n            }\n            None =>\
    \ {}\n        }\n        prev = Some(i);\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcey9s3y3.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    // TODO: Write your code here!\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq0ki9d7o.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = std::isize::MIN;\n\
    \    for n in lst {\n        if n <= prev {\n            return false;\n     \
    \   }\n        prev = n;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl8_r3iwh.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    for i in 0..lst.len()-1 {\n        if lst[i] != lst[i+1] &&\
    \ lst[i] > lst[i+1] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdksjwhbl.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted_lst = lst.clone();\n\
    \    sorted_lst.sort();\n    sorted_lst == lst\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ugt39u5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut v = lst.iter();\n    v.fold(Option::Some(*v.next().unwrap()),\
    \ |a, e| {\n        match a {\n            None => None,\n            Some(c)\
    \ => {\n                if e > &c {\n                    Some(*e)\n          \
    \      } else {\n                    None\n                }\n            }\n\
    \        }\n    })\n    .is_some()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `v`\n  --> /tmp/tmp_lwuoeyb.rs:26:26\n\
    \   |\n25 |     let mut v = lst.iter();\n   |         ----- move occurs because\
    \ `v` has type `std::slice::Iter<'_, isize>`, which does not implement the `Copy`\
    \ trait\n26 |     v.fold(Option::Some(*v.next().unwrap()), |a, e| {\n   |    \
    \ - value moved here   ^ value borrowed here after move\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    for i\
    \ in 0..lst.len() - 1 {\n        sorted = sorted && (lst[i] < lst[i + 1]);\n \
    \   }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp3112u__e.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // True if a sorted vector\n    let\
    \ mut sorted = true;\n    // Iterate through vector\n    for i in 0..lst.len()\
    \ {\n        // If the next value is less than the current value,\n        //\
    \ then return false.\n        if lst.get(i + 1) != None && lst[i + 1] < lst[i]\
    \ {\n            sorted = false;\n        }\n    }\n    // Return whether vector\
    \ is sorted or not\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5bv249th.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.iter().zip(lst.iter().skip(1)).all(|(a,\
    \ b)| a <= b)\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpei98bhvi.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ num = None;\n    for i in lst {\n        if let Some(n) = num {\n          \
    \  if i <= n {\n                sorted = false;\n                break;\n    \
    \        }\n        }\n        num = Some(i);\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxltpq34o.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyqnnen72.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: isize = lst[0];\n \
    \   for i in 1..lst.len() {\n        if lst[i] <= prev {\n            return false;\n\
    \        }\n        prev = lst[i];\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbswii6to.rs:22:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    let mut last_seen = lst[0];\n    for num\
    \ in lst {\n        if num < last_seen {\n            return false;\n        }\n\
    \        if num == last_seen {\n            i += 1;\n            if i > 1 {\n\
    \                return false;\n            }\n        }\n        last_seen =\
    \ num;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnwwwc2bb.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len()-1 {\n     \
    \   if lst[i] >= lst[i+1] {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpungchnfz.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for (i, &x) in lst.iter().enumerate()\
    \ {\n        if i > 0 && x < lst[i - 1] {\n            return false;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ar9xy77.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut prev\
    \ = None;\n    while i < lst.len() {\n        if let Some(p) = prev {\n      \
    \      if p == lst[i] {\n                return false;\n            }\n      \
    \      if p > lst[i] {\n                return false;\n            }\n       \
    \ }\n        prev = Some(lst[i]);\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprfg0wjc8.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut check_number = lst[0];\n\
    \    for i in lst {\n        if i <= check_number {\n            check_number\
    \ = i;\n        } else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx8p2bbkj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // In order to solve this problem,\
    \ we should first create a copy of the\n    // given vector, then sort it with\
    \ a function that we define. Then we\n    // compare the given vector to the sorted\
    \ vector and if the two vectors\n    // are the same then it returns true, otherwise\
    \ it returns false.\n    let mut lst_copy = lst.clone();\n    lst_copy.sort();\n\
    \    if lst == lst_copy {\n        true\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgy88f4mq.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut idx = 0;\n    if lst.len()\
    \ == 1 {\n        return true;\n    }\n    while idx < lst.len() - 1 {\n     \
    \   if lst[idx] < lst[idx + 1] {\n            idx += 1;\n        } else {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpu9ldaqd7.rs:26:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut it = lst.iter();\n    if\
    \ let Some(first) = it.next() {\n        for x in it {\n            if *x > *first\
    \ {\n                *first = *x;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*first`, which is behind a `&` reference\n\
    \  --> /tmp/tmplun3d0sa.rs:26:17\n   |\n23 |     if let Some(first) = it.next()\
    \ {\n   |                 ----- help: consider changing this to be a mutable reference:\
    \ `&mut isize`\n...\n26 |                 *first = *x;\n   |                 ^^^^^^^^^^^\
    \ `first` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst_iter = lst.iter();\n\
    \    let mut last = lst_iter.next();\n    for n in lst_iter {\n        if last.unwrap()\
    \ >= n {\n            return false;\n        }\n        last = Some(n);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8kxt6df1.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for item\
    \ in lst {\n        if item < prev {\n            return false;\n        }\n \
    \       prev = item;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpb6k6nn_1.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpz6vc65fy.rs:22:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for val in lst {\n        if let Some(cur) = last {\n    \
    \        if val <= cur {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        last = Some(val);\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp77uegz__.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for item\
    \ in lst {\n        if item < prev {\n            return false;\n        }\n \
    \       prev = item;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpb6k6nn_1.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = None;\n    for i in lst {\n        if last == None {\n            last\
    \ = Some(i);\n        } else {\n            if i < last.unwrap() {\n         \
    \       sorted = false;\n            }\n            last = Some(i);\n        }\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8uhurb2_.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut lst2 = lst.clone();\n    lst2.sort();\n    lst ==\
    \ lst2\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppuap87s9.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut arr = lst.clone();\n    arr.sort();\n\
    \    return lst == arr;\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk56djaxj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  if lst.len() == 1 { return true; }\n\
    \  for i in 0..lst.len()-1 {\n    if lst[i] > lst[i+1] { return false; }\n  }\n\
    \  return true;\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqpzulufe.rs:23:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    lst.dedup();\n    lst == lst.sort()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmp30cfbr6x.rs:25:9\n\
    \   |\n25 |     lst == lst.sort()\n   |         ^^ no implementation for `Vec<isize>\
    \ == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n    \
    \    if lst[i] == prev {\n            return false;\n        }\n        if lst[i]\
    \ < prev {\n            return false;\n        }\n        prev = lst[i];\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpij1xk5_c.rs:25:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    //TODO\n    let len = lst.len();\n\
    \    for i in 0..len {\n        for j in (i + 1)..len {\n            if lst[i]\
    \ >= lst[j] {\n                return false;\n            }\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk5nh99tu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = None;\n    for i in\
    \ lst {\n        match last {\n            None => last = Some(i),\n         \
    \   Some(j) => {\n                if i < j {\n                    return false;\n\
    \                }\n                last = Some(i);\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvx5fc6_e.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut p = 0;\n    for x in lst\
    \ {\n        if x > p {\n            p = x;\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa26a0amk.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.windows(2).all(|w| w[0] < w[1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpatjrk9k9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut c = lst.clone();\n    c.sort();\n\
    \    c == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjjevk5cn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.windows(2).all(|pair| pair[0]\
    \ < pair[1])\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu1rgl_d7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9m72d1s7.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut iter = lst.iter();\n    let\
    \ mut previous = iter.next();\n    if previous.is_none() {\n        true\n   \
    \ } else {\n        let mut current = previous.unwrap();\n        for i in iter\
    \ {\n            if *i < *current {\n                return false;\n         \
    \   }\n            current = i;\n        }\n        true\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmporiqacmo.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last = 0;\n    let mut first\
    \ = true;\n    for item in lst {\n        if !first && item <= last {\n      \
    \      return false;\n        }\n        first = false;\n        last = item;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptnhtw3pb.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut vec = lst.clone();\n    vec.sort();\n\
    \    let mut i = 0;\n    while i < vec.len() {\n        if vec[i] != lst[i] {\n\
    \            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkxsnv23p.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.windows(2).all(|w| w[0] < w[1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpatjrk9k9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  // TODO: Implement this function\n\
    \  false\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_ywe42_g.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut previous: isize = -1;\n \
    \   for i in lst {\n        if i == previous {\n            return false;\n  \
    \      }\n        if i < previous {\n            return false;\n        }\n  \
    \      previous = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_6lmrbnh.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: isize = 0;\n    let\
    \ mut duplicate: bool = false;\n    for i in lst {\n        if prev == i {\n \
    \           duplicate = true;\n        }\n        if prev > i {\n            return\
    \ false;\n        }\n        prev = i;\n    }\n    if duplicate {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2llobe_l.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ i = 0;\n    let mut prev = lst[0];\n    while i < lst.len() && sorted {\n  \
    \      if lst[i] <= prev {\n            prev = lst[i];\n            i += 1;\n\
    \        } else {\n            sorted = false;\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjgejvo6e.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut v = lst.clone();\n    v.sort();\n\
    \    v == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8i7h33dp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut new_lst = lst.clone();\n    new_lst.sort();\n    new_lst\
    \ == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc60ak_9c.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // use the last element of the list\
    \ as the basis for comparison,\n    // then zip the list together with its previous\
    \ element\n    // and check if the basis is larger than the previous.\n    //\
    \ If no previous element (i.e. first element), return true\n    let last_n = lst.last().unwrap();\n\
    \    lst.iter().zip(lst.iter().skip(1)).all(|(x, y)| {\n        if x <= last_n\
    \ {\n            y > x\n        } else {\n            false\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp7g9kdtb_.rs:26:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last_seen: isize = 0;\n    for i in &lst {\n        if *i < last_seen {\n  \
    \          sorted = false;\n        }\n        last_seen = *i;\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsw4kuwwc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // your code here\n    let mut check_vec\
    \ = lst.clone();\n    let mut curr_vec = lst.clone();\n    check_vec.sort();\n\
    \    for i in 0..curr_vec.len() {\n        if curr_vec[i] != check_vec[i] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8eyf34qd.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst_iter = lst.iter();\n\
    \    let mut result = true;\n    match lst_iter.next() {\n        Some(n) => {\n\
    \            let mut prev = *n;\n            for i in lst_iter {\n           \
    \     if prev >= *i {\n                    result = false;\n                 \
    \   break;\n                }\n                prev = *i;\n            }\n   \
    \     }\n        None => {\n            result = false;\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpurpo3suc.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8nvlznbw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() <= 1 {\n        return\
    \ true;\n    }\n    for i in 0..lst.len()-1 {\n        if lst[i] >= lst[i+1] {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpquf4n90u.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 1..lst.len() {\n       \
    \ if lst[i - 1] > lst[i] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw3tj0_s_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut current = None;\n    for\
    \ x in lst {\n        if let Some(prev) = current {\n            if x <= prev\
    \ {\n                return false;\n            }\n        }\n        current\
    \ = Some(x);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb1r2niac.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for x in 1..lst.len() {\n       \
    \ if lst[x - 1] >= lst[x] {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmperz7c95b.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.windows(2).all(|w| w[0] < w[1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpatjrk9k9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut acc = false;\n    let mut\
    \ temp: isize = 0;\n    for i in lst {\n        if acc {\n            if i < temp\
    \ {\n                return false;\n            }\n        }\n        acc = true;\n\
    \        temp = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw7lklm1y.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let n = lst.len();\n    for i in\
    \ 0..n - 1 {\n        if lst[i] > lst[i + 1] {\n            return false;\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqozj748e.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let len = lst.len();\n    if len\
    \ == 1 {\n        return true;\n    }\n\n    let mut previous_value = 0;\n   \
    \ let mut current_value = 0;\n    let mut current_index = 0;\n    let mut previous_value_exists\
    \ = false;\n\n    for item in lst {\n        current_value = item;\n        if\
    \ previous_value_exists {\n            if previous_value > current_value {\n \
    \               return false;\n            }\n            if current_index ==\
    \ len - 1 {\n                return true;\n            }\n        }\n        previous_value\
    \ = current_value;\n        previous_value_exists = true;\n        current_index\
    \ += 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgsddewud.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = -10000;\n    for num in lst {\n        if num == prev {\n           \
    \ sorted = false;\n        }\n        if num < prev {\n            sorted = false;\n\
    \        }\n        prev = num;\n    }\n    sorted\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6o9qrrgh.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() <= 1 {\n        return\
    \ true;\n    }\n    let mut idx = 0;\n    while idx < lst.len() - 1 {\n      \
    \  if lst[idx] < lst[idx + 1] {\n            idx += 1;\n        } else {\n   \
    \         return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps4np8qd2.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ x: Option<isize> = None;\n    for &i in lst.iter() {\n        if let Some(prev)\
    \ = x {\n            if i < prev {\n                sorted = false;\n        \
    \        break;\n            }\n        }\n        x = Some(i);\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfhhu_9x6.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 1..lst.len() {\n       \
    \ if lst[i] <= lst[i - 1] {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv9tyakjs.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    match lst.len() {\n        0 => true,\n\
    \        1 => true,\n        _ => {\n            let mut cur_el = lst[0];\n  \
    \          for el in lst {\n                if el < cur_el {\n               \
    \     return false;\n                }\n                cur_el = el;\n       \
    \     }\n            true\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa6okoz53.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last_number = None;\n   \
    \ for number in lst {\n        match last_number {\n            None => last_number\
    \ = Some(number),\n            Some(last_number) => {\n                if number\
    \ <= last_number {\n                    return false;\n                }\n   \
    \             last_number = Some(number);\n            }\n        }\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpui67y8yw.rs:30:31\n   |\n\
    26 |             Some(last_number) => {\n   |                  ----------- expected\
    \ due to the type of this binding\n...\n30 |                 last_number = Some(number);\n\
    \   |                               ^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n\n    let mut sorted = true;\n    let mut last = lst[0];\n   \
    \ for num in lst {\n        if num < last {\n            sorted = false;\n   \
    \         break;\n        } else {\n            last = num;\n        }\n    }\n\
    \n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc2qj7h2x.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n\n    let mut i = 1;\n    let mut curr = lst[0];\n    let mut\
    \ dup = false;\n    while i < lst.len() {\n        if lst[i] < curr {\n      \
    \      return false;\n        } else if lst[i] == curr {\n            dup = true;\n\
    \        } else {\n            dup = false;\n        }\n        curr = lst[i];\n\
    \        i += 1;\n    }\n    return !dup;\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpggvja8g1.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: Option<isize> = None;\n\
    \    for x in lst {\n        match prev {\n            Some(p) => {\n        \
    \        if p >= x {\n                    return false;\n                }\n \
    \           }\n            None => {}\n        }\n        prev = Some(x);\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4vqeqb7i.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpz6vc65fy.rs:22:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut sorted = true;\n    let mut previous = lst[0];\n \
    \   for &x in lst.iter().skip(1) {\n        if x < previous {\n            sorted\
    \ = false;\n            break;\n        }\n        previous = x;\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpyyjp6o28.rs:26:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut is_sorted = true;\n    let\
    \ mut previous_num = None;\n    for n in lst {\n        match previous_num {\n\
    \            Some(p) => {\n                if n < p {\n                    is_sorted\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         None => previous_num = Some(n),\n        }\n    }\n    is_sorted\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprv32tzg4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in lst {\n        if i <\
    \ prev {\n            return false;\n        }\n        prev = i;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqcs37766.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9m72d1s7.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut sorted = true;\n    let mut max = std::isize::MIN;\n\
    \    for num in lst {\n        if num > max {\n            max = num;\n      \
    \  } else {\n            sorted = false;\n            break;\n        }\n    }\n\
    \    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpof5phd7m.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    for i in 0..lst.len()-1 {\n        if lst[i] > lst[i+1] {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmoectd_w.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev: isize = 0;\n    for el in lst {\n        if el < prev {\n            sorted\
    \ = false;\n        }\n        prev = el;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmzuq13gl.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut is_ascending = true;\n  \
    \  for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1] {\n          \
    \  is_ascending = false;\n        }\n    }\n    is_ascending\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp7u5r553k.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() <= 1 {\n        return\
    \ true;\n    }\n    let mut prev = lst[0];\n    for i in lst {\n        if i <=\
    \ prev {\n            return false;\n        }\n        prev = i;\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsf03n8dw.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut new_lst = lst.clone();\n\
    \    new_lst.sort();\n    new_lst == lst\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjqnjfj_j.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpl76jdnkm.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8nvlznbw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnq512zph.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ iter = lst.iter();\n    let mut prev = iter.next();\n    while let Some(item)\
    \ = iter.next() {\n        if prev > item {\n            sorted = false;\n   \
    \         break;\n        }\n        prev = item;\n    }\n    sorted\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmp8ui62.rs:26:19\n   |\n\
    26 |         if prev > item {\n   |                   ^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n26 |         if prev > Some(item) {\n   |                   +++++    +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjmp8ui62.rs:30:16\n   |\n24 |  \
    \   let mut prev = iter.next();\n   |                    ----------- expected\
    \ due to this value\n...\n30 |         prev = item;\n   |                ^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n30 |         prev = Some(item);\n   |                +++++    +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: Implement this!\n    false\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp1djo3j3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.iter().scan(None, |prev, &x|\
    \ {\n        match prev {\n            None => {\n                *prev = Some(x);\n\
    \                None\n            }\n            Some(y) => {\n             \
    \   if x == y {\n                    return Some(false);\n                } else\
    \ if x < y {\n                    return Some(false);\n                } else\
    \ {\n                    *prev = Some(x);\n                    None\n        \
    \        }\n            }\n        }\n    }).any(|x| x)\n}\n\nfn main() {\n  \
    \  let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyl3hulop.rs:29:25\n   |\n\
    29 |                 if x == y {\n   |                         ^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n29\
    \ |                 if x == *y {\n   |                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyl3hulop.rs:31:31\n   |\n31 |              \
    \   } else if x < y {\n   |                               ^ expected `isize`,\
    \ found `&mut isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31\
    \ |                 } else if x < *y {\n   |                               +\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  lst.iter().scan(Some(&0), |previous,\
    \ current| {\n    if previous.is_some() && previous.unwrap() > current {\n   \
    \   return None;\n    }\n    *previous = Some(current);\n    Some(())\n  }).count()\
    \ == lst.len()\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjbzfya9x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8nvlznbw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let l = lst.len();\n    if l < 2\
    \ {\n        return true;\n    }\n    if l > 1 {\n        for i in 0..l - 1 {\n\
    \            if lst[i] > lst[i + 1] {\n                return false;\n       \
    \     }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprqdnn5oe.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = std::isize::MIN;\n\
    \    for n in lst {\n        if n < prev {\n            return false;\n      \
    \  }\n        prev = n;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ry0vo35.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    match lst.len() {\n        0 => true,\n\
    \        1 => true,\n        n => lst[0..n - 1]\n            .iter()\n       \
    \     .zip(lst[1..n].iter())\n            .all(|(x, y)| x < y),\n    }\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu9oa22vl.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = lst.iter().peekable();\n\
    \    while let Some(x) = sorted.next() {\n        if let Some(y) = sorted.peek()\
    \ {\n            if x > y {\n                return false;\n            }\n  \
    \      }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr8thoukf.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = 0;\n    for (i, val) in lst.iter().enumerate() {\n        if i > 0 {\n\
    \            if *val < last {\n                sorted = false;\n             \
    \   break;\n            }\n        }\n        last = *val;\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjal3e3l7.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // Your code here\n    false\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7ikz7wa_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    let mut has_duplicate = false;\n    let mut last_value =\
    \ lst[0];\n    for v in lst.iter().skip(1) {\n        if *v < last_value {\n \
    \           return false;\n        }\n        if *v == last_value {\n        \
    \    has_duplicate = true;\n        }\n        last_value = *v;\n    }\n    return\
    \ !has_duplicate;\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpmzjqk3hs.rs:27:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut i = 0;\n    let mut prev\
    \ = 0;\n    while i < lst.len() {\n        if lst[i] > prev {\n            prev\
    \ = lst[i];\n            i += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph7tpapkj.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = 0;\n    let mut count\
    \ = 0;\n    for i in lst {\n        if i == prev {\n            count += 1;\n\
    \        }\n        if count > 1 {\n            return false;\n        }\n   \
    \     if i < prev {\n            return false;\n        }\n        prev = i;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpofd8afvv.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    let mut prev = lst[0];\n    for num in lst.iter().skip(1)\
    \ {\n        if *num == prev {\n            return false;\n        } else if *num\
    \ < prev {\n            return false;\n        }\n        prev = *num;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpbh2ef1i4.rs:26:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut previous = None;\n    for\
    \ i in lst {\n        match previous {\n            Some(prev) => {\n        \
    \        if prev > i {\n                    return false;\n                }\n\
    \            }\n            None => {}\n        }\n        previous = Some(i);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbda7virg.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = std::isize::MIN;\n\
    \    for i in lst {\n        if i < prev {\n            return false;\n      \
    \  }\n        prev = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpya4bo_jd.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut i = 0;\n    while i < lst.len() - 1 {\n        if\
    \ lst[i] >= lst[i + 1] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpb1ejtcq_.rs:26:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for (i, n) in lst.iter().enumerate()\
    \ {\n        if i > 0 && n < &lst[i - 1] {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4r146rda.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut v = lst.iter();\n    match\
    \ v.next() {\n        None => true,\n        Some(prev) => v.all(|x| {\n     \
    \       let res = *x >= *prev;\n            *prev = *x;\n            res\n   \
    \     })\n    }\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*prev`, which is behind a `&` reference\n\
    \  --> /tmp/tmpgwxr4z4e.rs:27:13\n   |\n27 |             *prev = *x;\n   |   \
    \          ^^^^^^^^^^ cannot assign\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut nums = lst.iter();\n    let\
    \ mut index = 0;\n    let mut last = nums.next();\n    while let Some(x) = nums.next()\
    \ {\n        index += 1;\n        if *x < *last.unwrap() {\n            return\
    \ false;\n        }\n        last = Some(x);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa597f9jp.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // Your code here\n    let mut sorted\
    \ = true;\n    let mut last_num = 0;\n    for num in lst {\n        if last_num\
    \ > num {\n            sorted = false;\n        }\n        last_num = num;\n \
    \   }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeoc0_61r.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last_num = None;\n    for\
    \ num in lst {\n        match last_num {\n            None => last_num = Some(num),\n\
    \            Some(last_num) => {\n                if num < last_num {\n      \
    \              return false;\n                }\n                last_num = Some(num);\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpux4iayxm.rs:30:28\n   |\n\
    26 |             Some(last_num) => {\n   |                  -------- expected\
    \ due to the type of this binding\n...\n30 |                 last_num = Some(num);\n\
    \   |                            ^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let l = lst.len();\n    if l < 2\
    \ {\n        return true;\n    }\n    let mut prev = lst[0];\n    for i in 1..l\
    \ {\n        if lst[i] < prev {\n            return false;\n        }\n      \
    \  prev = lst[i];\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpekra3kmj.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst_iter = lst.iter();\n\
    \    lst_iter.by_ref().skip(1).all(|x| *x >= lst_iter.next().unwrap())\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr5ebwla5.rs:23:45\n   |\n\
    23 |     lst_iter.by_ref().skip(1).all(|x| *x >= lst_iter.next().unwrap())\n \
    \  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |     lst_iter.by_ref().skip(1).all(|x| *x >= *lst_iter.next().unwrap())\n\
    \   |                                             +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    lst.dedup();\n    lst == lst.clone().into_iter().enumerate().map(|(i, _)|\
    \ i as isize + 1).collect()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpklkpqow2.rs:25:9\n\
    \   |\n25 |     lst == lst.clone().into_iter().enumerate().map(|(i, _)| i as isize\
    \ + 1).collect()\n   |         ^^ cannot infer type\n   |\n   = note: multiple\
    \ `impl`s satisfying `Vec<isize>: PartialEq<_>` found in the `alloc` crate:\n\
    \           - impl<T, U, A, N> PartialEq<&[U; N]> for Vec<T, A>\n            \
    \ where A: Allocator, T: PartialEq<U>;\n           - impl<T, U, A, N> PartialEq<[U;\
    \ N]> for Vec<T, A>\n             where A: Allocator, T: PartialEq<U>;\n     \
    \      - impl<T, U, A1, A2> PartialEq<Vec<U, A2>> for Vec<T, A1>\n           \
    \  where A1: Allocator, A2: Allocator, T: PartialEq<U>;\n           - impl<T,\
    \ U, A> PartialEq<&[U]> for Vec<T, A>\n             where A: Allocator, T: PartialEq<U>;\n\
    \           and 2 more\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n25 |     lst == lst.clone().into_iter().enumerate().map(|(i, _)|\
    \ i as isize + 1).collect::<B>()\n   |                                       \
    \                                             +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len()-1 {\n     \
    \   for j in i+1..lst.len() {\n            if lst[i] >= lst[j] {\n           \
    \     return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprrnce_af.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.windows(2).all(|w| w[0] < w[1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpatjrk9k9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n    for i in 1..lst.len() {\n        if lst[i - 1] >= lst[i] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqb1hqzl4.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnq512zph.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ i = 0;\n    while i < lst.len() - 1 {\n        if lst[i] >= lst[i + 1] {\n \
    \           sorted = false;\n            break;\n        }\n        i += 1;\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvid3b4cg.rs:24:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut tmp = lst.clone();\n    tmp.sort();\n\
    \    lst == tmp\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8rjlcd09.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ last = 0;\n    for num in lst {\n        if num < last {\n            sorted\
    \ = false;\n        }\n        last = num;\n    }\n    sorted\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6nt0ufch.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut s: HashSet<isize> = HashSet::new();\n\
    \    for elem in lst {\n        if s.contains(&elem) {\n            return false;\n\
    \        }\n        s.insert(elem);\n    }\n    s.iter().enumerate().fold(true,\
    \ |acc, (i, &elem)| {\n        if i == 0 {\n            acc\n        } else {\n\
    \            acc && elem == *s.iter().nth(i - 1).unwrap() + 1\n        }\n   \
    \ })\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4jk96m29.rs:22:16\n\
    \   |\n22 |     let mut s: HashSet<isize> = HashSet::new();\n   |            \
    \    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp4jk96m29.rs:22:33\n   |\n22\
    \ |     let mut s: HashSet<isize> = HashSet::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // Your code here\n    let mut sorted_lst\
    \ = lst.clone();\n    sorted_lst.sort();\n    sorted_lst == lst\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx0boswr3.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    lst.iter().enumerate().all(|(i, &x)|\
    \ {\n        if i == 0 {\n            true\n        } else {\n            lst[i\
    \ - 1] < x\n        }\n    })\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9qqqu0k7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut temp_lst = lst.clone();\n\
    \    temp_lst.sort();\n    temp_lst == lst\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprmo6p8nk.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // Your code here!\n    let mut i\
    \ = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    while\
    \ i < lst.len() {\n        x = lst[i];\n        while i < lst.len() {\n      \
    \      y = lst[i];\n            if x == y {\n                z += 1;\n       \
    \     }\n            if z > 1 {\n                return false;\n            }\n\
    \            i += 1;\n        }\n        if x > y {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9ln_ya_7.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    for (i,\
    \ x) in lst.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        if x < &lst[i - 1] {\n            sorted = false;\n      \
    \      break;\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpchqlr7xk.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // check if vector has only one value\
    \ and return true since that is sorted\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    // for each element in vector, check if next element is\
    \ bigger\n    // if it is, return false\n    // when loop finishes and returns\
    \ false, it will enter else block\n    // and return true\n\n    for i in 0..lst.len()\
    \ - 1 {\n        if lst[i] >= lst[i + 1] {\n            return false;\n      \
    \  }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqsytvtp2.rs:32:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ iter = lst.iter();\n    let mut prev = iter.next();\n    for num in iter {\n\
    \        match prev {\n            Some(p) => {\n                if p < num {\n\
    \                    sorted = false;\n                    break;\n           \
    \     }\n            }\n            None => {}\n        }\n        prev = Some(num);\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9q0lpcpk.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for (i, a) in lst.iter().enumerate()\
    \ {\n        for (j, b) in lst.iter().enumerate() {\n            if i != j &&\
    \ a == b {\n                return false;\n            }\n        }\n    }\n \
    \   for i in 0..lst.len()-1 {\n        if lst[i] > lst[i+1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprz7tq8cr.rs:29:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n\n    let mut clone = lst.clone();\n    let mut sorted = clone.sort();\n\
    \    return clone == sorted;\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmprk_cwght.rs:28:18\n\
    \   |\n28 |     return clone == sorted;\n   |                  ^^ no implementation\
    \ for `Vec<isize> == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented\
    \ for `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut has_dup = false;\n    let\
    \ mut sorted = true;\n    let mut prev = None;\n    for i in lst {\n        if\
    \ prev.is_some() {\n            let p = prev.unwrap();\n            if p >= i\
    \ {\n                sorted = false;\n            }\n            if p == i {\n\
    \                has_dup = true;\n            }\n        }\n        prev = Some(i);\n\
    \    }\n    sorted && !has_dup\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmvyjj7g6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: Write your code here!\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpocwsitkp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n\n    let mut i = 0;\n    while i < lst.len() - 1 {\n        if\
    \ lst[i] >= lst[i + 1] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpln408o7o.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted_list = lst.clone();\n\
    \    sorted_list.sort();\n    let mut flag = true;\n    for (i, element) in lst.iter().enumerate()\
    \ {\n        if *element != sorted_list[i] {\n            flag = false;\n    \
    \    }\n    }\n    flag\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl668w023.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: isize = -1;\n    for\
    \ num in lst {\n        if num == prev {\n            return false;\n        }\n\
    \        prev = num;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7mao8v77.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut previous = -1;\n    for item\
    \ in lst {\n        if item == previous {\n            return false;\n       \
    \ }\n        previous = item;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdopz9pz0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut consecutive = 0;\n    for\
    \ i in 0..lst.len() - 1 {\n        if lst[i] < lst[i + 1] {\n            consecutive\
    \ += 1;\n        }\n    }\n    if consecutive == lst.len() - 1 {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpklxdf_h5.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: isize = lst[0];\n \
    \   for n in lst {\n        if n < prev {\n            return false;\n       \
    \ }\n        prev = n;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpphsz51ko.rs:22:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() <= 1 {\n        return\
    \ true;\n    }\n\n    for i in 1..lst.len() {\n        if lst[i] != lst[i - 1]\
    \ + 1 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuaat4akm.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut res = true;\n    for i in\
    \ 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1] {\n            res = false;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpkq235wf3.rs:23:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut curr = lst[0];\n    for num in lst {\n        if num\
    \ < curr {\n            return false;\n        }\n        curr = num;\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmplig8p21_.rs:25:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev: Option<isize> = None;\n\
    \    for i in lst {\n        if let Some(x) = prev {\n            if i <= x {\n\
    \                return false;\n            }\n        }\n        prev = Some(i);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5_geefoz.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnq512zph.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  let mut sorted = true;\n  let mut previous\
    \ = None;\n  for element in lst {\n    if let Some(p) = previous {\n      if p\
    \ >= element {\n        sorted = false;\n        break;\n      }\n    }\n    previous\
    \ = Some(element);\n  }\n  sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1mun4_5z.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // YOUR CODE HERE\n    false\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4lzgp2aa.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    //TODO Implement\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp07ynf1x3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    let mut i = 1;\n    while i < lst.len() {\n        if lst[i - 1] == lst[i]\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvrmu_9rb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut s = Sorted(lst);\n    s.0.sort();\n\
    \    s.0 == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Sorted`\
    \ in this scope\n  --> /tmp/tmpv2dcguds.rs:22:17\n   |\n22 |     let mut s = Sorted(lst);\n\
    \   |                 ^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // This is a very naive solution,\
    \ but one that is easy to understand.\n    // We want to compare each element\
    \ in the vector to the next one.\n    // We can do this by using the .windows()\
    \ iterator.\n    // For example, [1, 2, 3, 4].windows(2) gives us the pairs [(1,\
    \ 2), (2, 3), (3, 4)].\n    // Once we have the pairs, it is trivial to compare\
    \ the elements.\n    // Note that this solution assumes the vector is non-empty,\n\
    \    // so you may want to add a check for that.\n    //\n    // If we wanted\
    \ to, we could iterate over each pair and break early\n    // if we find an unsorted\
    \ pair. We will cover that below.\n    //\n    // If you want to get fancy, try\
    \ iterating over the vector in reverse, and\n    // breaking early if you find\
    \ the first unsorted pair.\n\n    // Your code here\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_vmxzecy.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ prev = lst[0];\n    for item in lst {\n        if item > prev {\n          \
    \  prev = item;\n        } else {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7n0l4r3q.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len()-1 {\n     \
    \   if lst[i] >= lst[i+1] {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpungchnfz.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // let mut sorted = lst.clone();\n\
    \    // sorted.sort();\n    // sorted == lst\n    let mut last = None;\n    for\
    \ num in lst {\n        if let Some(prev) = last {\n            if num < prev\
    \ {\n                return false;\n            }\n        }\n        last = Some(num);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_kcfyrux.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut n = 0;\n    let mut v = vec![];\n\
    \    let mut u = vec![];\n    for i in lst {\n        v.push(i);\n        if v.len()\
    \ > 1 {\n            if v[n] == v[n+1] {\n                u.push(v[n]);\n    \
    \        }\n            n = n + 1;\n        }\n    }\n    let mut m = v.len()\
    \ - 1;\n    let mut b = true;\n    for i in 0..m {\n        if v[i] > v[i+1] {\n\
    \            b = false;\n        }\n    }\n    if u.len() > 0 {\n        b = false;\n\
    \    }\n    b\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmph6u3lqx4.rs:34:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last_v = std::isize::MIN;\n\
    \    for v in lst {\n        if v < last_v {\n            return false;\n    \
    \    }\n        last_v = v;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpupjmuqdj.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // your code here\n    let mut previous\
    \ = None;\n    for num in lst {\n        match previous {\n            Some(n)\
    \ => {\n                if n >= num {\n                    return false;\n   \
    \             }\n            }\n            None => (),\n        }\n        previous\
    \ = Some(num);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzg994fbq.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ first = lst[0];\n    for i in lst {\n        if first > i {\n            sorted\
    \ = false;\n        }\n        first = i;\n    }\n    sorted\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpwbufrs60.rs:23:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n  let mut iter = lst.iter();\n  let mut\
    \ prev = iter.next();\n  for &x in iter {\n    if let Some(p) = prev {\n     \
    \ if x < p {\n        return false;\n      }\n    }\n    prev = Some(x);\n  }\n\
    \  true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppcvn590x.rs:26:14\n   |\n\
    26 |       if x < p {\n   |              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |       if x < *p {\n\
    \   |              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppcvn590x.rs:30:17\n\
    \   |\n30 |     prev = Some(x);\n   |                 ^\n   |                \
    \ |\n   |                 expected `&isize`, found `isize`\n   |             \
    \    help: consider borrowing here: `&x`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxkicyr0w.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823238
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpznc3sa8l.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // the sort algorithm returns a new\
    \ vector, so we can't mutate the original\n    // but we can return the result\
    \ of comparing them\n    lst == lst.clone().sort()\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmpk2jnli5l.rs:24:9\n\
    \   |\n24 |     lst == lst.clone().sort()\n   |         ^^ no implementation for\
    \ `Vec<isize> == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented\
    \ for `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut last_num = lst[0];\n    for\
    \ num in lst {\n        if num < last_num {\n            return false;\n     \
    \   }\n        last_num = num;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpay5mzkqy.rs:22:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9m72d1s7.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() < 2 {\n        return\
    \ true;\n    }\n\n    let mut found_dupe = false;\n    let mut first = true;\n\
    \    let mut last = 0;\n    for i in lst {\n        if first {\n            first\
    \ = false;\n            last = i;\n            continue;\n        }\n\n      \
    \  if last == i {\n            if found_dupe {\n                return false;\n\
    \            } else {\n                found_dupe = true;\n            }\n   \
    \     }\n\n        if last > i {\n            return false;\n        }\n     \
    \   last = i;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr7s7wx6j.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    lst.dedup();\n    lst == lst.sort()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmp30cfbr6x.rs:25:9\n\
    \   |\n25 |     lst == lst.sort()\n   |         ^^ no implementation for `Vec<isize>\
    \ == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented for `Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut tmp = lst[0];\n    for i in lst {\n        if i <\
    \ tmp {\n            return false;\n        }\n        tmp = i;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpd6rcvh31.rs:25:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    let mut curr = None;\n    for v in lst {\n        match curr\
    \ {\n            None => curr = Some(v),\n            Some(c) => {\n         \
    \       if v < c {\n                    return false;\n                }\n   \
    \             curr = Some(v);\n            }\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7v_3ezxh.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    if lst.len() <= 1 {\n        return\
    \ true;\n    }\n\n    let mut last = lst[0];\n    for i in lst {\n        if i\
    \ < last {\n            return false;\n        }\n        last = i;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7yfbqs5h.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut acc: isize = 0;\n    for\
    \ i in lst {\n        if i < acc {\n            return false;\n        }\n   \
    \     acc = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpudy318jw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // Write your solution here\n   \
    \ let mut prev: Option<isize> = None;\n    for n in lst {\n        match prev\
    \ {\n            Some(prev_val) => {\n                if prev_val > n {\n    \
    \                return false;\n                }\n            }\n           \
    \ None => {}\n        }\n        prev = Some(n);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi_xf3p98.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut lst = lst;\n    lst.sort();\n\
    \    let mut n = lst[0];\n    for i in lst.iter() {\n        if *i == n {\n  \
    \          return false;\n        }\n        n = *i;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpojj51r7v.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    // TODO: write is_sorted function\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_sorted;\n   \
    \ assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpox7onfxv.rs:23:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = lst[0];\n    for curr\
    \ in lst {\n        if curr < prev {\n            return false;\n        }\n \
    \       prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpiizbxy23.rs:22:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut sorted = true;\n    let mut\
    \ i = 0;\n    while i < lst.len() - 1 {\n        if lst[i] < lst[i + 1] {\n  \
    \          i += 1;\n        } else {\n            sorted = false;\n          \
    \  break;\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpluhh0eup.rs:24:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpa_9fiaq_.rs:22:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    match lst.len() {\n        0 => false,\n\
    \        1 => true,\n        2 => lst[0] < lst[1],\n        _ => is_sorted_rec(&lst,\
    \ 1),\n    }\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_sorted_rec` in this scope\n  -->\
    \ /tmp/tmp1hpgb8rk.rs:26:14\n   |\n26 |         _ => is_sorted_rec(&lst, 1),\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 101
  program: "/// Given a vector of numbers, return whether or not they are sorted\n\
    /// in ascending order. If vector has more than 1 duplicate of the same\n/// number,\
    \ return false. Assume no negative numbers and only integers.\n/// Examples\n\
    /// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n\
    /// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n///\
    \ true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1,\
    \ 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\n\
    fn is_sorted(lst: Vec<isize>) -> bool {\n    let mut previous: Option<isize> =\
    \ None;\n    for item in lst {\n        match previous {\n            Some(x)\
    \ => {\n                if x >= item {\n                    return false;\n  \
    \              }\n            }\n            None => {}\n        }\n        previous\
    \ = Some(item);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgs_wnnmc.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010766
