name: HumanEval_77_iscube
language: rs
prompt: "/// Write a function that takes an integer a and returns true \n/// if this\
  \ ingeger is a cube of some integer number.\n/// Note: you may assume the input\
  \ is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n\
  /// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n\
  /// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
  \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
  \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
  \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n \
  \   assert_eq!(candidate(1729), false);\n}\n"
completions: ['    (a as f64).powf(1.0/3.0).floor() == (a as f64).powf(1.0/3.0)',
  "    let sqrt = ((a as f64).abs().sqrt() as i32) as isize;\n    sqrt * sqrt * sqrt\
    \ == a", "    // TODO\n    unimplemented!()", "    let mut b = 1;\n    let mut\
    \ c = 0;\n    while c < a {\n        c = b * b * b;\n        if c == a {\n   \
    \         return true;\n        }\n        b += 1;\n    }\n    return false;",
  '    a.pow(3) % a == 0', "    let a: f64 = a as f64;\n    let n: f64 = a.cbrt();\n\
    \    let n: isize = n as isize;\n    n*n*n == a as isize", '    (0..100).map(|x|
    x*x*x).collect::<Vec<isize>>().contains(&a)', "    match a {\n        x if x ==\
    \ 0 => true,\n        x if x > 0 => {\n            let mut base = 0;\n       \
    \     let mut cube = 0;\n            while cube < x {\n                base +=\
    \ 1;\n                cube = base * base * base;\n            }\n            cube\
    \ == x\n        },\n        x if x < 0 => {\n            let mut base = 0;\n \
    \           let mut cube = 0;\n            while cube > x {\n                base\
    \ -= 1;\n                cube = base * base * base;\n            }\n         \
    \   cube == x\n        },\n        _ => panic!(\"the param a should not be 0.\"\
    ),\n    }", "    if a < 0 {\n        return false;\n    }\n    let mut x = a as\
    \ f64;\n    x = x.powf(1.0/3.0);\n    let y = x.round();\n    x - y == 0.0", " \
    \   if a == 0 {\n        return true;\n    }\n    let a = a.abs();\n    let mut\
    \ cube = 1;\n    while cube * cube * cube < a {\n        cube += 1;\n    }\n \
    \   cube * cube * cube == a", '    a.pow(3) == 0', '    a >= 0 && (a as f64).powf(1.0/3.0).fract()
    == 0.0', '    unimplemented!();', "    let mut cube_root = (a as f64).abs().cbrt()\
    \ as isize;\n    if cube_root * cube_root * cube_root == a {\n        return true;\n\
    \    }\n    if cube_root * cube_root * cube_root == -a {\n        return true;\n\
    \    }\n    false", '    (a as f64).powf(1.0/3.0).floor() == (a as f64).powf(1.0/3.0)',
  "    if a < 0 {\n        false\n    } else {\n        let b = (a as f64).powf(1.0/3.0);\n\
    \        (b.round() as isize).pow(3) == a\n    }", "    for i in 0..a+1 {\n  \
    \      if i*i*i == a {\n            return true;\n        }\n    }\n    return\
    \ false;", "    for i in 0..a {\n        if i*i*i == a {\n            return true;\n\
    \        }\n    }\n    return false;", "    let mut b = 0;\n    while b * b *\
    \ b < a {\n        b += 1;\n    }\n    if b * b * b == a {\n        true\n   \
    \ } else {\n        false\n    }", "    let mut i = 1;\n    let mut x = i * i\
    \ * i;\n    while x < a {\n        i += 1;\n        x = i * i * i;\n    }\n  \
    \  x == a"]
stop_tokens:
- "\n}"
