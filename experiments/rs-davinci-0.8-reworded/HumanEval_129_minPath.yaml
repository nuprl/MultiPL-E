name: HumanEval_129_minPath
language: rs
prompt: "/// Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n/// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You\
  \ have to find the minimum path of length k in the grid. You can start\n/// from\
  \ any cell, and in each step you can move to any of the neighbor cells,\n/// in\
  \ other words, you can go to cells which share an edge with you current\n/// cell.\n\
  /// Please note that a path of length k means visiting exactly k cells (not\n///\
  \ necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length\
  \ k) is considered less than a path B (of length k) if\n/// after making the ordered\
  \ vectors of the values on the cells that A and B go\n/// through (let's call them\
  \ lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words,\
  \ there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i]\
  \ and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed\
  \ that the answer is unique.\n/// Return an ordered vector of the values on the\
  \ cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1,\
  \ 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5,\
  \ 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1,\
  \ 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5,\
  \ 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1,\
  \ 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1,\
  \ 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1],\
  \ vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n\
  \    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7,\
  \ 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11,\
  \ 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1],\
  \ vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3,\
  \ 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6,\
  \ 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n   \
  \ assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2,\
  \ 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1,\
  \ 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"
completions: ["    let n = grid.len();\n    if n < 2 {\n        return vec![];\n \
    \   }\n    let (mut min_path, mut min_sum) = (Vec::new(), isize::max_value());\n\
    \    let mut kk = k;\n    while kk >= 0 {\n        let mut curr_path = Vec::new();\n\
    \        let mut curr_sum = 0;\n        for i in 0..n {\n            for j in\
    \ 0..n {\n                if grid[i][j] == kk {\n                    let mut last_sum\
    \ = kk;\n                    let mut last_path = vec![kk];\n                 \
    \   if i > 0 {\n                        let last_path =\n                    \
    \        minPath(getGrid(grid.clone(), i - 1, j), kk - 1);\n                 \
    \       if last_path.len() > 0 {\n                            last_sum = *last_path.last().unwrap();\n\
    \                        }\n                    }\n                    if j >\
    \ 0 {\n                        let last_path =\n                            minPath(getGrid(grid.clone(),\
    \ i, j - 1), kk - 1);\n                        if last_path.len() > 0 {\n    \
    \                        let last_sum_i = *last_path.last().unwrap();\n      \
    \                      if last_sum_i < last_sum {\n                          \
    \      last_sum = last_sum_i;\n                            }\n               \
    \         }\n                    }\n                    if last_sum < kk {\n \
    \                       curr_path = last_path;\n                        curr_sum\
    \ = last_sum;\n                    }\n                }\n            }\n     \
    \   }\n        curr_path.push(kk);\n        curr_sum += kk;\n        if curr_sum\
    \ < min_sum {\n            min_path = curr_path;\n            min_sum = curr_sum;\n\
    \        }\n        kk -= 1;\n    }\n    min_path", "    // edge cases\n    let\
    \ n = grid.len();\n    if n == 0 { return vec![]; }\n    if k == 0 { return vec![];\
    \ }\n    if k == 1 { return vec![grid[0][0]]; }\n    if n == 1 { return vec![grid[0][0]];\
    \ }\n    // make sure the grid has exactly k cells\n    let (mut start_i, mut\
    \ start_j) = (0, 0);\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if grid[i][j] == count {\n                start_i =\
    \ i;\n                start_j = j;\n                count += 1;\n            }\n\
    \        }\n    }\n    if count != k { return vec![]; }\n    // now let's go back\
    \ to the original problem\n    let mut ans = vec![];\n    // first, let's find\
    \ the min path of length 1\n    let (mut min_i, mut min_j) = (0, 0);\n    let\
    \ mut min_val = usize::max_value();\n    for i in 0..n {\n        for j in 0..n\
    \ {\n            if grid[i][j] < min_val {\n                min_i = i;\n     \
    \           min_j = j;\n                min_val = grid[i][j];\n            }\n\
    \        }\n    }\n    // now min_i, min_j is the location of the min val\n  \
    \  // and start_i, start_j is the location of the current min val\n    // let's\
    \ find the shortest path from start_i, start_j to min_i, min_j\n    let mut path\
    \ = find_path(start_i, start_j, min_i, min_j, &grid);\n    // add current min\
    \ val\n    ans.push(grid[start_i][start_j]);\n    // add this path\n    for (i,\
    \ j) in path {\n        ans.push(grid[i][j]);\n    }\n    // now we have to find\
    \ the min path of length k - 1\n    // and starting from min_i, min_j\n    let\
    \ mut new_", "    let n = grid.len();\n    assert!(n >= 2 && grid[0].len() ==\
    \ n);\n    // The idea is to first use a heap with a cost function that is the\n\
    \    // negation of the cell value, so the minimum path with length k will be\n\
    \    // poped as the min cost path, and then whenever popping an item, we put\n\
    \    // back the neighbors with the updated cost. This is an optimized version\n\
    \    // of Dijkstra's algorithm.\n    let mut heap = BinaryHeap::new();\n    //\
    \ The cost is the negation of the cell value.\n    heap.push(Item {\n        path:\
    \ vec![grid[0][0]],\n        cost: -grid[0][0],\n        r: 0,\n        c: 0,\n\
    \    });\n    let mut min_path = vec![];\n    let mut visited = vec![vec![false;\
    \ n]; n];\n    while let Some(item) = heap.pop() {\n        if item.path.len()\
    \ as isize == k {\n            min_path = item.path;\n            break;\n   \
    \     }\n        visited[item.r][item.c] = true;\n        for &(dr, dc) in &[(-1,\
    \ 0), (1, 0), (0, -1), (0, 1)] {\n            let nr = item.r as isize + dr;\n\
    \            let nc = item.c as isize + dc;\n            if nr >= 0 && nr < n\
    \ as isize && nc >= 0 && nc < n as isize\n                && !visited[nr as usize][nc\
    \ as usize]\n            {\n                heap.push(Item {\n               \
    \     path: append_path(&item.path, grid[nr as usize][nc as usize]),\n       \
    \             cost: item.cost - grid[nr as usize][nc as usize],\n            \
    \        r: nr as usize,\n                    c: nc as usize,\n              \
    \  });\n            }\n        }\n    }\n    min_path", "    let n = grid.len();\n\
    \    let mut queue = BinaryHeap::new();\n    queue.push(State::new(0, 0, k, n));\n\
    \    let mut result = Vec::new();\n    let mut visited = HashSet::new();\n   \
    \ while !queue.is_empty() {\n        let cur = queue.pop().unwrap();\n       \
    \ if cur.x < 0 || cur.x >= n as isize || cur.y < 0 || cur.y >= n as isize ||\n\
    \            cur.steps < 0 || cur.val > n as isize * n as isize ||\n         \
    \   visited.contains(&(cur.x, cur.y, cur.steps)) {\n            continue;\n  \
    \      }\n        if cur.steps == 0 {\n            result.push(cur.val);\n   \
    \         continue;\n        }\n        visited.insert((cur.x, cur.y, cur.steps));\n\
    \        queue.push(State::new(cur.x + 1, cur.y, cur.steps - 1, n));\n       \
    \ queue.push(State::new(cur.x - 1, cur.y, cur.steps - 1, n));\n        queue.push(State::new(cur.x,\
    \ cur.y + 1, cur.steps - 1, n));\n        queue.push(State::new(cur.x, cur.y -\
    \ 1, cur.steps - 1, n));\n    }\n    let mut i = 0;\n    while i < result.len()\
    \ {\n        if !visited.contains(&(result[i] % n as isize, result[i] / n as isize,\
    \ 0)) {\n            result.remove(i);\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result.sort();\n    result", "    let n = grid.len();\n\
    \    let mut dp = vec![vec![-1; n]; n];\n    let mut dp_sum = vec![vec![-1; n];\
    \ n];\n    let mut res = vec![0; k as usize];\n    dfs(&grid, k, 0, 0, &mut dp,\
    \ &mut dp_sum, &mut res, 0, 0);\n    res", "    let mut ans = Vec::new();\n  \
    \  for _ in 0..k {\n        ans.push(0);\n    }\n    let mut dp = vec![vec![Vec::new();\
    \ grid.len()]; grid.len()];\n    let mut min_path = Vec::new();\n    let mut min_val\
    \ = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[0].len() {\n  \
    \          if i == 0 && j == 0 {\n                dp[i][j].push(grid[i][j]);\n\
    \                min_path = dp[i][j].clone();\n                min_val = grid[i][j];\n\
    \            } else {\n                let mut this_path = Vec::new();\n     \
    \           let mut this_val = 0;\n                if i > 0 {\n              \
    \      if grid[i][j] < dp[i - 1][j][0] {\n                        this_path =\
    \ vec![grid[i][j]];\n                        this_val = grid[i][j];\n        \
    \            } else if grid[i][j] == dp[i - 1][j][0] {\n                     \
    \   this_path = vec![grid[i][j]];\n                        this_val = grid[i][j];\n\
    \                        let mut ii = i - 1;\n                        let mut\
    \ jj = j;\n                        let mut idx = 0;\n                        while\
    \ ii >= 0 && idx < dp[i - 1][j].len() {\n                            this_path.push(dp[ii][jj][idx]);\n\
    \                            ii -= 1;\n                            idx += 1;\n\
    \                        }\n                    } else {\n                   \
    \     this_path = dp[i - 1][j].clone();\n                        this_val = dp[i\
    \ - 1][j][0];\n                    }\n                }\n                if j\
    \ > 0 {\n                    if grid[i][j] < dp[i][j - 1][0] {\n             \
    \           this_path = vec![grid[i][j]];\n                        this_val =\
    \ grid[i][j];\n                    } else if grid[i][j] == dp[i][j - 1][0] {\n\
    \                        if", "    use std::collections::{HashMap, HashSet};\n\
    \    use std::cmp::{Ord, Ordering};\n    use std::rc::Rc;\n    use std::cell::RefCell;\n\
    \    use std::ops::Deref;\n    use itertools::Itertools;\n    use bimap::BiMap;\n\
    \    use multi_map::MultiMap;\n    use std::borrow::Borrow;\n    use std::hash::Hash;\n\
    \    use std::fmt::Debug;\n    use std::fmt::{Formatter, Error};\n    use crate::utils::tree::TreeNode;\n\
    \    use std::borrow::BorrowMut;\n    use crate::utils::linked_list::LinkedList;\n\
    \    use crate::utils::linked_list::ListNode;\n    use crate::utils::linked_list::List;\n\
    \    use crate::utils::tree::Tree;\n    use crate::utils::tree::BinaryTree;\n\
    \    use crate::utils::hash_tables::HashTable;\n    use crate::utils::hash_tables::HashTableSeparateChaining;\n\
    \    use crate::utils::hash_tables::Entry;\n    use crate::utils::array::Array;\n\
    \    use crate::utils::graph::Graph;\n    use crate::utils::graph::GraphWeighted;\n\
    \    use crate::utils::graph::Node;\n    use crate::utils::graph::Arc;\n    use\
    \ crate::utils::graph::Edge;\n    use crate::utils::graph::DirectedGraph;\n  \
    \  use crate::utils::graph::DirectedGraphWeighted;\n    use crate::utils::graph::NodeIndex;\n\
    \    use crate::utils::graph::WeightedNode;\n    use crate::utils::graph::WeightedEdge;\n\
    \    use crate::utils::graph::WeightedArc;\n    use crate::utils::graph::UndirectedGraph;\n\
    \    use crate::utils::graph::UndirectedGraphWeighted;\n    use crate::utils::graph::Kruskal;\n\
    \    use crate::utils::graph::Prim;\n    use crate::utils::graph::Dijkstra;\n\
    \    use crate::utils::graph::KruskalTree;\n    use crate::utils::graph::PrimTree",
  "    let n = grid.len();\n    let mut full_paths = vec![];\n    // To find the min\
    \ path of length k we can get every possible path\n    // and compare them.\n\
    \    // We choose to not start with the path of length 1 since if the k is\n \
    \   // relatively small, this way we will find the min path faster.\n    for _\
    \ in 0..(n * n - k) {\n        full_paths.push(Path { path: vec![], visited: vec![],\
    \ cost: 0 });\n    }\n    for i in 0..n {\n        for j in 0..n {\n         \
    \   get_paths(i, j, k, &grid, &mut full_paths);\n        }\n    }\n    let mut\
    \ min_path = full_paths[0].path.clone();\n    for full_path in full_paths {\n\
    \        if full_path.path < min_path {\n            min_path = full_path.path.clone();\n\
    \        }\n    }\n    min_path", "    let mut answer = Vec::new();\n    let rows\
    \ = grid.len();\n    let cols = grid[0].len();\n    let mut min_paths = vec![Vec::new();\
    \ rows * cols + 1];\n    for col in 0..cols {\n        for row in 0..rows {\n\
    \            min_paths[grid[row][col] as usize] = vec![row, col];\n        }\n\
    \    }\n    for i in 1..(rows * cols + 1) {\n        let row = min_paths[i][0];\n\
    \        let col = min_paths[i][1];\n        if row > 0 && grid[row - 1][col]\
    \ < grid[row][col] {\n            min_paths[i] = vec![row - 1, col];\n       \
    \ } else if row < rows - 1 && grid[row + 1][col] < grid[row][col] {\n        \
    \    min_paths[i] = vec![row + 1, col];\n        } else if col > 0 && grid[row][col\
    \ - 1] < grid[row][col] {\n            min_paths[i] = vec![row, col - 1];\n  \
    \      } else if col < cols - 1 && grid[row][col + 1] < grid[row][col] {\n   \
    \         min_paths[i] = vec![row, col + 1];\n        }\n    }\n    let mut first_cell\
    \ = 1;\n    for _ in 0..k {\n        answer.push(first_cell);\n        first_cell\
    \ = grid[min_paths[first_cell][0]][min_paths[first_cell][1]];\n    }\n    answer",
  "    let (m, n) = (grid.len(), grid[0].len());\n    let mut grid = grid;\n    for\
    \ r in 0..m {\n        for c in 0..n {\n            grid[r][c] = grid[r][c] +\
    \ ((r + 1) * n + c + 1) as isize;\n        }\n    }\n    let mut start_points\
    \ = Vec::with_capacity(m * n);\n    for i in 0..m {\n        for j in 0..n {\n\
    \            start_points.push((i, j));\n        }\n    }\n    start_points.sort_by_key(|&(i,\
    \ j)| grid[i][j]);\n    let mut best_path = vec![];\n    let mut best_cost = -1;\n\
    \    for &(i, j) in &start_points {\n        let (path, cost) = sp(i, j, m, n,\
    \ &grid, k);\n        if best_cost == -1 || cost < best_cost || (cost == best_cost\
    \ && path < best_path) {\n            best_path = path;\n            best_cost\
    \ = cost;\n        }\n    }\n    best_path", "    // (1) The answer is between\
    \ 1 and N * N\n    // (2) If you were to take the lexicographically smallest path\
    \ of length k\n    // between two cells, this will be the path that maximizes\
    \ the number of \n    // times that you go down (you will only turn right or down).\n\
    \    // (3) You can start at any cell.\n\n    // For every cell (i, j), let the\
    \ number of the cells in the path that go\n    // through (i, j) be 1. For every\
    \ cell (i, j), let the sum of the numbers\n    // of the cells in the paths that\
    \ go through (i, j) be the value of cell\n    // (i, j).\n    // For every cell\
    \ (i, j), let the number of the paths that go through (i, j) be 0.\n    // For\
    \ every cell (i, j), let the sum of the numbers of the paths that go through (i,\
    \ j) be 0.\n    // For every cell (i, j), let the number of the paths that\n \
    \   // ends at (i, j) and has length k be 0.\n\n    // The cell (i, j) is going\
    \ to be considered only if it has value at most k.\n    // The cell (i, j) is\
    \ going to be considered only if it is possible that we can go\n    // through\
    \ it in a path of length k.\n    // We need to be able to go through a path that\
    \ goes through a cell (i, j) \n    // with value at most k. We are able to go\
    \ through a path that goes through\n    // a cell (i, j) with value v, if and\
    \ only if there exist a path that goes\n    // through a cell (i - 1, j) with\
    \ value v - grid[i][j] or a path that goes\n    // through a cell (i, j - 1) with\
    \ value v - grid[i][j].\n    // If a path goes through a cell (i, j) with value\
    \ v, then the minimum path\n    // that we can take from (i, j) to (1, 1) in length\
    \ k - v is the path that\n    // maximizes the number of times that we go down\
    \ (we will only turn right or down).\n    // If", "    let mut cache = HashMap::new();\n\
    \    let mut grid = grid;\n    let n = grid.len();\n    for i in 0..n {\n    \
    \    for j in 0..n {\n            grid[i][j] = grid[i][j] - 1;\n        }\n  \
    \  }\n    let grid = grid;\n    let mut start = (0, 0);\n    for i in 0..n {\n\
    \        for j in 0..n {\n            let cache_value = cache.entry((i, j)).or_insert(None);\n\
    \            if *cache_value == None {\n                let mut path = vec![];\n\
    \                dfs(&grid, &mut path, &mut cache, k, i, j);\n               \
    \ *cache_value = Some(path);\n            }\n            if *cache_value != None\
    \ && (*cache_value).as_ref().unwrap().len() == k as usize {\n                if\
    \ cache_value.as_ref().unwrap() < &start {\n                    start = (i, j);\n\
    \                }\n            }\n        }\n    }\n    cache.get(&start).unwrap().as_ref().unwrap().clone()",
  "    if grid.is_empty() || grid[0].is_empty() {\n        return vec![];\n    }\n\
    \    let n = grid.len();\n    let mut visited = vec![vec![vec![]; n]; n];\n  \
    \  let mut pq = BinaryHeap::new();\n    pq.push(SavedPath::new(0, 0, grid[0][0],\
    \ grid[0][0], Vec::new()));\n    while !pq.is_empty() {\n        let path = pq.pop().unwrap();\n\
    \        let (i, j, sum, _, _) = path.0;\n        if visited[i][j].contains(&sum)\
    \ {\n            continue;\n        }\n        visited[i][j].push(sum);\n    \
    \    if path.1.len() == k as usize {\n            return path.1;\n        }\n\
    \        if i > 0 {\n            pq.push(SavedPath::new(i - 1, j, sum + grid[i\
    \ - 1][j], grid[i - 1][j],\n                                   path.1.clone()));\n\
    \        }\n        if i < n - 1 {\n            pq.push(SavedPath::new(i + 1,\
    \ j, sum + grid[i + 1][j], grid[i + 1][j],\n                                 \
    \  path.1.clone()));\n        }\n        if j > 0 {\n            pq.push(SavedPath::new(i,\
    \ j - 1, sum + grid[i][j - 1], grid[i][j - 1],\n                             \
    \      path.1.clone()));\n        }\n        if j < n - 1 {\n            pq.push(SavedPath::new(i,\
    \ j + 1, sum + grid[i][j + 1], grid[i][j + 1],\n                             \
    \      path.1.clone()));\n        }\n    }\n    vec![]", "    let mut answer =\
    \ std::vec::Vec::new();\n    let mut grid = grid;\n    let n = grid.len();\n \
    \   if n == 0 {\n        return answer;\n    }\n    let mut visited = HashSet::new();\n\
    \    let mut heap = BinaryHeap::new();\n    let mut current = (0, 0, grid[0][0]);\n\
    \    heap.push(Ordering::Greater(current));\n    visited.insert(current);\n  \
    \  while k > 0 {\n        current = heap.pop().unwrap().0;\n        if visited.contains(&current)\
    \ {\n            continue;\n        }\n        answer.push(current.2);\n     \
    \   k -= 1;\n        visited.insert(current);\n        let row = current.0;\n\
    \        let col = current.1;\n        let new_row = row + 1;\n        let new_col\
    \ = col + 1;\n        if new_row < n {\n            let new_item = (new_row, col,\
    \ grid[new_row][col]);\n            if !visited.contains(&new_item) {\n      \
    \          heap.push(Ordering::Greater(new_item));\n            }\n        }\n\
    \        if new_col < n {\n            let new_item = (row, new_col, grid[row][new_col]);\n\
    \            if !visited.contains(&new_item) {\n                heap.push(Ordering::Greater(new_item));\n\
    \            }\n        }\n    }\n    answer", "    let n = grid.len();\n    assert!(n\
    \ > 1);\n    assert!(n <= 10);\n    assert!(k >= 1);\n    assert!(k <= n as isize\
    \ * n as isize);\n    let mut res = vec![0; k as usize];\n    let mut curr = isize::MAX;\n\
    \    let mut min = curr;\n    let mut min_iter = vec![0; k as usize];\n    let\
    \ mut st = Vec::with_capacity(k as usize);\n    let mut used = vec![false; n];\n\
    \    backtrack(0, 0, k, &grid, &mut res, &mut curr, &mut min, &mut min_iter, &mut\
    \ st, &mut used);\n    min_iter", "    let mut memo = HashMap::new();\n    //\
    \ dfs the grid and return the minimum path of length k\n    let mut result = None;\n\
    \    dfs(&grid, k, &mut memo, &mut result);\n    if let Some(v) = result {\n \
    \       v\n    } else {\n        vec![]\n    }", "    let n = grid.len();\n  \
    \  let mut dp = vec![vec![None; n]; n];\n    let mut ans = vec![0; k as usize];\n\
    \    dfs(0, 0, k, &grid, &mut dp, &mut ans, 0, 0);\n    ans", "    let (m, n)\
    \ = (grid.len(), grid[0].len());\n    let mut coords = vec![];\n    let mut dist\
    \ = vec![];\n    let (mut x, mut y) = (0, 0);\n    let mut min = grid[x][y];\n\
    \    for i in 0..m {\n        for j in 0..n {\n            if grid[i][j] < min\
    \ {\n                x = i;\n                y = j;\n                min = grid[i][j];\n\
    \            }\n        }\n    }\n    coords.push((x, y));\n    dist.push(0);\n\
    \    let mut min_seq = vec![];\n    for _ in 0..k {\n        min_seq.push(grid[x][y]);\n\
    \    }\n    let mut q = (coords, dist);\n    let mut visited = vec![];\n    while\
    \ q.0.len() > 0 {\n        let (mut new_coords, mut new_dist) = (vec![], vec![]);\n\
    \        for i in 0..q.0.len() {\n            let (mut x, mut y) = q.0[i];\n \
    \           let mut d = q.1[i];\n            if x > 0 && grid[x - 1][y] < grid[x][y]\
    \ {\n                if visited.contains(&(x - 1, y)) {\n                    continue;\n\
    \                }\n                if d < k {\n                    new_coords.push((x\
    \ - 1, y));\n                    new_dist.push(d + 1);\n                }\n  \
    \          }\n            if x < m - 1 && grid[x + 1][y] < grid[x][y] {\n    \
    \            if visited.contains(&(x + 1, y)) {\n                    continue;\n\
    \                }\n                if d < k {\n                    new_coords.push((x\
    \ + 1, y));\n                    new_dist.push(d + 1);\n                }\n  \
    \          }\n            if y > 0 && grid[x][y - 1] < grid[x][y] {\n        \
    \        if visited.contains(&(x, y - 1)) {\n                    continue;\n \
    \               }\n                if", "    let mut r = vec![];\n    let mut\
    \ queue = MinQueue::new();\n    let mut visited = vec![vec![false; grid.len()];\
    \ grid.len()];\n    queue.push(Node::new(grid[0][0], 0, 0, 0));\n    visited[0][0]\
    \ = true;\n    while let Some(Node{val, row, col, cost}) = queue.pop() {\n   \
    \     r.push(val);\n        if cost == k { break; }\n        if row > 0 && !visited[row\
    \ - 1][col] {\n            queue.push(Node::new(grid[row - 1][col], row - 1, col,\
    \ cost + 1));\n            visited[row - 1][col] = true;\n        }\n        if\
    \ row < grid.len() - 1 && !visited[row + 1][col] {\n            queue.push(Node::new(grid[row\
    \ + 1][col], row + 1, col, cost + 1));\n            visited[row + 1][col] = true;\n\
    \        }\n        if col > 0 && !visited[row][col - 1] {\n            queue.push(Node::new(grid[row][col\
    \ - 1], row, col - 1, cost + 1));\n            visited[row][col - 1] = true;\n\
    \        }\n        if col < grid.len() - 1 && !visited[row][col + 1] {\n    \
    \        queue.push(Node::new(grid[row][col + 1], row, col + 1, cost + 1));\n\
    \            visited[row][col + 1] = true;\n        }\n    }\n    r", "    let\
    \ n = grid.len();\n    if n == 0 {\n        return vec![];\n    }\n    let m =\
    \ grid[0].len();\n    if m == 0 {\n        return vec![];\n    }\n    let mut\
    \ vis = vec![vec![false; m]; n];\n    let mut min_cost = vec![vec![1 << 30; m];\
    \ n];\n    let mut min_path = vec![vec![vec![]; m]; n];\n    let mut que = VecDeque::new();\n\
    \    que.push_back((0, 0, k));\n    while !que.is_empty() {\n        let (x, y,\
    \ r) = que.pop_front().unwrap();\n        if r < 0 {\n            continue;\n\
    \        }\n        if r == 0 {\n            min_cost[x][y] = 0;\n           \
    \ min_path[x][y] = vec![grid[x][y]];\n            continue;\n        }\n     \
    \   let mut dirs = vec![(0, 1), (0, -1), (1, 0), (-1, 0)];\n        dirs.sort_by_key(|&(dx,\
    \ dy)| {\n            if x + dx < 0 || x + dx >= n || y + dy < 0 || y + dy >=\
    \ m {\n                return 1 << 30;\n            }\n            return grid[x\
    \ + dx][y + dy];\n        });\n        for &(dx, dy) in dirs.iter() {\n      \
    \      if x + dx < 0 || x + dx >= n || y + dy < 0 || y + dy >= m {\n         \
    \       continue;\n            }\n            if !vis[x + dx][y + dy] || min_cost[x\
    \ + dx][y + dy] > min_cost[x][y] + 1 ||\n                (min_cost[x + dx][y +\
    \ dy] == min_cost[x][y] + 1 &&\n                    lexicographical_cmp(min_path[x\
    \ + dx][y + dy].as_mut_slice(),\n                                        &mut\
    \ [&grid[x][y]].to_vec())) {\n                vis[x + dx][y + dy]"]
stop_tokens:
- "\n}"
