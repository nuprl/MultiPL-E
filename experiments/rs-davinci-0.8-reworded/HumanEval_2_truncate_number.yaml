name: HumanEval_2_truncate_number
language: rs
prompt: "/// Given a positive floating point number, it can be decomposed into\n///\
  \ and integer part (largest integer smaller than given number) and decimals\n///\
  \ (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
  \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
  \ 0.0);\n}\n"
completions: ['    number - number.floor()', "    let integer_part = number.floor();\n\
    \    number - integer_part", "    let integer_part = number.floor();\n    number\
    \ - integer_part", '    (number.fract() * 10_f64).round() / 10_f64', '    number
    - number.floor()', "    let integer_part = number.floor();\n    number - integer_part",
  "    match number.trunc() {\n        num if num > number => num - 1.0,\n       \
    \ num => num,\n    }", '    return (number as i64) as f64;', '    number - number.floor()',
  '    number.fract()', '    number - number.floor()', "    let int_part = number.floor();\n\
    \    number - int_part", "    let s = number.to_string();\n    let f64_length\
    \ = s.len() as i32;\n    let decimal_index = s.find('.').unwrap_or(f64_length);\n\
    \    let decimal_part_length = f64_length - decimal_index - 1;\n    if decimal_part_length\
    \ == 0 {\n        0.0\n    } else {\n        number.fract()\n    }", "    let\
    \ (integer, decimal) = split_integer_decimal(number);\n    decimal", '    number
    - number.floor()', '    number - number.floor()', '    number - number.floor()',
  "    let number_truncated = number.trunc();\n    number - number_truncated", '    return
    number.fract();', '    number - (number as i64) as f64']
stop_tokens:
- "\n}"
