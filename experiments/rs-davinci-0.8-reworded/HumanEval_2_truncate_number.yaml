name: HumanEval_2_truncate_number
language: rs
prompt: "/// Given a positive floating point number, it can be decomposed into\n///\
  \ and integer part (largest integer smaller than given number) and decimals\n///\
  \ (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
  \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
  \ 0.0);\n}\n"
completions: ['    number - number.floor()', "    let integer_part = number.floor();\n\
    \    number - integer_part", "    let integer_part = number.floor();\n    number\
    \ - integer_part", '    (number.fract() * 10_f64).round() / 10_f64', '    number
    - number.floor()', "    let integer_part = number.floor();\n    number - integer_part",
  "    match number.trunc() {\n        num if num > number => num - 1.0,\n       \
    \ num => num,\n    }", '    return (number as i64) as f64;', '    number - number.floor()',
  '    number.fract()', '    number - number.floor()', "    let int_part = number.floor();\n\
    \    number - int_part", "    let s = number.to_string();\n    let f64_length\
    \ = s.len() as i32;\n    let decimal_index = s.find('.').unwrap_or(f64_length);\n\
    \    let decimal_part_length = f64_length - decimal_index - 1;\n    if decimal_part_length\
    \ == 0 {\n        0.0\n    } else {\n        number.fract()\n    }", "    let\
    \ (integer, decimal) = split_integer_decimal(number);\n    decimal", '    number
    - number.floor()', '    number - number.floor()', '    number - number.floor()',
  "    let number_truncated = number.trunc();\n    number - number_truncated", '    return
    number.fract();', '    number - (number as i64) as f64', "    let integer_part\
    \ = number.floor();\n    number - integer_part", '    return number - number.floor();',
  '    return number - number.floor();', "    if number.is_sign_positive() {\n   \
    \     number.fract()\n    } else {\n        number.fract() + 1.0\n    }", '    number.fract()',
  '    (number - number.floor())', '    number - number.floor()', '    number - number.floor()',
  '    number - number.floor()', "    // TODO\n    unimplemented!();", "    let int\
    \ = number.floor();\n    number - int", '    number - number.floor()', "    let\
    \ _integer_part = number.trunc();\n    let _decimal_part = number - _integer_part;\n\
    \    _decimal_part", "    if number.is_sign_positive() {\n        number.fract()\n\
    \    } else {\n        1.0 - (number.abs().fract())\n    }", '    number - number.floor()',
  '    number.fract()', "    let mut number = number;\n    loop {\n        if number\
    \ < 1.0 {\n            return number;\n        }\n        number -= 1.0;\n   \
    \ }", '    (number * 10.0).trunc() / 10.0', "    let integer_part = number.floor();\n\
    \    let decimal_part = number - integer_part;\n    decimal_part", "    let int_part\
    \ = number.floor();\n    number - int_part", '    number - number.floor()', '    number
    - number.floor()', '    number.fract()', '    number.fract()', "    let mut number\
    \ = number;\n    let mut res = 0f64;\n    while number > 1f64 {\n        number\
    \ -= 1f64;\n    }\n    res = number;\n    res", '    number.fract()', '    number
    - number.floor()', '    (number - number.floor())', '    number - number.floor()',
  '    number.fract()', '    return number - number.floor();', "    let integer_part\
    \ = number.floor();\n    return number - integer_part;", '    number.fract()',
  '    number.fract()', "    if number > 0.0 {\n        number - (number as i64) as\
    \ f64\n    } else {\n        number - (number as i64 - 1) as f64\n    }", '    (number
    % 1.0).abs()', "    // TODO: replace println! with the correct return value\n\
    \    if number > 0.0 {\n        let decimal = number - number.floor();\n     \
    \   decimal\n    } else {\n        let decimal = number - number.ceil();\n   \
    \     decimal\n    }", '    number - number.floor()', '    number.fract()', '    return
    (number * 10.0).trunc() / 10.0;', '    number - number.floor()', '    number.fract()',
  '    number.fract()', '    number.fract()', '    number - number.floor()', '    number
    - number.floor()', '    number.fract()', '    number - number.floor()', '    number
    - (number as i64) as f64', '    number - number.floor()', '    number - number.floor()',
  "    let integer = number.floor();\n    number - integer", '    number.fract()',
  "    if number < 0.0 {\n        1.0 + (number - number.floor())\n    } else {\n\
    \        number - number.floor()\n    }", '    return number - (number as i64)
    as f64;', "    // TODO\n    return 0.0;", '    number - number.floor()', "   \
    \ let int_part = number.floor();\n    let float_part = number - int_part;\n  \
    \  float_part", "    if number < 0.0 {\n        panic!(\"Number must be positive\"\
    );\n    }\n\n    number - number.floor()", '    number - number.floor()', '    number.fract()',
  '    number - number.floor()', "    let integer = number.floor();\n    let decimal\
    \ = number - integer;\n    return decimal;", '    return number.fract();', '    number
    - (number as i64) as f64', "    let number_int = number.floor();\n    number -\
    \ number_int", '    number - number.floor()', '    return number - number.floor();',
  '    number - number.floor()', '    number - number.floor()', "    let mut truncated\
    \ = number.trunc();\n    if number > 0.0 {\n        truncated = number.trunc()\
    \ - 1.0;\n    }\n    number - truncated", '    number.fract()', "    let integral:\
    \ i64 = number.trunc() as i64;\n    number - integral as f64", "    // We cannot\
    \ take modulo of floating point numbers\n    // so we must make use of the property\
    \ that\n    // (number - (number as integer)) is the left over part\n    number\
    \ - number.floor()", '    number - (number as i64) as f64', '    number.fract()',
  '    number - number.floor()', "    let (integer, decimal) = number.modf();\n  \
    \  return decimal;", '    number - number.floor()', '    number - number.floor()',
  '    number - (number as i64) as f64', "    let (int_part, dec_part) = decompose_number(number);\n\
    \    dec_part", '    number - number.floor()', "    let trunc = number.trunc();\n\
    \    number - trunc", "    let i = number.floor();\n    number - i", "    let\
    \ mut number = number;\n    let negative = number < 0.0;\n    if negative {\n\
    \        number = -number;\n    }\n    let mut int_part = number as u64;\n   \
    \ let decimals = number - (int_part as f64);\n    if negative {\n        -decimals\n\
    \    } else {\n        decimals\n    }", '    number - number.floor()', '    return
    number.fract();', '    number - number.floor()', "    if number >= 0.0 {\n   \
    \     number - number.floor()\n    } else {\n        number - number.ceil()\n\
    \    }", "    let integer_part = number.floor();\n    number - integer_part",
  '    number - number.floor()', '    number - number.floor()', '    number - number.floor()',
  "    // TODO: complete\n    number.fract()", '    number - number.floor()', '    number
    - number.floor()', '    number.trunc()', '    number - number.floor()', "    if\
    \ number.is_sign_positive() {\n        number - number.floor()\n    } else {\n\
    \        number - number.ceil()\n    }", "    let mut number = number;\n    while\
    \ number >= 1.0 {\n        number -= 1.0;\n    }\n    number", "    let decimals\
    \ = number.fract();\n    decimals", '    number - number.floor()', '    return
    number - number.floor();', "    let abs_number = number.abs();\n    let result\
    \ = abs_number - abs_number.floor();\n    number.signum() * result", '    number
    - number.floor()', "    let number = number.abs();\n    let rounded = number.round();\n\
    \    let integer = rounded.floor();\n    return number - integer;", '    number
    - number.floor()', '    number - (number as i64) as f64', "    let fraction =\
    \ number.fract();\n    if fraction > 0.0 {\n        return fraction;\n    }\n\
    \    1.0 + fraction", "    if number.is_sign_positive() {\n        return number\
    \ - (number as i64) as f64;\n    }\n    number - (number as i64) as f64 + 1.0",
  '    number - number.floor()', "    if number < 0.0 {\n        panic!(\"Cannot truncate\
    \ negative number\");\n    }\n    number.fract()", '    number - number.floor()',
  "    let (integer, decimal) = get_integer_and_decimal(number);\n    if integer <\
    \ 0.0 {\n        (integer - 1.0) + decimal\n    } else {\n        decimal\n  \
    \  }", "    let integer = number.floor();\n    let decimal = number - integer;\n\
    \    decimal", '    number - number.floor()', '    number - number.floor()', " \
    \   let rounded_number = number.round();\n    if rounded_number > number {\n \
    \       rounded_number - number\n    } else {\n        number - rounded_number\n\
    \    }", "    let int_part = number.floor();\n    return number - int_part;",
  '    number - number.floor()', '    return number - number.floor();', "    if number\
    \ < 0.0 {\n        number.abs() % 1.0\n    } else {\n        number % 1.0\n  \
    \  }", '    number.fract()', '    number - number.floor()', "    if number >=\
    \ 0.0 {\n        number.fract()\n    } else {\n        1.0 + number.fract()\n\
    \    }", "    match number.fract() {\n        f if f > 0.0 => f,\n        _ =>\
    \ 0.0,\n    }", "    let integer_part = number.floor();\n    return number - integer_part;",
  '    number.fract()', '    number - number.floor()', '    number.fract()', "   \
    \ // define a number always greater than 1\n    let ten = 10.0;\n    // truncate\
    \ the integer part of the number\n    let int_part = number.trunc();\n    // remove\
    \ the integer part of the number\n    let dec_part = number - int_part;\n    //\
    \ power of 10 that makes the decimal part an integer\n    let dec_mult = ten.powf(dec_part.abs().log10().ceil());\n\
    \    // round decimals to integer to avoid floating point issues\n    let dec_int\
    \ = (dec_part * dec_mult).round();\n    // return decimal part of number\n   \
    \ return dec_int / dec_mult;", '    number - number.floor()', "    let trunc_part\
    \ = (number as u64) as f64;\n    number - trunc_part", '    number - number.floor()',
  "    let int_part = number.floor();\n    number - int_part", "    // truncate_number(3.5)\
    \ -> 3\n    let truncate_number = number.trunc();\n    // 3.5 - 3 -> 0.5\n   \
    \ number - truncate_number", "    let remainder = number.fract();\n    if remainder\
    \ < 0.0 {\n        1.0 + remainder\n    } else {\n        remainder\n    }", '    number
    - number.floor()', "    let integer_part = number.floor();\n    number - integer_part",
  '    number - number.floor()', '    number - (number as i64) as f64', "    if number\
    \ > 0.0 {\n        number - number.floor()\n    } else {\n        number - number.ceil()\n\
    \    }", "    let (int_part, dec_part) = number.modf();\n    dec_part", '    number.fract()',
  "    let number_truncated = number.trunc();\n    return number - number_truncated;",
  "    if number >= 0.0 {\n        number - number.floor()\n    } else {\n       \
    \ number - number.ceil()\n    }", '    number - number.floor()', '    number.fract()',
  '    number - number.floor()', '    number.fract()', "    let i_part = number.trunc();\n\
    \    number - i_part", '    number.fract()', "    let number_int = number.floor();\n\
    \    number - number_int", "    let integer_part = number.floor();\n    number\
    \ - integer_part", '    number - number.floor()', '    (number - number.floor())',
  "    let integer_part = number.floor();\n    number - integer_part", '    number.fract()',
  '    number.fract()', "    if number >= 0.0 {\n        number.fract()\n    } else\
    \ {\n        1.0 + number.fract()\n    }", '    number.fract()', "    if number\
    \ > 0.0 {\n        (number - number.floor())\n    } else {\n        (number -\
    \ number.ceil())\n    }", "    let num_string = number.to_string();\n    let split:\
    \ Vec<&str> = num_string.split(\".\").collect();\n    match split.len() {\n  \
    \      2 => split[1].parse::<f64>().unwrap() / 10.0_f64.powf(split[1].len() as\
    \ f64),\n        _ => 0.0,\n    }", '    number.trunc()', '    number.fract()',
  '    number - (number as i64) as f64', '    number - number.floor()', '    number
    - number.floor()', '    (number - (number as i64) as f64)', "    let int_part\
    \ = number.floor();\n    number - int_part", "    let decimal_part = number -\
    \ number.floor();\n    decimal_part", "    let integer_part = number.floor();\n\
    \    let decimal_part = number - integer_part;\n    decimal_part", '    return
    number - (number as i64) as f64;', '    number - number.floor()', '    return
    number.fract();', "    let truncated = number.trunc();\n    number - truncated",
  '    number.fract()', '    number - number.floor()', '    return number.fract();']
stop_tokens:
- "\n}"
