language: rs
name: HumanEval_128_prod_signs
results:
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = 1;\n \
    \   let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n            product\
    \ *= -1;\n        }\n        sum += i.abs();\n    }\n    if sum == 0 {\n     \
    \   return None;\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpq7i1jszo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        if n > 0 {\n            prod *= 1;\n        } else if n\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += n.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"value of\
    \ product of signs of arr: {:?}\", arr);\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: value of product of signs
    of arr: [1, 2, 2, -4]'', /tmp/tmp3q19sgdq.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    match arr.len() {\n    \
    \    0 => None,\n        _ => {\n            let mut s = 1;\n            let mut\
    \ sum = 0;\n            for i in arr {\n                if i > 0 {\n         \
    \           sum += i;\n                } else if i < 0 {\n                   \
    \ sum += i.abs();\n                    s *= -1;\n                }\n         \
    \   }\n            Some(sum * s)\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpxrgn7tf_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        match n.signum() {\n            1 => {\n               \
    \ res *= 1;\n                sum += n;\n            }\n            -1 => {\n \
    \               res *= -1;\n                sum += n.abs();\n            }\n \
    \           _ => {}\n        }\n    }\n    Some(sum * res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmbkulqta.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let mut signs = vec![];\n    let mut magnitudes = vec![];\n   \
    \ for i in &arr {\n        let s = if *i > 0 { 1 } else if *i < 0 { -1 } else\
    \ { 0 };\n        signs.push(s);\n        magnitudes.push(i.abs());\n    }\n \
    \   let sign_prod = signs.iter().product();\n    Some(magnitudes.iter().sum::<isize>()\
    \ * sign_prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqa9bzjio.rs:21:9\n\
    \   |\n21 |     let sign_prod = signs.iter().product();\n   |         ^^^^^^^^^\
    \ consider giving `sign_prod` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * arr.iter().map(|x| x.signum()).product::<isize>())\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        match i.cmp(&0) {\n            Ordering::Less => {\n\
    \                total *= -1;\n                sum += i.abs();\n            }\n\
    \            Ordering::Greater => {\n                sum += i;\n            }\n\
    \            Ordering::Equal => {}\n        }\n    }\n    Some(total * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpay11bhsc.rs:20:13\n   |\n20 |             Ordering::Less => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpay11bhsc.rs:24:13\n\
    \   |\n24 |             Ordering::Greater => {\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpay11bhsc.rs:27:13\n   |\n27 |             Ordering::Equal\
    \ => {}\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut mult = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            mult *= 1;\n        } else if i\
    \ < 0 {\n            mult *= -1;\n        } else {\n            mult *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * mult)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let product = arr.iter().map(|&n| n.signum()).product();\n\
    \    let sum = arr.iter().map(|&n| n.abs()).sum();\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpihppxql5.rs:16:9\n\
    \   |\n16 |     let product = arr.iter().map(|&n| n.signum()).product();\n   |\
    \         ^^^^^^^ consider giving `product` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(None, |acc,\
    \ x| match acc {\n        None => Some(if *x > 0 { 1 } else if *x < 0 { -1 } else\
    \ { 0 }),\n        Some(signs) => Some(signs * if *x > 0 { 1 } else if *x < 0\
    \ { -1 } else { 0 }),\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpe9rjc01x.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"prod_signs({:?})\"\
    , arr)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: prod_signs([1, 2, 2, -4])'',
    /tmp/tmpxbp4aza7.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().fold(0, |acc, x| acc + x.abs());\n\
    \    let product = arr.iter().fold(1, |acc, x| {\n        match x {\n        \
    \    x if x > &0 => acc * 1,\n            x if x < &0 => acc * -1,\n         \
    \   _ => acc * 0,\n        }\n    });\n    Some(sum * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // your code goes here\n\
    \    match arr.len() {\n        0 => None,\n        _ => {\n            let prod\
    \ = arr.iter().fold(1, |prod, i| prod * i.signum());\n            let sum = arr.iter().map(|i|\
    \ i.abs()).sum();\n            Some(prod * sum)\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpgpgmt6j6.rs:18:17\n\
    \   |\n18 |             let sum = arr.iter().map(|i| i.abs()).sum();\n   |   \
    \              ^^^ consider giving `sum` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ x in arr {\n        match x.signum() {\n            0 => continue,\n       \
    \     -1 => prod *= -1,\n            _ => (),\n        }\n        sum += x.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpfz391y0v.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for x in arr {\n        sum += x.abs();\n  \
    \      if x > 0 {\n            prod *= 1;\n        } else if x < 0 {\n       \
    \     prod *= -1;\n        } else {\n            prod *= 0;\n        }\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `None`', /tmp/tmp068r9489.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n    }\n  \
    \  Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (positive, negative, zeros) = arr.iter().fold((0,\
    \ 0, 0), |(pos, neg, zer), e| {\n        if *e > 0 {\n            (pos + 1, neg,\
    \ zer)\n        } else if *e < 0 {\n            (pos, neg + 1, zer)\n        }\
    \ else {\n            (pos, neg, zer + 1)\n        }\n    });\n    if positive\
    \ == 0 || negative == 0 || (zeros > 0 && (positive + negative) < arr.len()) {\n\
    \        Some(0)\n    } else {\n        let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \        Some(sum * (if zeros > 0 { 0 } else { -1 }))\n    }\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-20)`,\n right: `Some(20)`', /tmp/tmpsr_pneyy.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let sum = arr.iter().fold(0,\
    \ |acc, x| acc + x.abs());\n    let product = arr.iter().fold(1, |acc, x| acc\
    \ * (x.signum() as isize));\n    match arr.len() {\n        0 => None,\n     \
    \   _ => Some(sum * product),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n   \
    \ for a in arr {\n        let sign = a.signum();\n        if sign != 0 {\n   \
    \         total *= sign;\n        }\n        sum += a.abs();\n    }\n    Some(sum\
    \ * total)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp5ivacax1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
