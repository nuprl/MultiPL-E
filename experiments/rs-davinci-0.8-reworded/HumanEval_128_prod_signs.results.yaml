language: rs
name: HumanEval_128_prod_signs
results:
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = 1;\n \
    \   let mut sum = 0;\n    for i in arr {\n        if i < 0 {\n            product\
    \ *= -1;\n        }\n        sum += i.abs();\n    }\n    if sum == 0 {\n     \
    \   return None;\n    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpq7i1jszo.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        if n > 0 {\n            prod *= 1;\n        } else if n\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += n.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"value of\
    \ product of signs of arr: {:?}\", arr);\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: value of product of signs
    of arr: [1, 2, 2, -4]'', /tmp/tmp3q19sgdq.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    match arr.len() {\n    \
    \    0 => None,\n        _ => {\n            let mut s = 1;\n            let mut\
    \ sum = 0;\n            for i in arr {\n                if i > 0 {\n         \
    \           sum += i;\n                } else if i < 0 {\n                   \
    \ sum += i.abs();\n                    s *= -1;\n                }\n         \
    \   }\n            Some(sum * s)\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpxrgn7tf_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        match n.signum() {\n            1 => {\n               \
    \ res *= 1;\n                sum += n;\n            }\n            -1 => {\n \
    \               res *= -1;\n                sum += n.abs();\n            }\n \
    \           _ => {}\n        }\n    }\n    Some(sum * res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmbkulqta.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let mut signs = vec![];\n    let mut magnitudes = vec![];\n   \
    \ for i in &arr {\n        let s = if *i > 0 { 1 } else if *i < 0 { -1 } else\
    \ { 0 };\n        signs.push(s);\n        magnitudes.push(i.abs());\n    }\n \
    \   let sign_prod = signs.iter().product();\n    Some(magnitudes.iter().sum::<isize>()\
    \ * sign_prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqa9bzjio.rs:21:9\n\
    \   |\n21 |     let sign_prod = signs.iter().product();\n   |         ^^^^^^^^^\
    \ consider giving `sign_prod` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * arr.iter().map(|x| x.signum()).product::<isize>())\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        match i.cmp(&0) {\n            Ordering::Less => {\n\
    \                total *= -1;\n                sum += i.abs();\n            }\n\
    \            Ordering::Greater => {\n                sum += i;\n            }\n\
    \            Ordering::Equal => {}\n        }\n    }\n    Some(total * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpay11bhsc.rs:20:13\n   |\n20 |             Ordering::Less => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpay11bhsc.rs:24:13\n\
    \   |\n24 |             Ordering::Greater => {\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpay11bhsc.rs:27:13\n   |\n27 |             Ordering::Equal\
    \ => {}\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut mult = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            mult *= 1;\n        } else if i\
    \ < 0 {\n            mult *= -1;\n        } else {\n            mult *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * mult)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let product = arr.iter().map(|&n| n.signum()).product();\n\
    \    let sum = arr.iter().map(|&n| n.abs()).sum();\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpihppxql5.rs:16:9\n\
    \   |\n16 |     let product = arr.iter().map(|&n| n.signum()).product();\n   |\
    \         ^^^^^^^ consider giving `product` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(None, |acc,\
    \ x| match acc {\n        None => Some(if *x > 0 { 1 } else if *x < 0 { -1 } else\
    \ { 0 }),\n        Some(signs) => Some(signs * if *x > 0 { 1 } else if *x < 0\
    \ { -1 } else { 0 }),\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpe9rjc01x.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"prod_signs({:?})\"\
    , arr)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: prod_signs([1, 2, 2, -4])'',
    /tmp/tmpxbp4aza7.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().fold(0, |acc, x| acc + x.abs());\n\
    \    let product = arr.iter().fold(1, |acc, x| {\n        match x {\n        \
    \    x if x > &0 => acc * 1,\n            x if x < &0 => acc * -1,\n         \
    \   _ => acc * 0,\n        }\n    });\n    Some(sum * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // your code goes here\n\
    \    match arr.len() {\n        0 => None,\n        _ => {\n            let prod\
    \ = arr.iter().fold(1, |prod, i| prod * i.signum());\n            let sum = arr.iter().map(|i|\
    \ i.abs()).sum();\n            Some(prod * sum)\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpgpgmt6j6.rs:18:17\n\
    \   |\n18 |             let sum = arr.iter().map(|i| i.abs()).sum();\n   |   \
    \              ^^^ consider giving `sum` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ x in arr {\n        match x.signum() {\n            0 => continue,\n       \
    \     -1 => prod *= -1,\n            _ => (),\n        }\n        sum += x.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpfz391y0v.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for x in arr {\n        sum += x.abs();\n  \
    \      if x > 0 {\n            prod *= 1;\n        } else if x < 0 {\n       \
    \     prod *= -1;\n        } else {\n            prod *= 0;\n        }\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `None`', /tmp/tmp068r9489.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n    }\n  \
    \  Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (positive, negative, zeros) = arr.iter().fold((0,\
    \ 0, 0), |(pos, neg, zer), e| {\n        if *e > 0 {\n            (pos + 1, neg,\
    \ zer)\n        } else if *e < 0 {\n            (pos, neg + 1, zer)\n        }\
    \ else {\n            (pos, neg, zer + 1)\n        }\n    });\n    if positive\
    \ == 0 || negative == 0 || (zeros > 0 && (positive + negative) < arr.len()) {\n\
    \        Some(0)\n    } else {\n        let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \        Some(sum * (if zeros > 0 { 0 } else { -1 }))\n    }\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-20)`,\n right: `Some(20)`', /tmp/tmpsr_pneyy.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let sum = arr.iter().fold(0,\
    \ |acc, x| acc + x.abs());\n    let product = arr.iter().fold(1, |acc, x| acc\
    \ * (x.signum() as isize));\n    match arr.len() {\n        0 => None,\n     \
    \   _ => Some(sum * product),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut total = 1;\n    let mut sum = 0;\n   \
    \ for a in arr {\n        let sign = a.signum();\n        if sign != 0 {\n   \
    \         total *= sign;\n        }\n        sum += a.abs();\n    }\n    Some(sum\
    \ * total)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp5ivacax1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823178
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut ret = 0;\n    for\
    \ n in arr {\n        if n < 0 {\n            prod *= -1;\n        } else if n\
    \ > 0 {\n            ret += n;\n        }\n    }\n    Some(ret * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpxpgbn18k.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        if i < 0 {\n            product *= -1;\n        }\n\
    \        sum += i.abs();\n    }\n    Some(sum * product)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpkr7b0u27.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let total = match arr.len()\
    \ {\n        0 => return None,\n        _ => arr.iter().fold(0, |acc, x| acc +\
    \ x)\n    };\n    let prod = match arr.len() {\n        0 => return None,\n  \
    \      _ => arr.iter().fold(1, |acc, x| acc * x)\n    };\n    Some(total * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpc3ebm39v.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let result = arr.iter().fold((1, 0), |(acc_sign,\
    \ acc_num), &x| {\n        if x < 0 {\n            (acc_sign * -1, acc_num + x.abs())\n\
    \        } else if x > 0 {\n            (acc_sign, acc_num + x)\n        } else\
    \ {\n            (0, acc_num)\n        }\n    });\n    Some(result.0 * result.1)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ num in arr {\n        if num > 0 {\n            prod *= 1;\n        } else if\
    \ num < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(None, |sum,\
    \ &elem| {\n        match elem {\n            0 => Some(0),\n            x if\
    \ x > 0 => sum.map(|acc| acc + elem),\n            x if x < 0 => sum.map(|acc|\
    \ acc - elem),\n            _ => unreachable!(),\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmp79t1819x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut sum = 0;\n    let\
    \ mut prod = 1;\n    for n in arr {\n        if n > 0 {\n            sum += n;\n\
    \            prod *= 1;\n        } else if n < 0 {\n            sum += n.abs();\n\
    \            prod *= -1;\n        }\n    }\n    if arr.len() > 0 {\n        Some(sum\
    \ * prod)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp75q9x4hu.rs:24:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for n in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n24  |     if arr.len()\
    \ > 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n15  |     for n in &arr {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sum: isize = 0;\n    let mut mul: isize\
    \ = 1;\n    for i in arr {\n        sum += i.abs();\n        mul *= i.signum();\n\
    \    }\n    Some(sum * mul)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    None\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpe63vadz4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ item in arr {\n        if item == 0 {\n            continue;\n        }\n  \
    \      prod *= item.signum();\n        sum += item.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpeczvmmnv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"The prod_signs\
    \ function needs to be implemented!\");\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: The prod_signs function
    needs to be implemented!'', /tmp/tmpytslxokx.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut res = arr.iter().fold(1,\
    \ |acc, &x| {\n        if x < 0 {\n            acc * -1\n        } else {\n  \
    \          acc\n        }\n    });\n    res *= arr.iter().fold(0, |acc, &x| acc\
    \ + x.abs());\n    Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpwm2vo0yu.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut total = 1;\n   \
    \ let mut count = 0;\n    for i in &arr {\n        match i {\n            _ if\
    \ *i > 0 => {\n                total *= *i;\n                count += 1;\n   \
    \         }\n            _ if *i < 0 => {\n                total *= *i;\n    \
    \            count += 1;\n            }\n            _ => {}\n        }\n    }\n\
    \    if count == 0 {\n        None\n    } else {\n        Some(total)\n    }\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpg5on3vt_.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ None for empty arr and a number for a non-empty arr\")\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return None for empty arr
    and a number for a non-empty arr'', /tmp/tmpb5eeqy1u.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for num in arr {\n        if num < 0 {\n            prod *= -1;\n\
    \        } else if num > 0 {\n            sum += num;\n        }\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpik7k9hyz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in vector: {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: return sum of magnitudes
    of integers multiplied by product of all signs of each number in vector: [1, 2,
    2, -4]'', /tmp/tmpbmfsif8y.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum: isize = arr.iter().map(|i| i.abs()).sum();\n\
    \    let sign: isize = arr.iter().fold(1, |acc, i| {\n        if *i > 0 {\n  \
    \          acc * 1\n        } else if *i < 0 {\n            acc * -1\n       \
    \ } else {\n            acc * 0\n        }\n    });\n    Some(sum * sign)\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    arr.iter().map(|n| n.abs()).sum::<isize>() * arr.iter().product::<isize>()\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dyalet3.rs:16:5\n   |\n\
    12 | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |                 \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n16 |     arr.iter().map(|n| n.abs()).sum::<isize>() * arr.iter().product::<isize>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |     Some(arr.iter().map(|n| n.abs()).sum::<isize>() * arr.iter().product::<isize>())\n\
    \   |     +++++                                                              \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(None, |acc,\
    \ val| match acc {\n        None => Some(val),\n        Some(acc) => Some(acc\
    \ * sign(*val) * val),\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmphu3z8_5w.rs:15:33\n\
    \   |\n15 |         Some(acc) => Some(acc * sign(*val) * val),\n   |         \
    \                        ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphu3z8_5w.rs:14:22\n   |\n14 |         None => Some(val),\n\
    \   |                      ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n14 |         None => Some(*val),\n   |     \
    \                 +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (mut sum, mut prod) = (0, 1);\n    for x in\
    \ arr {\n        if x < 0 {\n            prod *= -1;\n        }\n        sum +=\
    \ x.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpmw5kaldu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (mut signs, mut magnitudes) = (1, 0);\n  \
    \  for &i in &arr {\n        signs *= (i == 0) as isize - (i < 0) as isize;\n\
    \        magnitudes += i.abs();\n    }\n    Some(signs * magnitudes)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `Some(-9)`', /tmp/tmph1yy5z9t.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"{:?}\"\
    , arr)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: [1, 2, 2, -4]'', /tmp/tmpq9ffd404.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // let mut product: isize\
    \ = 0;\n    // let mut sum: isize = 0;\n    // for i in arr {\n    //     if i\
    \ > 0 {\n    //         product *= 1;\n    //         sum += i;\n    //     }\
    \ else if i < 0 {\n    //         product *= -1;\n    //         sum += i.abs();\n\
    \    //     } else {\n    //         product *= 0;\n    //         sum += 0;\n\
    \    //     }\n    // }\n    //\n    // if product == 0 {\n    //     return None;\n\
    \    // } else {\n    //     return Some(product * sum);\n    // }\n\n    let\
    \ sum: isize = arr.iter().map(|x| x.abs()).sum();\n    let product: isize = arr.iter().map(|x|\
    \ x.signum()).product();\n    if sum == 0 {\n        None\n    } else {\n    \
    \    Some(sum * product)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            res *= 1;\n        } else if i <\
    \ 0 {\n            res *= -1;\n        } else {\n            res *= 0;\n     \
    \   }\n        sum += i.abs();\n    }\n    Some(sum * res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sum = 0;\n    let mut product = 1;\n \
    \   for i in arr {\n        if i != 0 {\n            sum += i.abs();\n       \
    \     product *= i.signum();\n        }\n    }\n    Some(sum * product)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpw9xcj2zw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (sum, prod) = arr.iter().fold((0, 1), |(sum,\
    \ prod), v| {\n        (sum + v.abs(), prod * match v {\n            v if v >\
    \ 0 => 1,\n            v if v < 0 => -1,\n            _ => 0,\n        })\n  \
    \  });\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ytic_o6.rs:18:22\n   |\n\
    18 |             v if v > 0 => 1,\n   |                      ^\n   |         \
    \             |\n   |                      expected `&isize`, found integer\n\
    \   |                      help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1ytic_o6.rs:19:22\n   |\n19 |             v\
    \ if v < 0 => -1,\n   |                      ^\n   |                      |\n\
    \   |                      expected `&isize`, found integer\n   |            \
    \          help: consider borrowing here: `&0`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut total = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            total\
    \ *= 1;\n        } else if i < 0 {\n            total *= -1;\n        } else {\n\
    \            total *= 0;\n        }\n        sum += i.abs();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(total * sum)\n    }\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpgtn480ov.rs:25:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n25  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        if i < 0 {\n            product *= -1;\n        }\n\
    \        sum += i.abs();\n    }\n    Some(sum * product)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpkr7b0u27.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let x = arr.iter().map(|x| x.signum()).product::<isize>();\n\
    \    Some(arr.iter().map(|x| x.abs()).sum::<isize>() * x)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for i in arr {\n        sum += i.abs();\n        prod *= i.signum();\n\
    \    }\n    match (prod, sum) {\n        (0, 0) => None,\n        (0, _) => Some(0),\n\
    \        (_, _) => Some(prod * sum),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(0)`,\n right: `None`', /tmp/tmpbs5vdxw0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    None\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpe63vadz4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let result = arr.iter().map(|&x|\
    \ x.signum()).product::<isize>();\n    if arr.is_empty() {\n        None\n   \
    \ } else {\n        Some(result * arr.iter().sum::<isize>().abs())\n    }\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmptb690k1n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    None\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpe63vadz4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    None\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpe63vadz4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let n = arr.len();\n    let mut prod: isize =\
    \ 1;\n    let mut sum: isize = 0;\n    for i in 0..n {\n        if arr[i] == 0\
    \ {\n            continue;\n        }\n        prod *= arr[i].signum();\n    \
    \    sum += arr[i].abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n   \
    \ let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp7ln1gl_p.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // Write your code here\n\
    \    if arr.len() == 0 {\n        return None;\n    }\n    let mut prod = 1;\n\
    \    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1;\n        } else if i < 0 {\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            res *= 1;\n        } else if i <\
    \ 0 {\n            res *= -1;\n        } else {\n            res *= 0;\n     \
    \   }\n        sum += i.abs();\n    }\n    return Some(sum * res);\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut result = 1;\n  \
    \  let mut sum = 0;\n    for item in arr {\n        if item > 0 {\n          \
    \  result *= 1;\n            sum += item;\n        } else if item < 0 {\n    \
    \        result *= -1;\n            sum += -item;\n        } else {\n        \
    \    result *= 0;\n        }\n    }\n    if sum == 0 {\n        None\n    } else\
    \ {\n        Some(sum * result)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 0;\n    let mut prod = 1;\n    for\
    \ i in arr {\n        if i > 0 {\n            res += i;\n            prod *= 1;\n\
    \        } else if i < 0 {\n            res += -i;\n            prod *= -1;\n\
    \        } else {\n            prod = 0;\n        }\n    }\n    Some(res * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let (p, m) = arr.iter().fold((1,\
    \ 0), |(p, m), x| {\n        if *x < 0 {\n            (p * -1, m + x.abs())\n\
    \        } else if *x > 0 {\n            (p, m + x.abs())\n        } else {\n\
    \            (0, m)\n        }\n    });\n    if p == 0 {\n        None\n    }\
    \ else {\n        Some(p * m)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmp5wmh9gb5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for &elem in arr.iter() {\n        prod *= if elem == 0 {\
    \ 1 } else { elem.signum() };\n        sum += elem.abs();\n    }\n    if arr.is_empty()\
    \ {\n        None\n    } else {\n        Some(sum * prod)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpot0n7ia9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        if i > 0 {\n            product *= 1;\n        } else\
    \ if i < 0 {\n            product *= -1;\n        } else {\n            product\
    \ *= 0;\n        }\n        sum += i.abs();\n    }\n    return Some(sum * product);\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        if n == 0 {\n            res = 0;\n        } else if n <\
    \ 0 {\n            res *= -1;\n        }\n        sum += n.abs();\n    }\n   \
    \ Some(res * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.into_iter().fold(Some(1),\
    \ |acc, e| {\n        if e == 0 {\n            Some(0)\n        } else {\n   \
    \         acc.map(|acc_val| acc_val * e.signum())\n        }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpndasf77y.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for num in arr {\n        sum += num.abs();\n        match\
    \ num {\n            0 => {\n                prod = 0;\n                break;\n\
    \            }\n            x if x > 0 => {\n                prod *= 1;\n    \
    \        }\n            x if x < 0 => {\n                prod *= -1;\n       \
    \     }\n            _ => {\n                unreachable!();\n            }\n\
    \        }\n    }\n    if arr.is_empty() {\n        None\n    } else {\n     \
    \   Some(sum * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp3pm_d5qi.rs:33:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for num in arr {\n    |                ---\
    \ `arr` moved due to this implicit call to `.into_iter()`\n...\n33  |     if arr.is_empty()\
    \ {\n    |        ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for num in &arr {\n    |             \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut s: isize = 1;\n    for i in arr {\n  \
    \      if i == 0 {\n            s = 0;\n            break;\n        }\n      \
    \  if i < 0 {\n            s *= -1;\n        }\n    }\n    let mut sum: isize\
    \ = 0;\n    for i in arr {\n        sum += s * i.abs();\n    }\n    Some(sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `arr`\n   --> /tmp/tmp5ewiqysc.rs:27:14\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n17  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27  |     for i in arr\
    \ {\n    |              ^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n17  |     for i in &arr {\n    |              +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut magnitude =\
    \ 0;\n    for i in arr {\n        if i == 0 {\n            return Some(0);\n \
    \       }\n        let sign = i.signum();\n        if sign == 0 {\n          \
    \  continue;\n        }\n        product *= sign;\n        magnitude += i.abs();\n\
    \    }\n    Some(product * magnitude)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sign = arr.iter().fold(1, |acc, &elem| acc\
    \ * sign(elem));\n    let sum = arr.iter().fold(0, |acc, &elem| acc + elem.abs());\n\
    \    Some(sign * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sign` in this scope\n  --> /tmp/tmp6aloxhh7.rs:16:54\n\
    \   |\n16 |     let sign = arr.iter().fold(1, |acc, &elem| acc * sign(elem));\n\
    \   |                                                      ^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().map(|&n| n.abs()).sum::<isize>();\n\
    \    let prod = arr.iter().fold(1, |res, &n| res * (n.signum() as isize));\n \
    \   Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        sum += i.abs();\n        res *= match i {\n            0\
    \ => 0,\n            _ if i < 0 => -1,\n            _ => 1,\n        };\n    }\n\
    \    Some(sum * res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = 1;\n \
    \   let mut sum = 0;\n    for x in arr {\n        product *= x.signum();\n   \
    \     sum += x.abs();\n    }\n    if arr.len() == 0 {\n        None\n    } else\
    \ {\n        Some(product * sum)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpw9heg0pk.rs:19:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n19  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for x in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // None for empty arr\n\
    \    if arr.is_empty() {\n        return None;\n    }\n\n    // map the vector\
    \ to vector of signs\n    let signs = arr.iter().map(|x| {\n        if *x < 0\
    \ {\n            -1\n        } else if *x > 0 {\n            1\n        } else\
    \ {\n            0\n        }\n    });\n\n    // get product of signs and sum\
    \ of magnitudes\n    let (product, sum) = signs.fold((1, 0), |(prod, sum), sign|\
    \ {\n        (prod * sign, sum + sign.abs())\n    });\n\n    Some(product * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpt9qbfg1o.rs:31:34\n   |\n30 |     let (product, sum) = signs.fold((1,\
    \ 0), |(prod, sum), sign| {\n   |                                            \
    \               ---- you must specify a type for this binding, like `i32`\n31\
    \ |         (prod * sign, sum + sign.abs())\n   |                            \
    \      ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for &n in &arr {\n        product *= if n == 0 {\n            0\n        }\
    \ else if n > 0 {\n            1\n        } else {\n            -1\n        };\n\
    \        sum += n.abs();\n    }\n    Some(sum * product)\n}\n\nfn main() {\n \
    \   let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let res: Vec<isize> = arr.iter().map(|&x| x.signum()).collect();\n\
    \    let prod: isize = res.iter().product();\n    let sum: isize = arr.iter().map(|&x|\
    \ x.abs()).sum();\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let sum = arr.iter().filter(|&&x|\
    \ x != 0).fold(1, |acc, x| acc * x.signum());\n    let res = arr.iter().filter(|&&x|\
    \ x != 0).fold(0, |acc, x| acc + x.abs());\n    if res == 0 {\n        None\n\
    \    } else {\n        Some(res * sum)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp21dvz_59.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // if array is empty, return\
    \ None\n    if arr.len() == 0 {\n        return None;\n    }\n    // calculate\
    \ prod and sum of magnitudes\n    let (mut prod, mut sum) = (1, 0);\n    for x\
    \ in arr {\n        prod *= x.signum();\n        sum += x.abs();\n    }\n    //\
    \ return prod * sum\n    Some(prod * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let magnitudes: Vec<isize> = arr.iter().map(|x| x.abs()).collect();\n\
    \    let magnitudes_sum: isize = magnitudes.iter().sum();\n    let signs: Vec<isize>\
    \ = arr.iter().map(|x| \n        match x {\n            x if x > &0 => 1,\n  \
    \          x if x < &0 => -1,\n            _ => 0,\n        }\n    ).collect();\n\
    \    let signs_prod: isize = signs.iter().product();\n    Some(magnitudes_sum\
    \ * signs_prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for val in arr {\n        match val {\n            0 => continue,\n\
    \            x if x > 0 => {\n                prod *= 1;\n                sum\
    \ += x;\n            }\n            x if x < 0 => {\n                prod *= -1;\n\
    \                sum += x.abs();\n            }\n            _ => unreachable!(),\n\
    \        }\n    }\n    match sum {\n        0 => None,\n        x => Some(x *\
    \ prod),\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpxwc1u4nz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut arr = arr;\n   \
    \ arr.sort();\n    if arr.len() == 0 {\n        return None;\n    } else if arr.len()\
    \ == 1 {\n        return Some(arr[0]);\n    }\n    let mut res = arr[0];\n   \
    \ let mut sign = 1;\n    for i in 1..arr.len() {\n        if arr[i] == 0 {\n \
    \           continue;\n        }\n        if arr[i] < 0 {\n            sign *=\
    \ -1;\n        }\n        res += sign * arr[i];\n    }\n    Some(res)\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpw8cef5bx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let prod = arr.iter().fold(1, |prod, &n| { prod * n.signum() as\
    \ isize });\n    Some(arr.iter().fold(0, |sum, &n| { sum + n.abs() }))\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpt5g1xnp7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().map(|&i| if i == 0 { 1 } else\
    \ { i.abs() * i.signum() }).sum())\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(-9)`', /tmp/tmpo17_q4ka.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().fold((1, 0), |acc, x| {\n    \
    \    (acc.0 * (x.signum() as isize), acc.1 + x.abs())\n    }).1)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmp2ngzjxnh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut signs = 1;\n    let mut magnitudes = 0;\n\
    \    for x in arr {\n        if x > 0 {\n            signs *= 1;\n        } else\
    \ if x < 0 {\n            signs *= -1;\n        } else {\n            signs *=\
    \ 0;\n        }\n        magnitudes += x.abs();\n    }\n    Some(magnitudes *\
    \ signs)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().fold((1, 0), |acc, &x| {\n   \
    \     (acc.0 * x.signum(), acc.1 + x.abs())\n    }).0 * arr.iter().fold(0, |acc,\
    \ &x| acc + x.abs()))\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // complete this function\n\
    \    return None;\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpysnywmbb.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        match i.cmp(&0) {\n            Ordering::Greater => {\n\
    \                res *= 1;\n                sum += i;\n            }\n       \
    \     Ordering::Less => {\n                res *= -1;\n                sum +=\
    \ i.abs();\n            }\n            Ordering::Equal => {\n                res\
    \ *= 0;\n                sum += 0;\n            }\n        }\n    }\n    Some(res\
    \ * sum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpjtx3nhw0.rs:20:13\n   |\n20 |             Ordering::Greater => {\n \
    \  |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpjtx3nhw0.rs:24:13\n\
    \   |\n24 |             Ordering::Less => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpjtx3nhw0.rs:28:13\n   |\n28 |             Ordering::Equal\
    \ => {\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sum = 0;\n    let mut sign = 1;\n    for\
    \ i in arr {\n        if i > 0 {\n            sum += i;\n        } else if i <\
    \ 0 {\n            sum -= i;\n            sign *= -1;\n        }\n    }\n    Some(sum\
    \ * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpnj0utpnw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let prod = arr.iter().map(|&x| x.signum()).product();\n\
    \    Some(arr.iter().map(|&x| x.abs()).sum::<isize>() * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpi7w9wfwt.rs:16:9\n\
    \   |\n16 |     let prod = arr.iter().map(|&x| x.signum()).product();\n   |  \
    \       ^^^^ consider giving `prod` a type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut arr = arr;\n    arr.sort();\n    if arr[0]\
    \ >= 0 {\n        arr.iter().product()\n    } else if arr[arr.len() - 1] <= 0\
    \ {\n        arr.iter().rev().product()\n    } else {\n        let zeros = arr.iter().filter(|&x|\
    \ *x == 0).count();\n        let neg = arr.iter().filter(|&x| *x < 0).count();\n\
    \        if zeros == 0 && neg % 2 == 0 {\n            arr.iter().product()\n \
    \       } else {\n            arr.iter().skip(neg).product()\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Option<isize>: Product<&isize>` is not satisfied\n\
    \    --> /tmp/tmpd7lzbkqk.rs:19:20\n     |\n19   |         arr.iter().product()\n\
    \     |                    ^^^^^^^ the trait `Product<&isize>` is not implemented\
    \ for `Option<isize>`\n     |\n     = help: the trait `Product<Option<U>>` is\
    \ implemented for `Option<T>`\nnote: required by a bound in `std::iter::Iterator::product`\n\
    \nerror[E0277]: the trait bound `Option<isize>: Product<&isize>` is not satisfied\n\
    \    --> /tmp/tmpd7lzbkqk.rs:21:26\n     |\n21   |         arr.iter().rev().product()\n\
    \     |                          ^^^^^^^ the trait `Product<&isize>` is not implemented\
    \ for `Option<isize>`\n     |\n     = help: the trait `Product<Option<U>>` is\
    \ implemented for `Option<T>`\nnote: required by a bound in `std::iter::Iterator::product`\n\
    \nerror[E0277]: the trait bound `Option<isize>: Product<&isize>` is not satisfied\n\
    \    --> /tmp/tmpd7lzbkqk.rs:26:24\n     |\n26   |             arr.iter().product()\n\
    \     |                        ^^^^^^^ the trait `Product<&isize>` is not implemented\
    \ for `Option<isize>`\n     |\n     = help: the trait `Product<Option<U>>` is\
    \ implemented for `Option<T>`\nnote: required by a bound in `std::iter::Iterator::product`\n\
    \nerror[E0277]: the trait bound `Option<isize>: Product<&isize>` is not satisfied\n\
    \    --> /tmp/tmpd7lzbkqk.rs:28:34\n     |\n28   |             arr.iter().skip(neg).product()\n\
    \     |                                  ^^^^^^^ the trait `Product<&isize>` is\
    \ not implemented for `Option<isize>`\n     |\n     = help: the trait `Product<Option<U>>`\
    \ is implemented for `Option<T>`\nnote: required by a bound in `std::iter::Iterator::product`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sign_product = arr.iter().fold(1, |a, &b|\
    \ a * b.signum());\n    Some(arr.iter().fold(0, |a, &b| a + b.abs()) * sign_product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // your code here\n    None\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmphmc4e1b1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let p: isize = arr.iter().map(|x| if *x > 0 {\
    \ 1 } else if *x < 0 { -1 } else { 0 }).product();\n    let s: isize = arr.iter().map(|x|\
    \ x.abs()).sum();\n    Some(p * s)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // Rust: O(n)\n    // let\
    \ mut prod = arr.iter().fold(1, |acc, &x| if x > 0 { acc } else { -acc });\n \
    \   // arr.iter().fold(None, |acc, &x| {\n    //     if x == 0 {\n    //     \
    \    None\n    //     } else {\n    //         Some(if prod > 0 { acc.unwrap_or(0)\
    \ + x } else { acc.unwrap_or(0) - x })\n    //     }\n    // })\n    // Rust:\
    \ O(n)\n    let mut prod = 1;\n    let mut acc = 0;\n    for x in arr {\n    \
    \    if x == 0 {\n            return None;\n        } else {\n            if x\
    \ < 0 {\n                prod *= -1;\n            }\n            acc += if prod\
    \ > 0 { x } else { -x };\n        }\n    }\n    Some(acc)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(9)`,\n right: `Some(-9)`', /tmp/tmpjmwn9g19.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for num in arr {\n        product *= num.signum();\n        sum += num.abs();\n\
    \    }\n    Some(sum * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ num in arr {\n        sum += num.abs();\n        prod *= num.signum();\n   \
    \ }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n    for\
    \ n in arr {\n        if n > 0 {\n            sum += n;\n            prod *= 1;\n\
    \        } else if n < 0 {\n            sum += -n;\n            prod *= -1;\n\
    \        }\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpuklsylpn.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ num in arr {\n        if num == 0 {\n            continue;\n        }\n    \
    \    if num > 0 {\n            prod *= 1;\n        } else {\n            prod\
    \ *= -1;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpy4i3nbcb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    //if arr.len() == 0 {\n\
    \    //    return None;\n    //}\n    let mut product: isize = 1;\n    let mut\
    \ sum: isize = 0;\n    for a in arr {\n        if a < 0 {\n            product\
    \ *= -1;\n        }\n        sum += a.abs();\n    }\n    Some(sum * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpfgxvl7o8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \    let signs = arr.iter().fold(1, |acc, x| acc * x.signum());\n    Some(sum\
    \ * signs)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        if i > 0 {\n            product *= 1;\n        } else\
    \ if i < 0 {\n            product *= -1;\n        } else {\n            product\
    \ *= 0;\n        }\n        sum += i.abs();\n    }\n    Some(sum * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n \
    \       if i == 0 { prod = 0; }\n        else if i < 0 { prod *= -1; }\n     \
    \   sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut signs: Vec<isize>\
    \ = arr.into_iter().map(|x| if x > 0 { 1 } else if x < 0 { -1 } else { 0 }).collect();\n\
    \    signs.sort();\n    if signs.is_empty() {\n        return None;\n    }\n \
    \   let mut times = 1;\n    for &s in &signs {\n        times *= s;\n    }\n \
    \   let sum: isize = signs.into_iter().map(|x| x.abs()).sum();\n    Some(sum *\
    \ times)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-4)`,\n right: `Some(-9)`', /tmp/tmp58zh_cfd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut pos = 1;\n    let\
    \ mut neg = 1;\n    let mut sum = 0;\n    for x in arr {\n        if x > 0 {\n\
    \            pos *= x;\n        } else if x < 0 {\n            neg *= x;\n   \
    \     } else {\n            sum += pos + neg;\n            pos = 1;\n        \
    \    neg = 1;\n        }\n    }\n    if arr.is_empty() {\n        None\n    }\
    \ else {\n        Some(sum + pos + neg)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpi687fgk8.rs:27:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27  |     if arr.is_empty()\
    \ {\n    |        ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for x in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut arr = arr;\n   \
    \ arr.iter_mut().for_each(|n| *n = n.signum());\n    let prod = arr.iter().filter(|&&i|\
    \ i != 0).product();\n    arr.iter().map(|n| n.abs()).sum::<isize>().checked_mul(prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-4)`,\n right: `Some(-9)`', /tmp/tmpchyt_zma.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        sum += i.abs();\n        if i != 0 {\n           \
    \ product *= i.signum();\n        }\n    }\n    Some(sum * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp6sgkm99h.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().fold(0, |acc, x| acc + x.abs());\n\
    \    let prod = arr.iter().fold(1, |acc, x| acc * x.signum());\n    Some(sum *\
    \ prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    arr.iter().fold(Some(1), |result, &value| match\
    \ (result, value) {\n        (Some(res), el) if el < 0 => Some(res * -1),\n  \
    \      (Some(res), el) if el > 0 => Some(res * 1),\n        _ => None,\n    })\n\
    \    .map(|res| arr.iter().map(|el| el.abs()).sum::<isize>() * res)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmpj_pvfp_5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut signs = [0, 0, 0];\n\
    \    let mut sum = 0;\n    for x in arr {\n        match x.cmp(&0) {\n       \
    \     Ordering::Less => signs[0] += 1,\n            Ordering::Equal => signs[1]\
    \ += 1,\n            Ordering::Greater => signs[2] += 1,\n        }\n        sum\
    \ += x.abs();\n    }\n    if signs[0] % 2 == 0 {\n        Some(sum)\n    } else\
    \ {\n        Some(-sum)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp1l6xb6c5.rs:17:13\n   |\n17 |             Ordering::Less => signs[0]\
    \ += 1,\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp1l6xb6c5.rs:18:13\n\
    \   |\n18 |             Ordering::Equal => signs[1] += 1,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmp1l6xb6c5.rs:19:13\n   |\n19 |    \
    \         Ordering::Greater => signs[2] += 1,\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let prod = arr.iter().fold(1, |acc, x| acc * signum(*x));\n\
    \    let sum = arr.iter().map(|x| x.abs()).sum();\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `signum` in this scope\n  --> /tmp/tmpbkxvvib0.rs:16:50\n\
    \   |\n16 |     let prod = arr.iter().fold(1, |acc, x| acc * signum(*x));\n  \
    \ |                                                  ^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let arr_signs = arr.iter().map(|&x| x.signum()).collect::<Vec<_>>();\n\
    \    let sum = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    Some(sum * arr_signs.iter().product::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(Some(1),\
    \ |acc, x| match x {\n        0 => None,\n        x if x < 0 => acc.map(|a| a\
    \ * -1),\n        _ => acc,\n    })\n    .map(|a| arr.iter().fold(0, |acc, x|\
    \ acc + x.abs() * a))\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplo0zimkk.rs:15:18\n   |\n\
    15 |         x if x < 0 => acc.map(|a| a * -1),\n   |                  ^\n   |\
    \                  |\n   |                  expected `&isize`, found integer\n\
    \   |                  help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    arr.iter().fold(1, |acc, x| acc * x.signum()) *\n        arr.iter().map(|x|\
    \ x.abs()).sum::<isize>()\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9bg3sckh.rs:14:5\n   |\n\
    12 |   fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |               \
    \                      ------------- expected `Option<isize>` because of return\
    \ type\n13 |       if arr.is_empty() { return None; }\n14 | /     arr.iter().fold(1,\
    \ |acc, x| acc * x.signum()) *\n15 | |         arr.iter().map(|x| x.abs()).sum::<isize>()\n\
    \   | |__________________________________________________^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n14 ~\
    \     Some(arr.iter().fold(1, |acc, x| acc * x.signum()) *\n15 ~         arr.iter().map(|x|\
    \ x.abs()).sum::<isize>())\n   |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let signs: Vec<isize> = arr.iter().map(|&n| n.signum()).collect();\n\
    \    let ans = arr.iter().map(|&n| n.abs()).sum::<isize>() * signs.iter().product::<isize>();\n\
    \    Some(ans)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let p1 = arr.iter().product::<isize>();\n    let\
    \ p2 = arr.iter().map(|&x| x.abs()).sum::<isize>();\n    Some(p1 * p2)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-144)`,\n right: `Some(-9)`', /tmp/tmpt8ucb0p7.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for n in arr {\n        let sign = if n > 0 { 1 } else if n < 0 { -1 } else\
    \ { 0 };\n        product *= sign;\n        sum += n.abs();\n    }\n    Some(sum\
    \ * product)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let sum = arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>();\n    let prod = arr.iter().fold(1, |acc, &x| acc *\
    \ x.signum());\n    if sum == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let s: isize = arr.iter().fold(0, |acc, x| acc\
    \ + x.abs());\n    let p: isize = arr.iter().filter(|x| x.abs() > 0).fold(1, |acc,\
    \ x| acc * x.signum());\n    Some(s * p)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpb8m8qixz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // Implement prod_signs\
    \ function here\n    if arr.len() == 0 {\n        return None;\n    }\n\n    let\
    \ mut signs = 1;\n    let mut magnitudes = 0;\n\n    for n in arr {\n        if\
    \ n > 0 {\n            signs *= 1;\n        } else if n < 0 {\n            signs\
    \ *= -1;\n        } else {\n            signs *= 0;\n        }\n        magnitudes\
    \ += n.abs();\n    }\n\n    Some(magnitudes * signs)\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None }\n    let mut sign = 1;\n    let mut sum = 0;\n    for n in arr {\n  \
    \      sign *= match n {\n            0 => { 0 },\n            _ if n < 0 => {\
    \ -1 },\n            _ => { 1 },\n        };\n        sum += n.abs();\n    }\n\
    \    Some(sum * sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() { return\
    \ None; }\n    let mut prod = arr.iter().map(|x| if *x > 0 { 1 } else if *x <\
    \ 0 { -1 } else { 0 }).product();\n    prod * arr.iter().map(|x| x.abs()).sum::<isize>()\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpstnp7smz.rs:14:9\n\
    \   |\n14 |     let mut prod = arr.iter().map(|x| if *x > 0 { 1 } else if *x <\
    \ 0 { -1 } else { 0 }).product();\n   |         ^^^^^^^^ consider giving `prod`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut s: isize = 1;\n\
    \    let mut sum: isize = 0;\n    if arr.len() == 0 {\n        return None;\n\
    \    }\n    for n in arr {\n        if n == 0 {\n            s = 0;\n        }\
    \ else if n < 0 {\n            s *= -1;\n        }\n        sum += n.abs();\n\
    \    }\n    Some(sum * s)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // TODO\n    None\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpc1wz1jro.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for i in arr {\n        match i {\n        \
    \    0 => {\n                return None;\n            }\n            _ => {\n\
    \                sum += i.abs();\n                prod *= i.signum();\n      \
    \      }\n        }\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(0)`', /tmp/tmpx29_di01.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ v in arr {\n        if v < 0 {\n            prod *= -1;\n        } else if v\
    \ > 0 {\n            sum += v;\n        }\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmp1kgnwnww.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.is_empty()\n       \
    \ .then_some(0)\n        .map(|_| {\n            let mut total = 1;\n        \
    \    for x in arr {\n                total *= x.signum();\n            }\n   \
    \         arr.iter().map(|&x| x.abs()).sum::<isize>() * total\n        })\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmp39q4nt0s.rs:20:13\n\
    \    |\n17  |             for x in arr {\n    |                      --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n20  |             arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>() * total\n    |             ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `arr`\n    = note: move occurs because `arr` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n    = note: borrow occurs due to\
    \ deref coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |             for x\
    \ in &arr {\n    |                      +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: return sum of magnitudes
    of integers multiplied by product of all signs of each number in [1, 2, 2, -4]'',
    /tmp/tmps57j4xhk.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.into_iter().fold(None,\
    \ |acc, elem| {\n        let sign = match elem {\n            x if x > 0 => 1,\n\
    \            x if x < 0 => -1,\n            _ => 0,\n        };\n        if let\
    \ Some(x) = acc {\n            Some(x * sign)\n        } else {\n            Some(sign)\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpge6ldu6n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sign_prod = 1;\n    let mut abs_sum =\
    \ 0;\n    for x in arr {\n        sign_prod *= x.signum();\n        abs_sum +=\
    \ x.abs();\n    }\n    Some(sign_prod * abs_sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.is_empty()\n       \
    \ .then_some(arr.iter().fold(1, |acc, &x| acc * x.signum()))\n        .map(|sign|\
    \ arr.iter().fold(0, |acc, &x| acc + x.abs()))\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpfs5cw5ac.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sign = arr.iter().fold(1, |acc, &n| if n >\
    \ 0 { 1 } else if n < 0 { -1 } else { 0 }) as isize;\n    let sum = arr.iter().map(|n|\
    \ n.abs()).sum::<isize>();\n    Some(sign * sum)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpsn_wrnnh.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut signs = Vec::new();\n    let mut magnitudes\
    \ = Vec::new();\n    for v in arr {\n        if v > 0 {\n            signs.push(1);\n\
    \            magnitudes.push(v);\n        } else if v < 0 {\n            signs.push(-1);\n\
    \            magnitudes.push(-v);\n        } else {\n            signs.push(0);\n\
    \            magnitudes.push(0);\n        }\n    }\n    let mut res = magnitudes.iter().fold(1,\
    \ |acc, x| acc * x);\n    res *= signs.iter().fold(1, |acc, x| acc * x);\n   \
    \ Some(res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpebub0yqo.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let product = arr.iter().fold(1, |sum, el| sum\
    \ * match el {\n        0 => 0,\n        x if x > 0 => 1,\n        _ => -1,\n\
    \    });\n    Some(arr.iter().fold(0, |sum, el| sum + product * el.abs()))\n}\n\
    \nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5zszfgg.rs:18:18\n   |\n\
    18 |         x if x > 0 => 1,\n   |                  ^\n   |                 \
    \ |\n   |                  expected `&isize`, found integer\n   |            \
    \      help: consider borrowing here: `&0`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut sign_prod = 1;\n\
    \    let mut sum = 0;\n    if arr.len() == 0 {\n        return None;\n    } else\
    \ {\n        for i in arr {\n            match i {\n                0 => sign_prod\
    \ *= 0,\n                _ => {\n                    sign_prod *= i.signum();\n\
    \                    sum += i.abs();\n                }\n            }\n     \
    \   }\n    }\n    Some(sum * sign_prod)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        sum += i.abs();\n        res *= i.signum();\n    }\n   \
    \ Some(sum * res)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut v: Vec<isize> =\
    \ Vec::new();\n    let mut prod = 1;\n    for &i in arr.iter() {\n        if i\
    \ == 0 {\n            v.push(0);\n        } else if i > 0 {\n            v.push(1);\n\
    \            prod *= 1;\n        } else {\n            v.push(-1);\n         \
    \   prod *= -1;\n        }\n    }\n    if v.len() == 0 {\n        return None;\n\
    \    }\n    Some(v.iter().map(|x| x.abs()).sum::<isize>() * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-4)`,\n right: `Some(-9)`', /tmp/tmpjqe5ig9t.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \    let sign = arr.iter().fold(1, |acc, x| acc * x.signum());\n    Some(sum *\
    \ sign)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut total: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for i in arr {\n        if i > 0 {\n            total *= 1;\n    \
    \    } else if i < 0 {\n            total *= -1;\n        } else {\n         \
    \   total *= 0;\n        }\n        sum += i.abs();\n    }\n    Some(total * sum)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n \
    \   for i in arr {\n        product *= if i == 0 { 0 } else if i > 0 { 1 } else\
    \ { -1 };\n        sum += i.abs();\n    }\n    Some(sum * product)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for num in arr {\n        match num {\n            0 => {}\n     \
    \       x if x > 0 => {\n                prod *= 1;\n                sum += x;\n\
    \            }\n            y if y < 0 => {\n                prod *= -1;\n   \
    \             sum += y.abs();\n            }\n            _ => {}\n        }\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmp7h09dquz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for i in arr {\n        if i == 0 {\n            prod = 0;\n     \
    \   } else if i < 0 {\n            prod *= -1;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let prod = arr.iter().fold(1, |a, b| a * *b);\n\
    \    let sum = arr.iter().map(|x| x.abs()).sum();\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpv7ulv_t6.rs:17:9\n\
    \   |\n17 |     let sum = arr.iter().map(|x| x.abs()).sum();\n   |         ^^^\
    \ consider giving `sum` a type\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ n in arr {\n        match n.signum() {\n            0 => continue,\n       \
    \     1 => prod *= 1,\n            -1 => prod *= -1,\n            _ => panic!(\"\
    not 0, 1 or -1\"),\n        }\n        sum += n.abs();\n    }\n    Some(sum *\
    \ prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpgiletfxv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // your code here\n    None\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmphmc4e1b1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979924
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    None\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpe63vadz4.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let prod = arr.iter().map(|x| x.signum()).product();\n\
    \    let sum = arr.iter().map(|x| x.abs()).sum();\n    Some(prod * sum)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpddx4v8kx.rs:16:9\n\
    \   |\n16 |     let prod = arr.iter().map(|x| x.signum()).product();\n   |   \
    \      ^^^^ consider giving `prod` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // your code here\n    let\
    \ x: Option<isize> = None;\n    x\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(-9)`', /tmp/tmpxxgbtrul.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ v in arr {\n        if v < 0 {\n            prod *= -1;\n        } else if v\
    \ > 0 {\n            sum += v;\n        }\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmp1kgnwnww.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else if i\
    \ > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpu1k9srmi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // im sure there is a one-liner\
    \ solution, but ...\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in\
    \ arr {\n        let sign = match i.cmp(&0) {\n            Ordering::Less => -1,\n\
    \            Ordering::Equal => 0,\n            Ordering::Greater => 1,\n    \
    \    };\n        prod *= sign;\n        sum += i.abs();\n    }\n    match arr.len()\
    \ {\n        0 => None,\n        _ => Some(sum * prod),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmps9lecvl2.rs:18:13\n   |\n18 |             Ordering::Less => -1,\n  \
    \ |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmps9lecvl2.rs:19:13\n\
    \   |\n19 |             Ordering::Equal => 0,\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmps9lecvl2.rs:20:13\n   |\n20 |             Ordering::Greater\
    \ => 1,\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut sum = 0;\n    let\
    \ mut signs = 1;\n    for item in arr {\n        if item > 0 {\n            sum\
    \ += item;\n        } else if item < 0 {\n            sum -= item;\n         \
    \   signs *= -1;\n        }\n    }\n    if arr.len() > 0 {\n        Some(sum *\
    \ signs)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpnql1dsv4.rs:23:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for item in arr {\n    |                 ---\
    \ `arr` moved due to this implicit call to `.into_iter()`\n...\n23  |     if arr.len()\
    \ > 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n15  |     for item in &arr {\n    |                 +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut res = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            res *= 1;\n        } else if i <\
    \ 0 {\n            res *= -1;\n        } else {\n            res *= 0;\n     \
    \   }\n        sum += i.abs();\n    }\n    Some(sum * res)\n}\n\nfn main() {\n\
    \    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut product = 1;\n \
    \   let mut sum = 0;\n    for x in arr {\n        if x == 0 {\n            continue;\n\
    \        }\n        sum += x.abs();\n        product *= x.signum();\n    }\n \
    \   if arr.is_empty() {\n        None\n    } else {\n        Some(sum * product)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpuazar4pl.rs:22:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for x in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n22  |     if arr.is_empty()\
    \ {\n    |        ^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for x in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod: isize = 1;\n\
    \    let mut sum: isize = 0;\n    for i in arr {\n        sum += i.abs();\n  \
    \      prod *= i.signum();\n    }\n    if arr.len() == 0 {\n        None\n   \
    \ } else {\n        Some(sum * prod)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpf8zv0g8i.rs:19:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n19  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let arr = arr.into_iter().filter(|&x| x != 0).collect::<Vec<_>>();\n\
    \    if arr.is_empty() {\n        return Some(0);\n    }\n    let sum = arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>();\n    let mut prod = 1;\n    for x in arr {\n      \
    \  prod *= if x > 0 { 1 } else { -1 };\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpaby8szvo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut p1 = 1;\n    let mut p2 = 1;\n    for\
    \ i in arr {\n        if i > 0 {\n            p1 *= i;\n        } else if i <\
    \ 0 {\n            p2 *= i;\n        }\n    }\n    Some(p1 * p2)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpow7dtqit.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let (p, m) = arr.iter().fold((1, 1), |(p, m),\
    \ &x| {\n        if x < 0 {\n            (p, m * x)\n        } else if x > 0 {\n\
    \            (p * x, m)\n        } else {\n            (0, 0)\n        }\n   \
    \ });\n    Some(p * m)\n}\n\nfn main() {\n    let candidate = prod_signs;\n  \
    \  assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpt6yj3rj3.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.into_iter().fold(Some(1),\
    \ |sum, x| sum.and_then(|sum| match x {\n        0 => Some(0),\n        x => Some(sum\
    \ * x.signum()),\n    }))\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpotknihe1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // code here\n    let mut\
    \ product: isize = 1;\n    let mut sum: isize = 0;\n    for i in arr {\n     \
    \   if i > 0 {\n            product *= 1;\n            sum += i;\n        } else\
    \ if i < 0 {\n            product *= -1;\n            sum += i.abs();\n      \
    \  } else {\n            product *= 0;\n        }\n    }\n    if arr.len() ==\
    \ 0 {\n        None\n    } else {\n        Some(sum * product)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpwnht2ogk.rs:27:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n27  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.is_empty()\n       \
    \ .then_some(None)\n        .or_else(|| {\n            let (signs, magnitudes):\
    \ (Vec<isize>, Vec<isize>) = arr\n                .iter()\n                .map(|num|\
    \ {\n                    (\n                        num.signum(),\n          \
    \              num.abs()\n                    )\n                })\n        \
    \        .unzip();\n            let signs_product = signs.iter().product();\n\
    \            let magnitudes_sum = magnitudes.iter().sum();\n            signs_product\n\
    \                .checked_mul(magnitudes_sum)\n                .and_then(|res|\
    \ {\n                    Some(res)\n                })\n        })\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpybaby50s.rs:27:13\n\
    \   |\n25 |             let signs_product = signs.iter().product();\n   |    \
    \             ------------- consider giving `signs_product` a type\n26 |     \
    \        let magnitudes_sum = magnitudes.iter().sum();\n27 |             signs_product\n\
    \   |             ^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybaby50s.rs:13:5\n\
    \   |\n12 |   fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n   |        \
    \                             ------------- expected `Option<isize>` because of\
    \ return type\n13 | /     arr.is_empty()\n14 | |         .then_some(None)\n15\
    \ | |         .or_else(|| {\n16 | |             let (signs, magnitudes): (Vec<isize>,\
    \ Vec<isize>) = arr\n...  |\n31 | |                 })\n32 | |         })\n  \
    \ | |__________^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found enum `Option<Option<_>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(Some(1),\
    \ |acc, val| match acc {\n        Some(acc_val) => {\n            if *val == 0\
    \ {\n                Some(0)\n            } else {\n                Some(acc_val\
    \ * val.signum() * val.abs())\n            }\n        }\n        None => None,\n\
    \    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-16)`,\n right: `Some(-9)`', /tmp/tmpzejnfn0g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut magnitudes = vec![];\n    let mut signs\
    \ = vec![];\n    for i in arr {\n        magnitudes.push(i.abs());\n        if\
    \ i > 0 {\n            signs.push(1);\n        } else if i < 0 {\n           \
    \ signs.push(-1);\n        } else {\n            signs.push(0);\n        }\n \
    \   }\n    let magnitudes_sum = magnitudes.iter().sum();\n    let signs_prod =\
    \ signs.iter().product();\n    return Some(magnitudes_sum * signs_prod);\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpm26r0can.rs:28:9\n\
    \   |\n28 |     let magnitudes_sum = magnitudes.iter().sum();\n   |         ^^^^^^^^^^^^^^\
    \ consider giving `magnitudes_sum` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let product = arr.iter().fold(1,\
    \ |acc, &x| acc * signum(x));\n    let sum = arr.iter().map(|&x| abs(x)).sum();\n\
    \    if sum == 0 {\n        None\n    } else {\n        Some(product * sum)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `signum` in this scope\n  --> /tmp/tmpkzcn10jr.rs:13:54\n\
    \   |\n13 |     let product = arr.iter().fold(1, |acc, &x| acc * signum(x));\n\
    \   |                                                      ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  -->\
    \ /tmp/tmpkzcn10jr.rs:14:35\n   |\n14 |     let sum = arr.iter().map(|&x| abs(x)).sum();\n\
    \   |                                   ^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let a: isize = arr.iter().map(|x| x.abs()).sum();\n\
    \    let b: isize = arr.iter().map(|x| x.signum()).product();\n    Some(a * b)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6l3l51u8.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let arr_len = arr.len();\n\
    \    if arr_len == 0 {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut prod_magnitudes = 0;\n    for el in arr {\n        prod *= el.signum();\n\
    \        prod_magnitudes += el.abs();\n    }\n    Some(prod_magnitudes * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for n in arr {\n        sum += n.abs();\n        if n > 0 {\n    \
    \        prod *= 1;\n        } else if n < 0 {\n            prod *= -1;\n    \
    \    } else {\n            prod *= 0;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ num in arr {\n        prod *= if num < 0 { -1 } else { 1 };\n        sum +=\
    \ num.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpgyge6du5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sum = arr.iter().fold(0, |acc, &i| acc + i.abs());\n\
    \    let prod = arr.iter().fold(1, |acc, &i| acc * i.signum());\n    Some(sum\
    \ * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let (sums, prods) = arr.iter().fold((0,\
    \ 1), |(sum, prod), i| {\n        (sum + i.abs(), prod * i.signum())\n    });\n\
    \    arr.first().map(|_| sums * prods)\n}\n\nfn main() {\n    let candidate =\
    \ prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ item in arr {\n        sum += item.abs();\n        if item > 0 {\n         \
    \   prod *= 1;\n        } else if item < 0 {\n            prod *= -1;\n      \
    \  } else {\n            prod *= 0;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    Some(arr.iter().map(|&x| x.abs()).sum::<isize>()\
    \ * arr.iter().map(|&x| (x > 0) as isize - (x < 0) as isize).product::<isize>())\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut arr_magn = arr.clone();\n    let mut arr_sign\
    \ = arr.clone();\n    let mut sign_prod = 1;\n    let mut mag_sum = 0;\n    for\
    \ i in 0..arr.len() {\n        arr_magn[i] = arr[i].abs();\n        mag_sum +=\
    \ arr_magn[i];\n        if arr[i] == 0 {\n            arr_sign[i] = 0;\n     \
    \   } else if arr[i] > 0 {\n            arr_sign[i] = 1;\n        } else {\n \
    \           arr_sign[i] = -1;\n        }\n        sign_prod *= arr_sign[i];\n\
    \    }\n    return Some(mag_sum * sign_prod);\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut accum = arr.len() as isize;\n    for i\
    \ in &arr {\n        match i.signum() {\n            1 => accum *= 1,\n      \
    \      -1 => accum *= -1,\n            _ => accum *= 0,\n        }\n    }\n  \
    \  Some(accum)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-4)`,\n right: `Some(-9)`', /tmp/tmpy977vbbp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    // TODO: Implement the function\
    \ according to the instructions above\n    arr.iter().fold(None, |acc, &x| {\n\
    \        Some(\n            if acc.is_none() {\n                if x > 0 { 1 }\
    \ else if x < 0 { -1 } else { 0 }\n            } else {\n                let mut\
    \ y = acc.unwrap();\n                if x > 0 {\n                    y = y * 1;\n\
    \                } else if x < 0 {\n                    y = y * -1;\n        \
    \        } else {\n                    y = y * 0;\n                }\n       \
    \         y\n            }\n        )\n    })\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmptzdusgf8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpb2y4qn5q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979923
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let sign_prod = arr.iter().fold(1, |prod, x| {\n\
    \        if *x > 0 {\n            prod * 1\n        } else if *x < 0 {\n     \
    \       prod * -1\n        } else {\n            prod * 0\n        }\n    });\n\
    \    Some(arr.iter().fold(0, |sum, x| sum + x.abs()) * sign_prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.iter().fold(None, |acc,\
    \ x| match acc {\n        None => Some(x.signum()),\n        Some(res) => Some(res\
    \ * x.signum()),\n    })\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpeutgw9as.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 1
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n    let\
    \ mut sum = 0;\n    for a in arr {\n        match a.cmp(&0) {\n            Ordering::Greater\
    \ => {\n                prod *= 1;\n                sum += a;\n            }\n\
    \            Ordering::Less => {\n                prod *= -1;\n              \
    \  sum += -a;\n            }\n            Ordering::Equal => {}\n        }\n \
    \   }\n    if sum == 0 {\n        None\n    } else {\n        Some(sum * prod)\n\
    \    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpeew3oxh4.rs:17:13\n   |\n17 |             Ordering::Greater => {\n \
    \  |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpeew3oxh4.rs:21:13\n\
    \   |\n21 |             Ordering::Less => {\n   |             ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpeew3oxh4.rs:25:13\n   |\n25 |             Ordering::Equal\
    \ => {}\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ the sum of magnitudes of integers multiplied by product of all signs of each\
    \ number in {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return the sum of magnitudes
    of integers multiplied by product of all signs of each number in [1, 2, 2, -4]'',
    /tmp/tmpf1y3529q.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659979925
- exit_code: 0
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n    for\
    \ i in arr {\n        let sign = (i > 0) as isize - (i < 0) as isize;\n      \
    \  sum += i.abs();\n        prod *= sign;\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979925
- exit_code: 101
  program: "/// You are given a vector arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the vector, represented by 1, -1 or 0.\n/// Note: return None for\
    \ empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// 9\n///\
    \ >>> prod_signs(vec![0, 1])\n/// 0\n/// >>> prod_signs(vec![])\n/// None\nfn\
    \ prod_signs(arr: Vec<isize>) -> Option<isize> {\n    arr.into_iter().fold(Some(1),\
    \ |acc, n| {\n        if n > 0 {\n            acc.map(|acc| acc * 1)\n       \
    \ } else if n < 0 {\n            acc.map(|acc| acc * -1)\n        } else {\n \
    \           acc.map(|acc| acc * 0)\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n\
    \    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-1)`,\n right: `Some(-9)`', /tmp/tmpwqhujp83.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659979925
