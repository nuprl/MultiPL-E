language: rs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for ch in group.chars() {\n                if ch == '(' {\n\
    \                    depth += 1;\n                } else if ch == ')' {\n    \
    \                depth -= 1;\n                }\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            max_depth\n        })\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut stack =\
    \ Vec::new();\n    let mut deepest_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == ' ' {\n            res.push(deepest_level);\n           \
    \ stack.clear();\n            deepest_level = 0;\n        } else if c == '(' {\n\
    \            stack.push(c);\n            deepest_level = stack.len() as isize;\n\
    \        } else if c == ')' {\n            stack.pop();\n        }\n    }\n  \
    \  res.push(deepest_level);\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpywesrl_i.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // TODO: implement this function\n    let mut deepest_level\
    \ = Vec::new();\n    let mut current_level = 0;\n    let mut paren_string = paren_string.chars();\n\
    \    loop {\n        match paren_string.next() {\n            Some('(') => {\n\
    \                current_level += 1;\n            }\n            Some(')') =>\
    \ {\n                current_level -= 1;\n            }\n            Some(' ')\
    \ => {\n                deepest_level.push(current_level);\n                current_level\
    \ = 0;\n            }\n            None => {\n                break;\n       \
    \     }\n            _ => {}\n        }\n    }\n    deepest_level\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9ggex1_0.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting\
    \ = 0;\n    let mut parsed_parens = Vec::new();\n    for character in paren_string.chars()\
    \ {\n        match character {\n            '(' => {\n                curr_nesting\
    \ += 1;\n                if curr_nesting > max_nesting {\n                   \
    \ max_nesting = curr_nesting;\n                }\n            }\n            ')'\
    \ => {\n                curr_nesting -= 1;\n            }\n            ' ' =>\
    \ {\n                parsed_parens.push(max_nesting);\n                max_nesting\
    \ = 0;\n                curr_nesting = 0;\n            }\n            _ => (),\n\
    \        }\n    }\n    parsed_parens.push(max_nesting);\n    parsed_parens\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_pars = vec![];\n    let mut depth =\
    \ 0;\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            depth += 1;\n            if depth > max_depth {\n\
    \                max_depth = depth;\n            }\n        } else if c == ')'\
    \ {\n            depth -= 1;\n        } else if c == ' ' {\n            max_pars.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_pars.push(max_depth);\n\
    \    max_pars\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // TODO: implement me\n    let paren_groups: Vec<&str>\
    \ = paren_string.split_whitespace().collect();\n    // iterate through each group\
    \ of parens\n    let mut deep_parens: Vec<isize> = Vec::new();\n    for &group\
    \ in paren_groups.iter() {\n        // count number of open parens\n        let\
    \ mut open_parens: isize = 0;\n        let mut max_open_parens: isize = 0;\n \
    \       for character in group.chars() {\n            if character == '(' {\n\
    \                open_parens += 1;\n                if open_parens > max_open_parens\
    \ {\n                    max_open_parens = open_parens;\n                }\n \
    \           } else if character == ')' {\n                open_parens -= 1;\n\
    \            }\n        }\n        deep_parens.push(max_open_parens);\n    }\n\
    \    deep_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut count = 0;\n    let mut max_count = 0;\n\
    \    let mut counts = Vec::new();\n    let mut max_counts = Vec::new();\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            count += 1;\n\
    \            if count > max_count {\n                max_count = count;\n    \
    \        }\n        } else if c == ')' {\n            count -= 1;\n        } else\
    \ if c == ' ' {\n            counts.push(count);\n            max_counts.push(max_count);\n\
    \            count = 0;\n            max_count = 0;\n        }\n    }\n    max_counts\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp4hidltnc.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nested_parens = vec![];\n    let mut paren_count\
    \ = 0;\n    let mut max_nesting = 0;\n    for ch in paren_string.chars() {\n \
    \       if ch == '(' {\n            paren_count += 1;\n            if paren_count\
    \ > max_nesting {\n                max_nesting = paren_count;\n            }\n\
    \        } else if ch == ')' {\n            paren_count -= 1;\n        } else\
    \ if ch == ' ' {\n            nested_parens.push(max_nesting);\n            max_nesting\
    \ = 0;\n            paren_count = 0;\n        }\n    }\n    nested_parens.push(max_nesting);\n\
    \    nested_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_count = 0;\n    for c in paren_string.chars() {\n        match c {\n \
    \           '(' => paren_count += 1,\n            ')' => paren_count -= 1,\n \
    \           ' ' => paren_levels.push(paren_count),\n            _ => (),\n   \
    \     }\n    }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpajj4qr6l.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // keep track of the depth of the current group\n\
    \    let mut current_depth = 0;\n    // keep track of the maximum depth of any\
    \ group\n    let mut max_depth = 0;\n    // parse each character of the given\
    \ string one by one\n    paren_string.chars().fold(vec![], |mut acc, c| {\n  \
    \      // if character is '(' then increment current depth\n        if c == '('\
    \ {\n            current_depth += 1;\n            // update max depth if current\
    \ depth is greater than max\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth;\n            }\n        }\n        //\
    \ if character is ')' then decrement current depth\n        else if c == ')' {\n\
    \            current_depth -= 1;\n        }\n        // if character is space\
    \ then push the maximum depth of current group to the result vec\n        else\
    \ if c == ' ' {\n            acc.push(max_depth);\n            // reset max depth\
    \ to 0 to start counting new group\n            max_depth = 0;\n        }\n  \
    \      acc\n    })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpu5nb63tv.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<char> = Vec::new();\n    let\
    \ mut max_level: isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n  \
    \  for token in paren_string.chars() {\n        match token {\n            '('\
    \ => {\n                stack.push(token);\n                max_level += 1;\n\
    \            }\n            ')' => {\n                stack.pop();\n         \
    \       levels.push(max_level);\n                max_level -= 1;\n           \
    \ }\n            ' ' => {\n                levels.push(max_level);\n         \
    \   }\n            _ => panic!(\"Input string needs to contain only parentheses\
    \ and spaces.\"),\n        }\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 0, 3, 2, 1, 0, 1, 0, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmphgduocll.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // TODO: Implement this function\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmplhute2ju.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            let mut max_nesting = 0;\n           \
    \ let mut curr_nesting = 0;\n            for paren in paren_group.chars() {\n\
    \                if paren == '(' {\n                    curr_nesting += 1;\n \
    \               } else if paren == ')' {\n                    curr_nesting -=\
    \ 1;\n                }\n                if curr_nesting > max_nesting {\n   \
    \                 max_nesting = curr_nesting;\n                }\n           \
    \ }\n            max_nesting\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut count: isize = 0;\n    let mut max_count: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n            if count > max_count\
    \ {\n                max_count = count;\n            }\n        } else if c ==\
    \ ')' {\n            count -= 1;\n        } else if c == ' ' {\n            result.push(max_count);\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n    result.push(max_count);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for elem in paren_string.split_whitespace()\
    \ {\n        let mut paren_vec = Vec::new();\n        let mut running_max = 0;\n\
    \        let mut curr_max = 0;\n        for paren in elem.chars() {\n        \
    \    match paren {\n                '(' => {\n                    curr_max +=\
    \ 1;\n                    running_max = std::cmp::max(running_max, curr_max);\n\
    \                    paren_vec.push(paren);\n                }\n             \
    \   ')' => {\n                    curr_max -= 1;\n                    paren_vec.push(paren);\n\
    \                }\n                _ => {\n                    paren_vec.push(paren);\n\
    \                }\n            }\n        }\n        result.push(running_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let split_parens = paren_string.split_whitespace();\n\
    \    let mut output: Vec<isize> = Vec::new();\n    for paren in split_parens {\n\
    \        let mut num_open = 0;\n        let mut max_open = 0;\n        for char\
    \ in paren.chars() {\n            match char {\n                '(' => {\n   \
    \                 num_open += 1;\n                    if num_open > max_open {\n\
    \                        max_open = num_open;\n                    }\n       \
    \         }\n                ')' => {\n                    num_open -= 1;\n  \
    \              }\n                _ => (),\n            }\n        }\n       \
    \ if num_open == 0 {\n            output.push(max_open);\n        } else {\n \
    \           output.push(-1);\n        }\n    }\n    output\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut stack = vec![];\n    \
    \    let mut max_count = 0;\n        for symbol in paren_group.chars() {\n   \
    \         match symbol {\n                '(' => {\n                    stack.push(symbol);\n\
    \                    max_count = max_count.max(stack.len() as isize);\n      \
    \          }\n                ')' => {\n                    stack.pop();\n   \
    \             }\n                _ => panic!(\"Unrecognized character\"),\n  \
    \          }\n        }\n        levels.push(max_count);\n    }\n    levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting\
    \ = 0;\n    let mut output: Vec<isize> = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            curr_nesting += 1;\n            if curr_nesting\
    \ > max_nesting {\n                max_nesting = curr_nesting;\n            }\n\
    \        } else if c == ')' {\n            if i < paren_string.len() - 1 && paren_string.chars().nth(i\
    \ + 1).unwrap() == ' ' {\n                output.push(max_nesting);\n        \
    \        max_nesting = 0;\n                curr_nesting = 0;\n            } else\
    \ {\n                curr_nesting -= 1;\n            }\n        }\n    }\n   \
    \ output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprnx6fri2.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut out_vec: Vec<isize> = Vec::new();\n    for s in paren_groups {\n\
    \        let mut count: isize = 0;\n        let mut max_count: isize = 0;\n  \
    \      for c in s.chars() {\n            match c {\n                '(' => count\
    \ += 1,\n                ')' => count -= 1,\n                _ => (),\n      \
    \      }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        out_vec.push(max_count);\n    }\n    out_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n    paren_groups\n        .iter()\n        .map(|group| {\n\
    \            let mut max_count = 0;\n            let mut current_count = 0;\n\
    \            for c in group.chars() {\n                if c == '(' {\n       \
    \             current_count += 1;\n                } else if c == ')' {\n    \
    \                if current_count > max_count {\n                        max_count\
    \ = current_count;\n                    }\n                    current_count -=\
    \ 1;\n                }\n            }\n            max_count\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut depth\
    \ = 0;\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' {\n            results.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    results.push(max_depth);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Write your code here\n    let mut depths = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut current_depth = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|parens| {\n            let mut max_level = 0;\n            let mut\
    \ level = 0;\n            for c in parens.chars() {\n                if c == '('\
    \ {\n                    level += 1;\n                } else if c == ')' {\n \
    \                   level -= 1;\n                }\n                if level >\
    \ max_level {\n                    max_level = level;\n                }\n   \
    \         }\n            max_level\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let groups: Vec<String> = paren_string.split_whitespace().map(|s|\
    \ s.to_string()).collect();\n    let mut results: Vec<isize> = Vec::new();\n \
    \   for group in groups {\n        let mut max_level = 0;\n        let mut curr_level\
    \ = 0;\n        for char in group.chars() {\n            if char == '(' {\n  \
    \              curr_level += 1;\n            } else if char == ')' {\n       \
    \         curr_level -= 1;\n            }\n            if curr_level > max_level\
    \ {\n                max_level = curr_level;\n            }\n        }\n     \
    \   results.push(max_level);\n    }\n    results\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut curr_nesting\
    \ = 0;\n    let mut list_nesting = Vec::new();\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            curr_nesting += 1;\n            if\
    \ curr_nesting > max_nesting {\n                max_nesting = curr_nesting;\n\
    \            }\n        } else if paren == ')' {\n            curr_nesting -=\
    \ 1;\n        } else if paren == ' ' {\n            list_nesting.push(max_nesting);\n\
    \            max_nesting = 0;\n            curr_nesting = 0;\n        }\n    }\n\
    \    list_nesting.push(max_nesting);\n    list_nesting\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            let mut open_count = 0;\n            let\
    \ mut max_count = 0;\n            for c in paren_group.chars() {\n           \
    \     if c == '(' {\n                    open_count += 1;\n                  \
    \  if open_count > max_count {\n                        max_count = open_count;\n\
    \                    }\n                } else if c == ')' {\n               \
    \     open_count -= 1;\n                }\n            }\n            if open_count\
    \ != 0 {\n                panic!(\"unbalanced parenthesis\");\n            }\n\
    \            max_count\n        })\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|s|\
    \ {\n            let mut max_nesting = 0;\n            let mut nesting = 0;\n\
    \            for ch in s.chars() {\n                if ch == '(' {\n         \
    \           nesting += 1;\n                } else if ch == ')' {\n           \
    \         nesting -= 1;\n                }\n                if nesting > max_nesting\
    \ {\n                    max_nesting = nesting;\n                }\n         \
    \   }\n            max_nesting\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nested_vec = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        nested_vec.push(parse_single_paren_group(paren_group));\n\
    \    }\n    nested_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_single_paren_group` in this scope\n\
    \ --> /tmp/tmpu9zg0spy.rs:9:25\n  |\n9 |         nested_vec.push(parse_single_paren_group(paren_group));\n\
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976059
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            let mut current_depth = 0;\n         \
    \   let mut deepest_depth = 0;\n            for paren in paren_group.chars() {\n\
    \                match paren {\n                    '(' => {\n               \
    \         current_depth += 1;\n                        if current_depth > deepest_depth\
    \ {\n                            deepest_depth = current_depth;\n            \
    \            }\n                    }\n                    ')' => {\n        \
    \                current_depth -= 1;\n                    }\n                \
    \    _ => {}\n                }\n            }\n            deepest_depth\n  \
    \      })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut current_level\
    \ = 0;\n    let mut groups: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             groups.push(max_level);\n                max_level = 0;\n      \
    \          current_level = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    groups.push(max_level);\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<(char, isize)> = Vec::new();\n\
    \    let mut max_depth: isize = 0;\n    let mut paren_depth: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                if max_depth > 0 {\n                    paren_stack.push(('(',\
    \ max_depth));\n                }\n                max_depth += 1;\n         \
    \   }\n            ')' => {\n                paren_depth.push(max_depth);\n  \
    \              if paren_stack.is_empty() {\n                    max_depth = 0;\n\
    \                } else {\n                    let stack_top = paren_stack.pop().unwrap();\n\
    \                    max_depth = stack_top.1;\n                }\n           \
    \ }\n            _ => continue,\n        }\n    }\n    paren_depth\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpn144ey1k.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let\
    \ mut paren_stack: Vec<char> = Vec::new();\n    let mut paren_max: isize = 0;\n\
    \    let mut paren_level: isize = 0;\n    for c in paren_string.chars() {\n  \
    \      if c == ' ' {\n            if paren_stack.len() > 0 {\n               \
    \ output.push(paren_max);\n                paren_stack.clear();\n            \
    \    paren_max = 0;\n                paren_level = 0;\n            }\n       \
    \ } else if c == '(' {\n            paren_stack.push(c);\n            paren_level\
    \ += 1;\n            if paren_level > paren_max {\n                paren_max =\
    \ paren_level;\n            }\n        } else if c == ')' {\n            if paren_stack.len()\
    \ > 0 {\n                paren_stack.pop();\n                paren_level -= 1;\n\
    \            }\n        }\n    }\n    if paren_stack.len() > 0 {\n        output.push(paren_max);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmplkwm6te7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut group_stack\
    \ = Vec::new();\n    let mut max_nesting = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            group_stack.push(paren);\n       \
    \     max_nesting += 1;\n        } else if paren == ')' {\n            group_stack.pop();\n\
    \            if group_stack.is_empty() {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzugqf_er.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            group\n                .chars()\n          \
    \      .fold((0, 0), |(level, max_level), c| match c {\n                    '('\
    \ => (level + 1, cmp::max(level + 1, max_level)),\n                    ')' =>\
    \ (level - 1, cmp::max(level - 1, max_level)),\n                    _ => (level,\
    \ max_level),\n                })\n                .1\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpf9jboxc8.rs:13:40\n   |\n13 |                     '(' => (level\
    \ + 1, cmp::max(level + 1, max_level)),\n   |                                \
    \        ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpf9jboxc8.rs:14:40\n\
    \   |\n14 |                     ')' => (level - 1, cmp::max(level - 1, max_level)),\n\
    \   |                                        ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976059
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|parens| {\n            let mut deepest_count = 0;\n            let\
    \ mut curr_count = 0;\n            let mut char_iter = parens.chars();\n     \
    \       while let Some(ch) = char_iter.next() {\n                if ch == '('\
    \ {\n                    curr_count += 1;\n                    if curr_count >\
    \ deepest_count {\n                        deepest_count = curr_count;\n     \
    \               }\n                } else if ch == ')' {\n                   \
    \ curr_count -= 1;\n                }\n            }\n            deepest_count\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut paren_stack: Vec<char> = Vec::new();\n    let mut current_depth: isize =\
    \ 0;\n    let mut max_depth: isize = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            paren_stack.push(paren);\n       \
    \     current_depth += 1;\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth;\n            }\n        } else if paren\
    \ == ')' {\n            if paren_stack.pop() != Some('(') {\n                return\
    \ Vec::new();\n            }\n            current_depth -= 1;\n        } else\
    \ if paren == ' ' {\n            result.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut depth:\
    \ isize = 0;\n    let mut paren_group: String = String::new();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == ' ' {\n            if depth > max_depth {\n                max_depth =\
    \ depth;\n            }\n            depth = 0;\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            paren_group.clear();\n        } else\
    \ {\n            paren_group.push(c);\n            if c == '(' {\n           \
    \     depth += 1;\n            } else if c == ')' {\n                depth -=\
    \ 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7m_y9bee.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // create a vec of tuples representing groups of\
    \ parens and the number of parens\n    let paren_vec: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n    let paren_vec: Vec<(&str, usize)> = paren_vec.iter().map(|s|\
    \ (s, s.len())).collect();\n\n    // create a vec of pairs in which the index\
    \ is the paren level, and the value is the number of parens at that level\n  \
    \  // the index is initialized to 0\n    let mut levels: Vec<(usize, usize)> =\
    \ vec![(0, 0)];\n\n    // this method will iterate through the vec of tuples from\
    \ the split string\n    // and create a new vector of tuples where the first value\
    \ is the level of the paren\n    // and the second value is the number of parens\
    \ at that level\n    // levels is a mutable reference to this new vector\n   \
    \ paren_vec.iter().for_each(|pair| {\n        let parens = pair.1;\n        let\
    \ mut level = 0;\n        let mut count = 0;\n\n        // loop through the first\
    \ string in each pair in the vec\n        // and create a new pair with the index\
    \ as the level and the value as the number of parens\n        for c in pair.0.chars()\
    \ {\n            match c {\n                '(' => {\n                    level\
    \ += 1;\n                    count += 1;\n                }\n                ')'\
    \ => {\n                    level -= 1;\n                    count += 1;\n   \
    \             }\n                _ => (),\n            }\n        }\n\n      \
    \  // the loop through the vec of pairs and check if the level index is the same\n\
    \        // if it is, increment the paren count at that level by the number of\
    \ parens in the pair\n        // if not, add the tuple to the end of the vec\n\
    \        let mut found = false;\n        for i in 0..levels.len() {\n        \
    \    if levels[i].0 == level {\n                levels[i].1 += parens;\n     \
    \           found = true;\n            }\n        }\n        if !found {\n   \
    \         levels.push((level, count));\n        }\n    });\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(&str, usize)>` cannot be built from\
    \ an iterator over elements of type `(&&str, usize)`\n    --> /tmp/tmp_038p70_.rs:9:80\n\
    \     |\n9    |     let paren_vec: Vec<(&str, usize)> = paren_vec.iter().map(|s|\
    \ (s, s.len())).collect();\n     |                                           \
    \                                     ^^^^^^^ value of type `Vec<(&str, usize)>`\
    \ cannot be built from `std::iter::Iterator<Item=(&&str, usize)>`\n     |\n  \
    \   = help: the trait `FromIterator<(&&str, usize)>` is not implemented for `Vec<(&str,\
    \ usize)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp_038p70_.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n  |\n  = note: expected struct\
    \ `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976059
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n\
    \    let mut depth_stack: Vec<isize> = Vec::new();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for paren in paren_string.chars() {\n        match paren\
    \ {\n            '(' => {\n                let mut count = 1;\n              \
    \  paren_stack.push(paren.into());\n                if let Some(depth) = depth_stack.last_mut()\
    \ {\n                    *depth += 1;\n                } else {\n            \
    \        depth_stack.push(count);\n                }\n            }\n        \
    \    ')' => {\n                if paren_stack.pop().is_none() {\n            \
    \        panic!(\"Unbalanced right parentheses\");\n                }\n      \
    \          if let Some(depth) = depth_stack.pop() {\n                    result.push(depth);\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    if !paren_stack.is_empty() {\n        panic!(\"Unbalanced left parentheses\"\
    );\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: From<char>` is not satisfied\n  -->\
    \ /tmp/tmp_l96_jwf.rs:14:40\n   |\n14 |                 paren_stack.push(paren.into());\n\
    \   |                                        ^^^^ the trait `From<char>` is not\
    \ implemented for `isize`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n\
    \             <f32 as From<u16>>\n             <f32 as From<u8>>\n           \
    \  <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n\
    \             <f64 as From<i8>>\n           and 67 others\n   = note: required\
    \ because of the requirements on the impl of `Into<isize>` for `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976059
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            let mut level = 0;\n            let mut max_level\
    \ = 0;\n            for c in group.chars() {\n                match c {\n    \
    \                '(' => level += 1,\n                    ')' => level -= 1,\n\
    \                    _ => (),\n                }\n                max_level =\
    \ max_level.max(level);\n            }\n            max_level\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<(char, isize)> = Vec::new();\n\
    \    let mut output = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            if let Some((_, depth)) = stack.last() {\n    \
    \            stack.push((c, depth + 1));\n            } else {\n             \
    \   stack.push((c, 1));\n            }\n        } else if c == ')' {\n       \
    \     if let Some((last_char, depth)) = stack.pop() {\n                if last_char\
    \ == '(' {\n                    output.push(*depth);\n                } else {\n\
    \                    output.push(0);\n                }\n            } else {\n\
    \                output.push(0);\n            }\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptfsfpdlr.rs:19:33\n\
    \   |\n19 |                     output.push(*depth);\n   |                   \
    \              ^^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976059
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n \
    \   let paren_vec_vec: Vec<Vec<char>> = paren_string\n        .split_whitespace()\n\
    \        .map(|s| s.chars().collect())\n        .collect();\n    for item in paren_vec_vec\
    \ {\n        let mut num_left_paren = 0;\n        let mut curr_max = 0;\n    \
    \    for paren in item {\n            if paren == '(' {\n                num_left_paren\
    \ += 1;\n                if num_left_paren > curr_max {\n                    curr_max\
    \ = num_left_paren;\n                }\n            } else {\n               \
    \ num_left_paren -= 1;\n            }\n        }\n        paren_vec.push(curr_max);\n\
    \    }\n    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth = 0;\n    let mut paren_max_depth\
    \ = 0;\n    let mut paren_nesting = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_depth += 1;\n\
    \                if paren_depth > paren_max_depth {\n                    paren_max_depth\
    \ = paren_depth;\n                }\n            }\n            ')' => {\n   \
    \             paren_depth -= 1;\n            }\n            ' ' => {\n       \
    \         paren_nesting.push(paren_max_depth);\n                paren_depth =\
    \ 0;\n                paren_max_depth = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n    paren_nesting.push(paren_max_depth);\n    paren_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut curr_level\
    \ = 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                curr_level += 1;\n \
    \               if curr_level > max_level {\n                    max_level = curr_level;\n\
    \                }\n            }\n            ')' => {\n                if curr_level\
    \ > 0 {\n                    curr_level -= 1;\n                }\n           \
    \ }\n            ' ' => {\n                result.push(max_level);\n         \
    \       max_level = 0;\n                curr_level = 0;\n            }\n     \
    \       _ => (),\n        }\n    }\n    if curr_level > 0 {\n        result.push(max_level);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp02c6fsjb.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    return paren_string\n        .split_whitespace()\n\
    \        .map(|s| {\n            let mut max_nesting_level = 0;\n            let\
    \ mut current_nesting_level = 0;\n            for c in s.chars() {\n         \
    \       if c == '(' {\n                    current_nesting_level += 1;\n     \
    \               if current_nesting_level > max_nesting_level {\n             \
    \           max_nesting_level = current_nesting_level;\n                    }\n\
    \                } else if c == ')' {\n                    current_nesting_level\
    \ -= 1;\n                }\n            }\n            max_nesting_level\n   \
    \     })\n        .collect();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut group_max = Vec::new();\n    let mut max\
    \ = 0;\n    let mut current = 0;\n    for paren in paren_string.chars() {\n  \
    \      match paren {\n            '(' => {\n                current += 1;\n  \
    \              if current > max {\n                    max = current;\n      \
    \          }\n            }\n            ')' => {\n                current -=\
    \ 1;\n            }\n            ' ' => {\n                group_max.push(max);\n\
    \                max = 0;\n                current = 0;\n            }\n     \
    \       _ => continue,\n        }\n    }\n    group_max.push(max);\n    group_max\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut max_depth = 0;\n            let mut curr_depth\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                curr_depth += 1;\n                    if curr_depth > max_depth\
    \ {\n                        max_depth = curr_depth;\n                    }\n\
    \                } else if c == ')' {\n                    curr_depth -= 1;\n\
    \                }\n            }\n            max_depth\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut level =\
    \ 0;\n    let mut max_level = 0;\n    for ch in paren_string.chars() {\n     \
    \   if ch == '(' {\n            level += 1;\n            max_level = std::cmp::max(max_level,\
    \ level);\n        } else if ch == ')' {\n            level -= 1;\n        } else\
    \ if ch == ' ' {\n            ret.push(max_level);\n            max_level = 0;\n\
    \            level = 0;\n        }\n    }\n    if max_level > 0 {\n        ret.push(max_level);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<char> = Vec::new();\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    let mut highest_count: isize = 0;\n\
    \    let mut current_count: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current_count += 1;\n            if current_count\
    \ > highest_count {\n                highest_count = current_count;\n        \
    \    }\n            stack.push(c);\n        } else if c == ')' {\n           \
    \ current_count -= 1;\n            if current_count < 0 {\n                result.push(-1);\n\
    \                highest_count = 0;\n                current_count = 0;\n    \
    \            stack.clear();\n            } else {\n                stack.pop();\n\
    \                if stack.is_empty() {\n                    result.push(highest_count);\n\
    \                    highest_count = 0;\n                    current_count = 0;\n\
    \                }\n            }\n        } else if c == ' ' {\n            if\
    \ stack.is_empty() {\n                highest_count = 0;\n                current_count\
    \ = 0;\n            }\n        }\n    }\n    if !stack.is_empty() {\n        result.push(-1);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut current_level = 0;\n    let mut max_level\
    \ = 0;\n    let mut max_levels = Vec::new();\n    let mut chars = paren_string.chars();\n\
    \    while let Some(c) = chars.next() {\n        match c {\n            '(' =>\
    \ {\n                current_level += 1;\n                if current_level > max_level\
    \ {\n                    max_level = current_level;\n                }\n     \
    \       }\n            ')' => {\n                current_level -= 1;\n       \
    \     }\n            ' ' => {\n                max_levels.push(max_level);\n \
    \               max_level = 0;\n                current_level = 0;\n         \
    \   }\n            _ => panic!(\"Unexpected char {}\", c),\n        }\n    }\n\
    \    max_levels.push(max_level);\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            let mut max_depth = 0;\n            let\
    \ mut current_depth = 0;\n            for ch in paren_group.chars() {\n      \
    \          match ch {\n                    '(' => {\n                        current_depth\
    \ += 1;\n                        if current_depth > max_depth {\n            \
    \                max_depth = current_depth;\n                        }\n     \
    \               }\n                    ')' => {\n                        current_depth\
    \ -= 1;\n                    }\n                    _ => (),\n               \
    \ }\n            }\n            max_depth\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut current_level:\
    \ isize = 0;\n    let mut results: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             results.push(max_level);\n                max_level = 0;\n     \
    \           current_level = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    results.push(max_level);\n    results\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    for grp in paren_string.split_whitespace()\
    \ {\n        results.push(parse_nested_parens_helper(grp));\n    }\n    results\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n --> /tmp/tmpm5vc0k2f.rs:9:22\n  |\n9 |         results.push(parse_nested_parens_helper(grp));\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    for\
    \ paren in paren_string.split_whitespace() {\n        let mut paren_iter = paren.chars();\n\
    \        let mut max_nesting = 0;\n        let mut nesting = 0;\n        let mut\
    \ prev_c = ' ';\n        while let Some(c) = paren_iter.next() {\n           \
    \ if c == '(' {\n                nesting += 1;\n            } else if c == ')'\
    \ {\n                nesting -= 1;\n            }\n            if prev_c == '('\
    \ && c == ')' {\n                max_nesting = std::cmp::max(max_nesting, nesting);\n\
    \            }\n            prev_c = c;\n        }\n        output.push(max_nesting);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpsqub5pwa.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    return paren_string\n        .split_whitespace()\n\
    \        .map(|g| {\n            let mut paren_level = 0;\n            let mut\
    \ deepest_level = 0;\n            for c in g.chars() {\n                if c ==\
    \ '(' {\n                    paren_level += 1;\n                    if paren_level\
    \ > deepest_level {\n                        deepest_level = paren_level;\n  \
    \                  }\n                } else if c == ')' {\n                 \
    \   paren_level -= 1;\n                }\n            }\n            return deepest_level;\n\
    \        })\n        .collect();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level_idx = 0;\n    let mut max_levels\
    \ = Vec::new();\n    for ch in paren_string.chars() {\n        match ch {\n  \
    \          '(' => level_idx += 1,\n            ')' => level_idx -= 1,\n      \
    \      ' ' => {\n                max_levels.push(level_idx);\n               \
    \ level_idx = 0;\n            }\n            _ => panic!(\"Invalid character found\
    \ in string!\"),\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpik810a2w.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = vec![];\n    let mut open_count\
    \ = 0;\n    let mut max_open_count = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            open_count += 1;\n            if open_count\
    \ > max_open_count {\n                max_open_count = open_count;\n         \
    \   }\n        } else if c == ')' {\n            open_count -= 1;\n        } else\
    \ if c == ' ' {\n            max_nesting.push(max_open_count);\n            max_open_count\
    \ = 0;\n            open_count = 0;\n        }\n    }\n    max_nesting.push(max_open_count);\n\
    \    max_nesting\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut stack =\
    \ Vec::new();\n    let mut count = 0;\n    for ch in paren_string.chars() {\n\
    \        if ch == '(' {\n            stack.push(ch);\n            count += 1;\n\
    \        } else if ch == ')' {\n            stack.pop();\n            count -=\
    \ 1;\n        } else if ch == ' ' {\n            res.push(count);\n          \
    \  count = 0;\n        }\n    }\n    res.push(count);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfecgfppa.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<char> = Vec::new();\n  \
    \  let mut res: Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_vec.push(c);\n        } else if c ==\
    \ ')' {\n            if paren_vec.pop() == Some('(') {\n                res.push(paren_vec.len()\
    \ as isize);\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 0, 2, 1, 0, 0, 2, 1, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp0gph815c.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // let mut paren_stack: Vec<char> = Vec::new();\n\
    \    // let mut paren_stack_idx: Vec<usize> = Vec::new();\n    // let mut max_depth:\
    \ isize = 0;\n    // let mut curr_depth: isize = 0;\n    // let mut num_groups:\
    \ usize = 0;\n    // let mut group_max_depth: Vec<isize> = Vec::new();\n    //\
    \ for (i, c) in paren_string.chars().enumerate() {\n    //     match c {\n   \
    \ //         '(' => {\n    //             paren_stack.push(c);\n    //       \
    \      paren_stack_idx.push(i);\n    //             curr_depth += 1;\n    // \
    \            if curr_depth > max_depth {\n    //                 max_depth = curr_depth;\n\
    \    //             }\n    //         }\n    //         ')' => {\n    //     \
    \        paren_stack.pop();\n    //             paren_stack_idx.pop();\n    //\
    \             curr_depth -= 1;\n    //         }\n    //         ' ' => {\n  \
    \  //             if !paren_stack.is_empty() {\n    //                 panic!(\"\
    Error in parsing parentheses {} at index {}\", paren_string, i);\n    //     \
    \        }\n    //             group_max_depth.push(max_depth);\n    //      \
    \       max_depth = 0;\n    //             curr_depth = 0;\n    //           \
    \  num_groups += 1;\n    //         }\n    //         _ => {}\n    //     }\n\
    \    // }\n    // if !paren_stack.is_empty() {\n    //     panic!(\"Error in parsing\
    \ parentheses {} at index {}\", paren_string, paren_string.len() - 1);\n    //\
    \ }\n    // if num_groups != paren_string.split(' ').count() {\n    //     panic!(\"\
    Num groups {} is not equal to len {}\", num_groups, paren_string.split(' ').count());\n\
    \    // }\n    // group_max_depth.push(max_depth);\n    //\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpfkaztne4.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    groups.iter().map(|g| {\n        let mut num_left_parens = 0;\n        let\
    \ mut max_depth = 0;\n        let mut chars = g.chars();\n        while let Some(c)\
    \ = chars.next() {\n            match c {\n                '(' => {\n        \
    \            num_left_parens += 1;\n                    max_depth = num_left_parens.max(max_depth);\n\
    \                }\n                ')' => {\n                    num_left_parens\
    \ -= 1;\n                }\n                _ => unreachable!(),\n           \
    \ }\n        }\n        max_depth\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut res = Vec::new();\n    for paren_substring\
    \ in paren_string.split(\" \") {\n        let mut max_depth = 0;\n        let\
    \ mut curr_depth = 0;\n        for paren in paren_substring.chars() {\n      \
    \      if paren == '(' {\n                curr_depth += 1;\n                max_depth\
    \ = max(max_depth, curr_depth);\n            } else if paren == ')' {\n      \
    \          curr_depth -= 1;\n            }\n        }\n        res.push(max_depth);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmph30a0n8p.rs:14:29\n\
    \   |\n14 |                 max_depth = max(max_depth, curr_depth);\n   |    \
    \                         ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut paren_stack\
    \ = Vec::new();\n    let mut parse_vec = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_stack.push(c);\n            max_nesting\
    \ += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n      \
    \      max_nesting -= 1;\n        } else if c == ' ' {\n            parse_vec.push(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    parse_vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp5lzns1ik.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            s.chars()\n                .fold(0isize, |max_depth,\
    \ c| match c {\n                    '(' => max_depth + 1,\n                  \
    \  ')' => max_depth - 1,\n                    _ => max_depth,\n              \
    \  })\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpv6ahrclu.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ current_level = 0;\n    let mut max_level = 0;\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             paren_levels.push(max_level);\n                max_level = 0;\n\
    \                current_level = 0;\n            }\n            _ => (),\n   \
    \     }\n    }\n    if current_level > 0 {\n        paren_levels.push(max_level);\n\
    \    }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpwhnbf8vb.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut levels = Vec::new();\n\
    \    let mut current_level = 0;\n    for character in paren_string.chars() {\n\
    \        match character {\n            '(' => {\n                current_level\
    \ += 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               levels.push(current_level);\n                current_level -=\
    \ 1;\n            }\n            _ => {}\n        }\n    }\n    levels\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbtvtwg7l.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut maximum_nesting = 0;\n    let mut paren_vec:\
    \ Vec<isize> = Vec::new();\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' => {\n                maximum_nesting += 1;\n        \
    \        paren_vec.push(1);\n            }\n            ')' => {\n           \
    \     paren_vec.push(-1);\n                if paren_vec.iter().sum::<isize>()\
    \ == 0 {\n                    paren_vec.push(maximum_nesting);\n             \
    \       maximum_nesting = 0;\n                }\n            }\n            _\
    \ => continue,\n        }\n    }\n    paren_vec\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, -1, 1, -1, -1, 3, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, -1,\
    \ 1, -1, -1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpadqsur87.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            let mut max_nesting = 0;\n            let mut\
    \ current_nesting = 0;\n            let mut chars = group.chars();\n         \
    \   while let Some(paren) = chars.next() {\n                match paren {\n  \
    \                  '(' => {\n                        current_nesting += 1;\n \
    \                       if current_nesting > max_nesting {\n                 \
    \           max_nesting = current_nesting;\n                        }\n      \
    \              }\n                    ')' => {\n                        current_nesting\
    \ -= 1;\n                    }\n                    _ => panic!(\"Unexpected character\
    \ in paren string\"),\n                }\n            }\n            max_nesting\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut counter = 0;\n    let mut max_counter =\
    \ 0;\n    let mut max_parens = Vec::new();\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            counter += 1;\n        } else if ch ==\
    \ ')' {\n            counter -= 1;\n        } else if ch == ' ' {\n          \
    \  max_parens.push(max_counter);\n            max_counter = 0;\n        } else\
    \ {\n            panic!(\"Unknown char: {}\", ch);\n        }\n        if counter\
    \ > max_counter {\n            max_counter = counter;\n        }\n    }\n    max_parens.push(max_counter);\n\
    \    max_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|p| {\n            let mut max_depths = Vec::new();\n            let\
    \ mut depth = 0;\n            for c in p.chars() {\n                match c {\n\
    \                    '(' => depth += 1,\n                    ')' => depth -= 1,\n\
    \                    _ => {\n                        println!(\"Unexpected character\
    \ {:?}\", c);\n                        panic!();\n                    }\n    \
    \            }\n                max_depths.push(depth);\n            }\n     \
    \       if *max_depths.iter().max().unwrap() != 0 {\n                println!(\"\
    No matching parentheses in string {:?}\", p);\n                panic!();\n   \
    \         }\n            max_depths.into_iter().max().unwrap()\n        })\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''explicit panic'', /tmp/tmpithybclp.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: 'No matching parentheses in string "(()())"

    '
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_strings: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n    paren_strings\n        .iter()\n        .map(|paren_str|\
    \ {\n            let mut paren_level = 0;\n            let mut max_level = 0;\n\
    \            for char in paren_str.chars() {\n                if char == '(' {\n\
    \                    paren_level += 1;\n                } else if char == ')'\
    \ {\n                    paren_level -= 1;\n                }\n              \
    \  if paren_level > max_level {\n                    max_level = paren_level;\n\
    \                }\n            }\n            max_level\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_nesting\
    \ = 0;\n    let mut current_nesting = 0;\n    let mut paren_iter = paren_string.chars();\n\
    \    for c in paren_iter {\n        match c {\n            '(' => {\n        \
    \        current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => (),\n        }\n    }\n    result.push(max_nesting);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut chars = paren_string.chars();\n    let mut max_level = 0;\n    let mut curr_level\
    \ = 0;\n    loop {\n        match chars.next() {\n            Some('(') => {\n\
    \                curr_level += 1;\n                if curr_level > max_level {\n\
    \                    max_level = curr_level;\n                }\n            }\n\
    \            Some(')') => {\n                curr_level -= 1;\n            }\n\
    \            Some(' ') => {\n                result.push(max_level);\n       \
    \         max_level = 0;\n                curr_level = 0;\n            }\n   \
    \         None => {\n                result.push(max_level);\n               \
    \ break;\n            }\n            _ => {}\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_grp| {\n            let mut nest_level = 0;\n            let\
    \ mut max_nest_level = 0;\n            for c in paren_grp.chars() {\n        \
    \        if c == '(' {\n                    nest_level += 1;\n               \
    \ } else if c == ')' {\n                    nest_level -= 1;\n               \
    \ }\n                if nest_level > max_nest_level {\n                    max_nest_level\
    \ = nest_level;\n                }\n            }\n            max_nest_level\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut string_iter\
    \ = paren_string.split_whitespace();\n    while let Some(curr_str) = string_iter.next()\
    \ {\n        let mut curr_max = 0;\n        let mut max_so_far = 0;\n        for\
    \ ch in curr_str.chars() {\n            if ch == '(' {\n                curr_max\
    \ += 1;\n            } else if ch == ')' {\n                curr_max -= 1;\n \
    \           }\n            if curr_max > max_so_far {\n                max_so_far\
    \ = curr_max;\n            }\n        }\n        results.push(max_so_far);\n \
    \   }\n    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut curr_depth: isize = 0;\n    let mut max_depth: isize = 0;\n    for ch in\
    \ paren_string.chars() {\n        if ch == '(' {\n            curr_depth += 1;\n\
    \            if curr_depth > max_depth {\n                max_depth = curr_depth;\n\
    \            }\n        } else if ch == ')' {\n            curr_depth -= 1;\n\
    \        } else if ch == ' ' {\n            result.push(max_depth);\n        \
    \    curr_depth = 0;\n            max_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut max_depth = 0;\n            let mut current_depth\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                current_depth += 1;\n                    if current_depth > max_depth\
    \ {\n                        max_depth = current_depth;\n                    }\n\
    \                } else if c == ')' {\n                    current_depth -= 1;\n\
    \                }\n            }\n            max_depth\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nested_parens: Vec<isize> = Vec::new();\n\
    \    let mut max_nesting = 0;\n    let mut curr_nesting = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_nesting += 1;\n            if curr_nesting\
    \ > max_nesting {\n                max_nesting = curr_nesting;\n            }\n\
    \        } else if c == ')' {\n            if curr_nesting > 0 {\n           \
    \     curr_nesting -= 1;\n            }\n        } else if c == ' ' {\n      \
    \      nested_parens.push(max_nesting);\n            max_nesting = 0;\n      \
    \      curr_nesting = 0;\n        }\n    }\n    // For last group,\n    if max_nesting\
    \ > 0 {\n        nested_parens.push(max_nesting);\n    }\n    nested_parens\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n    let mut\
    \ max: isize = 0;\n    let mut curr: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr += 1;\n            if curr > max\
    \ {\n                max = curr;\n            }\n        } else if c == ')' {\n\
    \            curr -= 1;\n        } else if c == ' ' {\n            v.push(max);\n\
    \            max = 0;\n            curr = 0;\n        }\n    }\n    v.push(max);\n\
    \    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut paren_iter = paren_string.split_whitespace();\n    while let Some(paren)\
    \ = paren_iter.next() {\n        let mut paren_stack: Vec<char> = Vec::new();\n\
    \        let mut current_max = 0;\n        let mut current_level = 0;\n      \
    \  for ch in paren.chars() {\n            if ch == '(' {\n                paren_stack.push(ch);\n\
    \                current_level += 1;\n                if current_level > current_max\
    \ {\n                    current_max = current_level;\n                }\n   \
    \         } else if ch == ')' {\n                if paren_stack.len() > 0 {\n\
    \                    paren_stack.pop();\n                    current_level -=\
    \ 1;\n                }\n            }\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    let\
    \ mut paren_groups = Vec::new();\n    let mut paren_count = 0;\n    let mut max_nested_level\
    \ = Vec::new();\n    for paren in paren_string.chars() {\n        if paren ==\
    \ '(' {\n            paren_count += 1;\n        } else if paren == ')' {\n   \
    \         paren_count -= 1;\n        }\n        if paren == ' ' || paren == ')'\
    \ {\n            paren_groups.push(paren_count);\n        }\n    }\n    let mut\
    \ lowest_level = 0;\n    for paren_group in paren_groups {\n        if paren_group\
    \ < lowest_level {\n            lowest_level = paren_group;\n        }\n     \
    \   max_nested_level.push(paren_group - lowest_level);\n    }\n    max_nested_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 0, 0, 2, 1, 0, 0, 0, 0, 2, 1, 1, 1, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpmynuippo.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|s|\
    \ {\n            let mut open_parens = 0;\n            let mut max_level = 0;\n\
    \            for c in s.chars() {\n                if c == '(' {\n           \
    \         open_parens += 1;\n                    if open_parens > max_level {\n\
    \                        max_level = open_parens;\n                    }\n   \
    \             } else if c == ')' {\n                    open_parens -= 1;\n  \
    \              }\n            }\n            max_level\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut start_indices: Vec<usize> = Vec::new();\n    let mut end_indices:\
    \ Vec<usize> = Vec::new();\n    let mut group_level_vec: Vec<isize> = Vec::new();\n\
    \    let mut group_level: isize = 0;\n    let mut group_start_index: usize = 0;\n\
    \    let mut group_end_index: usize = 0;\n    for (i, paren) in paren_vec.iter().enumerate()\
    \ {\n        match paren {\n            '(' => {\n                if group_level\
    \ == 0 {\n                    group_start_index = i;\n                }\n    \
    \            group_level += 1;\n            }\n            ')' => {\n        \
    \        group_level -= 1;\n                if group_level == 0 {\n          \
    \          group_end_index = i;\n                    start_indices.push(group_start_index);\n\
    \                    end_indices.push(group_end_index);\n                }\n \
    \           }\n            _ => {}\n        }\n    }\n    for (i, j) in start_indices.iter().zip(end_indices.iter())\
    \ {\n        group_level_vec.push(parse_nested_parens_helper(&paren_vec[i + 1..j]));\n\
    \    }\n    group_level_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n  --> /tmp/tmps71pukus.rs:34:30\n   |\n34 |         group_level_vec.push(parse_nested_parens_helper(&paren_vec[i\
    \ + 1..j]));\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps71pukus.rs:34:75\n\
    \   |\n34 |         group_level_vec.push(parse_nested_parens_helper(&paren_vec[i\
    \ + 1..j]));\n   |                                                           \
    \                ^ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |         group_level_vec.push(parse_nested_parens_helper(&paren_vec[i\
    \ + 1..*j]));\n   |                                                          \
    \                 +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = Vec::new();\n    let mut\
    \ nested_parens = Vec::new();\n    for char in paren_string.chars() {\n      \
    \  match char {\n            '(' => {\n                nested_parens.push(char);\n\
    \            }\n            ')' => {\n                match nested_parens.pop()\
    \ {\n                    Some('(') => max_nesting.push(nested_parens.len() as\
    \ isize),\n                    Some(_) => panic!(\"Found stray ')'\"),\n     \
    \               None => panic!(\"Found stray ')'\"),\n                }\n    \
    \        }\n            _ => panic!(\"Found stray character\"),\n        }\n \
    \   }\n    if !nested_parens.is_empty() {\n        panic!(\"Unmatched parens\"\
    );\n    }\n    max_nesting\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Found stray character'', /tmp/tmpthijd_ni.rs:21:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut depth = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                depth += 1;\n           \
    \     if depth > max_nesting {\n                    max_nesting = depth;\n   \
    \             }\n            }\n            ')' => {\n                depth -=\
    \ 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                depth = 0;\n            }\n\
    \            _ => (),\n        }\n    }\n    result.push(max_nesting);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            paren_group\n                .chars()\n\
    \                .map(|c| match c {\n                    '(' => 1,\n         \
    \           ')' => -1,\n                    _ => 0,\n                })\n    \
    \            .scan(0, |acc, x| {\n                    *acc = *acc + x;\n     \
    \               Some(*acc)\n                })\n                .max()\n     \
    \           .unwrap()\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| count_deepest_nesting(group))\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_deepest_nesting` in this scope\n\
    \ --> /tmp/tmpphwje0na.rs:9:22\n  |\n9 |         .map(|group| count_deepest_nesting(group))\n\
    \  |                      ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nest_count: isize = 0;\n    let mut deepest_nest_count:\
    \ isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for i in paren_string.chars()\
    \ {\n        if i == '(' {\n            nest_count += 1;\n            if nest_count\
    \ > deepest_nest_count {\n                deepest_nest_count = nest_count;\n \
    \           }\n        } else if i == ')' {\n            nest_count -= 1;\n  \
    \      } else if i == ' ' {\n            result.push(deepest_nest_count);\n  \
    \          deepest_nest_count = 0;\n            nest_count = 0;\n        }\n \
    \   }\n    result.push(deepest_nest_count);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_groups: Vec<isize> = Vec::new();\n\
    \    let paren_strings: Vec<&str> = paren_string.split(\" \").collect();\n   \
    \ for paren_str in paren_strings {\n        let mut num_nested_parens = 0;\n \
    \       let mut max_nested_parens = 0;\n        for c in paren_str.chars() {\n\
    \            if c == '(' {\n                num_nested_parens += 1;\n        \
    \    } else if c == ')' {\n                num_nested_parens -= 1;\n         \
    \   }\n            if num_nested_parens > max_nested_parens {\n              \
    \  max_nested_parens = num_nested_parens;\n            }\n        }\n        paren_groups.push(max_nested_parens);\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: -1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut first_paren_pos\
    \ = 0;\n    let mut end_paren_pos = 0;\n    let mut i = 0;\n    while i < paren_string.len()\
    \ {\n        let mut group_parens = 0;\n        let mut inner_parens = 0;\n  \
    \      if &paren_string[i..i + 1] == \"(\" {\n            group_parens += 1;\n\
    \            inner_parens += 1;\n            first_paren_pos = i;\n          \
    \  i += 1;\n            while i < paren_string.len() && group_parens > 0 {\n \
    \               if &paren_string[i..i + 1] == \"(\" {\n                    group_parens\
    \ += 1;\n                    inner_parens += 1;\n                } else if &paren_string[i..i\
    \ + 1] == \")\" {\n                    group_parens -= 1;\n                }\n\
    \                i += 1;\n            }\n            end_paren_pos = i;\n    \
    \        let substring = &paren_string[first_paren_pos..end_paren_pos];\n    \
    \        if substring.contains(\"(\") {\n                let inner_parse = parse_nested_parens(substring.to_string());\n\
    \                vec.push(inner_parse.iter().max().unwrap().clone());\n      \
    \      } else {\n                vec.push(inner_parens);\n            }\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976066
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_levels = Vec::new();\n    let paren_groups:\
    \ Vec<&str> = paren_string.split_whitespace().collect();\n    for parens in paren_groups\
    \ {\n        let mut nest_counter = 0;\n        let mut max_nest = 0;\n      \
    \  for paren in parens.chars() {\n            if paren == '(' {\n            \
    \    nest_counter += 1;\n            } else if paren == ')' {\n              \
    \  nest_counter -= 1;\n            }\n            if nest_counter > max_nest {\n\
    \                max_nest = nest_counter;\n            }\n        }\n        max_levels.push(max_nest);\n\
    \    }\n    max_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting_depth = 0;\n    let mut depth\
    \ = 0;\n    let mut vec = Vec::new();\n    for c in paren_string.chars() {\n \
    \       match c {\n            '(' => {\n                depth += 1;\n       \
    \         if depth > max_nesting_depth {\n                    max_nesting_depth\
    \ = depth;\n                }\n            }\n            ')' => {\n         \
    \       depth -= 1;\n            }\n            ' ' => {\n                vec.push(max_nesting_depth);\n\
    \                max_nesting_depth = 0;\n                depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    vec.push(max_nesting_depth);\n\
    \    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Write code here\n    let mut depth: isize =\
    \ 0;\n    let mut result: Vec<isize> = Vec::new();\n    let mut paren_string:\
    \ Vec<char> = paren_string.chars().collect();\n    while !paren_string.is_empty()\
    \ {\n        let current_level: isize = 0;\n        while !paren_string.is_empty()\
    \ && *paren_string.first().unwrap() != ' ' {\n            let c = paren_string.remove(0);\n\
    \            if c == '(' {\n                depth += 1;\n            } else if\
    \ c == ')' {\n                depth -= 1;\n            }\n        }\n        if\
    \ paren_string.is_empty() {\n            result.push(depth);\n        } else {\n\
    \            paren_string.remove(0);\n            result.push(depth);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9la0kwj9.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            let mut stack = Vec::new();\n            let\
    \ mut max_level = 0;\n            let mut level = 0;\n            for paren in\
    \ group.chars() {\n                match paren {\n                    '(' => {\n\
    \                        level += 1;\n                        max_level = cmp::max(max_level,\
    \ level);\n                        stack.push(level);\n                    }\n\
    \                    ')' => {\n                        level = stack.pop().unwrap();\n\
    \                    }\n                    _ => (),\n                }\n    \
    \        }\n            max_level\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp8d997ruh.rs:17:37\n   |\n17 |                         max_level\
    \ = cmp::max(max_level, level);\n   |                                     ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut max_depth_stack\
    \ = Vec::new();\n    let mut result = Vec::new();\n    paren_string.chars().for_each(|ch|\
    \ {\n        if ch == '(' {\n            max_depth += 1;\n            max_depth_stack.push(max_depth);\n\
    \        } else if ch == ')' {\n            let depth = max_depth_stack.pop().unwrap();\n\
    \            result.push(depth);\n            max_depth -= 1;\n        }\n   \
    \ });\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpt4gafn6s.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|x|\
    \ parse_nested_parens_helper(x.to_string()))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n --> /tmp/tmp_b2404dq.rs:9:18\n  |\n9 |         .map(|x| parse_nested_parens_helper(x.to_string()))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depths = Vec::new();\n    let mut current_depth\
    \ = 0;\n    let mut current_max_depth = 0;\n    for char in paren_string.chars()\
    \ {\n        match char {\n            '(' => {\n                current_depth\
    \ += 1;\n                if current_depth > current_max_depth {\n            \
    \        current_max_depth = current_depth;\n                }\n            }\n\
    \            ')' => {\n                current_depth -= 1;\n            }\n  \
    \          ' ' => {\n                max_depths.push(current_max_depth);\n   \
    \             current_depth = 0;\n                current_max_depth = 0;\n   \
    \         }\n            _ => {}\n        }\n    }\n    max_depths\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpq_t_fd4m.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for s in paren_string.split(\"\
    \ \") {\n        let mut max_nesting = 0;\n        let mut current_nesting = 0;\n\
    \        for c in s.chars() {\n            if c == '(' {\n                current_nesting\
    \ += 1;\n            } else if c == ')' {\n                if current_nesting\
    \ > max_nesting {\n                    max_nesting = current_nesting;\n      \
    \          }\n                current_nesting -= 1;\n            }\n        }\n\
    \        result.push(max_nesting);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut current_level\
    \ = 0;\n    let mut paren_levels = Vec::new();\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                current_level\
    \ += 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             paren_levels.push(max_level);\n                max_level = 0;\n\
    \                current_level = 0;\n            }\n            _ => {}\n    \
    \    }\n    }\n    paren_levels.push(max_level);\n    paren_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut results = Vec::new();\n    for c in paren_string.chars() {\n    \
    \    match c {\n            '(' => {\n                depth += 1;\n          \
    \      if depth > max_depth {\n                    max_depth = depth;\n      \
    \          }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                results.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => panic!(\"Unexpected input!\"),\n        }\n    }\n    results.push(max_depth);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut count_vec = Vec::new();\n    let mut tmp_count\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => tmp_count += 1,\n            ')' => tmp_count -= 1,\n            ' ' => {\n\
    \                count_vec.push(tmp_count);\n                tmp_count = 0;\n\
    \            }\n            _ => {}\n        }\n    }\n    count_vec\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpw8bn5m2_.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_split = paren_string.split(\" \");\n\
    \    let mut nested_levels: Vec<isize> = Vec::new();\n    for paren in paren_split\
    \ {\n        let mut max_nested = 0;\n        let mut current_nested = 0;\n  \
    \      for c in paren.chars() {\n            if c == '(' {\n                current_nested\
    \ += 1;\n            } else if c == ')' {\n                current_nested -= 1;\n\
    \            }\n            if current_nested > max_nested {\n               \
    \ max_nested = current_nested;\n            }\n        }\n        nested_levels.push(max_nested);\n\
    \    }\n    nested_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|x| check_nested_parens(x.to_string()))\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_nested_parens` in this scope\n\
    \ --> /tmp/tmph4ps4vyz.rs:9:18\n  |\n9 |         .map(|x| check_nested_parens(x.to_string()))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|paren_group|\
    \ {\n            let mut count = 0;\n            let mut max_nesting = 0;\n  \
    \          for c in paren_group.chars() {\n                if c == '(' {\n   \
    \                 count += 1;\n                    if count > max_nesting {\n\
    \                        max_nesting = count;\n                    }\n       \
    \         } else if c == ')' {\n                    count -= 1;\n            \
    \    }\n            }\n            max_nesting\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // iterate through all the groups\n    paren_string\n\
    \        .split(\" \")\n        .map(|s| {\n            // iterate through each\
    \ char in the group string\n            s.chars()\n                .fold((0, 0),\
    \ |(current_max, current_count), c| {\n                    // for each opening\
    \ paren, increment the current depth\n                    // for each closing\
    \ paren, decrement the current depth\n                    // if current depth\
    \ is 0, we've reached the end of a single group\n                    // so set\
    \ current_count to zero\n                    // otherwise compare the current\
    \ max depth with the current count\n                    // and update current_max\
    \ accordingly\n                    match c {\n                        '(' => (current_max.max(current_count\
    \ + 1), current_count + 1),\n                        ')' => (current_max.max(current_count),\
    \ current_count - 1),\n                        _ => (current_max, current_count),\n\
    \                    }\n                })\n                .0\n        })\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_stack\
    \ = Vec::new();\n    let mut count = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_stack.push(c);\n            count +=\
    \ 1;\n        } else if c == ')' {\n            paren_stack.pop();\n         \
    \   count -= 1;\n        } else if c == ' ' {\n            result.push(count);\n\
    \            count = 0;\n        }\n    }\n    if !paren_stack.is_empty() {\n\
    \        panic!(\"Error parsing nested parentheses string\");\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpx5ff7wv3.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n\
    \    let mut count: Vec<isize> = Vec::new();\n    let mut max: isize = 0;\n  \
    \  let paren_string = paren_string.as_str();\n    let mut i: usize = 0;\n    while\
    \ i < paren_string.len() {\n        if paren_string.chars().nth(i).unwrap() ==\
    \ '(' {\n            paren_stack.push(paren_string.chars().nth(i).unwrap());\n\
    \            max += 1;\n        } else if paren_string.chars().nth(i).unwrap()\
    \ == ')' {\n            paren_stack.pop();\n            max -= 1;\n        } else\
    \ if paren_string.chars().nth(i).unwrap() == ' ' {\n            count.push(max);\n\
    \            max = 0;\n        }\n        i += 1;\n    }\n    count.push(max);\n\
    \    return count;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp2n92odow.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let\
    \ mut open_par_count: isize = 0;\n    let mut max_open_par_count: isize = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            open_par_count\
    \ += 1;\n            if open_par_count > max_open_par_count {\n              \
    \  max_open_par_count = open_par_count;\n            }\n        } else if c ==\
    \ ')' {\n            open_par_count -= 1;\n        } else if c == ' ' {\n    \
    \        output.push(max_open_par_count);\n            max_open_par_count = 0;\n\
    \            open_par_count = 0;\n        }\n    }\n    output.push(max_open_par_count);\n\
    \    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut group_max_nesting = Vec::new();\n    for\
    \ paren_group in paren_string.split(\" \") {\n        let mut nesting_level =\
    \ 0;\n        let mut max_nesting = 0;\n        for paren in paren_group.chars()\
    \ {\n            if paren == '(' {\n                nesting_level += 1;\n    \
    \        } else if paren == ')' {\n                nesting_level -= 1;\n     \
    \       }\n            if nesting_level > max_nesting {\n                max_nesting\
    \ = nesting_level;\n            }\n        }\n        group_max_nesting.push(max_nesting);\n\
    \    }\n    group_max_nesting\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let tokens: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut nest_levels: Vec<isize> = Vec::new();\n    for group in tokens {\n\
    \        let mut nest_level = 0;\n        let mut max_nest_level = 0;\n      \
    \  for ch in group.chars() {\n            if ch == '(' {\n                nest_level\
    \ += 1;\n            } else if ch == ')' {\n                nest_level -= 1;\n\
    \            }\n            if nest_level > max_nest_level {\n               \
    \ max_nest_level = nest_level;\n            }\n        }\n        nest_levels.push(max_nest_level);\n\
    \    }\n    nest_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut answers: Vec<isize> = Vec::new();\n   \
    \ let mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' {\n            answers.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    answers.push(max_depth);\n\
    \    answers\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut level:\
    \ isize = 0;\n    let mut paren_vec: Vec<isize> = Vec::new();\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if ch ==\
    \ ')' {\n            level -= 1;\n        } else if ch == ' ' {\n            paren_vec.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut paren_stack = Vec::new();\n\
    \        let mut max_nested_depth = 0;\n        for ch in paren_group.chars()\
    \ {\n            match ch {\n                '(' => {\n                    paren_stack.push(ch);\n\
    \                    max_nested_depth = max_nested_depth.max(paren_stack.len()\
    \ as isize);\n                }\n                ')' => {\n                  \
    \  if paren_stack.pop() != Some('(') {\n                        panic!(\"Paren\
    \ group is not balanced!\");\n                    }\n                }\n     \
    \           _ => panic!(\"Invalid parenthesis!\"),\n            }\n        }\n\
    \        if !paren_stack.is_empty() {\n            panic!(\"Paren group is not\
    \ balanced!\");\n        }\n        result.push(max_nested_depth);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Split the string and then extract the deepest\
    \ level of nesting for each group.\n    paren_string\n        .split_whitespace()\n\
    \        .map(|group| {\n            // Store the maximum depth of nesting and\
    \ the current depth as we traverse.\n            let mut max_depth = 0;\n    \
    \        let mut curr_depth = 0;\n\n            // Keep track of the last symbol,\
    \ which is a paren, and the current position in the group.\n            let mut\
    \ last_symbol = None;\n            let mut curr_pos = 0;\n\n            while\
    \ curr_pos < group.len() {\n                let c = group.chars().nth(curr_pos).unwrap();\n\
    \n                if c == '(' {\n                    curr_depth += 1;\n      \
    \              if curr_depth > max_depth {\n                        max_depth\
    \ = curr_depth;\n                    }\n                } else if c == ')' {\n\
    \                    curr_depth -= 1;\n                }\n\n                curr_pos\
    \ += 1;\n                last_symbol = Some(c);\n            }\n\n           \
    \ if last_symbol == Some('(') {\n                // If last_symbol is a left paren,\
    \ then we've encountered an unfinished paren pair.\n                max_depth\
    \ = -1;\n            }\n\n            max_depth\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|s|\
    \ {\n            let mut count = 0;\n            let mut max_count = 0;\n    \
    \        for c in s.chars() {\n                if c == '(' {\n               \
    \     count += 1;\n                } else if c == ')' {\n                    count\
    \ -= 1;\n                }\n                if count > max_count {\n         \
    \           max_count = count;\n                }\n            }\n           \
    \ max_count\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut curr_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            curr_level += 1;\n            if curr_level >\
    \ max_level {\n                max_level = curr_level;\n            }\n      \
    \  } else if c == ')' {\n            curr_level -= 1;\n        } else if c ==\
    \ ' ' {\n            result.push(max_level);\n            curr_level = 0;\n  \
    \          max_level = 0;\n        }\n    }\n    result.push(max_level);\n   \
    \ result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for paren_set\
    \ in paren_string.split_whitespace() {\n        let mut max_count = 0;\n     \
    \   let mut curr_count = 0;\n        for c in paren_set.chars() {\n          \
    \  if c == '(' {\n                curr_count += 1;\n                if curr_count\
    \ > max_count {\n                    max_count = curr_count;\n               \
    \ }\n            } else if c == ')' {\n                curr_count -= 1;\n    \
    \        }\n        }\n        result.push(max_count);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // let string = \"(()()) ((())) () ((())()())\"\
    ;\n    let mut paren_groups: Vec<isize> = Vec::new();\n    for paren_group in\
    \ paren_string.split(\" \") {\n        let mut max_level = 0;\n        let mut\
    \ paren_count = 0;\n        for paren in paren_group.chars() {\n            if\
    \ paren == '(' {\n                paren_count += 1;\n                if paren_count\
    \ > max_level {\n                    max_level = paren_count;\n              \
    \  }\n            } else if paren == ')' {\n                paren_count -= 1;\n\
    \            }\n        }\n        paren_groups.push(max_level);\n    }\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut depths = Vec::new();\n    for paren in paren_string.chars() {\n \
    \       match paren {\n            '(' => {\n                depth += 1;\n   \
    \             if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                if max_depth > 0\
    \ {\n                    depths.push(max_depth);\n                    max_depth\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpymv_6xka.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // use a hashmap to keep track of nested parens\n\
    \    let mut counts: HashMap<isize, isize> = HashMap::new();\n    let mut depths:\
    \ Vec<isize> = Vec::new();\n    let mut depth = 0;\n    let mut max_depth = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                // increase count of current depth\n\
    \                *counts.entry(depth).or_insert(0) += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                // decrease count of current\
    \ depth\n                *counts.entry(depth).or_insert(0) -= 1;\n           \
    \     depth -= 1;\n            }\n            _ => continue,\n        }\n    }\n\
    \    for depth in 1..=max_depth {\n        let count = *counts.get(&depth).unwrap();\n\
    \        // check if the counts at each depth are equal\n        if count == 0\
    \ {\n            depths.push(depth);\n        }\n    }\n    depths\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpvhsbzm7f.rs:8:21\n\
    \  |\n8 |     let mut counts: HashMap<isize, isize> = HashMap::new();\n  |   \
    \                  ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpvhsbzm7f.rs:8:45\n\
    \  |\n8 |     let mut counts: HashMap<isize, isize> = HashMap::new();\n  |   \
    \                                          ^^^^^^^ not found in this scope\n \
    \ |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut group_starts = paren_string.split(\" \"\
    );\n    let mut nested_levels = Vec::new();\n    for start in group_starts {\n\
    \        let mut open_parens = 0;\n        let mut max_open_parens = 0;\n    \
    \    for paren in start.chars() {\n            if paren == '(' {\n           \
    \     open_parens += 1;\n                if open_parens > max_open_parens {\n\
    \                    max_open_parens = open_parens;\n                }\n     \
    \       } else if paren == ')' {\n                open_parens -= 1;\n        \
    \    }\n        }\n        nested_levels.push(max_open_parens);\n    }\n    nested_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut nested_parens: isize = 0;\n    let mut max_nested_parens: isize = 0;\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            nested_parens\
    \ += 1;\n            if nested_parens > max_nested_parens {\n                max_nested_parens\
    \ = nested_parens;\n            }\n        } else if c == ')' {\n            nested_parens\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_nested_parens);\n\
    \            max_nested_parens = 0;\n            nested_parens = 0;\n        }\n\
    \    }\n    result.push(max_nested_parens);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let groups: Vec<&str> = paren_string.split(\" \"\
    ).collect();\n    groups.iter().map(|g| {\n        let (nest_count, _) = count_nested_parens(g);\n\
    \        nest_count\n    }).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nested_parens` in this scope\n\
    \ --> /tmp/tmp6txo80i1.rs:9:31\n  |\n9 |         let (nest_count, _) = count_nested_parens(g);\n\
    \  |                               ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = Vec::new();\n    let mut max_nesting\
    \ = 0;\n    let mut nested_parens = Vec::new();\n    let mut paren_list = paren_string.split(\"\
    \ \");\n    while let Some(paren_string) = paren_list.next() {\n        let mut\
    \ len = paren_string.len();\n        max_nesting = 0;\n        stack.clear();\n\
    \        for paren in paren_string.chars() {\n            len -= 1;\n        \
    \    match paren {\n                '(' => {\n                    max_nesting\
    \ += 1;\n                    stack.push(paren);\n                }\n         \
    \       ')' => {\n                    if len >= 1 && stack.pop().is_none() {\n\
    \                        max_nesting = 0;\n                        break;\n  \
    \                  }\n                }\n                _ => continue,\n    \
    \        }\n        }\n        nested_parens.push(max_nesting);\n    }\n    nested_parens\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgqgglcxz.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|paren_group|\
    \ {\n            let mut curr_nesting_level = 0;\n            let mut max_nesting_level\
    \ = 0;\n            for paren in paren_group.chars() {\n                match\
    \ paren {\n                    '(' => {\n                        curr_nesting_level\
    \ += 1;\n                        if curr_nesting_level > max_nesting_level {\n\
    \                            max_nesting_level = curr_nesting_level;\n       \
    \                 }\n                    }\n                    ')' => {\n   \
    \                     curr_nesting_level -= 1;\n                    }\n      \
    \              _ => panic!(\"Non paren character detected!\"),\n             \
    \   }\n            }\n            max_nesting_level\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| s.as_bytes())\n        .map(|s| {\n            let mut level =\
    \ 0;\n            let mut max_level = 0;\n            for c in s {\n         \
    \       match c {\n                    b'(' => level += 1,\n                 \
    \   b')' => level -= 1,\n                    _ => {}\n                }\n    \
    \            max_level = std::cmp::max(max_level, level);\n            }\n   \
    \         max_level\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_string\
    \ = paren_string.trim().to_string();\n    while !paren_string.is_empty() {\n \
    \       let group = paren_string.split(' ').next().unwrap();\n        let mut\
    \ paren_count = 0;\n        let mut max_nesting = 0;\n        for c in group.chars()\
    \ {\n            if c == '(' {\n                paren_count += 1;\n          \
    \      if paren_count > max_nesting {\n                    max_nesting = paren_count;\n\
    \                }\n            } else if c == ')' {\n                paren_count\
    \ -= 1;\n            }\n        }\n        result.push(max_nesting);\n       \
    \ paren_string = paren_string.replacen(group, \"\", 1);\n        paren_string\
    \ = paren_string.trim().to_string();\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n\
    \    let mut res: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_stack.push(0);\n\
    \            }\n            ')' => {\n                let max_level = match paren_stack.last()\
    \ {\n                    Some(x) => x + 1,\n                    None => 1,\n \
    \               };\n                res.push(max_level);\n                paren_stack.pop();\n\
    \                paren_stack.push(max_level);\n            }\n            ' '\
    \ => {\n                paren_stack.clear();\n            }\n            _ =>\
    \ continue,\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 1, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp8c7p4tsj.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|paren_group| {\n            let mut depth = 0;\n            let mut\
    \ max_depth = 0;\n            for paren in paren_group.chars() {\n           \
    \     match paren {\n                    '(' => depth += 1,\n                \
    \    ')' => depth -= 1,\n                    _ => (),\n                }\n   \
    \             max_depth = max_depth.max(depth);\n            }\n            max_depth\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            s.chars()\n                .fold(0, |max_nesting,\
    \ c| {\n                    match c {\n                        '(' => max_nesting\
    \ + 1,\n                        ')' => max_nesting - 1,\n                    \
    \    _ => max_nesting,\n                    }\n                })\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpecs4cqgz.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n\
    \    let mut total_stack: Vec<isize> = Vec::new();\n    let mut nesting_level:\
    \ isize = 0;\n    let mut max_nesting_level: isize = 0;\n    let mut current_group:\
    \ String = String::new();\n    let mut current_group_completed: bool = false;\n\
    \    let mut current_group_started: bool = false;\n    let mut index: usize =\
    \ 0;\n    let mut error_message: String = String::new();\n    let mut results:\
    \ Vec<isize> = Vec::new();\n\n    while index < paren_string.len() {\n       \
    \ if paren_string.chars().nth(index).unwrap() == '(' {\n            paren_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \            nesting_level += 1;\n            current_group.push(paren_string.chars().nth(index).unwrap());\n\
    \            current_group_started = true;\n        } else if paren_string.chars().nth(index).unwrap()\
    \ == ')' {\n            match paren_stack.pop() {\n                Some(_) =>\
    \ {\n                    nesting_level -= 1;\n                    current_group.push(paren_string.chars().nth(index).unwrap());\n\
    \                }\n                None => {\n                    error_message\
    \ = format!(\"Error: Found ')' without corresponding '(' at position {}\", index);\n\
    \                    break;\n                }\n            }\n        } else\
    \ if paren_string.chars().nth(index).unwrap() == ' ' {\n            if current_group_started\
    \ && current_group.len() == 0 {\n                error_message = format!(\"Error:\
    \ Empty group at position {}\", index);\n                break;\n            }\
    \ else if paren_stack.len() == 0 {\n                total_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \                current_group_completed = true;\n            } else {\n     \
    \           error_message = format!(\"Error: One of the parenthesis group is not\
    \ closed. Position: {}\",\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6xqh9hkx.rs:51:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n18 |     while index < paren_string.len() {\n   |                       \
    \               - unclosed delimiter\n...\n35 |         } else if paren_string.chars().nth(index).unwrap()\
    \ == ' ' {\n   |                                                             \
    \      - unclosed delimiter\n...\n42 |             } else {\n   |            \
    \        - this delimiter might not be properly closed...\n43 |              \
    \   error_message = format!(\"Error: One of the parenthesis group is not closed.\
    \ Position: {}\",\n44 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n51 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp6xqh9hkx.rs:43:40\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - closing delimiter\
    \ possibly meant for this\n...\n43 |                 error_message = format!(\"\
    Error: One of the parenthesis group is not closed. Position: {}\",\n   |     \
    \                                   ^ unclosed delimiter\n44 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: 1 positional argument in format string, but no arguments\
    \ were given\n  --> /tmp/tmp6xqh9hkx.rs:43:103\n   |\n43 |                 error_message\
    \ = format!(\"Error: One of the parenthesis group is not closed. Position: {}\"\
    ,\n   |                                                                      \
    \                                 ^^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6xqh9hkx.rs:20:30\n   |\n20 |             paren_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xqh9hkx.rs:40:34\n\
    \   |\n40 |                 total_stack.push(paren_string.chars().nth(index).unwrap());\n\
    \   |          "
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|parens| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for c in parens.chars() {\n                if c == '(' {\n\
    \                    depth += 1;\n                } else if c == ')' {\n     \
    \               depth -= 1;\n                }\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            max_depth\n        })\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut max_nesting_stack\
    \ = vec![];\n    for paren in paren_string.chars() {\n        match paren {\n\
    \            '(' => {\n                max_nesting += 1;\n                max_nesting_stack.push(max_nesting);\n\
    \            }\n            ')' => {\n                max_nesting_stack.push(max_nesting);\n\
    \                max_nesting -= 1;\n            }\n            _ => (),\n    \
    \    }\n    }\n    max_nesting_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2, 2, 2, 1, 1, 2, 3, 3, 2, 1, 1, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 1]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmplqt9o7mg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nested_parens: Vec<isize> = Vec::new();\n\
    \    let mut start_pos: isize = 0;\n    let mut open_count: isize = 0;\n    let\
    \ mut max_open_count: isize = 0;\n    for i in 0..paren_string.len() {\n     \
    \   if paren_string.chars().nth(i).unwrap() == '(' {\n            open_count +=\
    \ 1;\n            if open_count > max_open_count {\n                max_open_count\
    \ = open_count;\n            }\n        } else if paren_string.chars().nth(i).unwrap()\
    \ == ')' {\n            open_count -= 1;\n        }\n        if paren_string.chars().nth(i).unwrap()\
    \ == ' ' || i == paren_string.len() - 1 {\n            // A space indicates that\
    \ a group has ended\n            if open_count != 0 {\n                panic!(\"\
    ERROR: Mismatched parenthesis group found\");\n            }\n            nested_parens.push(max_open_count);\n\
    \            max_open_count = 0;\n            start_pos = i + 1;\n        }\n\
    \    }\n    return nested_parens;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawj6xupi.rs:27:25\n   |\n\
    8  |     let mut start_pos: isize = 0;\n   |                        ----- expected\
    \ due to this type\n...\n27 |             start_pos = i + 1;\n   |           \
    \              ^^^^^ expected `isize`, found `usize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n \
    \   let mut depth = 0;\n    let mut max_depth = 0;\n    let mut last_char: char\
    \ = '(';\n    for c in paren_string.chars() {\n        match c {\n           \
    \ '(' => {\n                depth += 1;\n                max_depth = cmp::max(max_depth,\
    \ depth);\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                paren_vec.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => (),\n        }\n        last_char = c;\n    }\n    paren_vec.push(max_depth);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpdqlz27kk.rs:15:29\n   |\n15 |                 max_depth = cmp::max(max_depth,\
    \ depth);\n   |                             ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = vec![];\n    let mut result = vec![];\n\
    \    let mut max_depth = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            stack.push(1);\n            max_depth += 1;\n        }\
    \ else if c == ')' {\n            max_depth -= 1;\n            stack.pop();\n\
    \        } else if c == ' ' {\n            result.push(max_depth);\n         \
    \   max_depth = 0;\n        }\n    }\n    result.push(max_depth);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpxoupxmte.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut stack\
    \ = Vec::new();\n    let mut open_count = 0;\n    let mut max_level = 0;\n   \
    \ for c in paren_string.chars() {\n        match c {\n            '(' => {\n \
    \               stack.push(c);\n                open_count += 1;\n           \
    \     max_level = if open_count > max_level {\n                    open_count\n\
    \                } else {\n                    max_level\n                };\n\
    \            }\n            ')' => {\n                let mut tmp_open_count =\
    \ 0;\n                while let Some(x) = stack.pop() {\n                    if\
    \ x == '(' {\n                        break;\n                    } else {\n \
    \                       tmp_open_count += 1;\n                    }\n        \
    \        }\n                open_count -= tmp_open_count + 1;\n            }\n\
    \            ' ' => {\n                levels.push(max_level);\n             \
    \   max_level = 0;\n            }\n            _ => {}\n        }\n    }\n   \
    \ levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpy2b7l_v8.rs:45:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // count number of parens and match\n    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut paren_count = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                paren_count\
    \ += 1;\n                if depth > max_depth {\n                    max_depth\
    \ = depth;\n                }\n            }\n            ')' => {\n         \
    \       depth -= 1;\n                paren_count += 1;\n            }\n      \
    \      ' ' => {\n                if paren_count > 0 {\n                    //\
    \ encountered a new group\n                    depths.push(max_depth);\n     \
    \               max_depth = 0;\n                    depth = 0;\n             \
    \       paren_count = 0;\n                }\n            }\n            _ => {\n\
    \                panic!(\"unexpected character in paren string {}\", c);\n   \
    \         }\n        }\n    }\n    depths.push(max_depth);\n    depths\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|paren_group|\
    \ {\n            let mut nesting_level = 0;\n            let mut max_nesting_level\
    \ = 0;\n            for paren in paren_group.chars() {\n                if paren\
    \ == '(' {\n                    nesting_level += 1;\n                } else if\
    \ paren == ')' {\n                    nesting_level -= 1;\n                }\n\
    \                if nesting_level > max_nesting_level {\n                    max_nesting_level\
    \ = nesting_level;\n                }\n            }\n            max_nesting_level\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut count = 0;\n    let mut max_nesting_level\
    \ = 0;\n    let mut paren_nesting_levels = Vec::new();\n    let paren_string =\
    \ paren_string.as_str();\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                count += 1;\n                if count\
    \ > max_nesting_level {\n                    max_nesting_level = count;\n    \
    \            }\n            }\n            ')' => {\n                count -=\
    \ 1;\n            }\n            ' ' => {\n                paren_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                count = 0;\n        \
    \    }\n            _ => continue,\n        }\n    }\n    paren_nesting_levels.push(max_nesting_level);\n\
    \    paren_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut current_depth = 0;\n            let mut\
    \ max_depth = 0;\n            for c in s.chars() {\n                match c {\n\
    \                    '(' => {\n                        current_depth += 1;\n \
    \                       if current_depth > max_depth {\n                     \
    \       max_depth = current_depth;\n                        }\n              \
    \      }\n                    ')' => {\n                        current_depth\
    \ -= 1;\n                    }\n                    _ => unreachable!(),\n   \
    \             }\n            }\n            max_depth\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n\
    \    let mut max_level: Vec<isize> = Vec::new();\n    let mut level: isize = 0;\n\
    \    let chars: Vec<char> = paren_string.chars().collect();\n    for ch in chars\
    \ {\n        if ch == '(' {\n            level += 1;\n            paren_stack.push(level);\n\
    \        } else if ch == ')' {\n            let top_of_stack = paren_stack.pop().unwrap();\n\
    \            level = top_of_stack - 1;\n        } else if ch == ' ' {\n      \
    \      max_level.push(*paren_stack.iter().max().unwrap());\n        }\n    }\n\
    \    return max_level;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmphdundz6x.rs:19:54

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Keep count of open/close parens.\n    let mut\
    \ open_parens = 0;\n    let mut max_nested_levels = 0;\n    let mut output = Vec::new();\n\
    \n    for character in paren_string.chars() {\n        match character {\n   \
    \         '(' => {\n                open_parens += 1;\n                if open_parens\
    \ > max_nested_levels {\n                    max_nested_levels = open_parens;\n\
    \                }\n            }\n            ')' => {\n                open_parens\
    \ -= 1;\n            }\n            ' ' => {\n                // Space found,\
    \ store results and reset open_parens and max_nested_levels.\n               \
    \ output.push(max_nested_levels);\n                open_parens = 0;\n        \
    \        max_nested_levels = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpff6vfa1n.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut depths: Vec<isize> = Vec::new();\n    let mut depth: isize = 0;\n\
    \    let mut max_depth: isize = 0;\n    for group in paren_groups {\n        for\
    \ char in group.chars() {\n            match char {\n                '(' => depth\
    \ += 1,\n                ')' => depth -= 1,\n                _ => (),\n      \
    \      }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        depths.push(max_depth);\n        depth = 0;\n\
    \        max_depth = 0;\n    }\n    depths\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut depth:\
    \ isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                if depth == 0 {\n\
    \                    result.push(max_depth);\n                    max_depth =\
    \ 0;\n                }\n            }\n            _ => (),\n        }\n    }\n\
    \    result.push(max_depth);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<char> = Vec::new();\n  \
    \  let mut count: isize = 0;\n    let mut max_depth: isize = 0;\n    let mut depth_vec:\
    \ Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == ' ' {\n            depth_vec.push(max_depth);\n            max_depth = 0;\n\
    \            count = 0;\n            continue;\n        }\n        paren_vec.push(c);\n\
    \        if c == '(' {\n            count += 1;\n            if count > max_depth\
    \ {\n                max_depth = count;\n            }\n        } else if c ==\
    \ ')' {\n            count -= 1;\n        }\n    }\n    depth_vec.push(max_depth);\n\
    \    depth_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut lv = Vec::new();\n    let mut max_nesting\
    \ = 0;\n    let mut current_nesting = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                lv.push(max_nesting);\n                max_nesting = 0;\n   \
    \             current_nesting = 0;\n            }\n            _ => {}\n     \
    \   }\n    }\n    lv.push(max_nesting);\n    lv\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\" \")\n        .map(|i|\
    \ find_max_depth(i.to_string()))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_depth` in this scope\n -->\
    \ /tmp/tmpezblq25m.rs:9:18\n  |\n9 |         .map(|i| find_max_depth(i.to_string()))\n\
    \  |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut output = Vec::new();\n    for paren_group\
    \ in paren_string.split(\" \") {\n        let mut max_level = 0;\n        let\
    \ mut curr_level = 0;\n        for char in paren_group.chars() {\n           \
    \ if char == '(' {\n                curr_level += 1;\n            } else if char\
    \ == ')' {\n                curr_level -= 1;\n            }\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    }\n        output.push(max_level);\n    }\n    output\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|g| count_deepest_nested_parens(g))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_deepest_nested_parens` in this\
    \ scope\n --> /tmp/tmpo0k93l5r.rs:9:18\n  |\n9 |         .map(|g| count_deepest_nested_parens(g))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_string = paren_string;\n    let mut\
    \ paren_vector: Vec<isize> = Vec::new();\n    while !paren_string.is_empty() {\n\
    \        let space_ind = paren_string.find(' ').unwrap_or(paren_string.len());\n\
    \        let paren_group = paren_string.get(0..space_ind).unwrap();\n        let\
    \ paren_group_len = paren_group.len();\n        let mut paren_count = 0;\n   \
    \     let mut paren_max = 0;\n        for paren in paren_group.chars() {\n   \
    \         if paren == '(' {\n                paren_count += 1;\n            }\
    \ else if paren == ')' {\n                paren_count -= 1;\n            }\n \
    \           if paren_count > paren_max {\n                paren_max = paren_count;\n\
    \            }\n        }\n        paren_vector.push(paren_max);\n        if space_ind\
    \ < paren_group_len {\n            paren_string = paren_string.get(space_ind +\
    \ 1..).unwrap().to_string();\n        } else {\n            paren_string = String::new();\n\
    \        }\n    }\n    paren_vector\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdy0p_ep4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    let\
    \ mut current_level: isize = 0;\n    let mut max_level: isize = 0;\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         current_level += 1;\n                if current_level > max_level {\n\
    \                    max_level = current_level;\n                }\n         \
    \   }\n            ')' => {\n                current_level -= 1;\n           \
    \ }\n            ' ' => {\n                output.push(max_level);\n         \
    \       max_level = 0;\n                current_level = 0;\n            }\n  \
    \          _ => continue,\n        }\n    }\n    output.push(max_level);\n   \
    \ output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_balancer\
    \ = 0;\n    let mut inner_paren_balancer = 0;\n    let mut max_balancer = 0;\n\
    \    let mut max_inner_balancer = 0;\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            paren_balancer += 1;\n            inner_paren_balancer\
    \ += 1;\n            if max_balancer < paren_balancer {\n                max_balancer\
    \ = paren_balancer;\n            }\n            if max_inner_balancer < inner_paren_balancer\
    \ {\n                max_inner_balancer = inner_paren_balancer;\n            }\n\
    \        } else if c == ')' {\n            paren_balancer -= 1;\n            inner_paren_balancer\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_inner_balancer);\n\
    \            max_inner_balancer = 0;\n            inner_paren_balancer = 0;\n\
    \        }\n    }\n    if max_inner_balancer > 0 {\n        result.push(max_inner_balancer);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nesting_levels = Vec::new();\n    let\
    \ mut nesting_level = 0;\n    let mut max_seen = 0;\n    let mut iter = paren_string.chars();\n\
    \    while let Some(c) = iter.next() {\n        match c {\n            '(' =>\
    \ {\n                nesting_level += 1;\n                if nesting_level > max_seen\
    \ {\n                    max_seen = nesting_level;\n                }\n      \
    \      }\n            ')' => {\n                nesting_level -= 1;\n        \
    \    }\n            ' ' => {\n                if nesting_level == 0 {\n      \
    \              max_nesting_levels.push(max_seen);\n                    max_seen\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n    max_nesting_levels.push(max_seen);\n    max_nesting_levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut result = Vec::new();\n\
    \    let mut max_level = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            level += 1;\n            max_level = if level > max_level\
    \ { level } else { max_level };\n        } else if c == ')' {\n            level\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_level);\n \
    \           max_level = 0;\n            level = 0;\n        }\n    }\n    if level\
    \ == 0 {\n        result.push(max_level);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| count_parens(s.to_string()))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_parens` in this scope\n --> /tmp/tmpnyyzlfr8.rs:9:18\n\
    \  |\n9 |         .map(|s| count_parens(s.to_string()))\n  |                 \
    \ ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<(char, isize)> = Vec::new();\n\
    \    let mut group_nesting: Vec<isize> = Vec::new();\n    let mut paren_count\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   paren_stack.push((c, paren_count));\n            paren_count += 1;\n     \
    \   } else if c == ')' {\n            let (_, level) = paren_stack.pop().unwrap();\n\
    \            group_nesting.push(paren_count - level);\n        }\n    }\n    group_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3, 1, 2, 3, 1, 1, 2, 1, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjzn6qkgz.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n \
    \   let mut max_level: isize = 0;\n    let mut curr_level: isize = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            curr_level +=\
    \ 1;\n            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        } else if c == ')' {\n            curr_level -= 1;\n \
    \       } else if c == ' ' {\n            paren_vec.push(max_level);\n       \
    \     max_level = 0;\n            curr_level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut levels = vec![];\n\
    \    let mut level = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                level += 1;\n                if level\
    \ > max_level {\n                    max_level = level;\n                }\n \
    \           }\n            ')' => {\n                level -= 1;\n           \
    \ }\n            ' ' => {\n                levels.push(max_level);\n         \
    \       max_level = 0;\n                level = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    levels.push(max_level);\n    levels\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            // (()()) - 2\n            // ((())) - 3\n     \
    \       // (()(()())) - 4\n            let mut max_nesting = 0;\n            let\
    \ mut curr_nesting = 0;\n            for ch in s.chars() {\n                match\
    \ ch {\n                    '(' => {\n                        curr_nesting +=\
    \ 1;\n                        if curr_nesting > max_nesting {\n              \
    \              max_nesting = curr_nesting;\n                        }\n      \
    \              }\n                    ')' => {\n                        curr_nesting\
    \ -= 1;\n                    }\n                    _ => {\n                 \
    \       return None;\n                    }\n                }\n            }\n\
    \            Some(max_nesting)\n        })\n        .filter_map(|option| option)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_nested = 0;\n    let mut curr_nested\
    \ = 0;\n    let mut result: Vec<isize> = Vec::new();\n    let mut open_parens\
    \ = 0;\n    let mut close_parens = 0;\n    let mut level_one_open = 0;\n    let\
    \ mut level_one_close = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                open_parens += 1;\n             \
    \   curr_nested += 1;\n                if curr_nested > max_nested {\n       \
    \             max_nested = curr_nested;\n                }\n                if\
    \ level_one_open == 0 {\n                    level_one_open = curr_nested;\n \
    \               }\n            }\n            ')' => {\n                close_parens\
    \ += 1;\n                curr_nested -= 1;\n                if curr_nested ==\
    \ 0 {\n                    result.push(max_nested);\n                    level_one_close\
    \ = 0;\n                    level_one_open = 0;\n                    max_nested\
    \ = 0;\n                }\n            }\n            ' ' => {\n             \
    \   // End of line\n                if curr_nested != 0 {\n                  \
    \  result.push(max_nested);\n                    level_one_close = 0;\n      \
    \              level_one_open = 0;\n                    max_nested = 0;\n    \
    \            }\n                open_parens = 0;\n                close_parens\
    \ = 0;\n            }\n            _ => {\n                // Nothing should be\
    \ here\n            }\n        }\n    }\n    // Last line\n    if curr_nested\
    \ != 0 {\n        result.push(max_nested);\n    }\n    if open_parens != close_parens\
    \ {\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // split string into groups\n    let paren_groups:\
    \ Vec<&str> = paren_string.split_whitespace().collect();\n    // count the maximum\
    \ nesting level for each group\n    let mut res = Vec::new();\n    for paren_group\
    \ in paren_groups {\n        let mut nest_level = 0;\n        let mut max_nest_level\
    \ = 0;\n        for paren in paren_group.chars() {\n            match paren {\n\
    \                '(' => nest_level += 1,\n                ')' => nest_level -=\
    \ 1,\n                _ => (),\n            }\n            if nest_level > max_nest_level\
    \ {\n                max_nest_level = nest_level;\n            }\n        }\n\
    \        res.push(max_nest_level);\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut curr_max: isize = 0;\n    let mut curr_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > curr_max {\n                curr_max = curr_level;\n            }\n      \
    \  } else if c == ')' {\n            curr_level -= 1;\n        } else if c ==\
    \ ' ' {\n            result.push(curr_max);\n            curr_max = 0;\n     \
    \       curr_level = 0;\n        }\n    }\n    result.push(curr_max);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut vec: Vec<isize> = Vec::new();\n    for\
    \ paren_group in paren_string.split_whitespace() {\n        vec.push(parse_single_paren_group(paren_group));\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_single_paren_group` in this scope\n\
    \ --> /tmp/tmp6n_ksbix.rs:9:18\n  |\n9 |         vec.push(parse_single_paren_group(paren_group));\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    for group in\
    \ paren_string.split(\" \") {\n        let mut count = 0;\n        let mut max_count\
    \ = 0;\n        for ch in group.chars() {\n            if ch == '(' {\n      \
    \          count += 1;\n            } else if ch == ')' {\n                count\
    \ -= 1;\n            }\n            if count > max_count {\n                max_count\
    \ = count;\n            }\n        }\n        results.push(max_count);\n    }\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for group in\
    \ paren_string.split(\" \") {\n        let mut curr_max = 0;\n        let mut\
    \ curr_level = 0;\n        for paren in group.chars() {\n            match paren\
    \ {\n                '(' => curr_level += 1,\n                ')' => curr_level\
    \ -= 1,\n                _ => (),\n            }\n            if curr_level >\
    \ curr_max {\n                curr_max = curr_level;\n            }\n        }\n\
    \        result.push(curr_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut outer_max = 0;\n    let mut depth = 0;\n\
    \    let mut res = Vec::new();\n    let chars = paren_string.chars();\n    for\
    \ ch in chars {\n        if ch == '(' {\n            depth += 1;\n           \
    \ if depth > outer_max {\n                outer_max = depth;\n            }\n\
    \        } else if ch == ')' {\n            depth -= 1;\n        } else if ch\
    \ == ' ' {\n            if depth > 0 {\n                println!(\"ERROR: input\
    \ string is not valid\");\n                return Vec::new();\n            }\n\
    \            res.push(outer_max);\n            outer_max = 0;\n        }\n   \
    \ }\n    // Add the last group.\n    res.push(outer_max);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let groups: Vec<&str> = paren_string.split(\" \"\
    ).collect();\n    let mut deepest_nestings: Vec<isize> = Vec::new();\n    for\
    \ group in groups {\n        // Special case for just empty parentheses ()\n \
    \       if group.len() == 2 {\n            deepest_nestings.push(1);\n       \
    \     continue;\n        }\n        let mut current_nesting: isize = 0;\n    \
    \    let mut max_nesting: isize = 0;\n        for char in group.chars() {\n  \
    \          if char == '(' {\n                current_nesting += 1;\n         \
    \   } else if char == ')' {\n                current_nesting -= 1;\n         \
    \   }\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting;\n            }\n        }\n        deepest_nestings.push(max_nesting);\n\
    \    }\n    deepest_nestings\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec: Vec<isize> = Vec::new();\n \
    \   let mut split_iter = paren_string.split(\" \");\n    loop {\n        match\
    \ split_iter.next() {\n            Some(substring) => {\n                let mut\
    \ depth: isize = 0;\n                let mut max_depth: isize = 0;\n         \
    \       for c in substring.chars() {\n                    if c == '(' {\n    \
    \                    depth += 1;\n                    } else if c == ')' {\n \
    \                       depth -= 1;\n                    }\n                 \
    \   if depth > max_depth {\n                        max_depth = depth;\n     \
    \               }\n                }\n                paren_vec.push(max_depth);\n\
    \            }\n            None => break,\n        }\n    }\n    paren_vec\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut open_parens\
    \ = 0;\n    let mut max_nesting = 0;\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            open_parens += 1;\n            max_nesting =\
    \ max(max_nesting, open_parens);\n        } else if c == ')' {\n            open_parens\
    \ -= 1;\n        } else if c == ' ' {\n            results.push(max_nesting);\n\
    \            max_nesting = 0;\n            open_parens = 0;\n        }\n    }\n\
    \    results.push(max_nesting);\n    results\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp2fmd624x.rs:13:27\n\
    \   |\n13 |             max_nesting = max(max_nesting, open_parens);\n   |   \
    \                        ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ count: isize = 0;\n    let mut max_count: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                count += 1;\n  \
    \              if count > max_count {\n                    max_count = count;\n\
    \                }\n            }\n            ')' => {\n                count\
    \ -= 1;\n            }\n            ' ' => {\n                paren_levels.push(max_count);\n\
    \                max_count = 0;\n                count = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    paren_levels.push(max_count);\n   \
    \ paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_vec:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut paren_stack: Vec<char>\
    \ = Vec::new();\n    let mut paren_level = 0;\n    let mut paren_level_max = 0;\n\
    \    let mut paren_end = false;\n    for paren in paren_vec {\n        if paren_end\
    \ {\n            paren_level_max = cmp::max(paren_level_max, paren_level);\n \
    \           result.push(paren_level_max);\n            paren_level = 0;\n    \
    \        paren_level_max = 0;\n            paren_end = false;\n        }\n   \
    \     if paren == '(' {\n            paren_stack.push(paren);\n            paren_level\
    \ += 1;\n        } else if paren == ')' {\n            if paren_stack.len() >\
    \ 0 {\n                paren_stack.pop();\n                paren_level -= 1;\n\
    \            } else {\n                // issue: found ) without open (\n    \
    \            println!(\"(()()) parse error!\");\n            }\n        } else\
    \ if paren == ' ' {\n            if paren_stack.len() == 0 {\n               \
    \ paren_end = true;\n            }\n        }\n    }\n    if paren_end == false\
    \ {\n        paren_level_max = cmp::max(paren_level_max, paren_level);\n     \
    \   result.push(paren_level_max);\n    }\n    println!(\"paren_level_max: {:?}\"\
    , result);\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpfz3k4oxe.rs:15:31\n   |\n15 |             paren_level_max = cmp::max(paren_level_max,\
    \ paren_level);\n   |                               ^^^ use of undeclared crate\
    \ or module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `cmp`\n  --> /tmp/tmpfz3k4oxe.rs:39:27\n   |\n39 |         paren_level_max\
    \ = cmp::max(paren_level_max, paren_level);\n   |                           ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count: isize = 0;\n    let mut max_count:\
    \ isize = 0;\n    let mut paren_counts: Vec<isize> = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            paren_count += 1;\n\
    \            if paren_count > max_count {\n                max_count = paren_count;\n\
    \            }\n        } else if c == ')' {\n            paren_count -= 1;\n\
    \        } else if c == ' ' {\n            paren_counts.push(max_count);\n   \
    \         max_count = 0;\n            paren_count = 0;\n        }\n    }\n   \
    \ paren_counts.push(max_count);\n    paren_counts\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut v = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut current_level = 0;\n    let mut deepest_level = 0;\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            current_level +=\
    \ 1;\n            stack.push(c);\n        } else if c == ')' {\n            current_level\
    \ -= 1;\n            stack.pop();\n        } else if c == ' ' {\n            if\
    \ current_level > deepest_level {\n                deepest_level = current_level;\n\
    \            }\n            v.push(deepest_level);\n            current_level\
    \ = 0;\n            deepest_level = 0;\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbsyw_x9w.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_depth: Vec<isize> = Vec::new();\n    let mut max_so_far: isize = 0;\n\
    \    let mut current_depth: isize = 0;\n    let paren_string = paren_string.replace(\"\
    \ \", \"\");\n\n    for c in paren_string.chars() {\n        if c == '(' {\n \
    \           current_depth += 1;\n            max_so_far = max(max_so_far, current_depth);\n\
    \            stack.push(current_depth);\n        } else if c == ')' {\n      \
    \      if stack.pop().is_some() {\n                current_depth -= 1;\n     \
    \       }\n        }\n    }\n\n    for depth in stack {\n        max_depth.push(max_so_far);\n\
    \    }\n\n    return max_depth;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpqg2c3enp.rs:16:26\n\
    \   |\n16 |             max_so_far = max(max_so_far, current_depth);\n   |   \
    \                       ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let\
    \ mut nested_count: isize = 0;\n    let mut max_count: isize = 0;\n    for ch\
    \ in paren_string.chars() {\n        if ch == '(' {\n            nested_count\
    \ += 1;\n            if nested_count > max_count {\n                max_count\
    \ = nested_count;\n            }\n        } else if ch == ')' {\n            nested_count\
    \ -= 1;\n        } else if ch == ' ' {\n            res.push(max_count);\n   \
    \         max_count = 0;\n            nested_count = 0;\n        }\n    }\n  \
    \  res.push(max_count);\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_group = paren_string.split_whitespace();\n\
    \    let mut output: Vec<isize> = Vec::new();\n    while let Some(ref group) =\
    \ paren_group.next() {\n        output.push(find_max_nesting_in_group(group.to_string()));\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_nesting_in_group` in this\
    \ scope\n  --> /tmp/tmp4grpdmtj.rs:10:21\n   |\n10 |         output.push(find_max_nesting_in_group(group.to_string()));\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut vec: Vec<isize> = Vec::new();\n    let\
    \ mut max_level: isize = 0;\n    let mut current_level: isize = 0;\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            current_level\
    \ += 1;\n            if current_level > max_level {\n                max_level\
    \ = current_level;\n            }\n        } else if c == ')' {\n            current_level\
    \ -= 1;\n        } else if c == ' ' {\n            vec.push(max_level);\n    \
    \        max_level = 0;\n            current_level = 0;\n        }\n    }\n  \
    \  if max_level > 0 {\n        vec.push(max_level);\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| count_nested_parens(s))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_nested_parens` in this scope\n\
    \ --> /tmp/tmpsoi70mlv.rs:9:18\n  |\n9 |         .map(|s| count_nested_parens(s))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parser = Parser::new();\n    let parsed_parens\
    \ = paren_string.split(\" \").map(|p| p.trim()).collect::<Vec<&str>>();\n    let\
    \ mut res = Vec::new();\n    for paren in parsed_parens {\n        res.push(parser.parse_parens(paren));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Parser`\n -->\
    \ /tmp/tmph7kdy8av.rs:7:22\n  |\n7 |     let mut parser = Parser::new();\n  |\
    \                      ^^^^^^ use of undeclared type `Parser`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_level: isize = 0;\n    let mut paren_levels: Vec<isize> = Vec::new();\n\
    \    for ch in paren_string.chars() {\n        if ch == '(' {\n            stack.push(max_level);\n\
    \            max_level += 1;\n        } else if ch == ')' {\n            let top\
    \ = stack.pop().unwrap();\n            if max_level > top + 1 {\n            \
    \    paren_levels.push(max_level - 1);\n            }\n            max_level =\
    \ top;\n        }\n    }\n    paren_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzotb90yr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                depth += 1;\n                } else if c == ')' {\n         \
    \           depth -= 1;\n                } else {\n                    panic!(\"\
    Unexpected character!\");\n                }\n                max_depth = std::cmp::max(max_depth,\
    \ depth);\n            }\n            max_depth\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // let paren_string = String::from(\"(()()) ((()))\
    \ () ((())()())\");\n    let mut answer: Vec<isize> = Vec::new();\n    let mut\
    \ stack: Vec<char> = Vec::new();\n    let mut curr_max = 0;\n    let mut seen_space\
    \ = false;\n    let mut seen_one_paren = false;\n    for c in paren_string.chars()\
    \ {\n        if c == ' ' {\n            // Found a space - new token.\n      \
    \      // Check if the stack is empty to handle case like \" () () \".\n     \
    \       if !stack.is_empty() {\n                answer.push(curr_max);\n     \
    \           curr_max = 0;\n            }\n            seen_space = true;\n   \
    \         seen_one_paren = false;\n        } else if c == '(' {\n            //\
    \ Found an opening paren.\n            // If we already saw a space before this,\
    \ we have a new token.\n            if seen_space {\n                answer.push(curr_max);\n\
    \                curr_max = 0;\n            }\n            stack.push(c);\n  \
    \          curr_max += 1;\n            seen_space = false;\n            seen_one_paren\
    \ = true;\n        } else if c == ')' {\n            // Found a closing paren.\n\
    \            // First remove the previous \"(\" from the stack.\n            if\
    \ stack.is_empty() {\n                // println!(\"Malformed input, returning...\"\
    );\n                return Vec::new();\n            }\n            stack.pop();\n\
    \            seen_space = false;\n            seen_one_paren = true;\n       \
    \ } else {\n            // Found a non-paren character.\n            // println!(\"\
    Found non-paren character, returning...\");\n            return Vec::new();\n\
    \        }\n    }\n    // If we saw a closing paren, there's a case where we want\
    \ to update the answer.\n    if seen_one_paren {\n        answer.push(curr_max);\n\
    \    }\n    answer\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp1za0ifsf.rs:59:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut max_level: isize = 0;\n    let mut current_level: isize = 0;\n    for (i,\
    \ c) in paren_string.chars().enumerate() {\n        match c {\n            '('\
    \ => {\n                current_level += 1;\n                if current_level\
    \ > max_level {\n                    max_level = current_level;\n            \
    \    }\n            }\n            ')' => {\n                current_level -=\
    \ 1;\n            }\n            ' ' => {\n                if i == paren_string.len()\
    \ - 1 {\n                    result.push(max_level);\n                } else {\n\
    \                    result.push(max_level);\n                    max_level =\
    \ 0;\n                    current_level = 0;\n                }\n            }\n\
    \            _ => panic!(\"Unexpected character: {}\", c),\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpx2ti5lm_.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    for group in\
    \ paren_string.split_whitespace() {\n        let mut max_nested_level = 0;\n \
    \       let mut curr_nested_level = 0;\n        for c in group.chars() {\n   \
    \         if c == '(' {\n                curr_nested_level += 1;\n           \
    \ } else if c == ')' {\n                curr_nested_level -= 1;\n            }\n\
    \            if curr_nested_level > max_nested_level {\n                max_nested_level\
    \ = curr_nested_level;\n            }\n        }\n        result.push(max_nested_level);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut open_count = 0;\n            let mut max_open_count\
    \ = 0;\n            for paren in s.chars() {\n                match paren {\n\
    \                    '(' => {\n                        open_count += 1;\n    \
    \                    if open_count > max_open_count {\n                      \
    \      max_open_count = open_count;\n                        }\n             \
    \       }\n                    ')' => {\n                        open_count -=\
    \ 1;\n                    }\n                    _ => {}\n                }\n\
    \            }\n            max_open_count\n        })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    for\
    \ s in paren_string.split_whitespace() {\n        let mut count = 0;\n       \
    \ let mut cur_max = 0;\n        for c in s.chars() {\n            if c == '('\
    \ {\n                count += 1;\n            } else if c == ')' {\n         \
    \       count -= 1;\n            }\n            cur_max = cur_max.max(count);\n\
    \        }\n        res.push(cur_max);\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n\
    \    let mut max_nesting: isize = 0;\n    let mut levels: Vec<isize> = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        if paren == ' ' {\n        \
    \    levels.push(max_nesting);\n            max_nesting = 0;\n            paren_stack.clear();\n\
    \        } else if paren == '(' {\n            paren_stack.push(paren);\n    \
    \        if paren_stack.len() as isize > max_nesting {\n                max_nesting\
    \ = paren_stack.len() as isize;\n            }\n        } else if paren == ')'\
    \ {\n            paren_stack.pop();\n        }\n    }\n    levels.push(max_nesting);\n\
    \    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            let mut cnt = 0;\n            let mut max_cnt =\
    \ 0;\n            for c in s.chars() {\n                if c == '(' {\n      \
    \              cnt += 1;\n                } else if c == ')' {\n             \
    \       cnt -= 1;\n                }\n                max_cnt = isize::max(max_cnt,\
    \ cnt);\n            }\n            max_cnt\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            s.chars()\n                .fold(0, |acc, c| match\
    \ c {\n                    '(' => acc + 1,\n                    ')' => acc - 1,\n\
    \                    _ => acc,\n                })\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpicd5whb3.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|p| {\n            let mut max_nesting = 0;\n            let mut curr_nesting\
    \ = 0;\n            for c in p.chars() {\n                if c == '(' {\n    \
    \                curr_nesting += 1;\n                    if curr_nesting > max_nesting\
    \ {\n                        max_nesting = curr_nesting;\n                   \
    \ }\n                } else if c == ')' {\n                    curr_nesting -=\
    \ 1;\n                }\n            }\n            max_nesting\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut result = Vec::new();\n    for group in paren_groups {\n        let\
    \ mut curr_level = 0;\n        let mut max_level = 0;\n        for paren in group.chars()\
    \ {\n            if paren == '(' {\n                curr_level += 1;\n       \
    \     } else if paren == ')' {\n                curr_level -= 1;\n           \
    \ }\n            if curr_level > max_level {\n                max_level = curr_level;\n\
    \            }\n        }\n        result.push(max_level);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| get_max_nested_level(s.chars()))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_max_nested_level` in this scope\n\
    \ --> /tmp/tmpxpp1ldg7.rs:9:18\n  |\n9 |         .map(|s| get_max_nested_level(s.chars()))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // parse from string to vectors:\n    let paren_groups\
    \ = parse_paren_groups(paren_string);\n    // for each group, count its maximum\
    \ nesting:\n    paren_groups.iter().map(count_max_nesting).collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_paren_groups` in this scope\n\
    \ --> /tmp/tmpg_rrw781.rs:8:24\n  |\n8 |     let paren_groups = parse_paren_groups(paren_string);\n\
    \  |                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `count_max_nesting` in this scope\n  --> /tmp/tmpg_rrw781.rs:10:29\n\
    \   |\n10 |     paren_groups.iter().map(count_max_nesting).collect()\n   |   \
    \                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    //vec![1, 2, 3, 4]\n    let mut max_levels = Vec::new();\n\
    \    let mut level = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if c ==\
    \ ')' {\n            level -= 1;\n        } else if c == ' ' {\n            max_levels.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    max_levels.push(max_level);\n\
    \    max_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|group| {\n            let mut is_open_paren = false;\n           \
    \ let mut max_depth = 0;\n            let mut current_depth = 0;\n           \
    \ for ch in group.chars() {\n                match ch {\n                    '('\
    \ => {\n                        if is_open_paren {\n                         \
    \   current_depth += 1;\n                        }\n                        is_open_paren\
    \ = true;\n                    }\n                    ')' => {\n             \
    \           is_open_paren = false;\n                        if current_depth >\
    \ max_depth {\n                            max_depth = current_depth;\n      \
    \                  }\n                        current_depth -= 1;\n          \
    \          }\n                    _ => (),\n                }\n            }\n\
    \            max_depth\n        })\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvl9qox0b.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut results = Vec::new();\n    let groups:\
    \ Vec<&str> = paren_string.split(\" \").collect();\n    for group in groups {\n\
    \        let mut current_count = 0;\n        let mut max_count = 0;\n        for\
    \ c in group.chars() {\n            if c == '(' {\n                current_count\
    \ += 1;\n            } else if c == ')' {\n                current_count -= 1;\n\
    \            }\n            if current_count > max_count {\n                max_count\
    \ = current_count;\n            }\n        }\n        results.push(max_count);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_stack\
    \ = Vec::new();\n    for (i, ch) in paren_string.chars().enumerate() {\n     \
    \   match ch {\n            '(' => {\n                if paren_stack.is_empty()\
    \ {\n                    paren_stack.push(0);\n                } else {\n    \
    \                paren_stack.push(paren_stack.last().unwrap() + 1);\n        \
    \        }\n            }\n            ')' => {\n                if i + 1 == paren_string.len()\
    \ || paren_string.chars().nth(i + 1).unwrap() == ' ' {\n                    let\
    \ depth = paren_stack.pop().unwrap();\n                    result.push(depth);\n\
    \                } else {\n                    let depth = paren_stack.pop().unwrap();\n\
    \                    paren_stack.push(depth - 1);\n                }\n       \
    \     }\n            _ => continue,\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 3, 3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7wdz2v80.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // TODO: parse the string and return a vector of\
    \ integers showing deepest level\n    // of nesting of parentheses\n    let mut\
    \ result: Vec<isize> = Vec::new();\n    let mut temp: Vec<char> = Vec::new();\n\
    \    let mut max: isize = 0;\n    let mut count: isize = 0;\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' => {\n                count += 1;\n \
    \               temp.push(ch);\n            }\n            ')' => {\n        \
    \        temp.push(ch);\n                count -= 1;\n            }\n        \
    \    ' ' => {\n                result.push(max);\n                max = 0;\n \
    \               count = 0;\n                temp.clear();\n            }\n   \
    \         _ => (),\n        }\n        if count > max {\n            max = count;\n\
    \        }\n    }\n    result.push(max);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // This is another case of using stack.\n    //\
    \ If we see an open parenthesis, push it on the stack.\n    // If we see a close\
    \ parenthesis, pop an element from the stack and\n    // update `max_depth` if\
    \ required.\n    // After the string is parsed, we can just return `max_depth`.\n\
    \    // The tricky part is to find the right place to update `max_depth`.\n  \
    \  // It is straightforward to update `max_depth` when we parse a close parenthesis.\n\
    \    // However, we can't do this. This is because an open parenthesis can be\
    \ a part of a group\n    // which has deepest level of nesting. For example, in\
    \ `(()())`, first open parenthesis\n    // has the deepest level of nesting in\
    \ the first group.\n    //\n    // So, the approach here is to count the number\
    \ of elements in the stack and update `max_depth`\n    // for each element we\
    \ pop.\n    // In the above example, we start with an empty stack. We push an\
    \ element on the stack\n    // when we see an open parenthesis. Now, when we parse\
    \ the close parenthesis, we pop an element\n    // from the stack and count the\
    \ number of elements in the stack. This is the level of nesting.\n    // We push\
    \ the element back on the stack and repeat this process until the stack is empty.\n\
    \    //\n    // For the second group, we start with an empty stack. Again, when\
    \ we see an open parenthesis,\n    // we push an element on the stack. When we\
    \ see the first close parenthesis, we pop an element\n    // from the stack. Now,\
    \ the stack is empty. This is because the stack should be empty after\n    //\
    \ the group has been parsed. So, we see that this group has a nesting level of\
    \ 1.\n    // We push the element back on the stack and parse the second close\
    \ parenthesis.\n    // Now, the stack has 1 element. This is the level of nesting.\n\
    \    // We push the element back on the stack and repeat this process until the\
    \ stack is empty.\n    // We now have the second group has a nesting level of\
    \ 3.\n    //\n    // We now parse the third group. It is of length 1.\n    //\
    \ And finally we parse the fourth group. This has a nesting\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp723wqcd_.rs:6:49\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  | \
    \   |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976062
