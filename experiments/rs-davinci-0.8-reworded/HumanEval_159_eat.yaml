name: HumanEval_159_eat
language: rs
prompt: "/// You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n\
  /// you should return a vector of [ total number of eaten carrots after your meals,\n\
  /// the number of carrots left after your meals ]\n/// if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n\
  /// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n\
  /// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n\
  /// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n\
  /// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining\
  \ : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n\
  /// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n\
  /// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
  \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
  \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n   \
  \ assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1),\
  \ vec![5, 0]);\n}\n"
completions: ['    vec![number + std::cmp::min(need, remaining), std::cmp::max(0,
    remaining - need)]', "    let eaten = match number + need - remaining {\n    \
    \    num if num > remaining => remaining,\n        num => num,\n    };\n    vec![eaten,\
    \ remaining - eaten]", "    let mut res: Vec<isize> = Vec::new();\n    let mut\
    \ number_ = number;\n    let mut remaining_ = remaining;\n    while remaining_\
    \ > 0 && number_ < need {\n        number_ += 1;\n        remaining_ -= 1;\n \
    \   }\n    res.push(number_);\n    res.push(remaining_);\n    res", "    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }", "    let eaten = (number + need).min(number\
    \ + remaining);\n    let remainder = (number + remaining) - eaten;\n    vec![eaten,\
    \ remainder]", "    let mut result = Vec::new();\n    let mut res: isize = number\
    \ + need;\n    if remaining <= 0 {\n        result.push(number);\n        result.push(remaining);\n\
    \    } else if remaining <= need {\n        result.push(number + remaining);\n\
    \        result.push(0);\n    } else {\n        result.push(res);\n        result.push(remaining\
    \ - need);\n    }\n    result", "    if need < remaining {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }", "    let mut eaten = number;\n    let mut left = remaining;\n    let\
    \ mut meal = 0;\n    while left > 0 && eaten < need {\n        eaten += 1;\n \
    \       left -= 1;\n        meal += 1;\n    }\n    let mut result = vec![];\n\
    \    result.push(eaten);\n    result.push(left);\n    result", "    vec![\n  \
    \      if remaining >= need { number + need } else { number + remaining },\n \
    \       if remaining >= need { remaining - need } else { 0 },\n    ]", "    let\
    \ eaten = number + need;\n    let left = if eaten > remaining { 0 } else { remaining\
    \ - eaten };\n    vec![eaten, left]", "    let mut left = remaining - number;\n\
    \    let mut eaten = number;\n    if left < need {\n        eaten += left;\n \
    \       left = 0;\n    } else {\n        eaten += need;\n        left -= need;\n\
    \    }\n    vec![eaten, left]", "    let left = if number+need > remaining {\n\
    \        0\n    } else {\n        remaining - (number+need)\n    };\n    vec![number+need,\
    \ left]", "    let total = number + need;\n    if total < remaining {\n      \
    \  vec![total, remaining - total]\n    } else {\n        vec![total, 0]\n    }",
  "    let sum = number + need;\n    let delta = if sum < remaining { sum } else {\
    \ remaining };\n    vec![delta, remaining - delta]", "    let eaten = number +\
    \ if need < remaining { need } else { remaining };\n    let remaining = if remaining\
    \ - need > 0 { remaining - need } else { 0 };\n    vec![eaten, remaining]", " \
    \   if number + need < remaining {\n        vec![number + need, remaining - number\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ mut res = Vec::new();\n    if number < 0 || need < 0 || remaining < 0 {\n  \
    \      return res;\n    }\n    if number + need <= remaining {\n        res.push(number\
    \ + need);\n        res.push(remaining - (number + need));\n    } else {\n   \
    \     res.push(number + remaining);\n        res.push(0);\n    }\n    res", " \
    \   if need + number <= remaining {\n        vec![need + number, remaining - need\
    \ - number]\n    } else {\n        vec![remaining + number, 0]\n    }", "    let\
    \ mut output = Vec::new();\n    let total = number + need;\n    if total <= remaining\
    \ {\n        output.push(total);\n        output.push(remaining - total);\n  \
    \  } else {\n        output.push(remaining + number);\n        output.push(0);\n\
    \    }\n    output", "    let mut eaten: isize = number;\n    if remaining >=\
    \ need {\n        eaten += need;\n        eaten -= remaining;\n    } else {\n\
    \        eaten += remaining;\n    }\n    vec![eaten, remaining]"]
stop_tokens:
- "\n}"
