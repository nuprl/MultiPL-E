name: HumanEval_159_eat
language: rs
prompt: "/// You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n\
  /// you should return a vector of [ total number of eaten carrots after your meals,\n\
  /// the number of carrots left after your meals ]\n/// if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n\
  /// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n\
  /// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n\
  /// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n\
  /// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining\
  \ : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n\
  /// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n\
  /// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
  \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
  \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n   \
  \ assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1),\
  \ vec![5, 0]);\n}\n"
completions: ['    vec![number + std::cmp::min(need, remaining), std::cmp::max(0,
    remaining - need)]', "    let eaten = match number + need - remaining {\n    \
    \    num if num > remaining => remaining,\n        num => num,\n    };\n    vec![eaten,\
    \ remaining - eaten]", "    let mut res: Vec<isize> = Vec::new();\n    let mut\
    \ number_ = number;\n    let mut remaining_ = remaining;\n    while remaining_\
    \ > 0 && number_ < need {\n        number_ += 1;\n        remaining_ -= 1;\n \
    \   }\n    res.push(number_);\n    res.push(remaining_);\n    res", "    if need\
    \ <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n\
    \        vec![number + remaining, 0]\n    }", "    let eaten = (number + need).min(number\
    \ + remaining);\n    let remainder = (number + remaining) - eaten;\n    vec![eaten,\
    \ remainder]", "    let mut result = Vec::new();\n    let mut res: isize = number\
    \ + need;\n    if remaining <= 0 {\n        result.push(number);\n        result.push(remaining);\n\
    \    } else if remaining <= need {\n        result.push(number + remaining);\n\
    \        result.push(0);\n    } else {\n        result.push(res);\n        result.push(remaining\
    \ - need);\n    }\n    result", "    if need < remaining {\n        vec![number\
    \ + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n\
    \    }", "    let mut eaten = number;\n    let mut left = remaining;\n    let\
    \ mut meal = 0;\n    while left > 0 && eaten < need {\n        eaten += 1;\n \
    \       left -= 1;\n        meal += 1;\n    }\n    let mut result = vec![];\n\
    \    result.push(eaten);\n    result.push(left);\n    result", "    vec![\n  \
    \      if remaining >= need { number + need } else { number + remaining },\n \
    \       if remaining >= need { remaining - need } else { 0 },\n    ]", "    let\
    \ eaten = number + need;\n    let left = if eaten > remaining { 0 } else { remaining\
    \ - eaten };\n    vec![eaten, left]", "    let mut left = remaining - number;\n\
    \    let mut eaten = number;\n    if left < need {\n        eaten += left;\n \
    \       left = 0;\n    } else {\n        eaten += need;\n        left -= need;\n\
    \    }\n    vec![eaten, left]", "    let left = if number+need > remaining {\n\
    \        0\n    } else {\n        remaining - (number+need)\n    };\n    vec![number+need,\
    \ left]", "    let total = number + need;\n    if total < remaining {\n      \
    \  vec![total, remaining - total]\n    } else {\n        vec![total, 0]\n    }",
  "    let sum = number + need;\n    let delta = if sum < remaining { sum } else {\
    \ remaining };\n    vec![delta, remaining - delta]", "    let eaten = number +\
    \ if need < remaining { need } else { remaining };\n    let remaining = if remaining\
    \ - need > 0 { remaining - need } else { 0 };\n    vec![eaten, remaining]", " \
    \   if number + need < remaining {\n        vec![number + need, remaining - number\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ mut res = Vec::new();\n    if number < 0 || need < 0 || remaining < 0 {\n  \
    \      return res;\n    }\n    if number + need <= remaining {\n        res.push(number\
    \ + need);\n        res.push(remaining - (number + need));\n    } else {\n   \
    \     res.push(number + remaining);\n        res.push(0);\n    }\n    res", " \
    \   if need + number <= remaining {\n        vec![need + number, remaining - need\
    \ - number]\n    } else {\n        vec![remaining + number, 0]\n    }", "    let\
    \ mut output = Vec::new();\n    let total = number + need;\n    if total <= remaining\
    \ {\n        output.push(total);\n        output.push(remaining - total);\n  \
    \  } else {\n        output.push(remaining + number);\n        output.push(0);\n\
    \    }\n    output", "    let mut eaten: isize = number;\n    if remaining >=\
    \ need {\n        eaten += need;\n        eaten -= remaining;\n    } else {\n\
    \        eaten += remaining;\n    }\n    vec![eaten, remaining]", "    let mut\
    \ eaten: isize = number;\n    let mut remain: isize = remaining;\n    if need\
    \ > remaining {\n        eaten += remaining;\n        remain = 0;\n    } else\
    \ {\n        eaten += need;\n        remain -= need;\n    }\n    vec![eaten, remain]",
  "    // TODO: Implement this function\n    // panic!(\"Not Implemented\");\n   \
    \ let mut eaten: isize = number;\n    if (need - number) <= remaining {\n    \
    \    eaten += need - number;\n    } else {\n        eaten += remaining;\n    }\n\
    \    let res = vec![eaten, remaining - (need - number)];\n    res", "    let eaten\
    \ = if need <= remaining {\n        number + need\n    } else {\n        number\
    \ + remaining\n    };\n    let left = if need <= remaining {\n        remaining\
    \ - need\n    } else {\n        0\n    };\n    vec![eaten, left]", '    vec![number
    + std::cmp::min(need, remaining), std::cmp::max(0, remaining - need)]', "    let\
    \ remaining = remaining - number;\n    let eaten = number + if remaining > need\
    \ { need } else { remaining };\n    vec![eaten, remaining.max(0)]", "    let total\
    \ = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }", "    let\
    \ mut eaten = number;\n    let mut remaining = remaining;\n    if remaining >=\
    \ need {\n        eaten += need;\n        remaining -= need;\n    } else {\n \
    \       eaten += remaining;\n        remaining = 0;\n    }\n    vec![eaten, remaining]",
  "    if number + need <= remaining {\n        vec![number + need, remaining - (number\
    \ + need)]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ total_carrots = number + need;\n    if total_carrots > remaining {\n       \
    \ vec![remaining, 0]\n    } else {\n        vec![total_carrots, remaining - total_carrots]\n\
    \    }", "    let mut sum = number + need;\n    if sum <= remaining {\n      \
    \  vec![sum, remaining - sum]\n    } else {\n        vec![remaining + number,\
    \ 0]\n    }", "    let total = number + if need < remaining { need } else { remaining\
    \ };\n    let remain = if need < remaining { remaining - need } else { 0 };\n\
    \    vec![total, remain]", "    let mut ret = vec![];\n    if need >= remaining\
    \ {\n        ret.push(number + remaining);\n        ret.push(0);\n    } else {\n\
    \        ret.push(number + need);\n        ret.push(remaining - need);\n    }\n\
    \    ret", "    if number + need > remaining {\n        return vec![remaining,\
    \ 0];\n    } else {\n        return vec![number + need, remaining - number - need];\n\
    \    }", "    if number < 0 || need < 0 || remaining < 0 {\n        return vec![0,\
    \ 0];\n    }\n    let mut result = remaining - (number + need);\n    if result\
    \ < 0 {\n        result = 0;\n    }\n    vec![number + need, result]", "    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }", "    let\
    \ eaten = number + std::cmp::min(need, remaining);\n    vec![eaten, remaining\
    \ - eaten]", "    let mut number = number;\n    let mut remaining = remaining;\n\
    \    if remaining < need {\n        number += remaining;\n        remaining =\
    \ 0;\n    } else {\n        number += need;\n        remaining -= need;\n    }\n\
    \    vec![number, remaining]", "    let number = number as usize;\n    let need\
    \ = need as usize;\n    let remaining = remaining as usize;\n    let mut carrots:\
    \ Vec<isize> = Vec::new();\n    let total_eaten: usize = number + need;\n    if\
    \ total_eaten <= remaining {\n        carrots.push(total_eaten as isize);\n  \
    \      carrots.push((remaining - total_eaten) as isize);\n    } else {\n     \
    \   carrots.push(remaining as isize);\n        carrots.push(0);\n    }\n    carrots",
  '    vec![number + remaining - need.min(remaining), remaining - need.min(remaining)]',
  "    let mut total = number + remaining;\n    if total >= need {\n        total\
    \ = need;\n    }\n    vec![total, remaining - (total - number)]", "    let mut\
    \ result = vec![];\n    let eaten = if number + need <= remaining {\n        number\
    \ + need\n    } else {\n        remaining\n    };\n    result.push(eaten);\n \
    \   result.push(remaining - eaten);\n    result", "    let total = number + need;\n\
    \    let mut diff = total - remaining;\n    if diff <= 0 {\n        diff = 0;\n\
    \    }\n    vec![total - diff, diff]", "    let mut hungry = need - number;\n\
    \    if hungry > remaining {\n        hungry = remaining;\n    }\n    vec![number\
    \ + hungry, remaining - hungry]", "    if remaining >= number + need {\n     \
    \   vec![number + need, remaining - (number + need)]\n    } else {\n        vec![remaining\
    \ + number, 0]\n    }", "    let sum = number + need;\n    vec![\n        sum,\n\
    \        if sum < remaining {\n            remaining - sum\n        } else {\n\
    \            0\n        }\n    ]", "    if number + need <= remaining {\n    \
    \    vec![number + need, remaining - number - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }", "    let mut result = vec![];\n    if need <= remaining\
    \ {\n        result.push(number + need);\n        result.push(remaining - need);\n\
    \    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result", "    if remaining < (need - number) {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - (need\
    \ - number)]\n    }", "    let mut remaining = remaining;\n    let mut number\
    \ = number;\n    for _ in number..number + need {\n        if remaining > 0 {\n\
    \            remaining -= 1;\n            number += 1;\n        }\n    }\n   \
    \ vec![number, remaining]", "    match (number, need, remaining) {\n        (number,\
    \ need, remaining) if need == 0 => vec![number, remaining],\n        (number,\
    \ need, remaining) if need > remaining => vec![number + remaining, 0],\n     \
    \   (number, need, remaining) => vec![number + need, remaining - need],\n    }",
  "    if remaining + number >= need {\n        vec![need, remaining + number - need]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }", "    let result =\
    \ number + need;\n    let mut stock = remaining - need;\n    let mut eaten = 0;\n\
    \    if stock < 0 {\n        eaten = result + stock;\n        stock = 0;\n   \
    \ } else {\n        eaten = result;\n    }\n    return vec![eaten, stock];", " \
    \   let mut n = number;\n    let mut r = remaining;\n    let mut result = Vec::new();\n\
    \    if number + remaining >= need {\n        n += need;\n        r -= need;\n\
    \    } else {\n        n += remaining;\n        r = 0;\n    }\n    result.push(n);\n\
    \    result.push(r);\n    result", "    let mut all_carrots = number + remaining;\n\
    \    if all_carrots < need {\n        all_carrots = 0;\n    } else {\n       \
    \ all_carrots -= need;\n    }\n    vec![number + remaining - all_carrots, all_carrots]",
  "    let mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result", "    let mut res\
    \ = number + need;\n    if res > remaining {\n        res = remaining;\n    }\n\
    \    vec![res, remaining - res]", "    let mut number = number;\n    let mut remaining\
    \ = remaining;\n    if need < remaining {\n        number += need;\n        remaining\
    \ -= need;\n    } else {\n        number += remaining;\n        remaining = 0;\n\
    \    }\n    vec![number, remaining]", "    let result = need + number;\n    let\
    \ remaining = if result > remaining {0} else {remaining - result};\n    vec![result,\
    \ remaining]", "    let total_need = number + need;\n    if total_need < remaining\
    \ {\n        vec![total_need, remaining - total_need]\n    } else {\n        vec![total_need\
    \ - remaining, 0]\n    }", "    let eaten = number + need;\n    let left = if\
    \ remaining >= need { remaining - need } else { 0 };\n    vec![eaten, left]",
  '    vec![(number + cmp::min(need, remaining)), cmp::max(0, remaining - need)]',
  "    if number + need <= remaining {\n        vec![number + need, remaining - (number\
    \ + need)]\n    } else {\n        vec![number + remaining, 0]\n    }", "    if\
    \ number + need < remaining {\n        vec![number + need, remaining - (number\
    \ + need)]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ mut num = number;\n    let mut rem = remaining;\n    let mut meal = 0;\n   \
    \ while rem > 0 && num < need {\n        num += 1;\n        rem -= 1;\n      \
    \  meal += 1;\n    }\n    let mut result = vec![];\n    result.push(num);\n  \
    \  result.push(rem);\n    result", "    let output = vec![number + std::cmp::min(need,\
    \ remaining), std::cmp::max(0, remaining - need)];\n    return output;", "   \
    \ let result: isize = number + remaining - need;\n    if result >= 0 {\n     \
    \   vec![number + remaining, result]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", "    if remaining < need - number {\n        vec![remaining + number,\
    \ 0]\n    } else {\n        vec![need, remaining - (need - number)]\n    }", " \
    \   let mut ret = vec![];\n    let total_carrots = number + remaining;\n    if\
    \ total_carrots >= need {\n        ret.push(need);\n        ret.push(total_carrots\
    \ - need);\n    } else {\n        ret.push(total_carrots);\n        ret.push(0);\n\
    \    }\n    ret", "    let mut eaten = number;\n    let mut remaining = remaining;\n\
    \    let mut eaten_now = 0;\n    let mut need = need;\n    while need > 0 {\n\
    \        if remaining > 0 {\n            eaten_now += 1;\n            need -=\
    \ 1;\n            remaining -= 1;\n        } else {\n            break;\n    \
    \    }\n    }\n    eaten += eaten_now;\n    return vec![eaten, remaining];", " \
    \   let mut vec = Vec::new();\n    if number <= 1000 && need <= 1000 && remaining\
    \ <= 1000 {\n        let sum: isize = number + need;\n        if sum <= remaining\
    \ {\n            vec.push(sum);\n            vec.push(remaining - sum);\n    \
    \    } else {\n            vec.push(remaining + number);\n            vec.push(0);\n\
    \        }\n    }\n    vec", "    if remaining >= number + need {\n        vec![number\
    \ + need, remaining - (number + need)]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", "    // your code here\n    let mut res = vec![];\n    if number\
    \ + need <= remaining {\n        res.push(number + need);\n        res.push(remaining\
    \ - (number + need));\n    } else {\n        res.push(number + remaining);\n \
    \       res.push(0);\n    }\n    res", "    if need < number {\n        panic!(\"\
    number of carrots eaten can't be greater than number of carrots needed\");\n \
    \   }\n    let remaining_carrots = remaining.checked_sub(need - number);\n   \
    \ match remaining_carrots {\n        Some(n) => vec![need, n],\n        None =>\
    \ vec![remaining + number, 0],\n    }", '    vec![number + std::cmp::min(need,
    remaining), std::cmp::max(0, remaining - need)]', "    let mut number = number;\n\
    \    let mut need = need;\n    let mut remaining = remaining;\n    let mut temp\
    \ = 0;\n    if remaining == 0 {\n        return vec![number, 0];\n    }\n    if\
    \ remaining < need {\n        temp = remaining;\n        need -= remaining;\n\
    \        remaining = 0;\n    } else {\n        remaining -= need;\n        temp\
    \ = need;\n        need = 0;\n    }\n    number += temp;\n    vec![number, remaining]",
  "    let mut result = Vec::new();\n    if remaining >= number + need {\n       \
    \ result.push(number + need);\n        result.push(remaining - number - need);\n\
    \    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result", "    let eaten = number + cmp::min(need, remaining);\n  \
    \  let remaining = remaining - cmp::min(need, remaining);\n    vec![eaten, remaining]",
  "    let left = number + remaining - need;\n    let eaten = if left < 0 { remaining\
    \ } else { need };\n    vec![eaten, left.max(0)]", "    let diff = need - number;\n\
    \    if diff <= remaining {\n        vec![need, remaining - diff]\n    } else\
    \ {\n        vec![number + remaining, 0]\n    }", "    let eat = remaining.min(number\
    \ + need);\n    vec![eat, remaining - eat]", "    let mut result = vec![];\n \
    \   if remaining >= need {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result", "    let total_carrots = number + remaining;\n    let left_carrots\
    \ = total_carrots - need;\n    if left_carrots >= 0 {\n        return vec![need,\
    \ left_carrots];\n    }\n    if left_carrots < 0 {\n        return vec![total_carrots,\
    \ 0];\n    }\n    unreachable!();", "    if remaining >= need {\n        return\
    \ vec![number + need, remaining - need];\n    }\n    vec![number + remaining,\
    \ 0]", "    let mut res = vec![number + remaining, 0];\n    if remaining < need\
    \ {\n        res[0] -= (need - remaining);\n    } else {\n        res[1] = remaining\
    \ - need;\n    }\n    res", "    if remaining >= number + need {\n        vec![number\
    \ + need, remaining - (number + need)]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", "    let mut res = vec![number, remaining];\n    if res[1] >= res[0]\
    \ + res[1] {\n        res[0] += res[1];\n        res[1] = 0;\n    } else {\n \
    \       res[0] += res[1];\n        res[1] = 0;\n    }\n    return res;", "   \
    \ vec![\n        number + ::std::cmp::min(need, remaining),\n        ::std::cmp::max(remaining\
    \ - need, 0),\n    ]", "    let eaten = if remaining > need {\n        number\
    \ + need\n    } else {\n        number + remaining\n    };\n    let left = if\
    \ remaining > need {\n        remaining - need\n    } else {\n        0\n    };\n\
    \    vec![eaten, left]", "    let remaining = remaining - number;\n    if remaining\
    \ < need {\n        return vec![remaining + number, 0];\n    } else {\n      \
    \  return vec![need + number, remaining - need];\n    }", '    vec![number + min(need,
    remaining), max(0, remaining - need)]', "    if remaining < need {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }", "    if need - number <= remaining {\n        vec![number + need, remaining\
    \ - (need - number)]\n    } else {\n        vec![number + remaining, 0]\n    }",
  "    let mut number = number;\n    let mut need = need;\n    let mut remaining =\
    \ remaining;\n    while need > 0 && remaining > 0 {\n        number += 1;\n  \
    \      need -= 1;\n        remaining -= 1;\n    }\n    vec![number, remaining]",
  "    let eaten = if need <= remaining {\n        number + need\n    } else {\n \
    \       number + remaining\n    };\n    let left = if need <= remaining {\n  \
    \      remaining - need\n    } else {\n        0\n    };\n    vec![eaten, left]",
  "    if remaining > number + need {\n        vec![number + need, remaining - number\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }", "    if\
    \ number + need <= remaining {\n        vec![number + need, remaining - (number\
    \ + need)]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ mut result = vec![];\n    let mut r = number + remaining;\n    if r > need {\n\
    \        r = need;\n    }\n    result.push(r);\n    result.push(remaining - r\
    \ + number);\n    result", "    if number + need <= remaining {\n        vec![number\
    \ + need, remaining - (number + need)]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", "    let x = (number + need).min(number + remaining);\n    vec![x,\
    \ (number + remaining) - x]", "    let mut total = number + remaining;\n    let\
    \ mut result = 0;\n    if total >= need {\n        result = total - need;\n  \
    \      total = need;\n    }\n    vec![total, result]", "    if need > remaining\
    \ {\n        let not_enough = remaining - number;\n        return vec![not_enough,\
    \ 0];\n    } else {\n        let enough = number + remaining;\n        return\
    \ vec![enough, 0];\n    }", "    let out = remaining - (need - number);\n    if\
    \ out >= 0 {\n        vec![number + need, out]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }", "    let hunger = need - number;\n    let num_carrots_left\
    \ = remaining - hunger;\n    if num_carrots_left < 0 {\n        return vec![number\
    \ + remaining, 0];\n    } else {\n        return vec![number + hunger, num_carrots_left];\n\
    \    }", "    let carrots_eaten = number + need;\n    let carrots_left = if carrots_eaten\
    \ > remaining {\n        0\n    } else {\n        remaining - carrots_eaten\n\
    \    };\n    vec![carrots_eaten, carrots_left]", "    let mut total_carrots =\
    \ 0;\n    let mut n_carrots = number;\n    let mut r_carrots = remaining;\n  \
    \  while n_carrots < need {\n        if r_carrots > 0 {\n            n_carrots\
    \ += 1;\n            r_carrots -= 1;\n            total_carrots += 1;\n      \
    \  } else {\n            break;\n        }\n    }\n    vec![total_carrots, r_carrots]",
  "    let remaining_carrots = remaining - need;\n    if remaining_carrots < 0 {\n\
    \        return vec![number + remaining, 0];\n    } else {\n        return vec![number\
    \ + need, remaining_carrots];\n    }", "    let mut total_number: isize = number;\n\
    \    if remaining + number < need {\n        total_number += remaining;\n    \
    \    let left: isize = 0;\n        vec![total_number, left]\n    } else {\n  \
    \      total_number += need;\n        let left: isize = remaining - need + number;\n\
    \        vec![total_number, left]\n    }", "    vec![\n        number + std::cmp::min(need,\
    \ remaining),\n        std::cmp::max(remaining - need, 0),\n    ]", "    let mut\
    \ res: Vec<isize> = Vec::new();\n    let mut eaten = number;\n    let mut remaining\
    \ = remaining;\n    if remaining == 0 {\n        res.push(eaten);\n        res.push(remaining);\n\
    \        return res;\n    }\n    while need > 0 {\n        if remaining == 0 {\n\
    \            break;\n        }\n        eaten += 1;\n        remaining -= 1;\n\
    \        need -= 1;\n    }\n    res.push(eaten);\n    res.push(remaining);\n \
    \   res", "    if need > number {\n        if need - number <= remaining {\n \
    \           return vec![need, remaining - (need - number)];\n        } else {\n\
    \            return vec![number + remaining, 0];\n        }\n    } else {\n  \
    \      return vec![number, remaining];\n    }", "    let mut carrots = number\
    \ + remaining;\n    let mut need = need;\n    while carrots > 0 && need > 0 {\n\
    \        carrots -= 1;\n        need -= 1;\n    }\n    vec![number + remaining\
    \ - carrots, carrots]", "    let eat_number = number + need;\n    if eat_number\
    \ <= remaining {\n        return vec![eat_number, remaining - eat_number];\n \
    \   }\n    vec![eat_number - remaining, 0]", "    let eaten = number + min(need,\
    \ remaining);\n    let remain = max(0, remaining - need);\n    vec![eaten, remain]",
  "    let mut ans: Vec<isize> = Vec::new();\n    let remain = remaining - number;\n\
    \    if need <= remain {\n        ans.push(number + need);\n        ans.push(remain\
    \ - need);\n    } else {\n        ans.push(number + remain);\n        ans.push(0);\n\
    \    }\n    ans", "    if remaining >= need {\n        vec![number + need, remaining\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }", "    let\
    \ eat = number + need;\n    let remaining = remaining - eat;\n    if remaining\
    \ > 0 {\n        return vec![eat, remaining];\n    } else {\n        return vec![eat,\
    \ 0];\n    }", "    if number + need <= remaining {\n        vec![number + need,\
    \ remaining - (number + need)]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", "    let mut number = number;\n    let mut remaining = remaining;\n\
    \    let mut result = Vec::new();\n    if number + remaining >= need {\n     \
    \   number += need;\n        remaining -= need;\n    } else {\n        number\
    \ += remaining;\n        remaining = 0;\n    }\n    result.push(number);\n   \
    \ result.push(remaining);\n    result", "    let mut number = number;\n    let\
    \ mut remaining = remaining;\n    if number + remaining >= need {\n        number\
    \ += need;\n        remaining -= need;\n    } else {\n        number += remaining;\n\
    \        remaining = 0;\n    }\n    vec![number, remaining]", "    let mut number\
    \ = number;\n    let mut remaining = remaining;\n    let mut need = need;\n  \
    \  if remaining <= need {\n        number += remaining;\n        remaining = 0;\n\
    \    } else {\n        number += need;\n        remaining -= need;\n    }\n  \
    \  vec![number, remaining]", "    let mut total_carrots = 0;\n    let carrots_eaten\
    \ = number + need;\n    if remaining > carrots_eaten {\n        total_carrots\
    \ = carrots_eaten;\n    } else {\n        total_carrots = remaining;\n    }\n\
    \    let remaining_carrots = remaining - total_carrots;\n    vec![total_carrots,\
    \ remaining_carrots]", "    // your code here.\n    let missing_carrots = need\
    \ - number;\n    let eaten_carrots = if missing_carrots > remaining {\n      \
    \  number + remaining\n    } else {\n        number + missing_carrots\n    };\n\
    \    let carrots_left = if missing_carrots > remaining {\n        0\n    } else\
    \ {\n        remaining - missing_carrots\n    };\n    vec![eaten_carrots, carrots_left]",
  "    if need - number > remaining {\n        vec![number + remaining, 0]\n    }\
    \ else {\n        vec![number + need, remaining - need]\n    }", "    let total\
    \ = number + remaining;\n    if total < need {\n        vec![total, 0]\n    }\
    \ else {\n        vec![need, total - need]\n    }", '    vec![number + min(need,
    remaining), max(0, remaining - need)]', "    let mut total = number + remaining;\n\
    \    if total >= need {\n        return vec![need, total - need];\n    } else\
    \ {\n        return vec![total, 0];\n    }", "    let eaten = number + min(need,\
    \ remaining);\n    vec![eaten, max(0, remaining - need)]", "    // your code here\n\
    \    let total_eat = number + need;\n    if total_eat <= remaining {\n       \
    \ vec![total_eat, remaining - total_eat]\n    } else {\n        vec![total_eat\
    \ - (total_eat - remaining), 0]\n    }", "    let mut number = number;\n    let\
    \ mut need = need;\n    let mut remaining = remaining;\n    let total: isize;\n\
    \    let left: isize;\n    if number + remaining < need {\n        total = number\
    \ + remaining;\n        left = 0;\n    } else {\n        total = need;\n     \
    \   left = number + remaining - need;\n    }\n    vec![total, left]", "    let\
    \ left = number + remaining - need;\n    vec![number + remaining - left.max(0),\
    \ left.max(0)]", "    let mut res = Vec::new();\n    let mut sum = number + remaining;\n\
    \    if sum >= need {\n        sum -= need;\n    } else {\n        sum = 0;\n\
    \    }\n    res.push(number + remaining - sum);\n    res.push(sum);\n    res",
  "    let total = number + need;\n    let left = total - remaining;\n    if left\
    \ > 0 {\n        vec![total - left, 0]\n    } else {\n        vec![total, -left]\n\
    \    }", "    if number + need > remaining {\n        vec![remaining, 0]\n   \
    \ } else {\n        vec![number + need, remaining - (number + need)]\n    }",
  "    if remaining + number >= need {\n        vec![need, remaining + number - need]\n\
    \    } else {\n        vec![remaining + number, 0]\n    }", "    if need - number\
    \ <= remaining {\n        vec![number + need, remaining - (need - number)]\n \
    \   } else {\n        vec![number + remaining, 0]\n    }", "    let new_amount\
    \ = number + need;\n    if new_amount > remaining {\n        vec![remaining, 0]\n\
    \    } else {\n        vec![new_amount, remaining - new_amount]\n    }", "   \
    \ if remaining >= need {\n        return vec![number + need, remaining - need];\n\
    \    } else {\n        return vec![number + remaining, 0];\n    }", "    let mut\
    \ remaining = remaining;\n    let mut number = number;\n    let mut need = need;\n\
    \    let mut vec = Vec::new();\n    if remaining <= 0 {\n        vec.push(number);\n\
    \        vec.push(0);\n        return vec;\n    }\n    number += need;\n    remaining\
    \ -= need;\n    if remaining <= 0 {\n        vec.push(number);\n        vec.push(0);\n\
    \        return vec;\n    }\n    if remaining < need {\n        vec.push(number\
    \ + remaining);\n        vec.push(0);\n        return vec;\n    }\n    vec.push(number);\n\
    \    vec.push(remaining);\n    vec", "    if number + need <= remaining {\n  \
    \      vec![number + need, remaining - (number + need)]\n    } else {\n      \
    \  vec![number + remaining, 0]\n    }", "    if remaining < need {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need]\n\
    \    }", '    vec![number + std::cmp::min(need, remaining), std::cmp::max(0, remaining
    - need)]', "    let eaten = number + remaining.min(need);\n    let left = remaining\
    \ - (need - number);\n    vec![eaten, left.max(0)]", "    let mut meal = number\
    \ + need;\n    if meal > remaining {\n        meal = remaining;\n    }\n    return\
    \ vec![meal, remaining - meal];", "    let total = number + remaining;\n    if\
    \ total >= need {\n        vec![need, total - need]\n    } else {\n        vec![total,\
    \ 0]\n    }", "    let total = number + need;\n    if total <= remaining {\n \
    \       vec![total, remaining - total]\n    } else {\n        vec![remaining +\
    \ number, 0]\n    }", "    let diff = number + need - remaining;\n    if diff\
    \ > 0 {\n        return vec![number + remaining, 0];\n    }\n    vec![number +\
    \ need, remaining - need]", "    let total = number + remaining;\n    let mut\
    \ left = need - total;\n    if left < 0 {\n        left = 0;\n    }\n    vec![total,\
    \ left]", "    let total = if remaining >= need {\n        number + need\n   \
    \ } else {\n        number + remaining\n    };\n    vec![total, remaining - need]",
  "    let total_after_eat = number + need;\n    let carrots_left = if total_after_eat\
    \ > remaining { 0 } else { remaining - total_after_eat };\n    vec![total_after_eat,\
    \ carrots_left]", "    let mut result = vec![number + need, remaining - need];\n\
    \    if result[1] < 0 {\n        result[1] = 0;\n        result[0] = number +\
    \ remaining;\n    }\n    result", "    // Your code here\n    if remaining >=\
    \ need {\n        vec![number + need, remaining - need]\n    } else {\n      \
    \  vec![number + remaining, 0]\n    }", "    let a = if remaining > need { need\
    \ } else { remaining };\n    let b = if remaining > need { 0 } else { remaining\
    \ - need };\n    vec![number + a, b]", "    let mut eaten = number;\n    if need\
    \ > remaining {\n        eaten += remaining;\n        return vec![eaten, 0];\n\
    \    }\n    eaten += need;\n    vec![eaten, remaining - need]", "    if number\
    \ >= need {\n        return vec![number, remaining];\n    }\n    if remaining\
    \ <= 0 {\n        return vec![number, 0];\n    }\n    let mut r = remaining -\
    \ (need - number);\n    if r < 0 {\n        r = 0;\n    }\n    return vec![need,\
    \ r];", "    let mut r = remaining;\n    if number + need <= remaining {\n   \
    \     r = remaining - number - need;\n    } else {\n        r = 0;\n    }\n  \
    \  vec![number + need, r]", "    if remaining > number + need {\n        vec![number\
    \ + need, remaining - number - need]\n    } else {\n        vec![number + remaining,\
    \ 0]\n    }", '    vec![number + std::cmp::min(need, remaining), std::cmp::max(0,
    remaining - need)]', "    let n = number + need;\n    let r = if n <= remaining\
    \ { remaining - n } else { 0 };\n    vec![n, r]", "    let sum: isize = number\
    \ + need;\n    if sum > remaining {\n        let rem = remaining - number;\n \
    \       vec![remaining, rem]\n    } else {\n        vec![sum, 0]\n    }", "  \
    \  let mut remain = need - number;\n    let mut total = number;\n    if remain\
    \ < remaining {\n        total += remain;\n        remain = 0;\n    } else {\n\
    \        total += remaining;\n        remain -= remaining;\n    }\n    vec![total,\
    \ remain]", "    let remaining = if remaining < 0 {\n        0\n    } else {\n\
    \        remaining\n    };\n    let need = if need < 0 {\n        0\n    } else\
    \ {\n        need\n    };\n    let number = if number < 0 {\n        0\n    }\
    \ else {\n        number\n    };\n    let remaining = if remaining + number <\
    \ need {\n        0\n    } else {\n        remaining + number - need\n    };\n\
    \    vec![number + need, remaining]", "    let eaten = number + need;\n    if\
    \ eaten <= remaining {\n        vec![eaten, remaining - eaten]\n    } else {\n\
    \        vec![eaten - remaining, 0]\n    }", "    let (e, r) = if remaining >\
    \ need - number {\n        (number + need, remaining - need + number)\n    } else\
    \ {\n        (number + remaining, 0)\n    };\n    vec![e, r]", "    let mut carrots_eaten\
    \ = number;\n    let mut carrots_remaining = remaining;\n    while carrots_eaten\
    \ < number + need && carrots_remaining > 0 {\n        carrots_eaten += 1;\n  \
    \      carrots_remaining -= 1;\n    }\n    vec![carrots_eaten, carrots_remaining]",
  "    let mut result = vec![];\n    if remaining == 0 {\n        result.push(number);\n\
    \        result.push(remaining);\n    } else if remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result", "    let\
    \ r = match number + need.min(remaining) {\n        x if x >= number => {\n  \
    \          if number + need >= remaining {\n                x - remaining\n  \
    \          } else {\n                x - need\n            }\n        }\n    \
    \    _ => 0,\n    };\n    vec![number + need.min(remaining), r]", "    let mut\
    \ a = number + remaining;\n    let mut b = 0;\n    if a >= need {\n        a -=\
    \ need;\n    } else {\n        b = need - a;\n        a = 0;\n    }\n    vec![a,\
    \ b]", "    return if remaining >= need {\n        vec![number + need, remaining\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    };", "    let\
    \ mut eaten = number;\n    let mut carrots = remaining;\n    let mut meal = 0;\n\
    \    while meal < need {\n        if carrots > 0 {\n            eaten += 1;\n\
    \            carrots -= 1;\n            meal += 1;\n        } else {\n       \
    \     break;\n        }\n    }\n    vec![eaten, carrots]", "    if remaining >=\
    \ need {\n        vec![number + need, remaining - need]\n    } else {\n      \
    \  vec![number + remaining, 0]\n    }", '    vec![number + min(need, remaining),
    max(0, remaining - need)]', "    let mut result = Vec::new();\n    if need <=\
    \ remaining {\n        result.push(number + need);\n        result.push(remaining\
    \ - need);\n    } else {\n        result.push(number + remaining);\n        result.push(0);\n\
    \    }\n    result", "    let n = number + min(need, remaining);\n    let r =\
    \ max(0, remaining - need);\n    vec![n, r]", "    let eat = if need > remaining\
    \ { remaining } else { need };\n    vec![number + eat, remaining - eat]", "  \
    \  let mut result = vec![number + remaining, 0];\n    if result[0] >= need {\n\
    \        result[0] = need;\n        result[1] = remaining - (need - number);\n\
    \    }\n    result", "    let total = number + need;\n    if total <= remaining\
    \ {\n        vec![total, remaining - total]\n    } else {\n        vec![remaining\
    \ + number, 0]\n    }", '    vec![number + if need < remaining { need } else {
    remaining }, if need < remaining { remaining - need } else { 0 }]', "    let (mut\
    \ total, mut rem): (isize, isize) = (number, remaining);\n    for _ in 0..need\
    \ {\n        if rem > 0 {\n            total += 1;\n            rem -= 1;\n  \
    \      }\n    }\n    vec![total, rem]", "    let mut total_carrots = number +\
    \ need;\n    let mut carrots_left = remaining - need;\n    if carrots_left < 0\
    \ {\n        total_carrots = remaining + number;\n        carrots_left = 0;\n\
    \    }\n    vec![total_carrots, carrots_left]", "    if number > 1000 || need\
    \ > 1000 || remaining > 1000 {\n        return vec![];\n    }\n\n    if number\
    \ > remaining || need > remaining {\n        return vec![remaining, 0];\n    }\n\
    \n    let mut total_number = number;\n    let mut total_remaining = remaining;\n\
    \n    for _ in 0..need {\n        if total_remaining > 0 {\n            total_number\
    \ += 1;\n            total_remaining -= 1;\n        }\n    }\n\n    vec![total_number,\
    \ total_remaining]", "    let n = number + remaining;\n    if n >= need {\n  \
    \      vec![need, n - need]\n    } else {\n        vec![n, 0]\n    }", "    let\
    \ available = remaining - number;\n    if available >= need {\n        vec![number\
    \ + need, available - need]\n    } else {\n        vec![number + available, 0]\n\
    \    }", "    vec![\n        (number + remaining).min(need),\n        need.min(remaining)\
    \ - number,\n    ]", "    let mut res = vec![];\n    if remaining < need {\n \
    \       res.push(number + remaining);\n        res.push(0);\n    } else {\n  \
    \      res.push(number + need);\n        res.push(remaining - need);\n    }\n\
    \    res", "    if need <= remaining {\n        vec![number + need, remaining\
    \ - need]\n    } else {\n        vec![number + remaining, 0]\n    }", "    //\
    \  if remaining < need - number\n    if remaining < need - number {\n        vec![number\
    \ + remaining, 0]\n    } else {\n        vec![number + need, remaining - need\
    \ + number]\n    }", "    let mut ret = Vec::with_capacity(2);\n    let eaten\
    \ = number + std::cmp::min(need, remaining);\n    let left = remaining - eaten;\n\
    \    ret.push(eaten);\n    ret.push(left);\n    ret", "    if number + need <=\
    \ remaining {\n        vec![number + need, remaining - (number + need)]\n    }\
    \ else {\n        vec![number + remaining, 0]\n    }", "    // your code\n   \
    \ let mut eaten = number;\n    let mut remaining = remaining;\n    let mut result\
    \ = vec![];\n    if number >= need {\n        result.push(need);\n        result.push(remaining);\n\
    \    } else {\n        while eaten < need {\n            if remaining == 0 {\n\
    \                result.push(eaten);\n                result.push(remaining);\n\
    \                break;\n            } else {\n                eaten += 1;\n \
    \               remaining -= 1;\n            }\n        }\n        if eaten >=\
    \ need {\n            result.push(eaten);\n            result.push(remaining);\n\
    \        }\n    }\n    result", "    let mut ret = vec![number, remaining];\n\
    \    let mut index = 0;\n    while ret[index] < need {\n        ret[index] +=\
    \ 1;\n        ret[index + 1] -= 1;\n        if ret[index + 1] == 0 {\n       \
    \     break;\n        }\n    }\n    ret", "    let res = number + need;\n    let\
    \ rem = if res > remaining { remaining - number } else { remaining - res };\n\
    \    vec![res, rem]", "    let result: Vec<isize>;\n    if number + need <= remaining\
    \ {\n        result = vec![number + need, remaining - (number + need)];\n    }\
    \ else {\n        result = vec![number + remaining, 0];\n    }\n    result", " \
    \   let num = number + std::cmp::min(need, remaining);\n    vec![num, std::cmp::max(0,\
    \ remaining - need)]", "    let mut total = number + need;\n    if total > remaining\
    \ {\n        total = remaining;\n    }\n    vec![total, remaining - total]", " \
    \   vec![\n        number + std::cmp::min(need, remaining),\n        std::cmp::max(remaining\
    \ - need, 0),\n    ]", "    let eaten = number + remaining.min(need);\n    vec![eaten,\
    \ remaining - need.min(remaining)]", "    let mut v: Vec<isize> = Vec::new();\n\
    \    if remaining == 0 {\n        v.push(0);\n        v.push(0);\n    } else if\
    \ remaining >= need {\n        v.push(number + need);\n        v.push(remaining\
    \ - need);\n    } else {\n        v.push(number + remaining);\n        v.push(0);\n\
    \    }\n    v", '    vec![number + std::cmp::min(need, remaining), std::cmp::max(0,
    remaining - need)]', "    let sum = number + need;\n    let left = if sum > remaining\
    \ {\n        sum - remaining\n    } else {\n        0\n    };\n    vec![sum, left]",
  "    // your code here :)\n    let mut total = number + need;\n    let mut remain\
    \ = remaining - total;\n    if remain < 0 {\n        total += remain;\n      \
    \  remain = 0;\n    }\n    vec![total, remain]"]
stop_tokens:
- "\n}"
