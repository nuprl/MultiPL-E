language: rs
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let map: HashMap<char, isize> = [\n      \
    \  ('A', 0),\n        ('E', 0),\n        ('I', 0),\n        ('O', 0),\n      \
    \  ('U', 0),\n        ('Y', 0),\n        ('a', 0),\n        ('e', 0),\n      \
    \  ('i', 0),\n        ('o', 0),\n        ('u', 0),\n        ('y', 0),\n    ].iter().cloned().collect();\n\
    \    for s_ in s.split(\" \") {\n        let mut c = 0;\n        for c_ in s_.chars()\
    \ {\n            if map.contains_key(&c_) {\n                c += 1;\n       \
    \     }\n        }\n        if c == n {\n            v.push(s_.to_string());\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp252ty7a3.rs:19:14\n\
    \   |\n19 |     let map: HashMap<char, isize> = [\n   |              ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n\tlet c = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n\ts.split_whitespace()\n\t\t.filter(|&v| {\n\t\t\tv.chars()\n\
    \t\t\t\t.filter(|&v| !c.contains(&v))\n\t\t\t\t.count() as isize == n\n\t\t})\n\
    \t\t.map(|s| s.to_string())\n\t\t.collect()\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp5g_loehe.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = \"aeiou\";\n    let mut result = Vec::new();\n    for word in s.split_whitespace()\
    \ {\n        let mut count = 0;\n        for c in word.chars() {\n           \
    \ if !vowels.contains(c) {\n                count += 1;\n            }\n     \
    \   }\n        if count == n {\n            result.push(word.to_string());\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpnf9uo369.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split('\
    \ ')\n        .filter(|w| w.chars().filter(|c| is_consonant(*c)).count() as isize\
    \ == n)\n        .map(|w| w.to_string())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpjp211h9o.rs:19:42\n   |\n19 |         .filter(|w| w.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n)\n   |                             \
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec: Vec<String> = Vec::new();\n    let mut counter: isize = 0;\n    let mut\
    \ word: String = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic()\
    \ {\n            if i.is_ascii_lowercase() {\n                if i != 'a' && i\
    \ != 'e' && i != 'i' && i != 'o' && i != 'u' {\n                    counter +=\
    \ 1;\n                }\n            } else {\n                if i != 'A' &&\
    \ i != 'E' && i != 'I' && i != 'O' && i != 'U' {\n                    counter\
    \ += 1;\n                }\n            }\n            word.push(i);\n       \
    \ } else {\n            if counter == n {\n                vec.push(word);\n \
    \           }\n            counter = 0;\n            word = String::new();\n \
    \       }\n    }\n    if counter == n {\n        vec.push(word);\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| n == consonants_count(w))\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `consonants_count` in this scope\n \
    \ --> /tmp/tmpa3q9_sfb.rs:19:26\n   |\n19 |         .filter(|w| n == consonants_count(w))\n\
    \   |                          ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| contains_n_consonants(word, n))\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `contains_n_consonants` in this scope\n\
    \  --> /tmp/tmpovxzjaeb.rs:19:24\n   |\n19 |         .filter(|word| contains_n_consonants(word,\
    \ n))\n   |                        ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    for w in words {\n        if count_consonants(w) == n {\n            result.push(w.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpw2vziof_.rs:21:12\n   |\n21 |         if count_consonants(w) ==\
    \ n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp1sy5pnx1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = \"aeiou\";\n    let mut result = Vec::new();\n    let arr: Vec<&str> = s.split_whitespace().collect();\n\
    \    for i in 0..arr.len() {\n        let mut count = 0;\n        for ch in arr[i].chars()\
    \ {\n            if !vowels.contains(ch) {\n                count += 1;\n    \
    \        }\n        }\n        if count == n {\n            result.push(arr[i].to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp51ugl067.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = vec![];\n    let split = s.split_whitespace();\n    for x in split {\n\
    \        let mut count = 0;\n        for y in x.chars() {\n            if y !=\
    \ 'a' && y != 'e' && y != 'i' && y != 'o' && y != 'u' && y != 'y' {\n        \
    \        count += 1;\n            }\n        }\n        if count == n {\n    \
    \        vec.push(x.to_string());\n        }\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpakcle0kt.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    for word in s.split(\" \") {\n        if count_consonants(word)\
    \ == n {\n            words.push(word.to_string());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmplb_kx57f.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    for word in s.split_whitespace() {\n        if n ==\
    \ count_consonants(word) {\n            words.push(word.to_string());\n      \
    \  }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpz18n3g6i.rs:20:17\n   |\n20 |         if n == count_consonants(word)\
    \ {\n   |                 ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n\
    \    let mut char_counter: isize = 0;\n    let vowels: [char; 6] = ['a', 'e',\
    \ 'i', 'o', 'u', 'y'];\n    let mut is_consonant: bool = false;\n    for c in\
    \ s.chars() {\n        if c.is_whitespace() {\n            if char_counter ==\
    \ n {\n                result.push(word);\n            }\n            word = String::new();\n\
    \            char_counter = 0;\n            is_consonant = false;\n        } else\
    \ {\n            if !is_consonant {\n                if vowels.contains(&c) {\n\
    \                    char_counter += 1;\n                } else {\n          \
    \          is_consonant = true;\n                }\n            }\n          \
    \  word.push(c);\n        }\n    }\n    if char_counter == n {\n        result.push(word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpd4qe6ew0.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let letters: Vec<&str> = s.split(\" \"\
    ).collect();\n    for i in letters {\n        let mut count = 0;\n        for\
    \ j in i.chars() {\n            match j {\n                'a' | 'e' | 'i' | 'o'\
    \ | 'u' | 'y' => {\n                    count += 1;\n                }\n     \
    \           _ => {\n                    count += 0;\n                }\n     \
    \       }\n        }\n        if count == n {\n            words.push(i.to_string());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp2_gfh8gp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let mut word = String::new();\n    let\
    \ mut wc: isize = 0;\n    for c in s.chars() {\n        if c == ' ' {\n      \
    \      if word.len() > 0 {\n                if wc == n {\n                   \
    \ words.push(word.clone());\n                }\n                word.clear();\n\
    \                wc = 0;\n            }\n        } else {\n            match c\
    \ {\n                'a' | 'e' | 'i' | 'o' | 'u' | 'y' => {},\n              \
    \  _ => wc += 1,\n            }\n            word.push(c);\n        }\n    }\n\
    \    if word.len() > 0 {\n        if wc == n {\n            words.push(word.clone());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpht44c3c6.rs:49:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let v: Vec<String>\
    \ = s.split_whitespace().map(|s| s.to_string()).collect();\n    let mut res: Vec<String>\
    \ = Vec::new();\n    for w in v {\n        let mut counter = 0;\n        for c\
    \ in w.chars() {\n            if is_consonant(c) {\n                counter +=\
    \ 1;\n            }\n        }\n        if counter == n {\n            res.push(w);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp2m92t_x5.rs:23:16\n   |\n23 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ string_vector: Vec<String> = Vec::new();\n    let mut words = s.split_whitespace();\n\
    \    while let Some(word) = words.next() {\n        let mut consonants = 0;\n\
    \        for letter in word.chars() {\n            if is_consonant(letter) {\n\
    \                consonants += 1;\n            }\n        }\n        if consonants\
    \ == n {\n            string_vector.push(word.to_string());\n        }\n    }\n\
    \    string_vector\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpuplhwje4.rs:23:16\n   |\n23 |             if is_consonant(letter) {\n\
    \   |                ^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `consonants`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| count_consonants(&w) == n)\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpyvd40gqn.rs:19:21\n   |\n19 |         .filter(|w| count_consonants(&w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let a =\
    \ b'a';\n    let mut result = Vec::new();\n    let mut v: Vec<&str> = s.split('\
    \ ').collect();\n    for mut w in v.drain(..) {\n        let mut count = 0;\n\
    \        for c in w.chars() {\n            let mut i = (c as u8) - a;\n      \
    \      if i <= b'z' - a && i >= b'a' - a {\n                if i != b'a' - a &&\
    \ i != b'e' - a && i != b'i' - a && i != b'o' - a && i != b'u' - a {\n       \
    \             count += 1;\n                }\n            }\n        }\n     \
    \   if count == n {\n            result.push(w.to_string());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpe8oyw2ol.rs:24:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let v: Vec<&str>\
    \ = s.split(\" \").collect();\n    let mut nv: Vec<String> = Vec::new();\n   \
    \ for word in v {\n        let count = count_consonants(word);\n        if count\
    \ == n {\n            nv.push(word.to_string());\n        }\n    }\n    nv\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpsazg3gqa.rs:21:21\n   |\n21 |         let count = count_consonants(word);\n\
    \   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let words = s.split_whitespace();\n    for word in\
    \ words {\n        let consonants = word.chars().filter(|ch| is_consonant(*ch)).count();\n\
    \        if consonants == n as usize {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp6n9akcqg.rs:21:51\n   |\n21 |         let consonants = word.chars().filter(|ch|\
    \ is_consonant(*ch)).count();\n   |                                          \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s_vec: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split(\" \").collect();\n\
    \    for word in words {\n        let len = word.chars().filter(|c| {\n      \
    \      match c {\n                'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I'\
    \ | 'O' | 'U' => false,\n                _ => true\n            }\n        }).count();\n\
    \        if len == n as usize {\n            s_vec.push(word.to_string());\n \
    \       }\n    }\n    s_vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let split_words = s.split_whitespace();\n    for word\
    \ in split_words {\n        let mut count = 0;\n        for letter in word.chars()\
    \ {\n            if letter != 'a' && letter != 'e' && letter != 'i' && letter\
    \ != 'o' && letter != 'u' {\n                count += 1;\n            }\n    \
    \    }\n        if count == n {\n            res.push(word.to_string());\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpiop8j0zq.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec: Vec<String> = Vec::new();\n    for word in s.split(\" \") {\n        let\
    \ mut count = 0;\n        for character in word.chars() {\n            if character.is_ascii_alphabetic()\
    \ && !character.is_ascii_lowercase() {\n                count += 1;\n        \
    \    }\n        }\n        if count == n {\n            vec.push(word.to_string());\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpbjlw_dpf.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut result = vec![];\n    let str_split\
    \ = s.split(\" \");\n    for word in str_split {\n        let mut count = 0;\n\
    \        for letter in word.chars() {\n            if letter != 'a' && letter\
    \ != 'e' && letter != 'i' && letter != 'o' && letter != 'u' && letter != 'y' {\n\
    \                count += 1;\n            }\n        }\n        if count == n\
    \ {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpv1zb1101.rs:40:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let split_vec: Vec<&str> = s.split(\"\
    \ \").collect();\n    for word in split_vec {\n        let mut x: isize = 0;\n\
    \        for char in word.chars() {\n            if !char.is_vowel() {\n     \
    \           x += 1;\n            }\n        }\n        if x == n {\n         \
    \   result.push(word.to_string());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwickcq1o.rs:23:22\n   |\n23 |             if !char.is_vowel()\
    \ {\n   |                      ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let words\
    \ = s.split_whitespace();\n    let mut ret: Vec<String> = Vec::new();\n    for\
    \ word in words {\n        let mut cons_count = 0;\n        for c in word.chars()\
    \ {\n            let lc = c.to_lowercase().to_string();\n            match lc.as_str()\
    \ {\n                \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => {}\n           \
    \     _ => cons_count += 1,\n            }\n        }\n        if cons_count ==\
    \ n {\n            ret.push(word.to_string());\n        }\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut word = String::new();\n    for character in s.chars()\
    \ {\n        if character.is_whitespace() {\n            if is_consonant(&word,\
    \ n) {\n                words.push(word);\n            }\n            word = String::new();\n\
    \        } else {\n            word.push(character);\n        }\n    }\n    if\
    \ is_consonant(&word, n) {\n        words.push(word);\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpoa6ehtlq.rs:22:16\n   |\n22 |             if is_consonant(&word, n)\
    \ {\n   |                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n  --> /tmp/tmpoa6ehtlq.rs:30:8\n\
    \   |\n30 |     if is_consonant(&word, n) {\n   |        ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| count_consonants(word) == n)\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpde02rj1e.rs:19:24\n   |\n19 |         .filter(|word| count_consonants(word)\
    \ == n)\n   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let s =\
    \ s.trim();\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let\
    \ mut selected_words: Vec<String> = Vec::new();\n    let mut cnt = 0;\n    for\
    \ i in 0..words.len() {\n        for c in words[i].chars() {\n            cnt\
    \ += if c.is_vowel() { -1 } else { 1 };\n        }\n        if cnt == n {\n  \
    \          selected_words.push(words[i].to_string());\n        }\n        cnt\
    \ = 0;\n    }\n    selected_words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppqs7y8uh.rs:24:25\n   |\n24 |             cnt += if c.is_vowel()\
    \ { -1 } else { 1 };\n   |                         ^^^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n\
    \    let mut is_word: bool = false;\n    let mut n_consonants: isize = 0;\n  \
    \  for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            is_word = true;\n            if !c.is_vowel() {\n               \
    \ n_consonants += 1;\n            }\n        } else {\n            if is_word\
    \ {\n                if n_consonants == n {\n                    words.push(word.clone());\n\
    \                }\n                word.clear();\n                is_word = false;\n\
    \                n_consonants = 0;\n            }\n        }\n    }\n    if is_word\
    \ {\n        if n_consonants == n {\n            words.push(word.clone());\n \
    \       }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsa2e9rd5.rs:26:19\n   |\n26 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO:\
    \ Implement me!\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy_nzjkj0.rs:19:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split(\" \").collect();\n\
    \    let mut count: isize = 0;\n    for i in words {\n        count = 0;\n   \
    \     for c in i.chars() {\n            match c {\n                'a' | 'e' |\
    \ 'i' | 'o' | 'u' | 'y' => count += 1,\n                _ => (),\n           \
    \ }\n        }\n        if count == n {\n            res.push(i.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpa14mc2ev.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    let mut current_word: String = String::from(\"\
    \");\n    for c in s.chars() {\n        if c == ' ' {\n            if number_of_consonants(&current_word)\
    \ == n {\n                words.push(current_word);\n            }\n         \
    \   current_word = String::from(\"\");\n        } else {\n            current_word.push(c);\n\
    \        }\n    }\n    if number_of_consonants(&current_word) == n {\n       \
    \ words.push(current_word);\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_of_consonants` in this scope\n\
    \  --> /tmp/tmpyudymp13.rs:22:16\n   |\n22 |             if number_of_consonants(&current_word)\
    \ == n {\n   |                ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `number_of_consonants` in this scope\n  -->\
    \ /tmp/tmpyudymp13.rs:30:8\n   |\n30 |     if number_of_consonants(&current_word)\
    \ == n {\n   |        ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vowels = HashSet::new();\n    vowels.insert('a');\n    vowels.insert('e');\n\
    \    vowels.insert('i');\n    vowels.insert('o');\n    vowels.insert('u');\n \
    \   let mut words = s.split_whitespace();\n    let mut res = Vec::new();\n   \
    \ for word in words {\n        let mut num_consonants = 0;\n        for ch in\
    \ word.chars() {\n            if !vowels.contains(&ch) {\n                num_consonants\
    \ += 1;\n            }\n        }\n        if num_consonants == n {\n        \
    \    res.push(word.to_string());\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpju0smz_8.rs:18:22\n   |\n18 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let mut word = String::new();\n    let\
    \ space = ' ';\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut consonants\
    \ = 0;\n    for c in s.chars() {\n        if c == space {\n            if consonants\
    \ == n {\n                result.push(word);\n            }\n            word\
    \ = String::new();\n            consonants = 0;\n        } else {\n          \
    \  if !vowels.contains(&c) {\n                consonants += 1;\n            }\n\
    \            word.push(c);\n        }\n    }\n    if consonants == n {\n     \
    \   result.push(word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpg9uke2m4.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret = Vec::new();\n    let mut counter = 0;\n    let mut idx = 0;\n    let str\
    \ = s.clone();\n    let chr = str.chars();\n    for i in chr {\n        let a\
    \ = i.is_alphabetic();\n        if a && is_vowel(i) {\n            counter +=\
    \ 1;\n        }\n        if a && is_consonant(i) {\n            counter -= 1;\n\
    \        }\n        if i == ' ' || i == '\\n' {\n            if counter == n {\n\
    \                let str_idx = s.get(idx..);\n                let str_idx = str_idx.unwrap();\n\
    \                let mut vec = str_idx.split(' ');\n                let vec =\
    \ vec.next().unwrap();\n                ret.push(vec.to_string());\n         \
    \   }\n            counter = 0;\n            idx = 0;\n        }\n        idx\
    \ += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp22qwrwfl.rs:25:17\n\
    \   |\n25 |         if a && is_vowel(i) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_consonant` in this scope\n\
    \  --> /tmp/tmp22qwrwfl.rs:28:17\n   |\n28 |         if a && is_consonant(i) {\n\
    \   |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let vowels = String::from(\"aeiou\");\n\
    \    for word in s.split_whitespace() {\n        let consonants = word.chars().filter(|x|\
    \ !vowels.contains(*x)).count();\n        if consonants == n as usize {\n    \
    \        result.push(String::from(word));\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp4nmo_tc3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!(\"\
    Return all words from string s that contain exactly {} consonants\", n);\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return all words from string
    s that contain exactly 4 consonants'', /tmp/tmp7xpawqz1.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let s_split: Vec<&str> = s.split(\" \"\
    ).collect();\n    for i in s_split {\n        if count_consonants(i.to_string())\
    \ == n {\n            result.push(i.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpsd3lf5wi.rs:21:12\n   |\n21 |         if count_consonants(i.to_string())\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| word.chars().filter(|c| is_consonant(*c)).count() as isize\
    \ == n)\n        .map(|word| word.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpwtjbeb8d.rs:19:48\n   |\n19 |         .filter(|word| word.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n)\n   |                             \
    \                   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let strings: Vec<&str> = s.split(\" \"\
    ).collect();\n    for string in strings {\n        let mut count = 0;\n      \
    \  for c in string.chars() {\n            if c.is_ascii_alphabetic() && !is_vowel(c)\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(string.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpn1b_0s88.rs:23:44\n\
    \   |\n23 |             if c.is_ascii_alphabetic() && !is_vowel(c) {\n   |   \
    \                                         ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let words\
    \ = s.split(\" \");\n    let mut count = 0;\n    let mut result = Vec::new();\n\
    \    for word in words {\n        for ch in word.chars() {\n            if ch.is_alphabetic()\
    \ && ch.is_lowercase() && !is_vowel(ch) {\n                count += 1;\n     \
    \       }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n        count = 0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpdn95h5i8.rs:23:60\n\
    \   |\n23 |             if ch.is_alphabetic() && ch.is_lowercase() && !is_vowel(ch)\
    \ {\n   |                                                            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    return s.split_whitespace()\n\
    \        .filter(|w| count_consonants(w) == n)\n        .map(|w| w.to_string())\n\
    \        .collect();\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpf8yegbqy.rs:19:21\n   |\n19 |         .filter(|w| count_consonants(w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ results = Vec::new();\n    for word in s.split_whitespace() {\n        if num_consonants(word)\
    \ == n {\n            results.push(word.to_string());\n        }\n    }\n    results\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_consonants` in this scope\n  -->\
    \ /tmp/tmph3yzi2fm.rs:20:12\n   |\n20 |         if num_consonants(word) == n {\n\
    \   |            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ consonants = Vec::new();\n    let mut words = Vec::new();\n    let mut word\
    \ = String::new();\n    let mut consonant_count = 0;\n    let mut i = 0;\n   \
    \ let mut k = 0;\n    while i < s.len() {\n        consonants.push(\"b\".to_string());\n\
    \        consonants.push(\"c\".to_string());\n        consonants.push(\"d\".to_string());\n\
    \        consonants.push(\"f\".to_string());\n        consonants.push(\"g\".to_string());\n\
    \        consonants.push(\"h\".to_string());\n        consonants.push(\"j\".to_string());\n\
    \        consonants.push(\"k\".to_string());\n        consonants.push(\"l\".to_string());\n\
    \        consonants.push(\"m\".to_string());\n        consonants.push(\"n\".to_string());\n\
    \        consonants.push(\"p\".to_string());\n        consonants.push(\"q\".to_string());\n\
    \        consonants.push(\"r\".to_string());\n        consonants.push(\"s\".to_string());\n\
    \        consonants.push(\"t\".to_string());\n        consonants.push(\"v\".to_string());\n\
    \        consonants.push(\"w\".to_string());\n        consonants.push(\"x\".to_string());\n\
    \        consonants.push(\"y\".to_string());\n        consonants.push(\"z\".to_string());\n\
    \        if s.chars().nth(i).unwrap().to_string() == \" \" {\n            if consonant_count\
    \ == n {\n                words.push(word.to_string());\n            }\n     \
    \       word = String::new();\n            consonant_count = 0;\n            k\
    \ = 0;\n        } else {\n            word.push(s.chars().nth(i).unwrap());\n\
    \            while k < consonants.len() {\n                if s.chars().nth(i).unwrap().to_string()\
    \ == consonants[k] {\n                    consonant_count += 1;\n            \
    \    }\n                k += 1;\n            }\n        }\n        i += 1;\n \
    \   }\n    if conson\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpiy5aw6gw.rs:65:1\n   |\n\
    64 |     if conson\n   |     -- this `if` expression has a condition, but no block\n\
    65 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = \"aeiouy\";\n    let mut consonants = 0;\n    let mut words = Vec::new();\n\
    \    let mut word = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            if vowels.contains(c) {\n                consonants = 0;\n  \
    \          } else {\n                consonants += 1;\n            }\n       \
    \     word.push(c);\n        } else {\n            if consonants == n {\n    \
    \            words.push(word);\n            }\n            consonants = 0;\n \
    \           word = String::new();\n        }\n    }\n    if consonants == n {\n\
    \        words.push(word);\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpu27u2bse.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut word = String::new();\n    let mut count =\
    \ 0;\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if\
    \ count == n {\n                words.push(word);\n            }\n           \
    \ word = String::new();\n            count = 0;\n        } else {\n          \
    \  word.push(c);\n            if !c.is_vowel() {\n                count += 1;\n\
    \            }\n        }\n    }\n    if count == n {\n        words.push(word);\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkqnaqhln.rs:30:19\n   |\n30 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec_string: Vec<String> = Vec::new();\n    let mut vec_tmp: Vec<&str> = s.split_whitespace().collect();\n\
    \    for (i, word) in vec_tmp.iter().enumerate() {\n        if is_consonant(word.to_string(),\
    \ n) {\n            vec_string.push(word.to_string());\n        }\n    }\n   \
    \ vec_string\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpe0j2ig_i.rs:21:12\n   |\n21 |         if is_consonant(word.to_string(),\
    \ n) {\n   |            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res: Vec<String> = Vec::new();\n    let vec: Vec<&str> = s.split_whitespace().collect();\n\
    \    for word in vec {\n        if count_consts(word) == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consts` in this scope\n  -->\
    \ /tmp/tmpkbs30qb1.rs:21:12\n   |\n21 |         if count_consts(word) == n {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| count_consonants(w) == n)\n        .map(String::from)\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpuc8e3rrd.rs:19:21\n   |\n19 |         .filter(|w| count_consonants(w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for word in s.split(\" \") {\n        let count = count_consonants(word);\n\
    \        if count == n {\n            words.push(word.to_string());\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpxl1oxedg.rs:20:21\n   |\n20 |         let count = count_consonants(word);\n\
    \   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = \"aeiou\";\n    let mut v = Vec::new();\n    for w in s.split_whitespace()\
    \ {\n        let mut c = 0;\n        for l in w.chars() {\n            if !vowels.contains(l)\
    \ {\n                c += 1;\n            }\n        }\n        if c == n {\n\
    \            v.push(w.to_string());\n        }\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpibf0hlhc.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let _v =\
    \ s.split_whitespace().filter(|x| count_consonants(x) == n).map(|x| x.to_string()).collect();\n\
    \    let mut v = Vec::new();\n    for word in _v {\n        v.push(word.to_string());\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpwk8hf54e.rs:18:46\n   |\n18 |     let _v = s.split_whitespace().filter(|x|\
    \ count_consonants(x) == n).map(|x| x.to_string()).collect();\n   |          \
    \                                    ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \     .filter(|word|{\n         let mut count = 0;\n         for c in word.chars()\
    \ {\n             if c.is_alphabetic() && !c.is_vowel() {\n                 count\
    \ += 1;\n             }\n         }\n         count == n\n     })\n     .map(|x|x.to_string())\n\
    \     .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3wz86nh1.rs:22:41\n   |\n22 |              if c.is_alphabetic()\
    \ && !c.is_vowel() {\n   |                                         ^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut buf = String::new();\n    let mut n_consonants\
    \ = 0;\n    for c in s.chars() {\n        if c == ' ' {\n            if n_consonants\
    \ == n {\n                result.push(buf.clone());\n            }\n         \
    \   buf.clear();\n            n_consonants = 0;\n        } else {\n          \
    \  buf.push(c);\n            if !c.is_vowel() {\n                n_consonants\
    \ += 1;\n            }\n        }\n    }\n    if n_consonants == n {\n       \
    \ result.push(buf);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpi_jzhjl2.rs:30:19\n   |\n30 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|x| (x.chars().filter(|c| !c.is_vowel()).count() as isize) ==\
    \ n)\n        .map(|x| x.to_string())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp6hi168ju.rs:19:46\n   |\n19 |         .filter(|x|\
    \ (x.chars().filter(|c| !c.is_vowel()).count() as isize) == n)\n   |         \
    \                                     ^^^^^^^^ method not found in `&char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut count = 0;\n    let mut word_vec\
    \ = vec![];\n    let mut word = String::new();\n    for ch in s.chars() {\n  \
    \      if ch.is_whitespace() {\n            if is_vovel(ch) {\n              \
    \  count += 1;\n            }\n            if n == (count as isize) {\n      \
    \          word_vec.push(word);\n            }\n            count = 0;\n     \
    \       word = String::new();\n        } else {\n            word.push(ch);\n\
    \            if is_vovel(ch) {\n                count += 1;\n            }\n \
    \       }\n    }\n    if n == (count as isize) {\n        word_vec.push(word);\n\
    \    }\n    word_vec\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vovel` in this scope\n  --> /tmp/tmpoqiv9ifj.rs:26:16\n\
    \   |\n26 |             if is_vovel(ch) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vovel` in this scope\n\
    \  --> /tmp/tmpoqiv9ifj.rs:36:16\n   |\n36 |             if is_vovel(ch) {\n \
    \  |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    for word in s.split(\" \") {\n       \
    \ let mut consonants = 0;\n        for ch in word.chars() {\n            if !ch.is_whitespace()\
    \ && !ch.is_lowercase() && ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' &&\
    \ ch != 'u' {\n                consonants += 1;\n            }\n        }\n  \
    \      if consonants == n {\n            words.push(word.to_string());\n     \
    \   }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp0shmwoct.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n  \
    \  let mut word_cons: isize = 0;\n    let str_iter = s.chars();\n    for c in\
    \ str_iter {\n        if c.is_alphabetic() {\n            word.push(c);\n    \
    \        if !is_vowel(c) {\n                word_cons += 1;\n            }\n \
    \       } else {\n            if word_cons == n {\n                v.push(word);\n\
    \            }\n            word = String::new();\n            word_cons = 0;\n\
    \        }\n    }\n    if word_cons == n {\n        v.push(word);\n    }\n   \
    \ v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpsg2fykv9.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ split = Vec::new();\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    let\
    \ mut result = Vec::new();\n    let mut temp = 0;\n    let mut add = true;\n \
    \   for word in s.split_whitespace() {\n        split.push(word);\n    }\n   \
    \ for word in split {\n        for i in word.chars() {\n            if consonants.contains(i)\
    \ {\n                temp += 1;\n            }\n        }\n        if temp ==\
    \ n {\n            result.push(word.to_string());\n        }\n        temp = 0;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpt0ho6y4u.rs:43:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| num_consonants(word) == n)\n        .map(String::from)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_consonants` in this scope\n  -->\
    \ /tmp/tmpmw4qfnnx.rs:19:24\n   |\n19 |         .filter(|word| num_consonants(word)\
    \ == n)\n   |                        ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s_iter = s.split_whitespace();\n    let mut s_vec: Vec<String> = Vec::new();\n\
    \    while let Some(word) = s_iter.next() {\n        let c_count = word.chars().filter(|&c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count() as isize;\n\
    \        if c_count == n {\n            s_vec.push(word.to_string());\n      \
    \  }\n    }\n    s_vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmphhcvl3kv.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split('\
    \ ')\n        .filter(|&w| {\n            w.chars()\n                .filter(|&c|\
    \ c.is_ascii_alphabetic())\n                .filter(|&c| !c.is_ascii_vowel())\n\
    \                .count() as isize == n\n        })\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpfqq573s2.rs:22:33\n   |\n22 |             \
    \    .filter(|&c| !c.is_ascii_vowel())\n   |                                 ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let s_clone = s.clone();\n    let v = s_clone.split_whitespace().collect::<Vec<&str>>();\n\
    \    for word in v {\n        let clone = word.clone();\n        let count = count_consonants(clone);\n\
    \        if count == n {\n            result.push(word.to_string());\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp_434tn2z.rs:23:21\n   |\n23 |         let count = count_consonants(clone);\n\
    \   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split(\" \").collect();\n\
    \    for w in words {\n        if number_of_consonants(w) == n {\n           \
    \ v.push(w.to_string());\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `number_of_consonants` in this scope\n\
    \  --> /tmp/tmph_af0s3r.rs:21:12\n   |\n21 |         if number_of_consonants(w)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    let mut m = 0;\n    let mut t = String::new();\n    for\
    \ c in s.chars() {\n        if c.is_alphabetic() {\n            t.push(c);\n \
    \           m += 1;\n        } else {\n            if m == n {\n             \
    \   v.push(t);\n            }\n            t = String::new();\n            m =\
    \ 0;\n        }\n    }\n    if m == n {\n        v.push(t);\n    }\n    v\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp4a0s8ohw.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut ret = Vec::new();\n    let mut\
    \ state = 0;\n    let mut chars = s.chars();\n    let mut word = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_whitespace() {\n    \
    \        if state == n {\n                ret.push(word);\n            }\n   \
    \         state = 0;\n            word = String::new();\n        } else {\n  \
    \          if !vowels.contains(&c) {\n                state += 1;\n          \
    \  }\n            word.push(c);\n        }\n    }\n    if state == n {\n     \
    \   ret.push(word);\n    }\n    ret\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp4wml91rz.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    for w in s.split_whitespace() {\n        if has_n_consonants(w,\
    \ n) {\n            result.push(w.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `has_n_consonants` in this scope\n \
    \ --> /tmp/tmpiu19m2_f.rs:20:12\n   |\n20 |         if has_n_consonants(w, n)\
    \ {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res: Vec<String> = Vec::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let sp = \" \";\n    let mut words = s.split(sp);\n    for word in words\
    \ {\n        let mut consonants = 0;\n        for i in word.chars() {\n      \
    \      if !vowels.contains(&i) {\n                consonants += 1;\n         \
    \   }\n        }\n        if consonants == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpt22yvmc1.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| num_consonants(w) == n)\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_consonants` in this scope\n  -->\
    \ /tmp/tmpts06w2ro.rs:19:21\n   |\n19 |         .filter(|w| num_consonants(w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| count_consonants(w) == n)\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpvb37broz.rs:19:21\n   |\n19 |         .filter(|w| count_consonants(w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let v : Vec<&str> = s.split(\" \").collect();\n    for\
    \ i in v {\n        let consonants = get_consonants(i);\n        if consonants\
    \ == n {\n            words.push(i.to_string());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_consonants` in this scope\n  -->\
    \ /tmp/tmpa3qbxymv.rs:21:26\n   |\n21 |         let consonants = get_consonants(i);\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|x| consonants_count(x) == n)\n        .map(|x| x.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `consonants_count` in this scope\n \
    \ --> /tmp/tmp1rcfgzth.rs:19:21\n   |\n19 |         .filter(|x| consonants_count(x)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = Vec::new();\n    for word in s.split_whitespace() {\n        let consonants:\
    \ isize = word.chars().map(|c| {\n            match c {\n                'A' |\
    \ 'E' | 'I' | 'O' | 'U' | 'a' | 'e' | 'i' | 'o' | 'u' => 0,\n                _\
    \ => 1\n            }\n        }).sum();\n        if consonants == n {\n     \
    \       vec.push(word.to_string());\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut current_word = String::new();\n    for ch in s.chars()\
    \ {\n        if ch == ' ' {\n            if current_word.chars().filter(|c| is_consonant(*c)).count()\
    \ as isize == n {\n                words.push(current_word);\n            }\n\
    \            current_word = String::new();\n        } else {\n            current_word.push(ch);\n\
    \        }\n    }\n    if current_word.chars().filter(|c| is_consonant(*c)).count()\
    \ as isize == n {\n        words.push(current_word);\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp5nbj9jc1.rs:22:48\n   |\n22 |             if current_word.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n {\n   |                            \
    \                    ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_consonant` in this scope\n  --> /tmp/tmp5nbj9jc1.rs:30:40\n\
    \   |\n30 |     if current_word.chars().filter(|c| is_consonant(*c)).count() as\
    \ isize == n {\n   |                                        ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let text:\
    \ Vec<&str> = s.split_whitespace().collect();\n    let vec: Vec<String> = text.iter().map(|&x|\
    \ x.to_string()).collect();\n    let mut res: Vec<String> = vec![];\n    for i\
    \ in 0..vec.len() {\n        let n_consonants = vec[i].to_lowercase().chars().filter(|&c|\
    \ {\n            c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c\
    \ != 'y'\n        }).count() as isize;\n        if n_consonants == n {\n     \
    \       res.push(vec[i].to_string());\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpkg6r532y.rs:35:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ret: Vec<String> = Vec::new();\n    let mut vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let words: Vec<&str> = s.split(\" \").collect();\n    for word in\
    \ words {\n        let mut consonants = 0;\n        for c in word.chars() {\n\
    \            if !vowels.contains(&c) {\n                consonants += 1;\n   \
    \         }\n        }\n        if consonants == n {\n            ret.push(word.to_string());\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp1u5b4qnp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec: Vec<String> = Vec::new();\n    let mut pre_is_space = true;\n    let mut\
    \ word = String::new();\n    let mut len = 0;\n    for c in s.chars() {\n    \
    \    if c.is_whitespace() {\n            if !pre_is_space {\n                pre_is_space\
    \ = true;\n                if len == n {\n                    vec.push(word);\n\
    \                }\n                word = String::new();\n                len\
    \ = 0;\n            }\n        } else {\n            pre_is_space = false;\n \
    \           if !c.is_lowercase() || !\"bcdfghjklmnpqrstvwxyz\".contains(c) {\n\
    \                len += 1;\n            }\n            word.push(c);\n       \
    \ }\n    }\n    if len == n {\n        vec.push(word);\n    }\n    vec\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpbre5t1qh.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ nn: Vec<String> = Vec::new();\n    let mut hm: HashMap<String, isize> = HashMap::new();\n\
    \    let m = \"aeiou\";\n    let s = s.split_whitespace();\n    for x in s {\n\
    \        let a = x.chars().filter(|&x| !m.contains(x)).count();\n        if a\
    \ == n as usize {\n            nn.push(x.to_string());\n        }\n    }\n   \
    \ nn\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp11g2e5r4.rs:19:17\n\
    \   |\n19 |     let mut hm: HashMap<String, isize> = HashMap::new();\n   |   \
    \              ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp11g2e5r4.rs:19:42\n\
    \   |\n19 |     let mut hm: HashMap<String, isize> = HashMap::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    for word in s.split_whitespace() {\n\
    \        if word.chars().filter(|c| !is_vowel(*c)).count() as isize == n {\n \
    \           result.push(word.to_string());\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpd2g81o1s.rs:20:37\n\
    \   |\n20 |         if word.chars().filter(|c| !is_vowel(*c)).count() as isize\
    \ == n {\n   |                                     ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    s.split_whitespace()\n        .filter(|w|\
    \ w.chars().filter(|c| c.is_alphabetic()).filter(|c| !c.is_vowel()).count() as\
    \ isize == n)\n        .map(|w| w.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpvmuuuzts.rs:22:75\n   |\n22 |         .filter(|w|\
    \ w.chars().filter(|c| c.is_alphabetic()).filter(|c| !c.is_vowel()).count() as\
    \ isize == n)\n   |                                                          \
    \                 ^^^^^^^^ method not found in `&char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    for w in s.split_whitespace() {\n        if count_consonants(w)\
    \ == n {\n            result.push(w.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpei6fyk96.rs:20:12\n   |\n20 |         if count_consonants(w) ==\
    \ n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut selected_words = Vec::new();\n\
    \    for word in s.split_whitespace() {\n        let mut consonants = 0;\n   \
    \     for c in word.chars() {\n            if !vowels.contains(&c) {\n       \
    \         consonants += 1;\n            }\n        }\n        if consonants ==\
    \ n {\n            selected_words.push(word.to_string());\n        }\n    }\n\
    \    selected_words\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp6lf6397m.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut words = Vec::new();\n    let mut word\
    \ = String::new();\n    let mut consonants = 0;\n    for ch in s.chars() {\n \
    \       if vowels.contains(&ch) {\n            consonants = 0;\n        } else\
    \ if ch != ' ' {\n            consonants += 1;\n        }\n        if ch == '\
    \ ' {\n            if consonants == n {\n                words.push(word);\n \
    \           }\n            word = String::new();\n            consonants = 0;\n\
    \        } else {\n            word.push(ch);\n        }\n    }\n    if consonants\
    \ == n {\n        words.push(word);\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpewbawd73.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let v: Vec<&str> = s.split_whitespace().collect();\n\
    \    for x in v {\n        if find_n_consonants(x, n) {\n            result.push(x.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_n_consonants` in this scope\n\
    \  --> /tmp/tmpvl09lo07.rs:21:12\n   |\n21 |         if find_n_consonants(x, n)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    for word in s.split_whitespace() {\n        if count_consonants(word)\
    \ == n {\n            words.push(word.to_string());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpx7wy4dqf.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split(\" \").collect();\n\
    \    for word in words {\n        if consonants(word) == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `consonants` in this scope\n  --> /tmp/tmpymadwe4i.rs:21:12\n\
    \   |\n21 |         if consonants(word) == n {\n   |            ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut res = vec![];\n    let mut words\
    \ = s.split_whitespace();\n    while let Some(word) = words.next() {\n       \
    \ let vowels = \"aeiou\";\n        let word_count = word.to_lowercase().chars().filter(|c|\
    \ !vowels.contains(*c)).count();\n        if word_count as isize == n {\n    \
    \        res.push(word.to_string());\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    for word in s.split_whitespace() {\n        if count_consonants(word)\
    \ == n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp1xn_quuf.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    for word in s.split_whitespace() {\n        if word.chars().filter(|&c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y').count()\
    \ as isize == n {\n            v.push(word.to_string());\n        }\n    }\n \
    \   v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp_izhr3se.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let all_words:\
    \ Vec<&str> = s.split_whitespace().collect();\n    let vowels = \"aeiou\";\n \
    \   let mut result: Vec<String> = Vec::new();\n    for word in all_words {\n \
    \       let mut count = 0;\n        for c in word.chars() {\n            if !vowels.contains(c)\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpircyxerf.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Split\
    \ the string into words\n    let mut words = s.split_whitespace();\n    // Create\
    \ an empty vector of string to store results\n    let mut results = Vec::new();\n\
    \    // Loop over words\n    for word in words {\n        // Count consonants\n\
    \        let consonants = count_consonants(word);\n        // If the number of\
    \ consonants equals to n,\n        // add the word to results vector\n       \
    \ if consonants == n {\n            results.push(word.to_string());\n        }\n\
    \    }\n    // Return the vector with results\n    results\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpawxcttfq.rs:25:26\n   |\n25 |         let consonants = count_consonants(word);\n\
    \   |                          ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // Split\
    \ the string on whitespace.\n    let words = s.split_whitespace();\n    // Return\
    \ a vector of only those words that contain the specified number of consonants.\n\
    \    words.filter(|w| count_consonants(w) == n).map(|w| w.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpdg1r_b7e.rs:21:22\n   |\n21 |     words.filter(|w| count_consonants(w)\
    \ == n).map(|w| w.to_string()).collect()\n   |                      ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ans = Vec::new();\n    for word in s.split_whitespace() {\n        let count\
    \ = word.chars().filter(|c| {\n            let c = *c;\n            c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u'\n        }).count();\n        if\
    \ count as isize == n {\n            ans.push(word.to_string());\n        }\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp0a4ux7xc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    for word in s.split_whitespace() {\n \
    \       if count_consonants(word) == n {\n            words.push(word.to_string());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpjrar10dv.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vec = vec![];\n    for word in\
    \ s.split(\" \") {\n        let mut count = 0;\n        for c in word.chars()\
    \ {\n            if !vowels.contains(&c) {\n                count += 1;\n    \
    \        }\n        }\n        if count == n {\n            vec.push(word.to_string());\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpvo5t1f0u.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    let mut current = String::new();\n\
    \    while i < s.len() {\n        let ch = s.chars().nth(i).unwrap();\n      \
    \  if ch.is_whitespace() {\n            if current.len() > 0 {\n             \
    \   if count_consonants(&current) == n {\n                    result.push(current);\n\
    \                }\n                current = String::new();\n            }\n\
    \        } else {\n            current.push(ch);\n        }\n        i += 1;\n\
    \    }\n    if current.len() > 0 {\n        if count_consonants(&current) == n\
    \ {\n            result.push(current);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp8gojzj2c.rs:25:20\n   |\n25 |                 if count_consonants(&current)\
    \ == n {\n   |                    ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `count_consonants` in this scope\n  --> /tmp/tmp8gojzj2c.rs:36:12\n\
    \   |\n36 |         if count_consonants(&current) == n {\n   |            ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let s =\
    \ s.split_whitespace().collect::<Vec<&str>>();\n    let mut results = Vec::new();\n\
    \    for ss in s {\n        let nn = ss.chars().filter(|x| !is_vowel(x.to_lowercase().next().unwrap())).count()\
    \ as isize;\n        if nn == n {\n            results.push(ss.to_string());\n\
    \        }\n    }\n    results\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgo9gx9co.rs:21:41\n\
    \   |\n21 |         let nn = ss.chars().filter(|x| !is_vowel(x.to_lowercase().next().unwrap())).count()\
    \ as isize;\n   |                                         ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n\
    \    let mut n_consonants: isize = 0;\n    for c in s.chars() {\n        if c\
    \ == ' ' {\n            if n_consonants == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n            n_consonants =\
    \ 0;\n        } else {\n            if !is_vowel(c) {\n                n_consonants\
    \ += 1;\n            }\n            word.push(c);\n        }\n    }\n    if n_consonants\
    \ == n {\n        words.push(word);\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpcy4e329k.rs:29:17\n\
    \   |\n29 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // let mut\
    \ v = Vec::new();\n    let mut v = Vec::with_capacity(s.len());\n    let words\
    \ = s.split_whitespace();\n    for word in words {\n        let n1 = word.chars().filter(|c|\
    \ is_consonant(*c)).count();\n        if n1 as isize == n {\n            v.push(word.to_string());\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpbdzr2_91.rs:22:42\n   |\n22 |         let n1 = word.chars().filter(|c|\
    \ is_consonant(*c)).count();\n   |                                          ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let words\
    \ = s.split(\" \");\n    let mut result: Vec<String> = Vec::new();\n    for word\
    \ in words {\n        let mut count = 0;\n        for l in word.chars() {\n  \
    \          if !(l == 'a' || l == 'e' || l == 'i' || l == 'o' || l == 'u') {\n\
    \                count += 1;\n            }\n        }\n        if count == n\
    \ {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp2qc3sbl0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    for word in s.split_whitespace() {\n        if is_consonant(word)\
    \ == n {\n            words.push(word.to_string());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp_2f_xmpd.rs:20:12\n   |\n20 |         if is_consonant(word) == n {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res: Vec<String> = Vec::new();\n    let lowercase_vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let words: Vec<&str> = s.split(\" \").collect();\n    for word\
    \ in words {\n        let mut cons_cnt = 0;\n        for char in word.chars()\
    \ {\n            if !lowercase_vowels.contains(&char) {\n                cons_cnt\
    \ += 1;\n            }\n        }\n        if cons_cnt == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp70k5mpig.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| num_consonants(w) == n)\n        .map(|s| s.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_consonants` in this scope\n  -->\
    \ /tmp/tmpm3wnda34.rs:19:21\n   |\n19 |         .filter(|w| num_consonants(w)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ans: Vec<String> = Vec::new();\n    let mut temp: String = String::new();\n\
    \    let mut consonants: isize = 0;\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            temp.push(c);\n            if c.is_vowel() {\n              \
    \  continue;\n            }\n            consonants += 1;\n        } else {\n\
    \            if consonants == n {\n                ans.push(temp);\n         \
    \   }\n            temp = String::new();\n            consonants = 0;\n      \
    \  }\n    }\n    if consonants == n {\n        ans.push(temp);\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpfceg67tr.rs:24:18\n   |\n24 |             if c.is_vowel()\
    \ {\n   |                  ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    for w in s.split(' ') {\n        if w.matches(|c: char|\
    \ !c.is_vowel()).count() as isize == n {\n            v.push(w.to_string());\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpe7vfmkkn.rs:20:35\n   |\n20 |         if w.matches(|c:\
    \ char| !c.is_vowel()).count() as isize == n {\n   |                         \
    \          ^^^^^^^^ method not found in `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ { return vec![]; }\n    let mut words: Vec<String> = Vec::new();\n    let mut\
    \ word: String = String::new();\n    let mut word_consonants: isize = 0;\n   \
    \ for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !is_vowel(c) {\n                word_consonants += 1;\n      \
    \      }\n        } else {\n            if word_consonants == n {\n          \
    \      words.push(word.clone());\n            }\n            word = String::new();\n\
    \            word_consonants = 0;\n        }\n    }\n    if word_consonants ==\
    \ n {\n        words.push(word);\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpu_qmmi6q.rs:25:17\n\
    \   |\n25 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for word in s.split_whitespace() {\n        let consonants\
    \ = word.chars().filter(|&c| is_consonant(c)).count();\n        if consonants\
    \ == n as usize {\n            words.push(word.to_string());\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpoj5b4yd6.rs:20:51\n   |\n20 |         let consonants = word.chars().filter(|&c|\
    \ is_consonant(c)).count();\n   |                                            \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::new();\n    let mut\
    \ current_number = 0;\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            current_word.push(c);\n            current_number += if c.is_lowercase()\
    \ {\n                match c {\n                    'a' | 'e' | 'i' | 'o' | 'u'\
    \ => 0,\n                    _ => 1,\n                }\n            } else {\n\
    \                match c {\n                    'A' | 'E' | 'I' | 'O' | 'U' =>\
    \ 0,\n                    _ => 1,\n                }\n            };\n       \
    \ } else {\n            if current_number == n {\n                result.push(current_word);\n\
    \            }\n            current_word = String::new();\n            current_number\
    \ = 0;\n        }\n    }\n    if current_number == n {\n        result.push(current_word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut str_words = String::new();\n    let mut words_split:\
    \ Vec<&str> = s.split_whitespace().collect();\n    let mut word_count = 0;\n \
    \   let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for mut element in words_split.iter_mut()\
    \ {\n        for mut letter in element.chars() {\n            for vowel in vowels.iter()\
    \ {\n                if *vowel == letter {\n                    word_count +=\
    \ 1;\n                }\n            }\n        }\n        if word_count == n\
    \ {\n            words.push(element.to_string());\n        }\n        word_count\
    \ = 0;\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpu2qb7a5e.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    return s.split(\"\
    \ \").filter(|&word| {\n        word.chars().filter(|&c| \"aeiou\".contains(c)).count()\
    \ as isize == n\n    }).map(|word| word.to_string()).collect();\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpguz1kln2.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ output: Vec<String> = Vec::new();\n    let v: Vec<&str> = s.split(\" \").collect();\n\
    \    for x in v {\n        if num_consonants(x) == n {\n            output.push(x.to_string());\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_consonants` in this scope\n  -->\
    \ /tmp/tmpy6tzqdba.rs:21:12\n   |\n21 |         if num_consonants(x) == n {\n\
    \   |            ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split('\
    \ ')\n        .filter(|x| vowels_consonants(x) == n)\n        .map(|x| x.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_consonants` in this scope\n\
    \  --> /tmp/tmpvmztmh6v.rs:19:21\n   |\n19 |         .filter(|x| vowels_consonants(x)\
    \ == n)\n   |                     ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let words = s.split(\" \").collect::<Vec<&str>>();\n\
    \    let mut result = Vec::new();\n    for word in words {\n        let mut count\
    \ = 0;\n        for c in word.chars() {\n            if !vowels.contains(&c) {\n\
    \                count += 1;\n            }\n        }\n        if count == n\
    \ {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp3icxntzj.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ s = s;\n    let mut result = Vec::new();\n    let mut words = Vec::new();\n\
    \    loop {\n        if let Some(index) = s.find(' ') {\n            words.push(s.drain(..index).collect());\n\
    \            s.drain(..1);\n        } else {\n            words.push(s);\n   \
    \         break;\n        }\n    }\n    let mut cons = ['B', 'C', 'D', 'F', 'G',\
    \ 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Z'];\n\
    \    let mut vowels = ['A', 'E', 'I', 'O', 'U', 'Y'];\n    for word in words {\n\
    \        let mut consonants = 0;\n        for ch in word.chars() {\n         \
    \   if cons.contains(&ch) {\n                consonants += 1;\n            }\n\
    \        }\n        if consonants == n {\n            result.push(word);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpq66r_p72.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \     .filter(|w| count_consonants(w) == n)\n     .map(|s| s.to_string())\n  \
    \   .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpoestnrmd.rs:19:18\n   |\n19 |      .filter(|w| count_consonants(w)\
    \ == n)\n   |                  ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n\
    \            if !c.is_vowel() {\n                count += 1;\n            }\n\
    \        } else {\n            if count == n {\n                res.push(word);\n\
    \            }\n            word = String::new();\n            count = 0;\n  \
    \      }\n    }\n    if count == n {\n        res.push(word);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_yzxt6_k.rs:24:19\n   |\n24 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut count = 0;\n    let mut current_word = String::new();\n\
    \    for (i, c) in s.chars().enumerate() {\n        if c.is_alphabetic() {\n \
    \           current_word.push(c);\n            if is_consonant(c) {\n        \
    \        count += 1;\n            }\n        } else {\n            if count ==\
    \ n {\n                result.push(current_word);\n            }\n           \
    \ current_word = String::new();\n            count = 0;\n        }\n        if\
    \ i == s.len() - 1 && count == n {\n            result.push(current_word);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp8l6268e5.rs:24:16\n   |\n24 |             if is_consonant(c) {\n   |\
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = vec![];\n    for word in s.split_whitespace() {\n     \
    \   if word.len() as isize == n {\n            words.push(word.to_string());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp2v_rymrh.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let words\
    \ = s.split_whitespace();\n    let mut v: Vec<String> = Vec::new();\n    for w\
    \ in words {\n        if count_consonants(w) == n {\n            v.push(w.to_string());\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp4944gowi.rs:21:12\n   |\n21 |         if count_consonants(w) ==\
    \ n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 0
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let strs: Vec<&str> = s.split(\" \").collect();\n\
    \    for x in strs {\n        let mut cons = 0;\n        for y in x.chars() {\n\
    \            match y {\n                'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E'\
    \ | 'I' | 'O' | 'U' => (),\n                _ => cons += 1,\n            }\n \
    \       }\n        if cons == n {\n            result.push(x.to_string());\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut word = String::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            let count = word.chars().filter(|c| !CONSONANTS.contains(c)).count()\
    \ as isize;\n            if count == n {\n                words.push(word);\n\
    \            }\n            word = String::new();\n        } else {\n        \
    \    word.push(c);\n        }\n    }\n    let count = word.chars().filter(|c|\
    \ !CONSONANTS.contains(c)).count() as isize;\n    if count == n {\n        words.push(word);\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `CONSONANTS` in this scope\n  --> /tmp/tmpqrs62zy1.rs:22:50\n\
    \   |\n22 |             let count = word.chars().filter(|c| !CONSONANTS.contains(c)).count()\
    \ as isize;\n   |                                                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `CONSONANTS` in this\
    \ scope\n  --> /tmp/tmpqrs62zy1.rs:31:42\n   |\n31 |     let count = word.chars().filter(|c|\
    \ !CONSONANTS.contains(c)).count() as isize;\n   |                           \
    \               ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| count_consonants(word) == n)\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpde02rj1e.rs:19:24\n   |\n19 |         .filter(|word| count_consonants(word)\
    \ == n)\n   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let mut words: Vec<&str> = s.split_whitespace().collect();\n\
    \    let mut cc: Vec<isize> = Vec::new();\n    for c in words.iter() {\n     \
    \   let mut counter = 0;\n        for a in c.chars() {\n            if a == 'a'\
    \ || a == 'e' || a == 'i' || a == 'o' || a == 'u' || a == 'y' {\n            \
    \    counter += 1;\n            }\n        }\n        cc.push(counter);\n    }\n\
    \    for i in 0..words.len() {\n        if (words[i].len() as isize - cc[i]) ==\
    \ n {\n            v.push(words[i].to_string());\n        }\n    }\n    v\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpannueyuj.rs:41:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vect: Vec<String> = Vec::new();\n    for word in s.split_whitespace() {\n  \
    \      if contains_consonants(word, n) {\n            vect.push(word.to_string());\n\
    \        }\n    }\n    vect\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `contains_consonants` in this scope\n\
    \  --> /tmp/tmpxaan7rz0.rs:20:12\n   |\n20 |         if contains_consonants(word,\
    \ n) {\n   |            ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vec:\
    \ Vec<&str> = s.split(\" \").collect();\n    let mut v: Vec<String> = Vec::new();\n\
    \    for word in vec {\n        let mut temp = word.to_string();\n        for\
    \ i in 0..word.len() {\n            let ch = temp.pop().unwrap();\n          \
    \  if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n      \
    \          continue;\n            }\n            else {\n                if temp.len()\
    \ == n as usize {\n                    v.push(word.to_string());\n           \
    \     }\n            }\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"little\", \"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpvutriqsr.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| word.chars().filter(|ch| ch.is_ascii_alphabetic()).count()\
    \ as isize == n)\n        .map(|word| word.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp074hc0_i.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for word in s.split_whitespace() {\n        let mut count\
    \ = 0;\n        for c in word.chars() {\n            match c {\n             \
    \   'a' | 'e' | 'i' | 'o' | 'u' | 'y' => (),\n                _ => count += 1,\n\
    \            }\n        }\n        if count == n {\n            words.push(word.to_string());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpoqvwi9dj.rs:37:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words: Vec<String> = Vec::new();\n    let vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    let lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n    for word\
    \ in s.split_whitespace() {\n        let word_consonants = word.chars().filter(|&c|\
    \ !vowels.contains(&c.to_string().as_str())).count();\n        if word_consonants\
    \ as isize == n {\n            words.push(word.to_string());\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpj53kab1j.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let v: Vec<&str>\
    \ = s.split(\" \").collect();\n    let mut res: Vec<String> = Vec::new();\n  \
    \  for i in v {\n        if count_consonants(i) == n {\n            res.push(i.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpkioiiq4c.rs:21:12\n   |\n21 |         if count_consonants(i) ==\
    \ n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    let mut word = String::new();\n    let mut cons_count\
    \ = 0;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n           \
    \ word.push(c);\n            if !is_vowel(c) {\n                cons_count +=\
    \ 1;\n            }\n        } else {\n            if cons_count == n {\n    \
    \            res.push(word);\n            }\n            word = String::new();\n\
    \            cons_count = 0;\n        }\n    }\n    if cons_count == n {\n   \
    \     res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpo56qxupt.rs:24:17\n\
    \   |\n24 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let chars\
    \ = s.split_whitespace();\n    let mut result = Vec::new();\n    for c in chars\
    \ {\n        if count_consonants(c) == n {\n            result.push(c.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpa4yex4nv.rs:21:12\n   |\n21 |         if count_consonants(c) ==\
    \ n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vowel_count: isize = 0;\n    let mut word_count: isize = 0;\n    let mut selected_words:\
    \ Vec<String> = Vec::new();\n    let mut current_word: String = String::new();\n\
    \    let mut is_word: bool = false;\n    for c in s.chars() {\n        if c ==\
    \ ' ' {\n            if is_word {\n                if word_count == n {\n    \
    \                selected_words.push(current_word);\n                }\n     \
    \           current_word = String::new();\n                is_word = false;\n\
    \                word_count = 0;\n            }\n        } else {\n          \
    \  is_word = true;\n            current_word.push(c);\n            if is_vowel(c)\
    \ {\n                vowel_count += 1;\n            } else {\n               \
    \ word_count += 1;\n            }\n        }\n    }\n    if is_word {\n      \
    \  if word_count == n {\n            selected_words.push(current_word);\n    \
    \    }\n    }\n    selected_words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpfzwqzqet.rs:36:16\n\
    \   |\n36 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let v: Vec<String>\
    \ = vec![];\n    return v;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpbrqju2ha.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let v =\
    \ s.split_whitespace().map(|x| x.to_string()).collect::<Vec<String>>();\n    return\
    \ v.into_iter().filter(|x| count_consonants(x.to_string()) == n).collect::<Vec<String>>();\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpb1_l4vuk.rs:19:37\n   |\n19 |     return v.into_iter().filter(|x|\
    \ count_consonants(x.to_string()) == n).collect::<Vec<String>>();\n   |      \
    \                               ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let mut count: isize = 0;\n    let mut word:\
    \ String = String::new();\n    for (i, c) in s.chars().enumerate() {\n       \
    \ if c == ' ' {\n            if count == n {\n                v.push(word);\n\
    \            }\n            count = 0;\n            word = String::new();\n  \
    \      } else {\n            word.push(c);\n            if vowels.contains(&c)\
    \ {\n                count += 1;\n            }\n        }\n    }\n    if count\
    \ == n {\n        v.push(word);\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpol4q3mn4.rs:30:16\n\
    \   |\n30 |             if vowels.contains(&c) {\n   |                ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let s =\
    \ s.replace(\" \", \"\");\n    let l = s.len();\n    let mut count = 0;\n    let\
    \ mut result = Vec::new();\n    let mut start = 0;\n    let vowels = \"aeiouAEIOU\"\
    ;\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(c) {\n\
    \            if count == n {\n                result.push(s[start..i].to_string());\n\
    \            }\n            count = 0;\n            start = i + 1;\n        }\
    \ else {\n            count += 1;\n        }\n    }\n    if count == n {\n   \
    \     result.push(s[start..l].to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpqx6ddg9u.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    fn vowel(c:\
    \ char) -> bool {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u'\
    \ | 'y' => true,\n            _ => false,\n        }\n    }\n    s.split(' ')\n\
    \        .filter(|w| w.chars().filter(|c| !vowel(*c)).count() as isize == n)\n\
    \        .map(|w| w.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpbl0eo_1g.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut previous_char_is_a_letter = false;\n    let\
    \ mut current_word = String::new();\n    for c in s.chars() {\n        if c ==\
    \ ' ' || c == '\\n' {\n            if previous_char_is_a_letter {\n          \
    \      let num_consonants = current_word.chars().filter(|&c| !is_vowel(c)).count()\
    \ as isize;\n                if num_consonants == n {\n                    result.push(current_word);\n\
    \                }\n                current_word = String::new();\n          \
    \  }\n            previous_char_is_a_letter = false;\n        } else {\n     \
    \       current_word.push(c);\n            previous_char_is_a_letter = true;\n\
    \        }\n    }\n    if !current_word.is_empty() {\n        let num_consonants\
    \ = current_word.chars().filter(|&c| !is_vowel(c)).count() as isize;\n       \
    \ if num_consonants == n {\n            result.push(current_word);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpfm9ddm7u.rs:24:72\n\
    \   |\n24 |                 let num_consonants = current_word.chars().filter(|&c|\
    \ !is_vowel(c)).count() as isize;\n   |                                      \
    \                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpfm9ddm7u.rs:37:64\n\
    \   |\n37 |         let num_consonants = current_word.chars().filter(|&c| !is_vowel(c)).count()\
    \ as isize;\n   |                                                            \
    \    ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let words: Vec<&str> = s.split_whitespace().collect();\n\
    \    for word in words {\n        let word_copy = word.to_string();\n        let\
    \ count = count_consonants(word_copy);\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp5jmns88h.rs:22:21\n   |\n22 |         let count = count_consonants(word_copy);\n\
    \   |                     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut result = Vec::new();\n    for word\
    \ in s.split_whitespace() {\n        let mut count = 0;\n        for c in word.chars()\
    \ {\n            if !vowels.contains(&c) {\n                count += 1;\n    \
    \        }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpbtlv53xs.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    for word in s.split_whitespace() {\n        if consonants(word)\
    \ == n {\n            list.push(word.to_string());\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `consonants` in this scope\n  --> /tmp/tmpt1y8znuz.rs:20:12\n\
    \   |\n20 |         if consonants(word) == n {\n   |            ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut vector: Vec<String> = Vec::new();\n\
    \    let mut i = 0;\n    for string in s.split(\" \") {\n        let length =\
    \ string.chars().filter(|c| {\n            match c {\n                'a' | 'e'\
    \ | 'i' | 'o' | 'u' | 'y' => false,\n                _ => true,\n            }\n\
    \        }).count();\n        if length == n as usize {\n            vector.push(string.to_string());\n\
    \        }\n    }\n    vector\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpfv4krpf_.rs:40:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // unimplemented!()\n\
    \    let mut v: Vec<String> = Vec::new();\n    let mut t_str: String = String::new();\n\
    \    let s: String = s.to_lowercase();\n    let mut is_first: bool = true;\n \
    \   let vec_str: Vec<char> = s.chars().collect();\n    for i in 0..vec_str.len()\
    \ {\n        if vec_str[i] == ' ' {\n            if is_first == false {\n    \
    \            if String::from(\"aeiou\").contains(vec_str[i - 1]) == false {\n\
    \                    t_str.push(vec_str[i - 1]);\n                }\n        \
    \    }\n            if t_str.len() == n as usize {\n                v.push(t_str.clone());\n\
    \            }\n            t_str.clear();\n            is_first = true;\n   \
    \     } else {\n            if is_first == true {\n                if String::from(\"\
    aeiou\").contains(vec_str[i]) == false {\n                    t_str.push(vec_str[i]);\n\
    \                }\n                is_first = false;\n            } else {\n\
    \                if String::from(\"aeiou\").contains(vec_str[i]) == false {\n\
    \                    t_str.push(vec_str[i]);\n                }\n            }\n\
    \        }\n    }\n    if t_str.len() == n as usize {\n        v.push(t_str.clone());\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"mryy\", \"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmpo9rgp2ck.rs:57:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let v: Vec<&str> = s.split(\" \").collect();\n\
    \    v.iter().filter(|x| count_consonants(&x.to_string()) == n).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpuczkavgi.rs:22:25\n   |\n22 |     v.iter().filter(|x| count_consonants(&x.to_string())\
    \ == n).map(|x| x.to_string()).collect()\n   |                         ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    for word in s.split_whitespace() {\n        if count_consonants(word)\
    \ == n {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmp1xn_quuf.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec: Vec<String> = Vec::new();\n    let mut words: Vec<&str> = s.split_whitespace().collect();\n\
    \    for w in words.iter() {\n        let mut count: isize = 0;\n        for c\
    \ in w.chars() {\n            if !c.is_vowel() {\n                count += 1;\n\
    \            }\n        }\n        if count == n {\n            vec.push(w.to_string());\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpa5u05l2d.rs:23:19\n   |\n23 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    for word in s.split_whitespace() {\n        let mut i =\
    \ 0;\n        for ch in word.chars() {\n            if !is_vowel(ch) {\n     \
    \           i += 1;\n            }\n        }\n        if i == n {\n         \
    \   v.push(word.to_string());\n        }\n    }\n    v\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpkfobpqf5.rs:22:17\n\
    \   |\n22 |             if !is_vowel(ch) {\n   |                 ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split('\
    \ ')\n        .map(|x| x.to_string())\n        .filter(|x| x.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpzrmztqvc.rs:20:42\n   |\n20 |         .filter(|x| x.chars().filter(|c|\
    \ is_consonant(*c)).count() as isize == n)\n   |                             \
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut word = String::new();\n    let is_conso =\
    \ |x: char| {\n        x != 'a' && x != 'e' && x != 'i' && x != 'o' && x != 'u'\
    \ && x != 'y'\n    };\n    for c in s.chars() {\n        if c == ' ' {\n     \
    \       if word.chars().filter(|x| is_conso(*x)).count() as isize == n {\n   \
    \             result.push(word.clone());\n            }\n            word.clear();\n\
    \        } else {\n            word.push(c);\n        }\n    }\n    if word.chars().filter(|x|\
    \ is_conso(*x)).count() as isize == n {\n        result.push(word);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpl4kjlmgy.rs:42:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    for word in s.split_whitespace() {\n        let mut found\
    \ = 0;\n        for ch in word.chars() {\n            if ch != 'a' && ch != 'e'\
    \ && ch != 'i' && ch != 'o' && ch != 'u' {\n                found += 1;\n    \
    \        }\n        }\n        if found == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmplgjgm232.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO:\
    \ Implement the function\n\n    vec![]\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpoqgpi8do.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ res = Vec::new();\n    for word in s.split_whitespace() {\n        let vowels\
    \ = \"aoeiu\";\n        let mut consonants = 0;\n        for c in word.chars()\
    \ {\n            if !vowels.contains(c) {\n                consonants += 1;\n\
    \            }\n        }\n        if consonants == n {\n            res.push(word.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmppgmi31by.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ consonants = 0;\n    let mut arr: Vec<String> = Vec::new();\n    let mut word:\
    \ String = String::new();\n    for letter in s.chars() {\n        if letter.is_alphabetic()\
    \ {\n            if !is_vowel(letter) {\n                consonants += 1;\n  \
    \          }\n            word.push(letter);\n        } else {\n            if\
    \ consonants == n {\n                arr.push(word);\n            }\n        \
    \    consonants = 0;\n            word = String::new();\n        }\n    }\n  \
    \  if consonants == n {\n        arr.push(word);\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7ppk9iuw.rs:23:17\n\
    \   |\n23 |             if !is_vowel(letter) {\n   |                 ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let split_words: Vec<&str> = s.split_whitespace().collect();\n\
    \    for word in split_words {\n        let mut count = 0;\n        for char in\
    \ word.chars() {\n            if !char.is_ascii_vowel() {\n                count\
    \ += 1;\n            }\n        }\n        if count == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpjar4msbg.rs:23:22\n   |\n23 |             if\
    \ !char.is_ascii_vowel() {\n   |                      ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|w| w.chars().filter(|c| c.is_lowercase()).count() as isize ==\
    \ n)\n        .map(|w| w.to_string())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp9q1gvubx.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ word_vec: Vec<String> = Vec::new();\n    for word in s.split_whitespace() {\n\
    \        if count_consonants(word) == n {\n            word_vec.push(word.to_string());\n\
    \        }\n    }\n    word_vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpg5rv4pp9.rs:20:12\n   |\n20 |         if count_consonants(word)\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result: Vec<String> = Vec::new();\n    let s: String = s.to_lowercase();\n \
    \   let mut words: Vec<&str> = s.split_whitespace().collect();\n    for word in\
    \ words.iter() {\n        let mut consonants: usize = 0;\n        for ch in word.chars()\
    \ {\n            if ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch !=\
    \ 'u' {\n                consonants += 1;\n            }\n        }\n        if\
    \ consonants == n as usize {\n            result.push(word.to_string());\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"mary\", \"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpgewoscck.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut result = Vec::new();\n    for (i,\
    \ word) in s.split_whitespace().enumerate() {\n        let mut number_of_consonants\
    \ = 0;\n        for ch in word.chars() {\n            if !vowels.contains(&ch)\
    \ {\n                number_of_consonants += 1;\n            }\n        }\n  \
    \      if number_of_consonants == n {\n            result.push(String::from(word));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpqxec__8c.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let words\
    \ = s.split_whitespace();\n    words.filter(|word| consonants(word) == n).map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `consonants` in this scope\n  --> /tmp/tmprqnp05ix.rs:19:25\n\
    \   |\n19 |     words.filter(|word| consonants(word) == n).map(|s| s.to_string()).collect()\n\
    \   |                         ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!(\"\
    return vec of words in s with {} consonants\", n);\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: return vec of words in s
    with 4 consonants'', /tmp/tmpusd4f0rn.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    // TODO:\
    \ it's your turn!\n    return vec![];\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpuzd9t9ai.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    for word in s.split_whitespace() {\n        let mut consonants\
    \ = 0;\n        for letter in word.chars() {\n            if !VOWELS.contains(letter)\
    \ {\n                consonants += 1;\n            }\n        }\n        if consonants\
    \ == n {\n            words.push(word.to_string());\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmpn6w5w_6w.rs:22:17\n\
    \   |\n22 |             if !VOWELS.contains(letter) {\n   |                 ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n    let v: Vec<&str> = s.split(\" \").collect();\n\
    \    let mut res: Vec<String> = vec![];\n    for word in v {\n        let mut\
    \ word = word.to_string();\n        word.make_ascii_lowercase();\n        let\
    \ mut chars: Vec<char> = word.chars().collect();\n        let mut count = 0;\n\
    \        for c in chars {\n            if !c.is_ascii_vowel() {\n            \
    \    count += 1;\n            }\n        }\n        if count == n {\n        \
    \    res.push(word);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp8l29q3nn.rs:29:19\n   |\n29 |             if\
    \ !c.is_ascii_vowel() {\n   |                   ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    if n < 0\
    \ { return vec![]; }\n    let mut words: Vec<String> = vec![];\n    let c = '\
    \ ';\n    let mut it = s.split(c);\n    loop {\n        match it.next() {\n  \
    \          Some(v) => {\n                if is_consonant(v) == n {\n         \
    \           words.push(v.to_string());\n                }\n            },\n  \
    \          None => break,\n        }\n    }\n    words\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp8e1eowpw.rs:25:20\n   |\n25 |                 if is_consonant(v) ==\
    \ n {\n   |                    ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = Vec::new();\n    for word in s.split_whitespace() {\n        let consonants\
    \ = String::from(word).chars().filter(|c| !\"aeiou\".contains(*c)).count() as\
    \ isize;\n        if consonants == n {\n            vec.push(String::from(word));\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmpszbc8k9q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| count_consonants(word) == n)\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpde02rj1e.rs:19:24\n   |\n19 |         .filter(|word| count_consonants(word)\
    \ == n)\n   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!(\"\
    Write the select_words function that returns a vector of all words from string\
    \ {:?} that contain exactly {} consonants\", s, n);\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Write the select_words function
    that returns a vector of all words from string "Mary had a little lamb" that contain
    exactly 4 consonants'', /tmp/tmpnibhnbm0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    for w in s.split_whitespace() {\n        if\
    \ n == n_consonants(w) {\n            v.push(w.to_string());\n        }\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `n_consonants` in this scope\n  -->\
    \ /tmp/tmpl6iml1jp.rs:20:17\n   |\n20 |         if n == n_consonants(w) {\n  \
    \ |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec_words = Vec::new();\n    for word in s.split_whitespace() {\n        if\
    \ n_consonants(word) == n {\n            vec_words.push(word.to_string());\n \
    \       }\n    }\n    vec_words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `n_consonants` in this scope\n  -->\
    \ /tmp/tmpnrxyhjsy.rs:20:12\n   |\n20 |         if n_consonants(word) == n {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let splited_s = s.split_whitespace();\n    for word\
    \ in splited_s {\n        let mut consonants = 0;\n        for letter in word.chars()\
    \ {\n            if !is_vowel(letter) {\n                consonants += 1;\n  \
    \          }\n        }\n        if consonants == n {\n            result.push(word.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpo22hgkjt.rs:23:17\n\
    \   |\n23 |             if !is_vowel(letter) {\n   |                 ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v = Vec::new();\n    for word in s.split_whitespace() {\n        let mut count\
    \ = 0;\n        for c in word.chars() {\n            if !c.is_vowel() {\n    \
    \            count += 1;\n            }\n        }\n        if count == n {\n\
    \            v.push(word.to_string());\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpp_faln32.rs:22:19\n   |\n22 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split('\
    \ ')\n        .filter(|word| {\n            word.chars()\n                .filter(|c|\
    \ c.is_ascii_alphabetic())\n                .filter(|c| !c.is_ascii_vowel())\n\
    \                .count() as isize == n\n        })\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp_u7yrja2.rs:22:32\n   |\n22 |          \
    \       .filter(|c| !c.is_ascii_vowel())\n   |                               \
    \ ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_ascii`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut word = String::new();\n    let s = s.to_lowercase();\n\
    \    for c in s.chars() {\n        if c.is_whitespace() {\n            if is_word_valid(&word,\
    \ n) {\n                result.push(word.clone());\n            }\n          \
    \  word.clear();\n        } else {\n            word.push(c);\n        }\n   \
    \ }\n    if is_word_valid(&word, n) {\n        result.push(word);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_word_valid` in this scope\n  -->\
    \ /tmp/tmpuuj_o13u.rs:23:16\n   |\n23 |             if is_word_valid(&word, n)\
    \ {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_word_valid` in this scope\n  --> /tmp/tmpuuj_o13u.rs:31:8\n\
    \   |\n31 |     if is_word_valid(&word, n) {\n   |        ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!(\"\
    select words in `{}` with {} consonants\", s, n);\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: select words in `Mary had
    a little lamb` with 4 consonants'', /tmp/tmplfgqnn3b.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ vec = Vec::new();\n    let mut vc = 0;\n    let mut vw = Vec::new();\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut iter = s.split_whitespace();\n\
    \    while let Some(x) = iter.next() {\n        for c in x.chars() {\n       \
    \     if vowels.contains(&c) {\n                vc += 1;\n            }\n    \
    \    }\n        if vc == n {\n            vw.push(x.to_string());\n        }\n\
    \        vc = 0;\n    }\n    vec = vw;\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpu_iajqy9.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n\
    \        .filter(|word| select_words_helper(word, n))\n        .map(|word| word.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpyogor3rr.rs:19:24\n   |\n19 |         .filter(|word| select_words_helper(word,\
    \ n))\n   |                        ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ ans = Vec::new();\n    let mut curr = String::new();\n    let mut cnt = 0;\n\
    \    for c in s.chars() {\n        if c.is_whitespace() {\n            if cnt\
    \ == n {\n                ans.push(curr);\n            }\n            curr = String::new();\n\
    \            cnt = 0;\n        } else {\n            curr.push(c);\n         \
    \   cnt += match c {\n                'a' | 'e' | 'i' | 'o' | 'u' | 'y' => 0,\n\
    \                _ => 1,\n            };\n        }\n    }\n    if cnt == n {\n\
    \        ans.push(curr);\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmpbb8zu0tp.rs:45:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n\tlet mut words\
    \ = Vec::new();\n\tlet mut count = 0;\n\tlet mut word = String::new();\n\tfor\
    \ c in s.chars() {\n\t\tif c.is_alphabetic() {\n\t\t\tif c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'y' {\n\t\t\t\tcontinue;\n\t\t\t\
    }\n\t\t\tword.push(c);\n\t\t\tcount += 1;\n\t\t} else {\n\t\t\tif count == n {\n\
    \t\t\t\twords.push(word);\n\t\t\t}\n\t\t\tword = String::new();\n\t\t\tcount =\
    \ 0;\n\t\t}\n\t}\n\tif count == n {\n\t\twords.push(word);\n\t}\n\twords\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lttl\"]`,\n right: `[\"little\"]`', /tmp/tmp9imgfc9_.rs:44:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let mut w: String = String::new();\n    let\
    \ mut cnt: isize = 0;\n    for c in s.chars() {\n        if c == ' ' {\n     \
    \       if cnt == n {\n                v.push(w);\n            }\n           \
    \ w = String::new();\n            cnt = 0;\n        } else {\n            if !is_vowel(c)\
    \ {\n                cnt += 1;\n            }\n            w.push(c);\n      \
    \  }\n    }\n    if cnt == n {\n        v.push(w);\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmppj3xqsxl.rs:29:17\n\
    \   |\n29 |             if !is_vowel(c) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdk7lz6d0.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a vector of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty vector.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"),\
    \ 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"\
    Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"\
    lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// vec![]\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    fn count_consonants(word:\
    \ &str) -> isize {\n        let mut consonants = 0;\n        for c in word.chars()\
    \ {\n            match c {\n                'a' | 'e' | 'i' | 'o' | 'u' | ' '\
    \ => {},\n                _ => consonants += 1,\n            }\n        }\n  \
    \      consonants\n    }\n\n    s.split_whitespace()\n        .filter(|word| count_consonants(word)\
    \ == n)\n        .map(|word| word.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp3qk1r_zd.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010693
