name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ["    let mut a = 1;\n    let mut b = n;\n    while b > 0 {\n       \
    \ if b % 2 == 1 {\n            a = (a * n) % p;\n        }\n        b = b / 2;\n\
    \        n = (n * n) % p;\n    }\n    a", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n == 1 {\n        return n;\n    }\n    let mut n = n;\n    let\
    \ mut p = p;\n    n %= p;\n    let mut x = 1;\n    let mut y = 2;\n    while n\
    \ > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n            y = (y * y)\
    \ % p;\n        } else {\n            n -= 1;\n            x = (x * y) % p;\n\
    \        }\n    }\n    x * y % p", "    if n < 0 {\n        return modp(-n, p);\n\
    \    }\n    if n < p {\n        return n;\n    }\n    let mut n = n;\n    let\
    \ mut x = 2;\n    let mut y = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            y = (x * y) % p;\n        }\n        x = (x * x) % p;\n        n\
    \ = n / 2;\n    }\n    y", "    if n == 0 {\n        return 1;\n    }\n    let\
    \ mut res = 1;\n    let mut a = n;\n    let mut b = p - 2;\n    while b > 0 {\n\
    \        if b % 2 == 1 {\n            res = (res * a) % p;\n        }\n      \
    \  a = (a * a) % p;\n        b /= 2;\n    }\n    res", "    if n == 0 {\n    \
    \    return 1;\n    }\n    let mut k = n / 2;\n    let mut m = 1;\n    if n %\
    \ 2 == 1 {\n        m = 2;\n    }\n    let (x, y) = (modp(k, p), modp(k, p));\n\
    \    return (x * x * m) % p;", "    // TODO : this should be a test for isize\n\
    \    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    let mut n = n;\n    // TODO : this should be a test for isize\n  \
    \  if n < 0 {\n        n = -n;\n    }\n    let mut result = 1;\n    let mut x\
    \ = n % p;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * x) % p;\n        }\n        n = n / 2;\n        x = (x * x) % p;\n    }\n\
    \    result", "    let mut r = 1;\n    let mut m = n;\n    while m > 0 {\n   \
    \     r = (r * m) % p;\n        m -= 1;\n    }\n    r", "    let mut d: isize\
    \ = 1;\n    let mut m: isize = n;\n    let mut r: isize = 0;\n    while m > 0\
    \ {\n        r = m % 2;\n        m = m / 2;\n        if r > 0 {\n            d\
    \ = (d * n) % p;\n        }\n        n = (n * n) % p;\n    }\n    d", "    let\
    \ mut r = 1;\n    let mut a = n;\n    let mut b = p;\n    while b > 0 {\n    \
    \    if b % 2 == 1 {\n            r = (r * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        b /= 2;\n    }\n    r", "    // To do:\n    // 2. code up\
    \ modp\n    // 3. make tests pass\n    unimplemented!()", "    if n < 0 {\n  \
    \      modp(n + p, p)\n    } else if n == 0 {\n        1\n    } else if n == 1\
    \ {\n        n\n    } else if n % 2 == 0 {\n        let d = modp(n / 2, p);\n\
    \        d * d % p\n    } else {\n        let d = modp(n - 1, p);\n        n *\
    \ d % p\n    }", "    let mut res = 1;\n    let mut base = n;\n    while base\
    \ > 0 {\n        if base & 1 != 0 {\n            res = res * n % p;\n        }\n\
    \        base >>= 1;\n        n = n * n % p;\n    }\n    res", "    if n < 1 {\n\
    \        return 1;\n    }\n\n    let mut r = 1;\n    let mut r_m = modp(n / 2,\
    \ p);\n    for _ in 0..n {\n        r = (r * r_m) % p;\n    }\n    r", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n   \
    \ }\n    let result = modp(n / 2, p);\n    let result = (result * result) % p;\n\
    \    if n % 2 == 0 {\n        return result;\n    } else {\n        return (result\
    \ * n) % p;\n    }", "    if n == 0 {\n        return 1;\n    }\n    if n % 2\
    \ == 0 {\n        let r = modp(n / 2, p);\n        return r * r % p;\n    }\n\
    \    return n * modp(n - 1, p) % p;", "    if n == 0 {\n        return 1;\n  \
    \  }\n\n    let mut base = modp(n / 2, p);\n    base = (base * base) % p;\n\n\
    \    if n % 2 == 1 {\n        return (base * 2) % p;\n    } else {\n        return\
    \ base;\n    }", "    assert!(p > 1);\n    let mut result = 1;\n    let mut n\
    \ = n;\n    let mut b = n;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       result = (result * b) % p;\n        }\n        b = (b * b) % p;\n    \
    \    n /= 2;\n    }\n    result", "    if n == 0 {\n        return 1;\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n / 2, p);\n        return (x * x)\
    \ % p;\n    }\n    return ((n % p) * modp(n - 1, p)) % p;", "    if n == 0 {\n\
    \        return 1;\n    }\n    if n < 0 {\n        return modp(n + p - 1, p);\n\
    \    }\n    let (mut result, mut two) = (1, 2);\n    while two <= n {\n      \
    \  two = two * 2;\n    }\n    two = two / 2;\n    while two > 0 {\n        if\
    \ two <= n {\n            result = (result * result) % p;\n            n = n -\
    \ two;\n        } else {\n            result = (result * result) % p;\n      \
    \  }\n        two = two / 2;\n    }\n    result", "    // Initialize result\n\
    \    let mut res = 1;\n    // Update x if it is more\n    // than or equal to\
    \ p\n    let mut x = n;\n    while x >= p {\n        x -= p;\n    }\n    // Update\
    \ x if it is more\n    // than or equal to p\n    let mut y = p - 1;\n    while\
    \ y >= 1 {\n        // If y is odd, multiply\n        // x with result\n     \
    \   if y & 1 != 0 {\n            res = (res * x) % p;\n        }\n        // y\
    \ must be even now\n        // y = y / 2\n        y = y >> 1;\n        x = (x\
    \ * x) % p;\n    }\n    res", "    let mut r = 1;\n    let mut power = n;\n  \
    \  while power > 0 {\n        if power % 2 == 1 {\n            r = (r * n) % p;\n\
    \        }\n        n = (n * n) % p;\n        power = power / 2;\n    }\n    r",
  "    let mut n = n;\n    let mut n_power_of_two = n;\n    n_power_of_two = n_power_of_two\
    \ * n_power_of_two % p;\n    n = n_power_of_two * n % p;\n    return n;", "  \
    \  if n == 0 {\n        return 1;\n    }\n    let mut m = modp(n / 2, p);\n  \
    \  m = m * m % p;\n    if n % 2 == 1 {\n        m = m * 2 % p;\n    }\n    m",
  "    let mut result = 1;\n    for _ in 0..n {\n        result = (result * 2) % p;\n\
    \    }\n    result", "    let mut result = 1;\n    let mut power = n;\n    while\
    \ power > 0 {\n        if power % 2 == 1 {\n            result = (result * n)\
    \ % p;\n        }\n        n = (n * n) % p;\n        power = power / 2;\n    }\n\
    \    result", "    let mut result = 1;\n    let mut exp = n;\n    let mut base\
    \ = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result = (result\
    \ * base) % p;\n        }\n        exp = exp / 2;\n        base = (base * base)\
    \ % p;\n    }\n    result", "    let mut res = 1;\n    let mut power = n;\n  \
    \  while power > 0 {\n        if power % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = (n * n) % p;\n        power = power / 2;\n    }\n\
    \    res", "    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n    \
    \    if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n =\
    \ n / 2;\n    }\n    res", "    if n % p == 0 {\n        return 1;\n    }\n  \
    \  if n == 0 {\n        return 0;\n    }\n    let mut acc = 1;\n    let mut k\
    \ = n;\n    while k > 0 {\n        if k % 2 == 1 {\n            acc = (acc * (n\
    \ % p)) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n  \
    \  acc", "    // NOTE: n < p\n    let mut r = 1;\n    let mut n = n;\n    while\
    \ n > 0 {\n        r = (r * n) % p;\n        n -= 1;\n    }\n    r", "    let\
    \ mut result = 1;\n    let mut n = n;\n    let mut p = p;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            result = (result * n) % p;\n        }\n\
    \        n = n / 2;\n        p = (p * p) % p;\n    }\n    result", "    let mut\
    \ n = n;\n    let mut x = 1;\n    loop {\n        if n == 0 {\n            return\
    \ x;\n        }\n        n = n - 1;\n        x = (x * 2) % p;\n    }", "    //\
    \ TODO: Handle negative values.\n    if n == 0 {\n        return 1;\n    }\n\n\
    \    let mut a = 1;\n    let mut x = n;\n    let mut p = p;\n\n    while x > 0\
    \ {\n        // a = (a * x) % p\n        if x % 2 == 1 {\n            a = (a *\
    \ x) % p;\n        }\n        x = x / 2;\n        p = (p * p) % p;\n    }\n\n\
    \    a", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n   \
    \     return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return modp(n -\
    \ 1, p) * n % p;", "    assert!(p > 1);\n    let mut result = 1;\n    for _ in\
    \ 0..n {\n        result = (result * 2) % p;\n    }\n    result", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        modp(n / 2, p) *\
    \ modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1, p) % p\n    }", " \
    \   let mut res = 1;\n    for _ in 0..n {\n        res = (res * 2) % p;\n    }\n\
    \    res", "    let mut ans = 1;\n    let mut base = n;\n    let mut exponent\
    \ = p;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n           \
    \ ans = (ans * base) % p;\n        }\n        base = (base * base) % p;\n    \
    \    exponent = exponent / 2;\n    }\n    ans", "    let mut n = n;\n    let mut\
    \ result = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            result\
    \ = (result * p) % MOD;\n        }\n        n /= 2;\n        p = (p * p) % MOD;\n\
    \    }\n    result", "    let mut res = 1;\n    let mut x = n;\n    let mut p\
    \ = p;\n    while x > 0 {\n        if x % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        x /= 2;\n        n = (n * n) % p;\n    }\n    res",
  "    if n % p == 0 {\n        return 1;\n    }\n    let mut v = 1;\n    for _ in\
    \ 0..n {\n        v = (v * 2) % p;\n    }\n    v", "    let mut n = n;\n    let\
    \ mut r = 1;\n    for _ in 0..n {\n        r = (r * 2) % p;\n    }\n    r", " \
    \   if n < 0 {\n        modp(-n, p)\n    } else if n == 0 {\n        1\n    }\
    \ else if n == 1 {\n        n % p\n    } else if n % 2 == 0 {\n        modp(2\
    \ * (n / 2), p) % p\n    } else {\n        (modp(n - 1, p) * n) % p\n    }", " \
    \   let mut result = 1;\n    let mut n = n;\n    let mut b = 2;\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            result = (result * b) % p;\n     \
    \   }\n        n /= 2;\n        b = (b * b) % p;\n    }\n    result", "    var\
    \ x: isize = 1;\n    var i: isize = 0;\n    while i < n {\n        x = (x * 2)\
    \ % p;\n        i = i + 1;\n    }\n    return x;", "    if n == 0 {\n        return\
    \ 1;\n    }\n\n    let mut k = n;\n    let mut j = 1;\n    while k > 1 {\n   \
    \     k /= 2;\n        j *= 2;\n    }\n\n    j /= 2;\n    k = n - j;\n    let\
    \ mut r = modp(j, p);\n    r = r * r % p;\n    if k > j {\n        r = r * n %\
    \ p;\n    }\n    r", "    let mut n = n;\n    let mut i = 1;\n    let mut k =\
    \ 2;\n    while n != 0 {\n        if n % 2 == 1 {\n            i = (i * k) % p;\n\
    \        }\n        n /= 2;\n        k = (k * k) % p;\n    }\n    i", "    if\
    \ n < 0 {\n        modp(n + p, p)\n    } else if n == 0 {\n        1\n    } else\
    \ if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        modp(t * t, p)\n \
    \   } else {\n        modp(2 * n, p) * modp(n - 1, p)\n    }", "    if n == 0\
    \ {\n        return 1;\n    }\n    if n < 0 {\n        return modp(-n, p);\n \
    \   }\n    let mut t = modp(n / 2, p);\n    t = (t * t) % p;\n    if n % 2 ==\
    \ 1 {\n        t = (t * 2) % p;\n    }\n    t", "    let mut r = 1;\n    let mut\
    \ b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * n)\
    \ % p;\n        }\n        b = b / 2;\n        n = (n * n) % p;\n    }\n    r",
  "    let mut res = 1;\n    let mut n = n;\n    let mut p = p;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n      \
    \  n = n / 2;\n        p = (p * p) % 13;\n    }\n    res", "    let mut result\
    \ = 1;\n    let mut base = n;\n    let mut exp = p;\n    while exp > 0 {\n   \
    \     if exp % 2 == 1 {\n            result = (result * base) % p;\n        }\n\
    \        exp = exp >> 1;\n        base = (base * base) % p;\n    }\n    result",
  "    if n == 0 {\n        return 1;\n    }\n    let mut result = modp(n >> 1, p);\n\
    \    result = (result * result) % p;\n    if n & 1 == 1 {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    assert!(n >= 0);\n    assert!(p > 0);\n\
    \    let mut m = 1;\n    for _ in 0..n {\n        m = (m * 2) % p;\n    }\n  \
    \  m", "    let mut res = 1;\n    let mut base = n;\n    while base > 0 {\n  \
    \      if base & 1 == 1 {\n            res = (res * n) % p;\n        }\n     \
    \   base >>= 1;\n        n = (n * n) % p;\n    }\n    res", "    if n == 0 {\n\
    \        return 1;\n    }\n\n    let mut res = modp(n / 2, p);\n    res = (res\
    \ * res) % p;\n\n    if n % 2 == 1 {\n        res = (res * 2) % p;\n    }\n\n\
    \    res", "    let mut x = 1;\n    let mut y = n;\n    while p > 1 {\n      \
    \  if p % 2 == 0 {\n            y = y * y % p;\n            p /= 2;\n        }\
    \ else {\n            x = x * y % p;\n            p -= 1;\n        }\n    }\n\
    \    return x * y % p;", "    let mut res = 1;\n    let mut x = n;\n    while\
    \ x > 0 {\n        if x % 2 == 1 {\n            res = (res * n) % p;\n       \
    \ }\n        x /= 2;\n        n = (n * n) % p;\n    }\n    res", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return modp(n /\
    \ 2, p) * modp(n / 2, p) % p;\n    }\n    return n * modp(n - 1, p) % p;", " \
    \   let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            res = (res * 2) % p;\n        }\n        n /= 2;\n    }\n\
    \    res", "    let mut n = n;\n    let mut res = 1;\n    let mut base = 2;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * base) %\
    \ p;\n        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n \
    \   res", "    if n == 0 {\n        return 1;\n    }\n    let mut d = modp(n >>\
    \ 1, p);\n    d = d * d % p;\n    if n & 1 == 1 {\n        d = d * 2 % p;\n  \
    \  }\n    d", "    let mut res = 1;\n    let mut base = n;\n    while base > 0\
    \ {\n        if base & 1 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        base >>= 1;\n        n = (n * n) % p;\n    }\n    res", "    if n ==\
    \ 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n        return modp(n\
    \ / 2, p) * modp(n / 2, p) % p;\n    } else {\n        return 2 * modp(n - 1,\
    \ p) % p;\n    }", "    let mut n = n;\n    let mut r = 1;\n    let mut m = p;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * m) % p;\n  \
    \      }\n        m = (m * m) % p;\n        n = n / 2;\n    }\n    r", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let x = modp(n\
    \ / 2, p);\n        return (x * x) % p;\n    }\n    return (n * modp(n - 1, p))\
    \ % p;", "    match n % p {\n        0 => 1,\n        x => powmod(2, x, p),\n\
    \    }", "    let mut x = 1;\n    let mut n = n;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            x = (x * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    x", "    let mut res = 1;\n    let mut pow = n;\n    let mut modulus\
    \ = p;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * n) % p;\n        }\n        pow /= 2;\n        n = (n * n) % p;\n    }\n \
    \   res", "    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n\
    \ / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res\
    \ * 2) % p;\n    }\n    res", "    let mut result = 1;\n    let mut n = n;\n \
    \   while n > 0 {\n        if n % 2 == 1 {\n            result = (result * 2)\
    \ % p;\n        }\n        n /= 2;\n    }\n    result", "    if n == 0 {\n   \
    \     return 1;\n    }\n    if n % 2 == 0 {\n        let y = modp(n / 2, p);\n\
    \        return (y * y) % p;\n    }\n    return (n * modp(n - 1, p)) % p;", " \
    \   let mut m = 1;\n    let mut i = 0;\n    let mut a = n;\n    while i < n {\n\
    \        if a % 2 == 1 {\n            m = (m * n) % p;\n        }\n        a =\
    \ a / 2;\n        n = (n * n) % p;\n        i += 1;\n    }\n    m", "    if n\
    \ == 0 {\n        return 1;\n    }\n\n    let mut res = 1;\n    let mut mul =\
    \ n;\n    while mul > 0 {\n        if mul % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        mul = mul / 2;\n        n = (n * n) % p;\n    }\n\
    \    res", '    return (n.pow(2) % p);', "    let mut r = 1;\n    let mut i =\
    \ n;\n    while i > 0 {\n        if i % 2 == 1 {\n            r = (r * n) % p;\n\
    \        }\n        n = (n * n) % p;\n        i = i / 2;\n    }\n    r", "   \
    \ let mut result = 1;\n    let mut b = n;\n    while b > 0 {\n        if b % 2\
    \ == 1 {\n            result = (result * n) % p;\n        }\n        b /= 2;\n\
    \        n = (n * n) % p;\n    }\n    result", "    let mut r = 1;\n    let mut\
    \ k = n;\n    let mut q = p;\n    while k > 0 {\n        if k % 2 == 1 {\n   \
    \         r = (r * q) % p;\n        }\n        k = k / 2;\n        q = (q * q)\
    \ % p;\n    }\n    r", "    if n == 0 {\n        return 1;\n    }\n    if n %\
    \ 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n      \
    \  modp(n - 1, p) * modp(n - 1, p) * modp(2, p) % p\n    }", "    let mut r =\
    \ 1;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n       \
    \     r = (r * n) % p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n\
    \    }\n    r", "    // math.pow(x, y)\n    let mut result = 1;\n    let mut x\
    \ = n;\n    let mut y = p;\n    while y > 0 {\n        if y % 2 == 1 {\n     \
    \       result = (result * x) % p;\n        }\n        y = y >> 1;\n        x\
    \ = (x * x) % p;\n    }\n    result", "    let mut ret = 1;\n    let mut a = n;\n\
    \    let mut b = p;\n    while b > 0 {\n        if b % 2 == 1 {\n            ret\
    \ = (ret * a) % p;\n        }\n        a = (a * a) % p;\n        b /= 2;\n   \
    \ }\n    ret", "    let mut res = 1;\n    let mut base = n;\n    while base >\
    \ 0 {\n        if base & 1 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        base >>= 1;\n        n = (n * n) % p;\n    }\n    res", "    let mut\
    \ ans = 1;\n    for _ in 0..n {\n        ans = (ans * 2) % p;\n    }\n    ans",
  "    if n < 0 {\n        return -1;\n    }\n    if n == 0 {\n        return 1;\n\
    \    }\n    let mut r = n;\n    for _ in 1..n {\n        r = (r * n) % p;\n  \
    \  }\n    r", "    assert!(p > 1);\n    let mut res = 1;\n    for _ in 0..n {\n\
    \        res = (res * 2) % p;\n    }\n    res", "    if n >= p {\n        n %\
    \ p\n    } else if n < 0 {\n        n % p + p\n    } else {\n        n\n    }",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let t =\
    \ modp(n / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n - 1,\
    \ p) * n) % p;", "    let mut t = 1;\n    let mut n = n;\n    let mut p = p;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            t = (t * n) % p;\n  \
    \      }\n        n = n / 2;\n        n = (n * n) % p;\n    }\n    t", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return modp(n\
    \ / 2, p) * modp(n / 2, p) % p;\n    }\n    return modp(n - 1, p) * modp(n + 1,\
    \ p) % p;", "    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n\
    \        let t = modp(n / 2, p);\n        return (t * t) % p;\n    } else {\n\
    \        return (modp(n - 1, p) * (n % p)) % p;\n    }", "    if n == 0 {\n  \
    \      return 1;\n    }\n    let mut ans = modp(n >> 1, p);\n    ans = (ans *\
    \ ans) % p;\n    if n & 1 == 1 {\n        ans = (ans * 2) % p;\n    }\n    ans",
  "    let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n    n", "    if\
    \ n == 0 {\n        return 1;\n    }\n    else if n == 1 {\n        return n;\n\
    \    }\n    else if n % 2 == 0 {\n        let a = modp(n / 2, p);\n        return\
    \ (a * a) % p;\n    }\n    else {\n        return ((modp(n - 1, p) % p) * (n %\
    \ p)) % p;\n    }", "    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return n;\n    }\n    if n % 2 == 0 {\n        let res = modp(n /\
    \ 2, p);\n        return (res * res) % p;\n    }\n    return (n * modp(n - 1,\
    \ p)) % p;", "    assert!(p > 1);\n    if n % p == 0 {\n        0\n    } else\
    \ {\n        let mut n = n % p;\n        if n < 0 {\n            n += p;\n   \
    \     }\n        assert!(n > 0);\n        let mut two_n = 1;\n        for _ in\
    \ 0..n {\n            two_n = (two_n * 2) % p;\n        }\n        two_n\n   \
    \ }", "    let mut res = 1;\n    for _ in 0..n {\n        res = (res * 2) % p;\n\
    \    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    let mut q =\
    \ modp(n >> 1, p);\n    q = (q * q) % p;\n    if n & 1 == 1 {\n        q = (q\
    \ * n) % p;\n    }\n    q", "    let mut result = 1;\n    for _ in 0..n {\n  \
    \      result = result * 2 % p;\n    }\n    result", "    let mut result = 1;\n\
    \    for _ in 0..n {\n        result = (result * 2) % p;\n    }\n    result",
  "    // return pow(2, n, p)\n    if n == 0 {\n        return 1;\n    }\n    let\
    \ mut res = modp(n / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n\
    \        res = (res * 2) % p;\n    }\n    res", "    let mut n = n;\n    let mut\
    \ a = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            a = (a * n)\
    \ % p;\n        }\n        n = n / 2;\n    }\n    a", "    let mut r = 1;\n  \
    \  let mut m = n;\n    while m > 0 {\n        if m % 2 == 1 {\n            r =\
    \ (r * n) % p;\n        }\n        n = (n * n) % p;\n        m = m / 2;\n    }\n\
    \    r", "    let mut r = 1;\n    let mut k = n;\n    let mut m = p;\n    while\
    \ k > 0 {\n        if k % 2 == 1 {\n            r = (r * k) % m;\n        }\n\
    \        k = k / 2;\n        m = (m * m) % p;\n    }\n    r", "    let mut a =\
    \ 2isize;\n    let mut b = 1isize;\n    let mut c = n;\n    while c > 0 {\n  \
    \      if c % 2 == 1 {\n            b = (b * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        c = c / 2;\n    }\n    b", "    let mut a = 1;\n    let mut\
    \ b = n;\n    let mut c = p;\n    while b > 0 {\n        if b % 2 == 1 {\n   \
    \         a = (a * b) % c;\n        }\n        b = b / 2;\n        c = (c * c)\
    \ % p;\n    }\n    a", "    let mut out = 1;\n    for _ in 0..n {\n        out\
    \ = (out * 2) % p;\n    }\n    out", "    return if n == 0 {\n        1\n    }\
    \ else if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        (t * t) % p\n\
    \    } else {\n        (2 * modp(n - 1, p)) % p\n    };", "    let mut r = 1;\n\
    \    let mut s = 2;\n    let mut i = n;\n    while i > 0 {\n        if i % 2 ==\
    \ 1 {\n            r = (r * s) % p;\n        }\n        s = (s * s) % p;\n   \
    \     i = i / 2;\n    }\n    r", "    let mut r = 1;\n    let mut k = n;\n   \
    \ while k > 0 {\n        while k & 1 == 0 {\n            k /= 2;\n        }\n\
    \        k -= 1;\n        if k >= p {\n            r = (r * modp(k % p, p)) %\
    \ p;\n        } else {\n            r = (r * k) % p;\n        }\n    }\n    r",
  "    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n    let mut r = modp(n\
    \ / 2, p);\n    r = (r * r) % p;\n    if n % 2 == 1 {\n        r = (r * n) % p;\n\
    \    }\n    r", "    let mut result = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % 101;\n        }\n        n /= 2;\n        p = (p * p) % 101;\n    }\n\
    \    result", "    if n == 0 {\n        return 1;\n    }\n    let mut m = modp(n\
    \ / 2, p);\n    m = (m * m) % p;\n    if n % 2 == 1 {\n        m = (m * n) % p;\n\
    \    }\n    m", "    if n == 0 {\n        return 1;\n    }\n\n    let mut res\
    \ = modp(n / 2, p);\n    res = (res * res) % p;\n\n    if n % 2 == 1 {\n     \
    \   res = (res * 2) % p;\n    }\n\n    res", "    let mut pow = n;\n    let mut\
    \ res = 1;\n    while pow > 0 {\n        if pow & 1 == 1 {\n            res =\
    \ (res * n) % p;\n        }\n        pow >>= 1;\n        n = (n * n) % p;\n  \
    \  }\n    res", "    if n < 0 {\n        // Only positive exponents\n        return\
    \ -1;\n    }\n    let mut b = 1;\n    for _ in 0..n {\n        b = b * 2 % p;\n\
    \    }\n    b", "    if n < 0 {\n        return modp(p - ((p - n) % p), p);\n\
    \    }\n    let mut m = 1;\n    let mut d = n;\n    while d > 0 {\n        if\
    \ d % 2 == 1 {\n            m = (m * n) % p;\n        }\n        n = (n * n) %\
    \ p;\n        d = d / 2;\n    }\n    m", "    if n == 0 {\n        return 1;\n\
    \    }\n\n    let mut result = modp(n / 2, p);\n    result = (result * result)\
    \ % p;\n\n    if n % 2 == 1 {\n        result = (result * 2) % p;\n    }\n\n \
    \   result", "    if n == 0 {\n        return 1;\n    }\n\n    let mut result\
    \ = 1;\n    let mut k = n;\n    while k > 0 {\n        if k % 2 == 1 {\n     \
    \       result = (result * n) % p;\n        }\n        n = (n * n) % p;\n    \
    \    k = k / 2;\n    }\n    result", "    if n < 0 {\n        modp(-n, p)\n  \
    \  } else if n < p {\n        n\n    } else if n == p {\n        0\n    } else\
    \ {\n        modp(2 * n - p, p)\n    }", "    let mut m = 1;\n    let mut i =\
    \ 0;\n    while i < n {\n        m = (m * 2) % p;\n        i += 1;\n    }\n  \
    \  m", "    let mut result = 1;\n    for _ in 0..n {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    if n == 0 {\n        return 1;\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n  \
    \  }\n    return n * modp(n - 1, p) % p;", "    let mut a = 1;\n    let mut b\
    \ = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            a = (a * n) %\
    \ p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n    }\n    a", " \
    \   if n % p == 0 {\n        return 1;\n    }\n\n    if n == 0 {\n        return\
    \ 0;\n    }\n\n    if n == 1 {\n        return 1;\n    }\n\n    let mut result\
    \ = modp(n / 2, p);\n    result = (result * result) % p;\n\n    if n % 2 == 1\
    \ {\n        result = (result * 2) % p;\n    }\n\n    result", "    if n == 0\
    \ {\n        return 1;\n    }\n    let mut res = 1;\n    let mut n = n % p;\n\
    \    let mut nn = n;\n    while nn > 1 {\n        if nn % 2 == 1 {\n         \
    \   res = (res * n) % p;\n        }\n        n = (n * n) % p;\n        nn /= 2;\n\
    \    }\n    res * n % p", "    let mut k = n;\n    let mut r = 1;\n    while k\
    \ > 0 {\n        if k % 2 == 1 {\n            r = (r * n) % p;\n        }\n  \
    \      n = (n * n) % p;\n        k = k / 2;\n    }\n    r", "    let mut b = n;\n\
    \    let mut c = 1;\n    let mut d = 0;\n    let mut e = 0;\n    while b > 0 {\n\
    \        e = b & 1;\n        b = b >> 1;\n        d = 2 * d + e;\n        if p\
    \ <= d {\n            d = d - p;\n        }\n        if e == 1 {\n           \
    \ c = (c * d) % p;\n        }\n    }\n    c", "    let mut res = 1;\n    let mut\
    \ n = n;\n    let mut p = p;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         res = (res * n) % p;\n        }\n        n = n / 2;\n        n = (n\
    \ * n) % p;\n    }\n    res", "    let mut r = 1;\n    let mut a = n;\n    while\
    \ a > 0 {\n        if a % 2 == 1 {\n            r = (r * n) % p;\n        }\n\
    \        a = a / 2;\n        n = (n * n) % p;\n    }\n    r", "    if n == 0 {\n\
    \        return 1;\n    }\n    let mut res = 1;\n    let mut n = n;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n       \
    \ }\n        n = n / 2;\n        n = (n * n) % p;\n    }\n    res", "    if n\
    \ == 0 {\n        return 1;\n    }\n    let mut x = 1;\n    for _ in 0..n {\n\
    \        x = (x * 2) % p;\n    }\n    x", "    if n == 0 {\n        return 1;\n\
    \    }\n\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p)\
    \ % p;\n    } else {\n        return modp(n - 1, p) * modp(n - 1, p) * n % p;\n\
    \    }", "    let mut res = 1;\n    let mut y = n;\n    let mut z = p;\n    while\
    \ y > 0 {\n        if y % 2 == 1 {\n            res = (res * y) % z;\n       \
    \ }\n        y = y / 2;\n        z = (z * z) % p;\n    }\n    res", "    if n\
    \ == 0 {\n        return 1;\n    }\n    let mut result = modp(n / 2, p);\n   \
    \ result = (result * result) % p;\n    if n % 2 == 1 {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    let mut i = 1;\n    let mut mul = n;\n \
    \   while i < p {\n        mul = (mul * n) % p;\n        i += 1;\n    }\n    mul",
  "    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * p) % 101;\n        }\n        n /= 2;\n      \
    \  p = (p * p) % 101;\n    }\n    res", "    if n < 0 {\n        panic!(\"Expected\
    \ number to be non-negative!\");\n    }\n    if p < 0 {\n        panic!(\"Expected\
    \ prime to be positive!\");\n    }\n    if n == 0 {\n        return 1;\n    }\n\
    \    //  Compute n^n mod p.\n    let mut result = n;\n    for _ in 1..n {\n  \
    \      result = (result * n) % p;\n    }\n    result", '    modp_rec(n, p, 1)',
  "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    if n % 2 == 0 {\n        let z = modp(n / 2, p);\n        return z\
    \ * z % p;\n    }\n    n * modp(n - 1, p) % p", "    let mut res = 1;\n    for\
    \ _ in 0..n {\n        res = (res * 2) % p;\n    }\n    res", "    let mut r =\
    \ 1;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n       \
    \     r = (r * n) % p;\n        }\n        b = b / 2;\n        n = (n * n) % p;\n\
    \    }\n    r", "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n\
    \        return n;\n    }\n    if n % 2 == 0 {\n        let m = modp(n / 2, p);\n\
    \        return (m * m) % p;\n    }\n    return (modp(n - 1, p) * n) % p;", " \
    \   let mut res = 1;\n    let mut mul = n;\n    let mut exp = p - 2;\n    while\
    \ exp > 0 {\n        if exp % 2 == 1 {\n            res = (res * mul) % p;\n \
    \       }\n        mul = (mul * mul) % p;\n        exp /= 2;\n    }\n    res",
  "    let mut n = n;\n    let mut result = 1;\n    let mut twop = 1;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * twop) % p;\n\
    \        }\n        twop = (twop * twop) % p;\n        n = n / 2;\n    }\n   \
    \ result", "    let mut n = n;\n    let mut result = 1;\n    while n > 0 {\n \
    \       if n % 2 == 1 {\n            result = (result * n) % p;\n        }\n \
    \       n = n / 2;\n    }\n    result", "    let mut res = 1;\n    for _ in 0..n\
    \ {\n        res = res * 2 % p;\n    }\n    res", "    let mut r = 1;\n    let\
    \ mut k = n;\n    while k > 0 {\n        if k % 2 == 1 {\n            r = (r *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        k /= 2;\n    }\n    r",
  "    let mut result = 1;\n    for _ in 0..n {\n        result = result * 2 % p;\n\
    \    }\n    result", "    let t = 1;\n    let mut p = p;\n    let mut n = n;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            t = (t * p) % modulo;\n\
    \        }\n        p = (p * p) % modulo;\n        n /= 2;\n    }\n    t", " \
    \   let mut res = 1;\n    let mut mul = n;\n    let mut exp = p - 2;\n    while\
    \ exp > 0 {\n        if exp % 2 == 1 {\n            res = (res * mul) % p;\n \
    \       }\n        mul = (mul * mul) % p;\n        exp /= 2;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n    let mut z = modp(n / 2, p);\n  \
    \  z = (z * z) % p;\n    if n % 2 == 1 {\n        z = (z * n) % p;\n    }\n  \
    \  z", "    let mut res = 1;\n    let mut k = n;\n    while k > 0 {\n        if\
    \ k % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = (n *\
    \ n) % p;\n        k /= 2;\n    }\n    res", "    if n < 0 {\n        modp(-n,\
    \ p)\n    } else if n == 0 {\n        1\n    } else if n % 2 == 0 {\n        modp(n\
    \ / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1, p) % p\n\
    \    }", "    let mut n = n % p;\n    if n == 0 {\n        1\n    } else {\n \
    \       let mut result = 1;\n        for _ in 0..n {\n            result = (result\
    \ * 2) % p;\n        }\n        result\n    }", "    assert!(p > 0);\n    if n\
    \ <= 0 {\n        return 1;\n    }\n    let mut result = 1;\n    let mut i = n;\n\
    \    let mut x = 2;\n    while i > 0 {\n        while i % 2 == 0 {\n         \
    \   i /= 2;\n            x = (x * x) % p;\n        }\n        i -= 1;\n      \
    \  result = (result * x) % p;\n    }\n    result", "    let mut t = 1;\n    let\
    \ mut c = n;\n    while c > 0 {\n        if c % 2 == 1 {\n            t = (t *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        c = c / 2;\n    }\n  \
    \  t", "    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res", "    let mut res = 1;\n    let mut nn = n;\n    let mut p =\
    \ p;\n    while nn > 0 {\n        if nn % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        nn = nn / 2;\n        n = (n * n) % p;\n    }\n   \
    \ res", "    // calculate (n % p)\n    let mut r = n % p;\n    // ensure result\
    \ is positive if n is positive\n    if n > 0 && r < 0 {\n        r += p;\n   \
    \ }\n    // ensure result is 0 if n is 0\n    if n == 0 {\n        r = 0;\n  \
    \  }\n    r", "    let mut res = 1;\n    let mut a = n;\n    while a > 0 {\n \
    \       if a % 2 == 1 {\n            res = (res * n) % p;\n        }\n       \
    \ a = a / 2;\n        n = (n * n) % p;\n    }\n    res", "    let mut result =\
    \ 1;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n       \
    \     result = (result * n) % p;\n        }\n        b /= 2;\n        n = (n *\
    \ n) % p;\n    }\n    result", "    // Be aware of numerics!\n    let mut res\
    \ = 1;\n    let mut n = n;\n    let mut x = 2;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = (res * x) % p;\n        }\n        x = (x *\
    \ x) % p;\n        n = n / 2;\n    }\n    res", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let z = modp(n / 2, p);\n        return\
    \ z * z % p;\n    }\n    modp(n - 1, p) * n % p", "    let mut b = 1;\n    let\
    \ mut r = n;\n    while r > 0 {\n        if r % 2 == 1 {\n            b = (b *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        r = r / 2;\n    }\n  \
    \  b", "    let mut x = 1;\n    let mut y = n;\n    while p > 1 {\n        if\
    \ p % 2 == 0 {\n            y = (y * y) % p;\n            p /= 2;\n        } else\
    \ {\n            x = (x * y) % p;\n            p -= 1;\n        }\n    }\n   \
    \ (x * y) % p", "    // Handle negative exponents.\n    if n < 0 {\n        return\
    \ modp(n + p - 1, p);\n    }\n\n    let mut t: isize = 1;\n    let mut r: isize\
    \ = 1;\n    let mut i: isize = 1;\n\n    while i <= n {\n        t = t * 2;\n\
    \        r = (r * r) % p;\n\n        if t > n {\n            t = 1;\n        \
    \    r = (r * 3) % p;\n        }\n\n        i += 1;\n    }\n\n    r", "    if\
    \ n == 0 {\n        return 1;\n    }\n    let mut result = modp(n / 2, p);\n \
    \   result = (result * result) % p;\n    if n % 2 == 1 {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    if n == 0 {\n        return 1;\n    }\n\n\
    \    if n == 1 {\n        return n;\n    }\n\n    let mut p0 = n;\n    let mut\
    \ c = 1;\n\n    while p0 > 1 {\n        if p0 % 2 == 0 {\n            p0 = p0\
    \ / 2;\n            c = c * 2;\n        } else {\n            p0 = p0 - 1;\n \
    \           c = c * 2;\n        }\n    }\n\n    let mut result = (n * c) % p;\n\
    \n    if result < 0 {\n        result = p + result;\n    }\n\n    result", " \
    \   let res = (1..n).fold(1, |acc, _| acc * 2 % p);\n    res", "    let mut result\
    \ = 1;\n    for _ in 0..n {\n        result = (result * 2) % p;\n    }\n    result",
  "    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n        if x % 2 ==\
    \ 1 {\n            r = (r * n) % p;\n        }\n        x = x / 2;\n        n\
    \ = (n * n) % p;\n    }\n    r", "    assert!(n >= 0);\n    let mut r = 1;\n \
    \   let mut q = n;\n    let mut x = p - 2;\n    while q > 0 {\n        if q %\
    \ 2 == 1 {\n            r = (r * x) % p;\n        }\n        x = (x * x) % p;\n\
    \        q = q / 2;\n    }\n    r", "    let mut m = n;\n    let mut w = 1;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            w = (w * n) % p;\n  \
    \      }\n        n = (n * n) % p;\n        m = m / 2;\n    }\n    w", "    if\
    \ n == 0 {\n        return 1;\n    }\n\n    let mut ret = modp(n / 2, p);\n  \
    \  ret = (ret * ret) % p;\n    if n % 2 == 1 {\n        ret = (ret * 2) % p;\n\
    \    }\n    ret", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return\
    \ modp(n - 1, p) * modp(n, p) % p;", "    let mut x = 1;\n    let mut a = n;\n\
    \    let mut b = p;\n    while b > 0 {\n        if b % 2 == 1 {\n            x\
    \ = x * a % p;\n        }\n        a = a * a % p;\n        b = b / 2;\n    }\n\
    \    x", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n   \
    \     let rest = modp(n / 2, p);\n        return (rest * rest) % p;\n    }\n \
    \   return (modp(n - 1, p) * n) % p;", "    let mut r = 1;\n    let mut n = n;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p;\n  \
    \      }\n        n /= 2;\n    }\n    r", "    let mut a = 1;\n    let mut b =\
    \ n;\n    while b > 0 {\n        if b % 2 == 1 {\n            a = (a * n) % p;\n\
    \        }\n        b = b / 2;\n        n = (n * n) % p;\n    }\n    a", "   \
    \ let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * res) % p;\n        }\n        n /= 2;\n    }\n\
    \    res", "    let result = modexp(2, n, p);\n    if result == -1 {\n       \
    \ return 1;\n    }\n    result", "    let mut a = n;\n    let mut b = 1;\n   \
    \ for i in 0..p - 1 {\n        b = (b * a) % p;\n    }\n    b", "    let mut result\
    \ = 1;\n    for _ in 0..n {\n        result = (result * 2) % p;\n    }\n    result",
  "    let mut n = n;\n    let mut result = 1;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            result = (result * p) % 101;\n        }\n        n /=\
    \ 2;\n        p = (p * p) % 101;\n    }\n    result", "    let mut a = 1;\n  \
    \  let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            a =\
    \ (a * n) % p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n    }\n\
    \    a", "    if n % p == 0 {\n        return 1;\n    }\n    let mut r = 1;\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % 2 == 1 {\n            r\
    \ = (r * 2) % p;\n        }\n        n /= 2;\n        n %= p;\n    }\n    r",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return modp(n - 1, p) * n %\
    \ p;", "    if n == 0 {\n        return 1;\n    }\n    let mut n = n;\n    let\
    \ mut r = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            r = (r *\
    \ 2) % p;\n        }\n        n /= 2;\n        if n > 0 {\n            r = (r\
    \ * r) % p;\n        }\n    }\n    r", "    let mut res = 1;\n    let mut _n =\
    \ n;\n    let mut _p = p;\n    while _n > 0 {\n        if _n % 2 == 1 {\n    \
    \        res = (res * _p) % p;\n        }\n        _n = _n / 2;\n        _p =\
    \ (_p * _p) % p;\n    }\n    res", "    let mut x = 1;\n    let mut y = n;\n \
    \   while p > 1 {\n        if p % 2 == 0 {\n            y = y * y % p;\n     \
    \       p /= 2;\n        } else {\n            x = x * y % p;\n            p -=\
    \ 1;\n        }\n    }\n    x * y % p", "    if n >= p {\n        return modp(n\
    \ % p, p);\n    } else if n == 0 {\n        return 1;\n    } else if n % 2 ==\
    \ 0 {\n        return modp(n * 2, p) % p;\n    } else {\n        return (modp(n\
    \ - 1, p) + p) % p;\n    }", "    if n == 0 {\n        return 1;\n    }\n    if\
    \ n % 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n  \
    \      n * modp(n - 1, p) % p\n    }", "    let mut n = n;\n    let mut res =\
    \ 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * p)\
    \ % 101;\n        }\n        n /= 2;\n        p = (p * p) % 101;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    if n % 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n   \
    \ } else {\n        n * modp(n - 1, p) % p\n    }", "    if n == 0 {\n       \
    \ return 1;\n    }\n    if n % 2 == 0 {\n        let x = modp(n / 2, p);\n   \
    \     return (x * x) % p;\n    }\n    let x = modp(n - 1, p);\n    return (x *\
    \ (n % p)) % p;", "    let mut n = n % p;\n    if n < 0 {\n        n += p;\n \
    \   }\n    n", "    let mut res = 1;\n    let mut k = n;\n    let mut b = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * b) % p;\n\
    \        }\n        k = k / 2;\n        b = (b * b) % p;\n    }\n    res", " \
    \   if n < 0 {\n        modp(n + p, p)\n    } else if n == 0 {\n        1\n  \
    \  } else if n % 2 == 0 {\n        square(modp(n / 2, p)) % p\n    } else {\n\
    \        (modp(n - 1, p) * n) % p\n    }"]
stop_tokens:
- "\n}"
