name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ["    let mut a = 1;\n    let mut b = n;\n    while b > 0 {\n       \
    \ if b % 2 == 1 {\n            a = (a * n) % p;\n        }\n        b = b / 2;\n\
    \        n = (n * n) % p;\n    }\n    a", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n == 1 {\n        return n;\n    }\n    let mut n = n;\n    let\
    \ mut p = p;\n    n %= p;\n    let mut x = 1;\n    let mut y = 2;\n    while n\
    \ > 1 {\n        if n % 2 == 0 {\n            n /= 2;\n            y = (y * y)\
    \ % p;\n        } else {\n            n -= 1;\n            x = (x * y) % p;\n\
    \        }\n    }\n    x * y % p", "    if n < 0 {\n        return modp(-n, p);\n\
    \    }\n    if n < p {\n        return n;\n    }\n    let mut n = n;\n    let\
    \ mut x = 2;\n    let mut y = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            y = (x * y) % p;\n        }\n        x = (x * x) % p;\n        n\
    \ = n / 2;\n    }\n    y", "    if n == 0 {\n        return 1;\n    }\n    let\
    \ mut res = 1;\n    let mut a = n;\n    let mut b = p - 2;\n    while b > 0 {\n\
    \        if b % 2 == 1 {\n            res = (res * a) % p;\n        }\n      \
    \  a = (a * a) % p;\n        b /= 2;\n    }\n    res", "    if n == 0 {\n    \
    \    return 1;\n    }\n    let mut k = n / 2;\n    let mut m = 1;\n    if n %\
    \ 2 == 1 {\n        m = 2;\n    }\n    let (x, y) = (modp(k, p), modp(k, p));\n\
    \    return (x * x * m) % p;", "    // TODO : this should be a test for isize\n\
    \    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    let mut n = n;\n    // TODO : this should be a test for isize\n  \
    \  if n < 0 {\n        n = -n;\n    }\n    let mut result = 1;\n    let mut x\
    \ = n % p;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * x) % p;\n        }\n        n = n / 2;\n        x = (x * x) % p;\n    }\n\
    \    result", "    let mut r = 1;\n    let mut m = n;\n    while m > 0 {\n   \
    \     r = (r * m) % p;\n        m -= 1;\n    }\n    r", "    let mut d: isize\
    \ = 1;\n    let mut m: isize = n;\n    let mut r: isize = 0;\n    while m > 0\
    \ {\n        r = m % 2;\n        m = m / 2;\n        if r > 0 {\n            d\
    \ = (d * n) % p;\n        }\n        n = (n * n) % p;\n    }\n    d", "    let\
    \ mut r = 1;\n    let mut a = n;\n    let mut b = p;\n    while b > 0 {\n    \
    \    if b % 2 == 1 {\n            r = (r * a) % p;\n        }\n        a = (a\
    \ * a) % p;\n        b /= 2;\n    }\n    r", "    // To do:\n    // 2. code up\
    \ modp\n    // 3. make tests pass\n    unimplemented!()", "    if n < 0 {\n  \
    \      modp(n + p, p)\n    } else if n == 0 {\n        1\n    } else if n == 1\
    \ {\n        n\n    } else if n % 2 == 0 {\n        let d = modp(n / 2, p);\n\
    \        d * d % p\n    } else {\n        let d = modp(n - 1, p);\n        n *\
    \ d % p\n    }", "    let mut res = 1;\n    let mut base = n;\n    while base\
    \ > 0 {\n        if base & 1 != 0 {\n            res = res * n % p;\n        }\n\
    \        base >>= 1;\n        n = n * n % p;\n    }\n    res", "    if n < 1 {\n\
    \        return 1;\n    }\n\n    let mut r = 1;\n    let mut r_m = modp(n / 2,\
    \ p);\n    for _ in 0..n {\n        r = (r * r_m) % p;\n    }\n    r", "    if\
    \ n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n   \
    \ }\n    let result = modp(n / 2, p);\n    let result = (result * result) % p;\n\
    \    if n % 2 == 0 {\n        return result;\n    } else {\n        return (result\
    \ * n) % p;\n    }", "    if n == 0 {\n        return 1;\n    }\n    if n % 2\
    \ == 0 {\n        let r = modp(n / 2, p);\n        return r * r % p;\n    }\n\
    \    return n * modp(n - 1, p) % p;", "    if n == 0 {\n        return 1;\n  \
    \  }\n\n    let mut base = modp(n / 2, p);\n    base = (base * base) % p;\n\n\
    \    if n % 2 == 1 {\n        return (base * 2) % p;\n    } else {\n        return\
    \ base;\n    }", "    assert!(p > 1);\n    let mut result = 1;\n    let mut n\
    \ = n;\n    let mut b = n;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       result = (result * b) % p;\n        }\n        b = (b * b) % p;\n    \
    \    n /= 2;\n    }\n    result", "    if n == 0 {\n        return 1;\n    }\n\
    \    if n % 2 == 0 {\n        let x = modp(n / 2, p);\n        return (x * x)\
    \ % p;\n    }\n    return ((n % p) * modp(n - 1, p)) % p;", "    if n == 0 {\n\
    \        return 1;\n    }\n    if n < 0 {\n        return modp(n + p - 1, p);\n\
    \    }\n    let (mut result, mut two) = (1, 2);\n    while two <= n {\n      \
    \  two = two * 2;\n    }\n    two = two / 2;\n    while two > 0 {\n        if\
    \ two <= n {\n            result = (result * result) % p;\n            n = n -\
    \ two;\n        } else {\n            result = (result * result) % p;\n      \
    \  }\n        two = two / 2;\n    }\n    result", "    // Initialize result\n\
    \    let mut res = 1;\n    // Update x if it is more\n    // than or equal to\
    \ p\n    let mut x = n;\n    while x >= p {\n        x -= p;\n    }\n    // Update\
    \ x if it is more\n    // than or equal to p\n    let mut y = p - 1;\n    while\
    \ y >= 1 {\n        // If y is odd, multiply\n        // x with result\n     \
    \   if y & 1 != 0 {\n            res = (res * x) % p;\n        }\n        // y\
    \ must be even now\n        // y = y / 2\n        y = y >> 1;\n        x = (x\
    \ * x) % p;\n    }\n    res"]
stop_tokens:
- "\n}"
