name: HumanEval_58_common
language: rs
results:
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut x = l1.clone();\n    let mut y\
    \ = l2.clone();\n    x.sort();\n    y.sort();\n    let mut a = Vec::new();\n \
    \   let mut b = Vec::new();\n    for i in 0..x.len() {\n        for j in 0..y.len()\
    \ {\n            if x[i] == y[j] {\n                a.push(x[i]);\n          \
    \      y.remove(j);\n                break;\n            }\n        }\n    }\n\
    \    for i in 0..a.len() {\n        if i == 0 {\n            b.push(a[i]);\n \
    \       } else {\n            if a[i] != a[i - 1] {\n                b.push(a[i]);\n\
    \            }\n        }\n    }\n    b\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    let mut\
    \ common = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n \
    \       if i >= v1.len() || j >= v2.len() {\n            break;\n        }\n \
    \       if v1[i] == v2[j] {\n            common.push(v1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    common\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpm7v3dbnr.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = Vec::new();\n    for i in l1\
    \ {\n        if l2.contains(&i) {\n            v.push(i);\n        }\n    }\n\
    \    v.sort();\n    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut tmp = l1.clone();\n    let mut\
    \ result = vec![];\n    for element in l2 {\n        if tmp.contains(&element)\
    \ {\n            result.push(element);\n            tmp.remove_item(&element);\n\
    \        }\n    }\n    result.sort();\n    result.dedup();\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remove_item` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpk7fs_lul.rs:12:17\n   |\n12 |          \
    \   tmp.remove_item(&element);\n   |                 ^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `remove`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgbjs2b8z.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let (m,\
    \ n) = (l1.len(), l2.len());\n    let (mut i, mut j) = (0, 0);\n    while i <\
    \ m && j < n {\n        if l1[i] < l2[j] {\n            i += 1;\n        } else\
    \ if l1[i] > l2[j] {\n            j += 1;\n        } else {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpr4bqm24z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \    let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    uniq_l1.retain(|x|\
    \ uniq_l2.contains(x));\n    uniq_l1.into_iter().collect::<Vec<isize>>()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprvdegibq.rs:7:48\n\
    \  |\n7 |     let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprvdegibq.rs:8:48\n\
    \  |\n8 |     let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut iter1\
    \ = l1.iter();\n    let mut iter2 = l2.iter();\n    let mut v1 = iter1.next();\n\
    \    let mut v2 = iter2.next();\n    while v1.is_some() && v2.is_some() {\n  \
    \      let a = v1.unwrap();\n        let b = v2.unwrap();\n        if a == b {\n\
    \            res.push(*a);\n            v1 = iter1.next();\n            v2 = iter2.next();\n\
    \        } else if a < b {\n            v1 = iter1.next();\n        } else {\n\
    \            v2 = iter2.next();\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // TODO: implement this function\n    let\
    \ len1 = l1.len();\n    let len2 = l2.len();\n    let mut unique = vec![];\n \
    \   let mut common = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    if len1\
    \ > len2 {\n        while i < len1 {\n            if !unique.contains(&l1[i])\
    \ {\n                unique.push(l1[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len2 {\n            if unique.contains(&l2[j]) {\n\
    \                common.push(l2[j]);\n            }\n            j += 1;\n   \
    \     }\n    } else {\n        while i < len2 {\n            if !unique.contains(&l2[i])\
    \ {\n                unique.push(l2[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len1 {\n            if unique.contains(&l1[j]) {\n\
    \                common.push(l1[j]);\n            }\n            j += 1;\n   \
    \     }\n    }\n    common.sort();\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // let mut answer = Vec::new();\n    //\
    \ for i in l1 {\n    //     if l2.contains(&i) {\n    //         answer.push(i);\n\
    \    //     }\n    // }\n    // answer.sort();\n    // answer.dedup();\n    //\
    \ answer\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpvmutg06f.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    let mut answer = Vec::new();\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            answer.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    answer\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp8r2tmxw6.rs:11:29\n   |\n11 |     let l1\
    \ = l1.into_iter().unique().collect::<Vec<isize>>();\n   |                   \
    \          ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror[E0599]:\
    \ no method named `unique` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmp8r2tmxw6.rs:12:29\n   |\n12 |     let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n\
    \   |                             ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut res: Vec<isize>\
    \ = Vec::new();\n\n    for n in l1 {\n        set1.insert(n);\n    }\n    for\
    \ n in l2 {\n        set2.insert(n);\n    }\n\n    for n in set1 {\n        if\
    \ set2.contains(&n) {\n            res.push(n);\n        }\n    }\n\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpu5u072d0.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpu5u072d0.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpu5u072d0.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpu5u072d0.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    let mut common = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n     \
    \   if v1[i] == v2[j] {\n            common.push(v1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if v1[i] < v2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ temp1 = l1.clone();\n    let mut temp2 = l2.clone();\n    temp1.sort();\n  \
    \  temp2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < temp1.len()\
    \ && j < temp2.len() {\n        if temp1[i] == temp2[j] {\n            result.push(temp1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if temp1[i] < temp2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n \
    \           j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // Sort vectors\n    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\n    // Walk through vectors,\
    \ comparing elements\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut out\
    \ = Vec::new();\n    while i1 < l1.len() && i2 < l2.len() {\n        let e1 =\
    \ l1[i1];\n        let e2 = l2[i2];\n        if e1 == e2 {\n            out.push(e1);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if e1 < e2 {\n   \
    \         i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \n    out\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut vec1 = l1.clone();\n    let mut\
    \ vec2 = l2.clone();\n    vec1.sort();\n    vec2.sort();\n    let mut vec1_iter\
    \ = vec1.into_iter();\n    let mut vec2_iter = vec2.into_iter();\n    let mut\
    \ vec1_next = vec1_iter.next();\n    let mut vec2_next = vec2_iter.next();\n \
    \   let mut intersection = Vec::new();\n    while vec1_next.is_some() && vec2_next.is_some()\
    \ {\n        if vec1_next.unwrap() == vec2_next.unwrap() {\n            intersection.push(vec1_next.unwrap());\n\
    \            vec1_next = vec1_iter.next();\n            vec2_next = vec2_iter.next();\n\
    \        } else if vec1_next.unwrap() < vec2_next.unwrap() {\n            vec1_next\
    \ = vec1_iter.next();\n        } else {\n            vec2_next = vec2_iter.next();\n\
    \        }\n    }\n    intersection\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
