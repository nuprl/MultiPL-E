language: rs
name: HumanEval_58_common
results:
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut x = l1.clone();\n    let mut y\
    \ = l2.clone();\n    x.sort();\n    y.sort();\n    let mut a = Vec::new();\n \
    \   let mut b = Vec::new();\n    for i in 0..x.len() {\n        for j in 0..y.len()\
    \ {\n            if x[i] == y[j] {\n                a.push(x[i]);\n          \
    \      y.remove(j);\n                break;\n            }\n        }\n    }\n\
    \    for i in 0..a.len() {\n        if i == 0 {\n            b.push(a[i]);\n \
    \       } else {\n            if a[i] != a[i - 1] {\n                b.push(a[i]);\n\
    \            }\n        }\n    }\n    b\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    v1.dedup();\n    v2.dedup();\n    let mut\
    \ common = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n \
    \       if i >= v1.len() || j >= v2.len() {\n            break;\n        }\n \
    \       if v1[i] == v2[j] {\n            common.push(v1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    common\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm7v3dbnr.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = Vec::new();\n    for i in l1\
    \ {\n        if l2.contains(&i) {\n            v.push(i);\n        }\n    }\n\
    \    v.sort();\n    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut tmp = l1.clone();\n    let mut\
    \ result = vec![];\n    for element in l2 {\n        if tmp.contains(&element)\
    \ {\n            result.push(element);\n            tmp.remove_item(&element);\n\
    \        }\n    }\n    result.sort();\n    result.dedup();\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_item` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpk7fs_lul.rs:12:17\n   |\n12 |          \
    \   tmp.remove_item(&element);\n   |                 ^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `remove`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let (m,\
    \ n) = (l1.len(), l2.len());\n    let (mut i, mut j) = (0, 0);\n    while i <\
    \ m && j < n {\n        if l1[i] < l2[j] {\n            i += 1;\n        } else\
    \ if l1[i] > l2[j] {\n            j += 1;\n        } else {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpr4bqm24z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \    let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    uniq_l1.retain(|x|\
    \ uniq_l2.contains(x));\n    uniq_l1.into_iter().collect::<Vec<isize>>()\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprvdegibq.rs:7:48\n\
    \  |\n7 |     let mut uniq_l1 = l1.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprvdegibq.rs:8:48\n\
    \  |\n8 |     let mut uniq_l2 = l2.into_iter().collect::<HashSet<isize>>();\n\
    \  |                                                ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut iter1\
    \ = l1.iter();\n    let mut iter2 = l2.iter();\n    let mut v1 = iter1.next();\n\
    \    let mut v2 = iter2.next();\n    while v1.is_some() && v2.is_some() {\n  \
    \      let a = v1.unwrap();\n        let b = v2.unwrap();\n        if a == b {\n\
    \            res.push(*a);\n            v1 = iter1.next();\n            v2 = iter2.next();\n\
    \        } else if a < b {\n            v1 = iter1.next();\n        } else {\n\
    \            v2 = iter2.next();\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // TODO: implement this function\n    let\
    \ len1 = l1.len();\n    let len2 = l2.len();\n    let mut unique = vec![];\n \
    \   let mut common = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    if len1\
    \ > len2 {\n        while i < len1 {\n            if !unique.contains(&l1[i])\
    \ {\n                unique.push(l1[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len2 {\n            if unique.contains(&l2[j]) {\n\
    \                common.push(l2[j]);\n            }\n            j += 1;\n   \
    \     }\n    } else {\n        while i < len2 {\n            if !unique.contains(&l2[i])\
    \ {\n                unique.push(l2[i]);\n            }\n            i += 1;\n\
    \        }\n        while j < len1 {\n            if unique.contains(&l1[j]) {\n\
    \                common.push(l1[j]);\n            }\n            j += 1;\n   \
    \     }\n    }\n    common.sort();\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // let mut answer = Vec::new();\n    //\
    \ for i in l1 {\n    //     if l2.contains(&i) {\n    //         answer.push(i);\n\
    \    //     }\n    // }\n    // answer.sort();\n    // answer.dedup();\n    //\
    \ answer\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpvmutg06f.rs:21:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    let mut answer = Vec::new();\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            answer.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    answer\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp8r2tmxw6.rs:11:29\n   |\n11 |     let l1\
    \ = l1.into_iter().unique().collect::<Vec<isize>>();\n   |                   \
    \          ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror[E0599]:\
    \ no method named `unique` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmp8r2tmxw6.rs:12:29\n   |\n12 |     let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n\
    \   |                             ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut res: Vec<isize>\
    \ = Vec::new();\n\n    for n in l1 {\n        set1.insert(n);\n    }\n    for\
    \ n in l2 {\n        set2.insert(n);\n    }\n\n    for n in set1 {\n        if\
    \ set2.contains(&n) {\n            res.push(n);\n        }\n    }\n\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpu5u072d0.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpu5u072d0.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpu5u072d0.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpu5u072d0.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    let mut common = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n     \
    \   if v1[i] == v2[j] {\n            common.push(v1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if v1[i] < v2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ temp1 = l1.clone();\n    let mut temp2 = l2.clone();\n    temp1.sort();\n  \
    \  temp2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < temp1.len()\
    \ && j < temp2.len() {\n        if temp1[i] == temp2[j] {\n            result.push(temp1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if temp1[i] < temp2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n \
    \           j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // Sort vectors\n    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\n    // Walk through vectors,\
    \ comparing elements\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut out\
    \ = Vec::new();\n    while i1 < l1.len() && i2 < l2.len() {\n        let e1 =\
    \ l1[i1];\n        let e2 = l2[i2];\n        if e1 == e2 {\n            out.push(e1);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if e1 < e2 {\n   \
    \         i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \n    out\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut vec1 = l1.clone();\n    let mut\
    \ vec2 = l2.clone();\n    vec1.sort();\n    vec2.sort();\n    let mut vec1_iter\
    \ = vec1.into_iter();\n    let mut vec2_iter = vec2.into_iter();\n    let mut\
    \ vec1_next = vec1_iter.next();\n    let mut vec2_next = vec2_iter.next();\n \
    \   let mut intersection = Vec::new();\n    while vec1_next.is_some() && vec2_next.is_some()\
    \ {\n        if vec1_next.unwrap() == vec2_next.unwrap() {\n            intersection.push(vec1_next.unwrap());\n\
    \            vec1_next = vec1_iter.next();\n            vec2_next = vec2_iter.next();\n\
    \        } else if vec1_next.unwrap() < vec2_next.unwrap() {\n            vec1_next\
    \ = vec1_iter.next();\n        } else {\n            vec2_next = vec2_iter.next();\n\
    \        }\n    }\n    intersection\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut\
    \ l3 = vec![];\n    for i in l1 {\n        if l2.contains(&i) {\n            l3.push(i);\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut rv = Vec::new();\n    let mut v1\
    \ = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len()\
    \ {\n        if v1[i] == v2[j] {\n            rv.push(v1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    rv\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // Convert both lists to hash sets.\n \
    \   let h1: HashSet<isize> = l1.into_iter().collect();\n    let h2: HashSet<isize>\
    \ = l2.into_iter().collect();\n\n    // Compute the intersection of the two hash\
    \ sets.\n    let intersection: HashSet<isize> = h1.intersection(&h2).cloned().collect();\n\
    \n    // Transform the set into a vector and sort it.\n    let mut result: Vec<isize>\
    \ = intersection.into_iter().collect();\n    result.sort();\n\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpyscek88t.rs:8:13\n\
    \  |\n8 |     let h1: HashSet<isize> = l1.into_iter().collect();\n  |        \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpyscek88t.rs:9:13\n  |\n9 |     let h2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyscek88t.rs:12:23\n\
    \   |\n12 |     let intersection: HashSet<isize> = h1.intersection(&h2).cloned().collect();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut v1\
    \ = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len()\
    \ {\n        if v1[i] == v2[j] {\n            result.push(v1[i]);\n          \
    \  i += 1;\n            j += 1;\n        } else if v1[i] < v2[j] {\n         \
    \   i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  let mut l3 = l1.iter().collect::<Vec<&isize>>();\n\
    \  l3.sort();\n  let mut l4 = l2.iter().collect::<Vec<&isize>>();\n  l4.sort();\n\
    \  let mut l5 = l3.iter().cloned().collect::<Vec<isize>>();\n  l5.retain(|x| l4.binary_search(&x).is_ok());\n\
    \  l5.sort();\n  l5.dedup();\n  l5\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpjlwpjkw_.rs:11:35\n     |\n\
    11   |   let mut l5 = l3.iter().cloned().collect::<Vec<isize>>();\n     |    \
    \                               ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let (mut\
    \ i, mut j) = (0, 0);\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            if res.len() == 0 || res[res.len() - 1] != l1[i] {\n\
    \                res.push(l1[i]);\n            }\n            i += 1;\n      \
    \      j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n     \
    \   } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw1t25twv.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_elements: Vec<isize> = Vec::new();\n\
    \    let mut sorted_unique_list1 = sorted_unique(l1);\n    let mut sorted_unique_list2\
    \ = sorted_unique(l2);\n    while sorted_unique_list1.len() > 0 && sorted_unique_list2.len()\
    \ > 0 {\n        let value1 = sorted_unique_list1[0];\n        let value2 = sorted_unique_list2[0];\n\
    \        if value1 < value2 {\n            sorted_unique_list1.remove(0);\n  \
    \      } else if value1 > value2 {\n            sorted_unique_list2.remove(0);\n\
    \        } else {\n            common_elements.push(value1);\n            sorted_unique_list1.remove(0);\n\
    \            sorted_unique_list2.remove(0);\n        }\n    }\n    common_elements\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_unique` in this scope\n -->\
    \ /tmp/tmpg8dm4o6u.rs:8:35\n  |\n8 |     let mut sorted_unique_list1 = sorted_unique(l1);\n\
    \  |                                   ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `sorted_unique` in this scope\n --> /tmp/tmpg8dm4o6u.rs:9:35\n\
    \  |\n9 |     let mut sorted_unique_list2 = sorted_unique(l2);\n  |          \
    \                         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let set1: HashSet<_> = l1.iter().collect();\n\
    \    let set2: HashSet<_> = l2.iter().collect();\n    let result = set1.intersection(&set2).cloned().collect::<Vec<isize>>();\n\
    \    result.sort();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpt5f76z87.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<_> = l1.iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n --> /tmp/tmpt5f76z87.rs:8:15\n  |\n8 |     let set2: HashSet<_>\
    \ = l2.iter().collect();\n  |               ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            if result.len() == 0 || result[result.len()\
    \ - 1] != l1[i] {\n                result.push(l1[i]);\n            }\n      \
    \      i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpkgwuu9le.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().cloned().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp9718ia23.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut t1 = l1.clone();\n    let mut t2\
    \ = l2.clone();\n    t1.sort();\n    t2.sort();\n    let mut t3 = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < t1.len() && j < t2.len()\
    \ {\n        if t1[i] < t2[j] {\n            i += 1;\n        } else if t1[i]\
    \ > t2[j] {\n            j += 1;\n        } else {\n            t3.push(t1[i]);\n\
    \            i += 1;\n            j += 1;\n        }\n    }\n    t3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1\n        .iter()\n\
    \        .filter(|&x| l2.contains(x))\n        .cloned()\n        .collect::<Vec<isize>>();\n\
    \    result.sort();\n    result.dedup();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ l1idx = 0;\n    let mut l2idx = 0;\n    while l1idx < l1.len() && l2idx < l2.len()\
    \ {\n        if l1[l1idx] == l2[l2idx] {\n            result.push(l1[l1idx]);\n\
    \            l1idx += 1;\n            l2idx += 1;\n        } else if l1[l1idx]\
    \ < l2[l2idx] {\n            l1idx += 1;\n        } else {\n            l2idx\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw_c2ccsw.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    let mut iter1 = l1.iter();\n    let mut iter2 = l2.iter();\n\
    \    let mut item1 = iter1.next();\n    let mut item2 = iter2.next();\n    while\
    \ item1.is_some() && item2.is_some() {\n        if item1.unwrap() < item2.unwrap()\
    \ {\n            item1 = iter1.next();\n        } else if item1.unwrap() > item2.unwrap()\
    \ {\n            item2 = iter2.next();\n        } else {\n            result.push(*item1.unwrap());\n\
    \            item1 = iter1.next();\n            item2 = iter2.next();\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut uniqued = l1.clone();\n    uniqued.dedup();\n\
    \    uniqued.retain(|x| l2.contains(x));\n    uniqued\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp1v0zuxrs.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut\
    \ l2: Vec<isize> = l2;\n    l1.sort();\n    l2.sort();\n    let mut l: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            l.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ht: HashMap<isize, bool> = HashMap::new();\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for elem in l1 {\n        ht.insert(elem,\
    \ true);\n    }\n    for elem in l2 {\n        if ht.contains_key(&elem) {\n \
    \           result.push(elem);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmphhexnr_5.rs:7:17\n\
    \  |\n7 |     let mut ht: HashMap<isize, bool> = HashMap::new();\n  |        \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n --> /tmp/tmphhexnr_5.rs:7:40\n\
    \  |\n7 |     let mut ht: HashMap<isize, bool> = HashMap::new();\n  |        \
    \                                ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n \
    \   let mut h1: HashSet<isize> = HashSet::new();\n    let mut h2: HashSet<isize>\
    \ = HashSet::new();\n    for i in l1 {\n        h1.insert(i);\n    }\n    for\
    \ i in l2 {\n        h2.insert(i);\n    }\n    for i in h1 {\n        if h2.contains(&i)\
    \ {\n            v.push(i);\n        }\n    }\n    v.sort();\n    v\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpnlfpnhga.rs:8:17\n\
    \  |\n8 |     let mut h1: HashSet<isize> = HashSet::new();\n  |              \
    \   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpnlfpnhga.rs:8:34\n  |\n8 |  \
    \   let mut h1: HashSet<isize> = HashSet::new();\n  |                        \
    \          ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpnlfpnhga.rs:9:17\n  |\n9 | \
    \    let mut h2: HashSet<isize> = HashSet::new();\n  |                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpnlfpnhga.rs:9:34\n  |\n9 |     let\
    \ mut h2: HashSet<isize> = HashSet::new();\n  |                              \
    \    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut list1 = l1.clone();\n    let mut\
    \ list2 = l2.clone();\n    list1.sort();\n    list2.sort();\n    let mut l1_i\
    \ = 0;\n    let mut l2_i = 0;\n    let mut common_list = Vec::new();\n    while\
    \ l1_i < list1.len() && l2_i < list2.len() {\n        if list1[l1_i] == list2[l2_i]\
    \ {\n            common_list.push(list1[l1_i]);\n            l1_i += 1;\n    \
    \        l2_i += 1;\n        } else if list1[l1_i] < list2[l2_i] {\n         \
    \   l1_i += 1;\n        } else {\n            l2_i += 1;\n        }\n    }\n \
    \   common_list\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut\
    \ l2: Vec<isize> = l2;\n    l1.sort();\n    l2.sort();\n    let mut res: Vec<isize>\
    \ = Vec::new();\n    let mut a = 0;\n    let mut b = 0;\n    while a < l1.len()\
    \ && b < l2.len() {\n        if l1[a] < l2[b] {\n            a += 1;\n       \
    \ } else if l1[a] > l2[b] {\n            b += 1;\n        } else {\n         \
    \   res.push(l1[a]);\n            a += 1;\n            b += 1;\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut r: Vec<isize> = Vec::new();\n   \
    \ let mut i1 = 0;\n    let mut i2 = 0;\n    loop {\n        if i1 == l1.len()\
    \ || i2 == l2.len() {\n            break;\n        }\n        if l1[i1] == l2[i2]\
    \ {\n            r.push(l1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        } else if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else {\n\
    \            i2 += 1;\n        }\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut\
    \ l2: Vec<isize> = l2;\n    let mut output: Vec<isize> = Vec::new();\n    l1.sort();\n\
    \    l2.sort();\n    let mut it1 = l1.iter();\n    let mut it2 = l2.iter();\n\
    \    let mut e1 = it1.next();\n    let mut e2 = it2.next();\n    while e1.is_some()\
    \ && e2.is_some() {\n        if e1.unwrap() < e2.unwrap() {\n            e1 =\
    \ it1.next();\n        } else if e1.unwrap() > e2.unwrap() {\n            e2 =\
    \ it2.next();\n        } else {\n            output.push(*e1.unwrap());\n    \
    \        e1 = it1.next();\n            e2 = it2.next();\n        }\n    }\n  \
    \  output\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    for i in l1 {\n     \
    \   set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n    }\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in set1.intersection(&set2)\
    \ {\n        result.push(*i);\n    }\n    result.sort();\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmphitsspjf.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmphitsspjf.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmphitsspjf.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmphitsspjf.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let len1 = l1.len();\n    let len2 = l2.len();\n\
    \    while i < len1 && j < len2 {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            result.push(l1[i]);\n            i += 1;\n            j += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v: Vec<isize> = l1.iter().cloned().collect();\n\
    \    v.extend(l2.iter().cloned());\n    v.sort();\n    v.dedup();\n    v\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 9, 34, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpghk2j4rl.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut uniq = HashSet::new();\n    for\
    \ &x in &l1 {\n        uniq.insert(x);\n    }\n    for &x in &l2 {\n        uniq.insert(x);\n\
    \    }\n    uniq.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpc6togx4v.rs:7:20\n  |\n7 |     let mut uniq = HashSet::new();\n  | \
    \                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976060
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut nums1 = l1;\n    let mut nums2\
    \ = l2;\n    nums1.sort();\n    nums2.sort();\n    let mut nums1_it = nums1.iter();\n\
    \    let mut nums2_it = nums2.iter();\n    let mut nums1_element = nums1_it.next();\n\
    \    let mut nums2_element = nums2_it.next();\n    let mut out = Vec::new();\n\
    \    while nums1_element != None && nums2_element != None {\n        let a = nums1_element.unwrap();\n\
    \        let b = nums2_element.unwrap();\n        if a == b {\n            out.push(*a);\n\
    \            nums1_element = nums1_it.next();\n            nums2_element = nums2_it.next();\n\
    \        } else if a < b {\n            nums1_element = nums1_it.next();\n   \
    \     } else {\n            nums2_element = nums2_it.next();\n        }\n    }\n\
    \    out\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // TODO\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp94jjhmpa.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    fn cmp(x: &isize, y: &isize) -> Ordering\
    \ {\n        if x < y {\n            Ordering::Less\n        } else if x > y {\n\
    \            Ordering::Greater\n        } else {\n            Ordering::Equal\n\
    \        }\n    }\n\n    let mut l3 = l1.clone();\n    l3.extend(l2.clone());\n\
    \    l3.sort_by(cmp);\n    let mut l4 = Vec::new();\n    let mut last_x = None;\n\
    \    for x in l3 {\n        if x == last_x.unwrap_or(0) {\n            l4.push(x);\n\
    \        }\n        last_x = Some(x);\n    }\n    l4\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n -->\
    \ /tmp/tmpzw35e9qh.rs:9:13\n  |\n9 |             Ordering::Less\n  |         \
    \    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpzw35e9qh.rs:11:13\n   |\n11\
    \ |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpzw35e9qh.rs:13:13\n   |\n13 |             Ordering::Equal\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0412]: cannot\
    \ find type `Ordering` in this scope\n --> /tmp/tmpzw35e9qh.rs:7:37\n  |\n7 |\
    \     fn cmp(x: &isize, y: &isize) -> Ordering {\n  |                        \
    \             ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ one of these items\n  |\n1 | use std::cmp::Ordering;\n  |\n1 | use std::sync::atomic::Ordering;\n\
    \  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    let mut\
    \ a1 = l1.iter();\n    let mut a2 = l2.iter();\n    let mut e1 = a1.next();\n\
    \    let mut e2 = a2.next();\n    while e1.is_some() && e2.is_some() {\n     \
    \   let v1 = e1.unwrap();\n        let v2 = e2.unwrap();\n        if v1 == v2\
    \ {\n            result.push(*v1);\n            e1 = a1.next();\n            e2\
    \ = a2.next();\n        } else if v1 < v2 {\n            e1 = a1.next();\n   \
    \     } else {\n            e2 = a2.next();\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut new_list: Vec<isize>\
    \ = Vec::new();\n\n    for item in l1 {\n        set1.insert(item);\n    }\n\n\
    \    for item in l2 {\n        set2.insert(item);\n    }\n\n    for item in set1\
    \ {\n        if set2.contains(&item) {\n            new_list.push(item);\n   \
    \     }\n    }\n\n    new_list.sort();\n    new_list\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpipk14ewl.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpipk14ewl.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpipk14ewl.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpipk14ewl.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let commons = set1.intersection(&set2);\n\
    \    let mut sorted_commons: Vec<isize> = commons.cloned().collect();\n    sorted_commons.sort();\n\
    \    sorted_commons\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpc4tx2pdf.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<isize> = l1.into_iter().collect();\n  |      \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpc4tx2pdf.rs:8:15\n  |\n8 | \
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp1v0zuxrs.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // build intersections\n    let mut l1_s\
    \ = l1.clone();\n    let mut l2_s = l2.clone();\n    l1_s.sort();\n    l2_s.sort();\n\
    \    l1_s.dedup();\n    l2_s.dedup();\n    let mut l1_s = l1_s.iter();\n    let\
    \ mut l2_s = l2_s.iter();\n    let mut l1_s_cur = l1_s.next();\n    let mut l2_s_cur\
    \ = l2_s.next();\n    let mut res = Vec::new();\n    loop {\n        match (l1_s_cur,\
    \ l2_s_cur) {\n            (Some(v1), Some(v2)) => {\n                if v1 <\
    \ v2 {\n                    l1_s_cur = l1_s.next();\n                } else if\
    \ v1 > v2 {\n                    l2_s_cur = l2_s.next();\n                } else\
    \ {\n                    res.push(*v1);\n                    l1_s_cur = l1_s.next();\n\
    \                    l2_s_cur = l2_s.next();\n                }\n            }\n\
    \            _ => break,\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    for x in l1\
    \ {\n        if l2.contains(&x) {\n            res.push(x);\n        }\n    }\n\
    \    res.sort();\n    res.dedup();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_vec: Vec<isize> = Vec::new();\n\
    \    let mut first_iter = l1.iter();\n    let mut second_iter = l2.iter();\n \
    \   loop {\n        let mut el1 = first_iter.next();\n        let mut el2 = second_iter.next();\n\
    \        match (el1, el2) {\n            (Some(first), Some(second)) => {\n  \
    \              if first == second {\n                    common_vec.push(*first);\n\
    \                } else if first < second {\n                    el2 = second_iter.next();\n\
    \                } else {\n                    el1 = first_iter.next();\n    \
    \            }\n            }\n            _ => break,\n        }\n    }\n   \
    \ common_vec\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpohdqy23r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // These are ordered arrays\n    // We\
    \ should sort and then return the sorted unique elements\n    let mut l3 = vec![];\n\
    \    let mut p1 = 0;\n    let mut p2 = 0;\n    let len1 = l1.len();\n    let len2\
    \ = l2.len();\n    while p1 < len1 && p2 < len2 {\n        if l1[p1] < l2[p2]\
    \ {\n            p1 += 1;\n        } else if l1[p1] > l2[p2] {\n            p2\
    \ += 1;\n        } else {\n            l3.push(l1[p1]);\n            p1 += 1;\n\
    \            p2 += 1;\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpcoowl26u.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1_clone\
    \ = l1.clone();\n    let mut l2_clone = l2.clone();\n    for i in l1_clone {\n\
    \        for j in l2_clone.clone() {\n            if i == j {\n              \
    \  result.push(i);\n                let index = l2_clone.iter().position(|&x|\
    \ x == j).unwrap();\n                l2_clone.remove(index);\n            }\n\
    \        }\n    }\n    result.sort();\n    result.dedup();\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut\
    \ l2: Vec<isize> = l2;\n    let mut common: Vec<isize> = Vec::new();\n    l1.sort();\n\
    \    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_values: Vec<isize> = vec![];\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    for val in l2 {\n   \
    \     set2.insert(val);\n    }\n    for val in l1 {\n        if set2.contains(&val)\
    \ {\n            common_values.push(val);\n        }\n    }\n    common_values.sort();\n\
    \    common_values.dedup();\n    common_values\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprgue3l_d.rs:8:19\n\
    \  |\n8 |     let mut set2: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmprgue3l_d.rs:8:36\n  |\n8 |  \
    \   let mut set2: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ a = l1.clone();\n    let mut b = l2.clone();\n    a.sort();\n    b.sort();\n\
    \    while a.len() > 0 && b.len() > 0 {\n        if a[0] == b[0] {\n         \
    \   result.push(a[0]);\n            a.remove(0);\n            b.remove(0);\n \
    \       } else if a[0] < b[0] {\n            a.remove(0);\n        } else {\n\
    \            b.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut unique = vec![];\n    let mut l1\
    \ = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let (mut i,\
    \ mut j) = (0, 0);\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            if unique.is_empty() || unique[unique.len() - 1] !=\
    \ l1[i] {\n                unique.push(l1[i]);\n            }\n            i +=\
    \ 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    unique\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_vector: Vec<isize> = Vec::new();\n\
    \    let mut current_left_pointer = 0;\n    let mut current_right_pointer = 0;\n\
    \    let mut left_vector = l1.clone();\n    let mut right_vector = l2.clone();\n\
    \    left_vector.sort();\n    right_vector.sort();\n    left_vector.dedup();\n\
    \    right_vector.dedup();\n    while current_left_pointer < left_vector.len()\
    \ && current_right_pointer < right_vector.len() {\n        let current_left_element\
    \ = left_vector[current_left_pointer];\n        let current_right_element = right_vector[current_right_pointer];\n\
    \        if current_left_element == current_right_element {\n            common_vector.push(current_left_element);\n\
    \            current_left_pointer += 1;\n            current_right_pointer +=\
    \ 1;\n        } else if current_left_element < current_right_element {\n     \
    \       current_left_pointer += 1;\n        } else {\n            current_right_pointer\
    \ += 1;\n        }\n    }\n    common_vector\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n     \
    \   if v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i] > v2[j] {\n\
    \            j += 1;\n        } else {\n            if result.is_empty() || v1[i]\
    \ != result[result.len() - 1] {\n                result.push(v1[i]);\n       \
    \     }\n            i += 1;\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  let mut l1 = l1;\n  let mut l2 = l2;\n  l1.sort();\n\
    \  l2.sort();\n  let mut common: Vec<isize> = Vec::new();\n  for n in l1 {\n \
    \   if l2.contains(&n) {\n      common.push(n);\n    }\n  }\n  common.sort();\n\
    \  common.dedup();\n  common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut common = vec![];\n    let mut last\
    \ = None;\n    for i in l1.iter() {\n        for j in l2.iter() {\n          \
    \  if i == j && last != Some(*i) {\n                common.push(*i);\n       \
    \         last = Some(*i);\n            }\n        }\n    }\n    common\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.extend(l2.clone());\n\
    \    result.sort();\n    result.dedup();\n    result.iter().filter(|&x| l1.contains(x)\
    \ && l2.contains(x)).cloned().collect()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = Vec::new();\n    let mut s\
    \ = BTreeSet::new();\n    for i in l1 {\n        s.insert(i);\n    }\n    for\
    \ i in l2 {\n        if s.contains(&i) {\n            v.push(i);\n        }\n\
    \    }\n    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n -->\
    \ /tmp/tmpax3b1w2y.rs:8:17\n  |\n8 |     let mut s = BTreeSet::new();\n  |   \
    \              ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::BTreeSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = l1.clone();\n    v.sort();\n\
    \    let mut v_u = v.clone();\n    v_u.dedup();\n    let mut v2 = l2.clone();\n\
    \    v2.sort();\n    let mut v2_u = v2.clone();\n    v2_u.dedup();\n    let mut\
    \ a = Vec::new();\n    for i in v_u {\n        for j in v2_u {\n            if\
    \ i == j {\n                a.push(i);\n            }\n        }\n    }\n    a\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `v2_u`\n   --> /tmp/tmp3x0b3us6.rs:17:18\n\
    \    |\n13  |     let mut v2_u = v2.clone();\n    |         -------- move occurs\
    \ because `v2_u` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    ...\n17  |         for j in v2_u {\n    |                  ^^^^ `v2_u` moved due\
    \ to this implicit call to `.into_iter()`, in previous iteration of loop\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `v2_u`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |         for j in &v2_u {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = l1.into_iter().collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.dedup();\n    let mut v2 = l2.into_iter().collect::<Vec<isize>>();\n\
    \    v2.sort();\n    v2.dedup();\n    v.into_iter().filter(|&x| v2.contains(&x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    for i in l1\
    \ {\n        if l2.contains(&i) {\n            res.push(i);\n        }\n    }\n\
    \    res.sort();\n    res.dedup();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut set1 = BTreeSet::new();\n    let\
    \ mut set2 = BTreeSet::new();\n    let mut result = Vec::new();\n    for elem\
    \ in l1 {\n        set1.insert(elem);\n    }\n    for elem in l2 {\n        set2.insert(elem);\n\
    \    }\n    for elem in set1.intersection(&set2) {\n        result.push(*elem);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  -->\
    \ /tmp/tmpttd1u9ot.rs:11:20\n   |\n11 |     let mut set1 = BTreeSet::new();\n\
    \   |                    ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmpttd1u9ot.rs:12:20\n\
    \   |\n12 |     let mut set2 = BTreeSet::new();\n   |                    ^^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::BTreeSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i1\
    \ = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len() {\n    \
    \    let el1 = l1[i1];\n        let el2 = l2[i2];\n        if el1 == el2 {\n \
    \           result.push(el1);\n            i1 += 1;\n            i2 += 1;\n  \
    \      } else if el1 < el2 {\n            i1 += 1;\n        } else {\n       \
    \     i2 += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmp7amqz0ab.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = l1.iter().cloned().collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.dedup();\n    let mut v2 = l2.iter().cloned().collect::<Vec<isize>>();\n\
    \    v2.sort();\n    v2.dedup();\n    let mut intersection = vec![];\n    for\
    \ el in v {\n        if v2.contains(&el) {\n            intersection.push(el);\n\
    \        }\n    }\n    intersection\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    for v in l1 {\n        set1.insert(v);\n    }\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for v in l2 {\n        set2.insert(v);\n    }\n    let\
    \ mut result: Vec<isize> = vec![];\n    for v in set1.intersection(&set2) {\n\
    \        result.push(*v);\n    }\n    result.sort();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzw6_d484.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpzw6_d484.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n  --> /tmp/tmpzw6_d484.rs:11:19\n   |\n11\
    \ |     let mut set2: HashSet<isize> = HashSet::new();\n   |                 \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpzw6_d484.rs:11:36\n   |\n11\
    \ |     let mut set2: HashSet<isize> = HashSet::new();\n   |                 \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1 {\n        if let Ok(_) = l2.binary_search(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result.dedup();\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 653]`,\n right: `[1, 5, 653]`', /tmp/tmp0ojstz34.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2\
    \ = l2.clone();\n    v1.sort();\n    v2.sort();\n    v1.dedup();\n    v2.dedup();\n\
    \    let mut l = vec![];\n    for x in v1 {\n        if v2.contains(&x) {\n  \
    \          l.push(x);\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut a = l1.clone();\n    let mut b\
    \ = l2.clone();\n    a.sort();\n    b.sort();\n    a.into_iter().filter(|x| b.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ idx1 = 0;\n    let mut idx2 = 0;\n    let len1 = l1.len();\n    let len2 = l2.len();\n\
    \    loop {\n        if idx1 == len1 || idx2 == len2 {\n            break;\n \
    \       }\n        if l1[idx1] == l2[idx2] {\n            res.push(l1[idx1]);\n\
    \            idx1 += 1;\n            idx2 += 1;\n        } else if l1[idx1] <\
    \ l2[idx2] {\n            idx1 += 1;\n        } else {\n            idx2 += 1;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1.clone();\n    let mut v2\
    \ = l2.clone();\n    v1.sort();\n    v2.sort();\n    let mut v3 = Vec::new();\n\
    \    let mut v4 = Vec::new();\n    v1.dedup();\n    v2.dedup();\n    for i in\
    \ v1 {\n        for j in v2.clone() {\n            if i == j {\n             \
    \   v3.push(i);\n            }\n        }\n    }\n    for i in v3 {\n        v4.push(i);\n\
    \    }\n    v4\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().collect::<HashSet<isize>>()\n\
    \        .intersection(&l2.into_iter().collect::<HashSet<isize>>())\n        .map(|x|\
    \ *x)\n        .collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpj4asskcf.rs:7:30\n\
    \  |\n7 |     l1.into_iter().collect::<HashSet<isize>>()\n  |                \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpj4asskcf.rs:8:49\n  |\n8 | \
    \        .intersection(&l2.into_iter().collect::<HashSet<isize>>())\n  |     \
    \                                            ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|&i| l2.contains(i)).map(|i|\
    \ *i).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmp9ztmyvam.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut l: Vec<isize>\
    \ = Vec::new();\n\n    for i in l1 {\n        set1.insert(i);\n    }\n    for\
    \ i in l2 {\n        set2.insert(i);\n    }\n\n    for i in set1 {\n        if\
    \ set2.contains(&i) {\n            l.push(i);\n        }\n    }\n\n    l.sort();\n\
    \    l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp3xn0d4jy.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp3xn0d4jy.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp3xn0d4jy.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmp3xn0d4jy.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut list = l1.clone();\n    list.extend(l2.clone());\n\
    \    let mut list = list.into_iter().collect::<HashSet<isize>>();\n    list.retain(|&x|\
    \ l1.contains(&x) && l2.contains(&x));\n    list.into_iter().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmptuz49dcu.rs:9:47\n\
    \  |\n9 |     let mut list = list.into_iter().collect::<HashSet<isize>>();\n \
    \ |                                               ^^^^^^^ not found in this scope\n\
    \  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x|\
    \ l2.contains(x)).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    for i in l1 {\n     \
    \   set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n    }\n\
    \    let mut set3: HashSet<isize> = HashSet::new();\n    for i in set1 {\n   \
    \     if set2.contains(&i) {\n            set3.insert(i);\n        }\n    }\n\
    \    let mut ret: Vec<isize> = Vec::new();\n    for i in set3 {\n        ret.push(i);\n\
    \    }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmppewbcds6.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmppewbcds6.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmppewbcds6.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmppewbcds6.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n  --> /tmp/tmppewbcds6.rs:15:19\n   |\n15 |     let\
    \ mut set3: HashSet<isize> = HashSet::new();\n   |                   ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmppewbcds6.rs:15:36\n   |\n15 |  \
    \   let mut set3: HashSet<isize> = HashSet::new();\n   |                     \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n\
    \    let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n    s1.retain(|&x|\
    \ s2.contains(&x));\n    s1.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpqc3ng4jx.rs:7:43\n\
    \  |\n7 |     let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n  |     \
    \                                      ^^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror[E0412]: cannot find type `BTreeSet` in this scope\n --> /tmp/tmpqc3ng4jx.rs:8:43\n\
    \  |\n8 |     let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n  |     \
    \                                      ^^^^^^^^ not found in this scope\n  |\n\
    help: consider importing this struct\n  |\n1 | use std::collections::BTreeSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ll1 = l1.clone();\n    let mut\
    \ ll2 = l2.clone();\n    ll1.sort();\n    ll2.sort();\n    let mut l = Vec::new();\n\
    \    let mut j = 0;\n    for i in 0..ll1.len() {\n        while j < ll2.len()\
    \ && ll2[j] < ll1[i] {\n            j += 1;\n        }\n        if j < ll2.len()\
    \ && ll2[j] == ll1[i] {\n            l.push(ll2[j]);\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().sorted().collect::<HashSet<isize>>()\n\
    \        .intersection(&l2.into_iter().sorted().collect::<HashSet<isize>>())\n\
    \        .cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpjaqsqu8y.rs:7:39\n\
    \  |\n7 |     l1.into_iter().sorted().collect::<HashSet<isize>>()\n  |       \
    \                                ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n --> /tmp/tmpjaqsqu8y.rs:8:58\n  |\n\
    8 |         .intersection(&l2.into_iter().sorted().collect::<HashSet<isize>>())\n\
    \  |                                                          ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n --> /tmp/tmpjaqsqu8y.rs:7:20\n  |\n7 |     l1.into_iter().sorted().collect::<HashSet<isize>>()\n\
    \  |                    ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n --> /tmp/tmpjaqsqu8y.rs:8:39\n  |\n8 |         .intersection(&l2.into_iter().sorted().collect::<HashSet<isize>>())\n\
    \  |                                       ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    for i in 0..l1.len()\
    \ {\n        for j in 0..l2.len() {\n            if l1[i] == l2[j] {\n       \
    \         res.push(l1[i]);\n            }\n        }\n    }\n    res.sort();\n\
    \    res.dedup();\n    res\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1;\n    l3.sort();\n    l3.dedup();\n\
    \    let mut l4 = l2;\n    l4.sort();\n    l4.dedup();\n    let mut l5 = Vec::new();\n\
    \    for i in l3 {\n        if l4.contains(&i) {\n            l5.push(i);\n  \
    \      }\n    }\n    l5\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    for i in l1 {\n        set1.insert(i);\n    }\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for i in l2 {\n        set2.insert(i);\n    }\n    let\
    \ intersection: HashSet<isize> = set1.intersection(&set2).map(|x| *x).collect();\n\
    \    let mut ret: Vec<isize> = Vec::new();\n    for i in intersection {\n    \
    \    ret.push(i);\n    }\n    ret.sort();\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp1un23ra3.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp1un23ra3.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n  --> /tmp/tmp1un23ra3.rs:11:19\n   |\n11\
    \ |     let mut set2: HashSet<isize> = HashSet::new();\n   |                 \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp1un23ra3.rs:11:36\n   |\n11\
    \ |     let mut set2: HashSet<isize> = HashSet::new();\n   |                 \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmp1un23ra3.rs:15:23\n\
    \   |\n15 |     let intersection: HashSet<isize> = set1.intersection(&set2).map(|x|\
    \ *x).collect();\n   |                       ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.retain(|x| l2.contains(x));\n    result.extend(l1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    // TODO: Implement\
    \ me!\n    let mut a = 0;\n    let mut b = 0;\n    while a < l1.len() && b < l2.len()\
    \ {\n        if l1[a] == l2[b] {\n            if !res.contains(&l1[a]) {\n   \
    \             res.push(l1[a]);\n            }\n            a += 1;\n         \
    \   b += 1;\n        } else if l1[a] < l2[b] {\n            a += 1;\n        }\
    \ else {\n            b += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            if res.len() == 0 || res[res.len() - 1] !=\
    \ l1[i] {\n                res.push(l1[i]);\n            }\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    for el in l1 {\n        if l2.contains(&el) {\n        \
    \    result.push(el);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  let mut l1 = l1;\n  let mut l2 = l2;\n  l1.sort();\n\
    \  l2.sort();\n  let mut i = 0;\n  let mut j = 0;\n  let mut common = Vec::new();\n\
    \  while i < l1.len() && j < l2.len() {\n    if l1[i] < l2[j] {\n      i += 1;\n\
    \    } else if l1[i] > l2[j] {\n      j += 1;\n    } else {\n      common.push(l1[i]);\n\
    \      i += 1;\n      j += 1;\n    }\n  }\n  common\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n       \
    \ if v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i] > v2[j] {\n\
    \            j += 1;\n        } else {\n            res.push(v1[i]);\n       \
    \     i += 1;\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // TODO\n    let mut v = Vec::new();\n\
    \    for i in l1 {\n        for j in l2 {\n            if i == j {\n         \
    \       v.push(i);\n            }\n        }\n    }\n    v.sort();\n    v.dedup();\n\
    \    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `l2`\n   --> /tmp/tmpricv1qr3.rs:10:18\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                           -- move occurs because `l2` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n10  |         for j in l2 {\n\
    \    |                  ^^ `l2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `l2`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10\
    \  |         for j in &l2 {\n    |                  +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let result: HashSet<isize>\
    \ = set1.intersection(&set2).cloned().collect();\n    let mut vec = result.into_iter().collect::<Vec<isize>>();\n\
    \    vec.sort();\n    vec\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp4wc2wy0a.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<isize> = l1.into_iter().collect();\n  |      \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp4wc2wy0a.rs:8:15\n  |\n8 | \
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n --> /tmp/tmp4wc2wy0a.rs:9:17\n  |\n9 |     let result: HashSet<isize>\
    \ = set1.intersection(&set2).cloned().collect();\n  |                 ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.into_iter().collect::<Vec<isize>>();\n\
    \    let mut l4 = l2.into_iter().collect::<Vec<isize>>();\n    l3.sort();\n  \
    \  l4.sort();\n    let mut l5 = Vec::new();\n    let mut j = 0;\n    for i in\
    \ 0..l3.len() {\n        if j < l4.len() && l3[i] == l4[j] {\n            l5.push(l3[i]);\n\
    \            j += 1;\n        } else if j < l4.len() && l3[i] > l4[j] {\n    \
    \        j += 1;\n            i -= 1;\n        }\n    }\n    l5\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmpegbbwwmw.rs:19:13\n\
    \   |\n19 |             i -= 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmpegbbwwmw.rs:19:13\n\
    \   |\n13 |     for i in 0..l3.len() {\n   |         -\n   |         |\n   | \
    \        first assignment to `i`\n   |         help: consider making this binding\
    \ mutable: `mut i`\n...\n19 |             i -= 1;\n   |             ^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let mut res: Vec<isize>\
    \ = set1.intersection(&set2).cloned().collect();\n    res.sort();\n    res\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp74ns4fyf.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<isize> = l1.into_iter().collect();\n  |      \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp74ns4fyf.rs:8:15\n  |\n8 | \
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp1v0zuxrs.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    for i in l1 {\n     \
    \   set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n    }\n\
    \    let mut common: Vec<isize> = Vec::new();\n    for i in set1.intersection(&set2)\
    \ {\n        common.push(*i);\n    }\n    common.sort();\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprfyd_hw3.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmprfyd_hw3.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmprfyd_hw3.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmprfyd_hw3.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s1 = l1.clone();\n    let mut s2\
    \ = l2.clone();\n    s1.sort();\n    s2.sort();\n    let mut unique_list: Vec<isize>\
    \ = Vec::new();\n    for i in s1.iter() {\n        if s2.contains(i) {\n     \
    \       if !unique_list.contains(i) {\n                unique_list.push(*i);\n\
    \            }\n        }\n    }\n    unique_list\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_vec: Vec<isize> = Vec::new();\n\
    \    for i in l1 {\n        if l2.contains(&i) {\n            common_vec.push(i);\n\
    \        }\n    }\n    common_vec.sort();\n    common_vec.dedup();\n    common_vec\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            if res.len() == 0 || l1[i] != res[res.len()\
    \ - 1] {\n                res.push(l1[i]);\n            }\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut l1_set = HashSet::new();\n    let\
    \ mut common = Vec::new();\n    for i in l1 {\n        l1_set.insert(i);\n   \
    \ }\n    for i in l2 {\n        if l1_set.contains(&i) {\n            common.push(i);\n\
    \        }\n    }\n    common.sort();\n    common.dedup();\n    common\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpt30xzclg.rs:11:22\n   |\n11 |     let mut l1_set = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut iter = l1.iter().cloned().filter(|&x|\
    \ l2.contains(&x));\n    let mut l = Vec::new();\n    for e in iter {\n      \
    \  l.push(e);\n    }\n    l.sort();\n    l.dedup();\n    l\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|&i| l2.contains(&i)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpdy2q4d5m.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut s1 = HashSet::new();\n    let mut\
    \ s2 = HashSet::new();\n    let mut out = HashSet::new();\n    for i in l1 {\n\
    \        s1.insert(i);\n    }\n    for i in l2 {\n        s2.insert(i);\n    }\n\
    \    for i in s1 {\n        if s2.contains(&i) {\n            out.insert(i);\n\
    \        }\n    }\n    let mut out: Vec<isize> = out.into_iter().collect();\n\
    \    out.sort();\n    out\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp27h72u3_.rs:7:18\n  |\n7 |     let mut s1 = HashSet::new();\n  |   \
    \               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp27h72u3_.rs:8:18\n\
    \  |\n8 |     let mut s2 = HashSet::new();\n  |                  ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp27h72u3_.rs:9:19\n  |\n9 |     let mut out = HashSet::new();\n  |  \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = Vec::new();\n    let mut l1\
    \ = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    for x in l1 {\n        if l2.contains(&x) {\n          \
    \  v.push(x);\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut r = vec![];\n    let l1s = l1.clone();\n\
    \    let l2s = l2.clone();\n    for i in l1s {\n        if l2s.contains(&i) {\n\
    \            r.push(i);\n        }\n    }\n    r.sort();\n    let mut s = vec![];\n\
    \    let rs = r.clone();\n    for i in rs {\n        if !s.contains(&i) {\n  \
    \          s.push(i);\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for n in\
    \ l1 {\n        if l2.contains(&n) {\n            result.push(n);\n        }\n\
    \    }\n    result.sort();\n    result.dedup();\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut v: Vec<isize> = Vec::new();\n   \
    \ let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < l1.len() && i2 < l2.len()\
    \ {\n        if l1[i1] == l2[i2] {\n            v.push(l1[i1]);\n            i1\
    \ += 1;\n            i2 += 1;\n        } else if l1[i1] < l2[i2] {\n         \
    \   i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n    v\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut n1 = l1.len();\n    let mut n2 = l2.len();\n\
    \    while i < n1 && j < n2 {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpr2vjdtax.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut common = vec![];\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if\
    \ l1[i] == l2[j] {\n            common.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    common\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.retain(|x| l2.contains(x));\n    let mut\
    \ l3 = l1.clone();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut u1 = l1.clone();\n    let mut u2\
    \ = l2.clone();\n    u1.sort();\n    u2.sort();\n    let mut i1 = 0;\n    let\
    \ mut i2 = 0;\n    let mut c: Vec<isize> = Vec::new();\n    while i1 < u1.len()\
    \ && i2 < u2.len() {\n        if u1[i1] == u2[i2] {\n            c.push(u1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        } else if u1[i1] < u2[i2]\
    \ {\n            i1 += 1;\n        } else {\n            i2 += 1;\n        }\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut result = Vec::new();\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            result.push(l1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw1t25twv.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut x: Vec<isize> = l1.into_iter().collect();\n\
    \    let mut y: Vec<isize> = l2.into_iter().collect();\n    x.sort();\n    y.sort();\n\
    \    let mut result: Vec<isize> = Vec::new();\n    let mut i: usize = 0;\n   \
    \ let mut j: usize = 0;\n    while i < x.len() && j < y.len() {\n        if x[i]\
    \ == y[j] {\n            result.push(x[i]);\n            i += 1;\n           \
    \ j += 1;\n        } else if x[i] < y[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ set = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut len1\
    \ = l1.len();\n    let mut len2 = l2.len();\n    while i < len1 && j < len2 {\n\
    \        if l1[i] == l2[j] {\n            if !set.contains(&l1[i]) {\n       \
    \         res.push(l1[i]);\n                set.insert(l1[i]);\n            }\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpgi4zpqql.rs:12:19\n   |\n12 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v1 = l1;\n    let mut v2 = l2;\n\
    \    v1.sort();\n    v2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n       \
    \ if v1[i] < v2[j] {\n            i += 1;\n        } else if v1[i] > v2[j] {\n\
    \            j += 1;\n        } else {\n            res.push(v1[i]);\n       \
    \     i += 1;\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut common = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            common.push(l1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in\
    \ l1 {\n        for j in l2.clone() {\n            if i == j {\n             \
    \   res.push(i);\n            }\n        }\n    }\n    res.sort();\n    res.dedup();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n\n    for v in l1 {\n        set1.insert(v);\n    }\n    for\
    \ v in l2 {\n        set2.insert(v);\n    }\n\n    let inter = set1.intersection(&set2);\n\
    \    for v in inter {\n        ret.push(*v);\n    }\n    ret.sort();\n    ret\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzabkqubf.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmpzabkqubf.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpzabkqubf.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmpzabkqubf.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).map(|&x|\
    \ x).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmprafgqusk.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().intersect(l2.into_iter()).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `intersect` found for struct `std::vec::IntoIter`\
    \ in the current scope\n --> /tmp/tmpu5x05d11.rs:7:20\n  |\n7 |     l1.into_iter().intersect(l2.into_iter()).cloned().collect()\n\
    \  |                    ^^^^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let v1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let v2: HashSet<isize> = l2.into_iter().collect();\n    v1.intersection(&v2).map(|i|\
    \ *i).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpch4l3qil.rs:7:13\n\
    \  |\n7 |     let v1: HashSet<isize> = l1.into_iter().collect();\n  |        \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n --> /tmp/tmpch4l3qil.rs:8:13\n  |\n8 |     let v2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  |             ^^^^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let s1: Vec<isize> = l1.iter().cloned().collect();\n\
    \    let s2: Vec<isize> = l2.iter().cloned().collect();\n    let mut v1: Vec<isize>\
    \ = s1.iter().cloned().collect();\n    let mut v2: Vec<isize> = s2.iter().cloned().collect();\n\
    \    v1.sort();\n    v2.sort();\n    return v1.iter().cloned().filter(|x| v2.contains(x)).collect();\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    // use cursor pattern to step through two\
    \ vectors at the same time\n    let mut res = Vec::new();\n    let mut l1_cursor\
    \ = 0;\n    let mut l2_cursor = 0;\n    while l1_cursor < l1.len() && l2_cursor\
    \ < l2.len() {\n        let el1 = l1[l1_cursor];\n        let el2 = l2[l2_cursor];\n\
    \        if el1 < el2 {\n            l1_cursor += 1;\n        } else if el1 >\
    \ el2 {\n            l2_cursor += 1;\n        } else {\n            // el1 ==\
    \ el2\n            res.push(el1);\n            l1_cursor += 1;\n            l2_cursor\
    \ += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = vec![];\n    for i in l1\
    \ {\n        if l2.contains(&i) {\n            res.push(i);\n        }\n    }\n\
    \    res.sort();\n    res.dedup();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    for v in\
    \ l1.iter() {\n        if l2.contains(v) {\n            result.push(*v);\n   \
    \     }\n    }\n    result.sort();\n    result.dedup();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|x|\
    \ l2.contains(x)).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut c = Vec::new();\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if\
    \ l1[i] == l2[j] {\n            c.push(l1[i]);\n            i += 1;\n        \
    \    j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n       \
    \ } else {\n            j += 1;\n        }\n    }\n    c\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut fvec = Vec::new();\n    let mut\
    \ bvec = Vec::new();\n    if l1.len() >= l2.len() {\n        fvec = l1;\n    \
    \    bvec = l2;\n    } else {\n        fvec = l2;\n        bvec = l1;\n    }\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in 0..bvec.len() {\n\
    \        for j in 0..fvec.len() {\n            if bvec[i] == fvec[j] {\n     \
    \           result.push(bvec[i]);\n            }\n        }\n    }\n    result.sort();\n\
    \    result.dedup();\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut c = l1.clone();\n    let mut d\
    \ = l2.clone();\n    c.sort();\n    d.sort();\n    c.dedup();\n    d.dedup();\n\
    \    let mut com: Vec<isize> = Vec::new();\n    for v in c {\n        if d.contains(&v)\
    \ {\n            com.push(v);\n        }\n    }\n    com\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] < l2[j] {\n            i += 1;\n        } else if l1[i] > l2[j] {\n\
    \            j += 1;\n        } else {\n            res.push(l1[i]);\n       \
    \     i += 1;\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let vec: Vec<isize>\
    \ = set1.intersection(&set2).map(|x| *x).collect();\n    let mut v_sorted = vec.clone();\n\
    \    v_sorted.sort();\n    v_sorted\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp1rx2eab9.rs:7:15\n\
    \  |\n7 |     let set1: HashSet<isize> = l1.into_iter().collect();\n  |      \
    \         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmp1rx2eab9.rs:8:15\n  |\n8 | \
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n  |               ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l: Vec<isize> = l1.clone();\n \
    \   l.extend(l2.clone());\n    let mut s: Vec<isize> = l.clone();\n    s.sort();\n\
    \    s.dedup();\n    s.into_iter().filter(|n| l1.contains(n) && l2.contains(n)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ li1 = l1.clone();\n    let mut li2 = l2.clone();\n    li1.sort();\n    li2.sort();\n\
    \    if li1.contains(&li2[0]) {\n        res.push(li2[0]);\n    }\n    li2.remove(0);\n\
    \    li1.retain(|x| x != &res[0]);\n    li2.retain(|x| x != &res[0]);\n    for\
    \ elem in li1 {\n        if li2.contains(&elem) {\n            res.push(elem);\n\
    \        }\n    }\n    res.sort();\n    res.dedup();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpx7cwvf0s.rs:12:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw1t25twv.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = Vec::new();\n    for i in\
    \ l1 {\n        for j in l2.clone() {\n            if i == j {\n             \
    \   l3.push(i);\n            }\n        }\n    }\n    l3.sort();\n    l3.dedup();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut sorted1 = l1.clone();\n    let\
    \ mut sorted2 = l2.clone();\n    sorted1.sort();\n    sorted2.sort();\n    sorted1.retain(|&x|\
    \ sorted2.contains(&x));\n    sorted1.dedup();\n    sorted1\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize> = Vec::new();\n\
    \    for num in l1 {\n        for num1 in l2.clone() {\n            if num ==\
    \ num1 {\n                vec.push(num)\n            }\n        }\n    }\n   \
    \ vec.sort();\n    vec.dedup();\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let l1 = set(l1);\n    let l2 = set(l2);\n\
    \    let mut result = Vec::new();\n    for item in l1 {\n        if l2.contains(&item)\
    \ {\n            result.push(item);\n        }\n    }\n    result.sort();\n  \
    \  result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `set` in this scope\n --> /tmp/tmprhq8tr5p.rs:7:14\n\
    \  |\n7 |     let l1 = set(l1);\n  |              ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `set` in this scope\n --> /tmp/tmprhq8tr5p.rs:8:14\n\
    \  |\n8 |     let l2 = set(l2);\n  |              ^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let length1 = l1.len();\n    let length2 = l2.len();\n\
    \    while i < length1 && j < length2 {\n        if l1[i] == l2[j] {\n       \
    \     result.push(l1[i]);\n            i += 1;\n            j += 1;\n        }\
    \ else if l1[i] < l2[j] {\n            i += 1;\n        } else {\n           \
    \ j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for n in\
    \ l1 {\n        if l2.contains(&n) {\n            result.push(n);\n        }\n\
    \    }\n    result.sort();\n    result.dedup();\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.iter().filter(|&x|\
    \ l2.contains(x)).cloned().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut r = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n        if l1[i]\
    \ == l2[j] {\n            if r.is_empty() || l1[i] != r[r.len() - 1] {\n     \
    \           r.push(l1[i]);\n            }\n            i += 1;\n            j\
    \ += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut output = Vec::new();\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            output.push(l1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // TODO: Implement the function.\n    let\
    \ mut sorted_l1 = l1.clone();\n    sorted_l1.sort();\n    let mut sorted_l2 =\
    \ l2.clone();\n    sorted_l2.sort();\n    let mut results: Vec<isize> = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < sorted_l1.len() && i2\
    \ < sorted_l2.len() {\n        if sorted_l1[i1] == sorted_l2[i2] {\n         \
    \   results.push(sorted_l1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        } else if sorted_l1[i1] < sorted_l2[i2] {\n            i1 += 1;\n   \
    \     } else {\n            i2 += 1;\n        }\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.intersect(&l2).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `intersect` found for struct `Vec<isize>`\
    \ in the current scope\n --> /tmp/tmp9jdzfowv.rs:7:8\n  |\n7 |     l1.intersect(&l2).cloned().collect()\n\
    \  |        ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `insert`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgbjs2b8z.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let (mut l1, mut l2) = (l1, l2);\n    l1.sort();\n\
    \    l2.sort();\n    let mut res = Vec::new();\n    let (mut l1i, mut l2i) = (0,\
    \ 0);\n    while l1i < l1.len() && l2i < l2.len() {\n        if l1[l1i] < l2[l2i]\
    \ {\n            l1i += 1;\n        } else if l1[l1i] > l2[l2i] {\n          \
    \  l2i += 1;\n        } else {\n            res.push(l1[l1i]);\n            l1i\
    \ += 1;\n            l2i += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l3.into_iter().filter(|x| l4.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    // Implement your solution here\n    l1.iter().cloned().collect::<HashSet<isize>>().intersection(&l2.iter().cloned().collect::<HashSet<isize>>()).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpkq5d278o.rs:8:34\n\
    \  |\n8 |     l1.iter().cloned().collect::<HashSet<isize>>().intersection(&l2.iter().cloned().collect::<HashSet<isize>>()).cloned().collect::<Vec<i...\n\
    \  |                                  ^^^^^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\
    \nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpkq5d278o.rs:8:95\n\
    \  |\n8 |     l1.iter().cloned().collect::<HashSet<isize>>().intersection(&l2.iter().cloned().collect::<HashSet<isize>>()).cloned().collect::<Vec<i...\n\
    \  |                                                                         \
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] < l2[j] {\n            i += 1;\n        } else if l1[i] > l2[j] {\n\
    \            j += 1;\n        } else {\n            result.push(l1[i]);\n    \
    \        i += 1;\n            j += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[653]`,\n right: `[1, 5, 653]`', /tmp/tmpev8o1gou.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n  let mut new: Vec<isize> = vec![];\n  let\
    \ mut index = 1;\n  let mut v1 = l1.clone();\n  let mut v2 = l2.clone();\n  v1.sort();\n\
    \  v2.sort();\n  v1.dedup();\n  v2.dedup();\n  for _elem in v1 {\n    if v2.contains(&_elem)\
    \ {\n      new.push(_elem);\n    }\n  }\n  new.sort();\n  new.dedup();\n  new\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ll1 = l1.clone();\n    let mut\
    \ ll2 = l2.clone();\n    ll1.sort();\n    ll2.sort();\n    let mut res = Vec::new();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let ll1_len = ll1.len();\n    let\
    \ ll2_len = ll2.len();\n    while i < ll1_len && j < ll2_len {\n        if ll1[i]\
    \ == ll2[j] {\n            res.push(ll1[i]);\n            i += 1;\n          \
    \  j += 1;\n        } else if ll1[i] < ll2[j] {\n            i += 1;\n       \
    \ } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v: Vec<isize> = l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect();\n    v.sort();\n    v.dedup();\n    v\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common_list: Vec<isize> = vec![];\n\
    \    for l in l1 {\n        if l2.contains(&l) {\n            common_list.push(l);\n\
    \        }\n    }\n    common_list.sort();\n    common_list.dedup();\n    common_list\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.into_iter().filter(|x| l2.contains(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpfpx6kseo.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ tmp = Vec::new();\n    for e in l1 {\n        if l2.contains(&e) {\n       \
    \     tmp.push(e);\n        }\n    }\n    for e in l2 {\n        if l1.contains(&e)\
    \ {\n            tmp.push(e);\n        }\n    }\n    for t in tmp {\n        if\
    \ !res.contains(&t) {\n            res.push(t);\n        }\n    }\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l1`\n   --> /tmp/tmp26r341b6.rs:15:12\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \           -- move occurs because `l1` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n9   |     for e in l1 {\n    |            \
    \  -- `l1` moved due to this implicit call to `.into_iter()`\n...\n15  |     \
    \    if l1.contains(&e) {\n    |            ^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `l1`\n    = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n9   |     for e in &l1 {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v: Vec<isize> = vec![];\n    for\
    \ x in l1 {\n        for y in l2.clone() {\n            if x == y {\n        \
    \        v.push(x);\n            }\n        }\n    }\n    v.sort();\n    v.dedup();\n\
    \    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let l1 = l1.into_iter().unique().collect::<Vec<isize>>();\n\
    \    let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n    let mut result\
    \ = Vec::new();\n    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n\
    \            if l1[i] == l2[j] {\n                result.push(l1[i]);\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpjufx13xk.rs:11:29\n   |\n11 |     let l1\
    \ = l1.into_iter().unique().collect::<Vec<isize>>();\n   |                   \
    \          ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror[E0599]:\
    \ no method named `unique` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpjufx13xk.rs:12:29\n   |\n12 |     let l2 = l2.into_iter().unique().collect::<Vec<isize>>();\n\
    \   |                             ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize> = Vec::new();\n\
    \    let mut set: HashSet<isize> = HashSet::new();\n    for v in l1 {\n      \
    \  set.insert(v);\n    }\n    for v in l2 {\n        if set.contains(&v) {\n \
    \           ret.push(v);\n        }\n    }\n    ret.sort();\n    ret.dedup();\n\
    \    ret\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp1z9xx500.rs:8:18\n\
    \  |\n8 |     let mut set: HashSet<isize> = HashSet::new();\n  |             \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmp1z9xx500.rs:8:35\n  |\n8 |  \
    \   let mut set: HashSet<isize> = HashSet::new();\n  |                       \
    \            ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this\
    \ struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut v = l1.iter().chain(l2.iter()).cloned().collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.dedup();\n    v\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 7, 9, 34, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmplqbydda7.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut res: Vec<isize>\
    \ = Vec::new();\n\n    for i in l1 {\n        set1.insert(i);\n    }\n    for\
    \ i in l2 {\n        set2.insert(i);\n    }\n\n    let set3: HashSet<_> = set1.intersection(&set2).collect();\n\
    \    for i in set3 {\n        res.push(*i);\n    }\n    res.sort();\n    res\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmplhpzvqsq.rs:7:19\n\
    \  |\n7 |     let mut set1: HashSet<isize> = HashSet::new();\n  |            \
    \       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n --> /tmp/tmplhpzvqsq.rs:7:36\n  |\n7 |  \
    \   let mut set1: HashSet<isize> = HashSet::new();\n  |                      \
    \              ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmplhpzvqsq.rs:8:19\n  |\n8 | \
    \    let mut set2: HashSet<isize> = HashSet::new();\n  |                   ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n --> /tmp/tmplhpzvqsq.rs:8:36\n  |\n8 |     let\
    \ mut set2: HashSet<isize> = HashSet::new();\n  |                            \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n  --> /tmp/tmplhpzvqsq.rs:18:15\n   |\n18 |     let\
    \ set3: HashSet<_> = set1.intersection(&set2).collect();\n   |               ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize> = l1;\n    let mut\
    \ l2: Vec<isize> = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    let mut v = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            v.push(l1[i]);\n            i += 1;\n            j += 1;\n      \
    \  }\n    }\n    v\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let l1_set: HashSet<isize> = l1.iter().cloned().collect();\n\
    \    let l2_set: HashSet<isize> = l2.iter().cloned().collect();\n    let mut res:\
    \ Vec<isize> = l1_set.intersection(&l2_set).cloned().collect();\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpimumk8u_.rs:7:17\n\
    \  |\n7 |     let l1_set: HashSet<isize> = l1.iter().cloned().collect();\n  |\
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0412]: cannot\
    \ find type `HashSet` in this scope\n --> /tmp/tmpimumk8u_.rs:8:17\n  |\n8 | \
    \    let l2_set: HashSet<isize> = l2.iter().cloned().collect();\n  |         \
    \        ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976062
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n \
    \           j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2,\
    \ 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpn1zxqwan.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976061
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw1t25twv.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut\
    \ cnt = 0;\n    for i in l1 {\n        for j in l2.iter() {\n            if i\
    \ == *j {\n                res.push(i);\n                break;\n            }\n\
    \        }\n    }\n    res.sort();\n    res.dedup();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 101
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpw_c2ccsw.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976061
- exit_code: 0
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n  \
    \          result.push(l1[i]);\n            i += 1;\n            j += 1;\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976062
- exit_code: 1
  program: "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut common = Vec::new();\n    let mut\
    \ copy = l2.clone();\n    for i in l1 {\n        if copy.contains(&i) {\n    \
    \        common.push(i);\n            copy.remove_item(&i);\n        }\n    }\n\
    \    return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_item` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpdk45q_kt.rs:12:18\n   |\n12 |          \
    \   copy.remove_item(&i);\n   |                  ^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `remove`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976062
