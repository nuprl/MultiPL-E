name: HumanEval_90_next_smallest
language: rs
prompt: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
  \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n/// >>>\
  \ next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n///\
  \ None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
  \ -> Option<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"
completions: ['    unimplemented!()', "    let mut lst = lst;\n    lst.sort();\n \
    \   if lst.len() == 0 {\n        return None;\n    }\n    if lst.len() == 1 {\n\
    \        return None;\n    }\n    if lst.len() == 2 {\n        if lst[0] == lst[1]\
    \ {\n            return None;\n        }\n    }\n    Some(lst[1])", '    unimplemented!()',
  "    if lst.len() == 0 {\n        return None;\n    }\n    let mut min = lst[0];\n\
    \    let mut submin = std::isize::MAX;\n    for el in lst {\n        if el < min\
    \ {\n            submin = min;\n            min = el;\n        } else if el <\
    \ submin && el != min {\n            submin = el;\n        }\n    }\n    if submin\
    \ == std::isize::MAX {\n        None\n    } else {\n        Some(submin)\n   \
    \ }", "    if lst.len() < 2 {\n        return None;\n    }\n    let mut lst =\
    \ lst;\n    lst.sort();\n    for i in 0..lst.len() - 1 {\n        if lst[i] !=\
    \ lst[i + 1] {\n            return Some(lst[i + 1]);\n        }\n    }\n    None",
  "    //TODO\n    None", '    unimplemented!();', "    let mut sorted = lst.clone();\n\
    \    sorted.sort();\n    let uniq: Vec<isize> = sorted.into_iter().unique().collect();\n\
    \    if uniq.len() < 2 {\n        None\n    } else {\n        Some(uniq[1])\n\
    \    }", "    if lst.len() < 2 {\n        return None;\n    }\n    lst.iter().skip(1).min().cloned()",
  "    let mut sorted_list = lst.clone();\n    sorted_list.sort();\n    for i in 1..sorted_list.len()\
    \ {\n        if sorted_list[i] != sorted_list[i - 1] {\n            return Some(sorted_list[i]);\n\
    \        }\n    }\n    None", '    unimplemented!()', "    if lst.len() == 0 {\n\
    \        return None;\n    }\n\n    let mut min = lst[0];\n    let mut second_min\
    \ = lst[0];\n\n    for n in lst {\n        if n < min {\n            second_min\
    \ = min;\n            min = n;\n        } else if n < second_min {\n         \
    \   second_min = n;\n        }\n    }\n\n    match second_min {\n        s if\
    \ s == min => None,\n        _ => Some(second_min),\n    }", "    if lst.len()\
    \ < 2 {\n        return None;\n    }\n    let mut small_ind = 0;\n    let mut\
    \ sec_small_ind = 1;\n    if lst[sec_small_ind] < lst[small_ind] {\n        small_ind\
    \ = 1;\n        sec_small_ind = 0;\n    }\n    for i in 2..lst.len() {\n     \
    \   if lst[i] < lst[small_ind] {\n            sec_small_ind = small_ind;\n   \
    \         small_ind = i;\n        } else if lst[i] < lst[sec_small_ind] {\n  \
    \          sec_small_ind = i;\n        }\n    }\n    return Some(lst[sec_small_ind]);",
  "    lst.iter().min_by(|x, y| {\n        let diff = x - y;\n        if diff == 0\
    \ {\n            Ordering::Equal\n        } else if diff > 0 {\n            Ordering::Greater\n\
    \        } else {\n            Ordering::Less\n        }\n    })", '    lst.iter().enumerate().filter(|&(i,
    _)| i > 0).min_by_key(|&(_, x)| x).map(|(_, x)| *x)', '    unimplemented!();',
  "    let min = lst.iter().min().unwrap();\n    let mut second_min = None;\n    for\
    \ item in lst {\n        if item != *min {\n            second_min = if let Some(x)\
    \ = second_min {\n                Some(cmp::min(x, item))\n            } else\
    \ {\n                Some(item)\n            }\n        }\n    }\n    second_min",
  "    // TODO\n    let mut temp:Vec<isize> = Vec::new();\n    let mut temp1:Vec<isize>\
    \ = Vec::new();\n    let mut ret:Option<isize> = None;\n    let mut ret1:Option<isize>\
    \ = None;\n    for x in lst {\n        temp.push(x);\n    }\n    let mut min =\
    \ temp[0];\n    for x in temp.iter() {\n        if *x < min {\n            min\
    \ = *x;\n        }\n    }\n    let mut min1 = min;\n    for x in temp.iter() {\n\
    \        if *x < min1 && *x != min {\n            min1 = *x;\n        }\n    }\n\
    \    ret = Some(min1);\n    ret", "    if lst.len() < 2 {\n        return None;\n\
    \    }\n    let mut small = std::isize::MAX;\n    let mut next_small = std::isize::MAX;\n\
    \    for v in lst {\n        if v < small {\n            next_small = small;\n\
    \            small = v;\n        } else if v < next_small {\n            next_small\
    \ = v;\n        }\n    }\n    if next_small == std::isize::MAX {\n        None\n\
    \    } else {\n        Some(next_small)\n    }", '    lst.into_iter().min().and_then(|min|
    lst.into_iter().filter(|&x| x != min).min())']
stop_tokens:
- "\n}"
