language: rs
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \    num.chars().filter(|&c| primes.contains(&c)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpg0cmbgqv.rs:23:17\n\
    \   |\n23 |     let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .map(|x|\
    \ x.to_digit(16).unwrap() as usize)\n        .filter(|x| primes.contains(x))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let result = num.chars().filter(|c| {\n        let v = match c\
    \ {\n            '2' => 2,\n            '3' => 3,\n            '5' => 5,\n   \
    \         '7' => 7,\n            'B' => 11,\n            'D' => 13,\n        \
    \    _ => { return false; }\n        };\n        is_prime(v)\n    }).count();\n\
    \    result as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpshayagub.rs:33:9\n\
    \   |\n33 |         is_prime(v)\n   |         ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let v = [2, 3, 5, 7, 11, 13];\n    let mut result = 0;\n    for\
    \ i in num.chars() {\n        let decimal = i.to_digit(16).unwrap();\n       \
    \ if v.contains(&decimal) {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    let mut valid_nums = 0;\n    for c in\
    \ num.chars() {\n        if c == '2' || c == '3' || c == '5' || c == '7' {\n \
    \           primes += 1;\n        } else if c == 'B' || c == 'D' {\n         \
    \   primes += 1;\n        }\n        valid_nums += 1;\n    }\n    primes\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut prime_cnt = 0;\n    let mut hex_num: Vec<char> = num.chars().collect();\n\
    \    for i in 0..hex_num.len() {\n        let mut k = match hex_num[i] {\n   \
    \         '2' => 2,\n            '3' => 3,\n            '5' => 5,\n          \
    \  '7' => 7,\n            'B' => 11,\n            'D' => 13,\n            _ =>\
    \ { continue; }\n        };\n        let mut flag = true;\n        for j in 2..k\
    \ {\n            if k % j == 0 {\n                flag = false;\n            \
    \    break;\n            }\n        }\n        if flag {\n            prime_cnt\
    \ += 1;\n        }\n    }\n    prime_cnt\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let values = vec!['2', '3', '5', '7', 'B', 'D'];\n    for i in num.chars()\
    \ {\n        if values.contains(&i) {\n            counter += 1;\n        }\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        if ch\
    \ >= '2' && ch <= '7' {\n            count += 1;\n        } else if ch == 'B'\
    \ || ch == 'D' {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `6`', /tmp/tmpzhqg3r5r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let x =\
    \ match c {\n            '2' => 2,\n            '3' => 3,\n            '5' =>\
    \ 5,\n            '7' => 7,\n            'B' => 11,\n            'D' => 13,\n\
    \            _ => continue,\n        };\n        if is_prime(x) {\n          \
    \  count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptlxuc81v.rs:34:12\n\
    \   |\n34 |         if is_prime(x) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut sum = 0;\n    let vec: Vec<&str> = num.split(\"\").collect();\n\
    \    for v in vec {\n        if v == \"0\" || v == \"1\" || v == \"2\" || v ==\
    \ \"3\" || v == \"4\" || v == \"5\" || v == \"6\" || v == \"7\" || v == \"8\"\
    \ || v == \"9\" {\n            continue;\n        } else if v == \"A\" || v ==\
    \ \"C\" || v == \"E\" {\n            continue;\n        } else if v == \"B\" ||\
    \ v == \"D\" || v == \"F\" {\n            sum += 1;\n        }\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmp9jvol89d.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let s: String = num.chars().filter(|x|\
    \ primes.contains(&x.to_digit(16).unwrap())).collect();\n    s.len() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let res = num.chars().filter(|&x| vec!['2', '3', '5', '7', 'B',\
    \ 'D'].contains(&x));\n    res.count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut digits = num.chars().collect::<Vec<char>>();\n\
    \    let zero_to_nine = (0..10).collect::<Vec<u8>>();\n    let hex_primes = vec![2,\
    \ 3, 5, 7, 11, 13];\n    digits.sort();\n    for a in digits {\n        if zero_to_nine.contains(&(a\
    \ as u8 - '0' as u8)) || \n            hex_primes.contains(&(a as u8 - '0' as\
    \ u8)) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpzylawq_x.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let hex_digits = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        for n in hex_digits.iter()\
    \ {\n            if c == *n {\n                counter += 1;\n            }\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let input = num.chars();\n    let mut primes: Vec<isize> = vec![2,\
    \ 3, 5, 7, 11, 13];\n    let mut prime_count = 0;\n    for i in input {\n    \
    \    if i.is_digit(10) {\n            if primes.contains(&(i.to_digit(10).unwrap()\
    \ as isize)) {\n                prime_count += 1;\n            }\n        } else\
    \ {\n            let hex = i.to_digit(16).unwrap();\n            if primes.contains(&(hex\
    \ as isize)) {\n                prime_count += 1;\n            }\n        }\n\
    \    }\n    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut sum = 0;\n    for c in num.chars() {\n        match c {\n\
    \            '2' | '3' | '5' | '7' | 'B' | 'D' => sum += 1,\n            _ =>\
    \ {},\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if is_prime_hex(c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_hex` in this scope\n  -->\
    \ /tmp/tmpgatnqnos.rs:25:12\n   |\n25 |         if is_prime_hex(c) {\n   |   \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut res = 0;\n    for c in num.chars() {\n        let n = match\
    \ c {\n            '2' => true,\n            '3' => true,\n            '5' =>\
    \ true,\n            '7' => true,\n            'B' => true,\n            'D' =>\
    \ true,\n            _ => false,\n        };\n        if n {\n            res\
    \ += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let valid_hex_digits = vec!['0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let prime_hex_digits = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    // implement your code here\n    0\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmgvxjukz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    for c in num.chars() {\n        if let Some(v) = c.to_digit(16) {\n     \
    \       if primes.contains(&v) {\n                count += 1;\n            }\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let chars = num.chars().collect::<Vec<char>>();\n\
    \    for c in chars {\n        if c.is_digit(10) {\n            let d = c.to_digit(10).unwrap();\n\
    \            if d == 2 || d == 3 || d == 5 || d == 7 {\n                counter\
    \ += 1;\n            }\n        } else {\n            let d = c.to_digit(16).unwrap();\n\
    \            if d == 11 || d == 13 {\n                counter += 1;\n        \
    \    }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut res = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    for n in num.chars() {\n        let mut c = n.to_string();\n        if c\
    \ == \"A\" {\n            c = \"10\".to_string();\n        } else if c == \"B\"\
    \ {\n            c = \"11\".to_string();\n        } else if c == \"C\" {\n   \
    \         c = \"12\".to_string();\n        } else if c == \"D\" {\n          \
    \  c = \"13\".to_string();\n        } else if c == \"E\" {\n            c = \"\
    14\".to_string();\n        } else if c == \"F\" {\n            c = \"15\".to_string();\n\
    \        }\n        if primes.contains(&c.parse::<i32>().unwrap()) {\n       \
    \     res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let valid_chars = vec!['0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let mut primes = 0;\n    let mut\
    \ it = num.chars();\n    while let Some(c) = it.next() {\n        if !valid_chars.contains(&c)\
    \ {\n            panic!(\"Invalid Hex Number\")\n        } else {\n          \
    \  let decimal_num = if c.is_numeric() {\n                c.to_digit(10).unwrap()\n\
    \            } else {\n                c as isize - 55\n            };\n     \
    \       if decimal_num == 2 || decimal_num == 3 || decimal_num == 5 || decimal_num\
    \ == 7 || decimal_num == 11 || decimal_num == 13 {\n                primes +=\
    \ 1;\n            }\n        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpjlrurgea.rs:33:17\n\
    \   |\n30 |               let decimal_num = if c.is_numeric() {\n   |  _______________________________-\n\
    31 | |                 c.to_digit(10).unwrap()\n   | |                 -----------------------\
    \ expected because of this\n32 | |             } else {\n33 | |              \
    \   c as isize - 55\n   | |                 ^^^^^^^^^^^^^^^ expected `u32`, found\
    \ `isize`\n34 | |             };\n   | |_____________- `if` and `else` have incompatible\
    \ types\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let uppercase_numbers = HashSet::from_iter(\n        \"0123456789ABCDEF\"\
    .chars()\n    );\n    let prime_numbers = HashSet::from_iter(\n        vec!['2',\
    \ '3', '5', '7', 'B', 'D']\n    );\n    let mut result = 0;\n    for i in num.chars()\
    \ {\n        if uppercase_numbers.contains(&i) && prime_numbers.contains(&i) {\n\
    \            result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp4zy9a809.rs:23:29\n   |\n23 |     let uppercase_numbers = HashSet::from_iter(\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp4zy9a809.rs:26:25\n   |\n26 |     let prime_numbers = HashSet::from_iter(\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => {}\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010515
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let allowed_chars = vec!['0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let allowed_primes = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    let mut result = 0;\n    for c in num.chars()\
    \ {\n        let is_allowed = allowed_chars.contains(&c);\n        if is_allowed\
    \ {\n            let is_prime = allowed_primes.contains(&c);\n            if is_prime\
    \ {\n                result += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .map(|ch| match ch {\n            '2' => 1,\n\
    \            '3' => 1,\n            '5' => 1,\n            '7' => 1,\n       \
    \     'B' => 1,\n            'D' => 1,\n            _ => 0,\n        })\n    \
    \    .sum()\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let v = vec![2, 3, 5, 7, 11, 13];\n    let mut s = num.chars();\n\
    \    let mut count = 0;\n    while let Some(a) = s.next() {\n        let val =\
    \ match a {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' |\
    \ '9' => a.to_digit(10).unwrap(),\n            'A' => 10,\n            'B' =>\
    \ 11,\n            'C' => 12,\n            'D' => 13,\n            'E' => 14,\n\
    \            'F' => 15,\n            _ => 0,\n        };\n        if v.contains(&val)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let prime_digits = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        if prime_digits.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n  \
    \  let mut chars = num.chars();\n    loop {\n        let digit = match chars.next()\
    \ {\n            Some(c) => c,\n            None => break,\n        };\n     \
    \   let dec_digit = digit.to_digit(16).unwrap();\n        if primes.contains(&dec_digit)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|c| c.is_digit(16))\n        .filter(|c|\
    \ c.to_digit(16).unwrap() <= 7 || c.to_digit(16).unwrap() == 11 || c.to_digit(16).unwrap()\
    \ == 13)\n        .map(|_| 1)\n        .sum()\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpf7f9q6td.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = [2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n\
    \    for c in num.chars() {\n        if c.is_digit(16) {\n            let digit\
    \ = c.to_digit(16).unwrap();\n            for h in hex_primes.iter() {\n     \
    \           if digit == *h {\n                    count += 1;\n              \
    \      break;\n                }\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let chars = num.chars();\n    let mut count = 0;\n    for c in\
    \ chars {\n        if is_prime(c.to_digit(16).unwrap() as u32) {\n           \
    \ count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7co_b5mf.rs:26:12\n\
    \   |\n26 |         if is_prime(c.to_digit(16).unwrap() as u32) {\n   |      \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // let s: Vec<char> = num.chars().collect();\n    let chars: Vec<char>\
    \ = num.chars().collect();\n    let mut primes: isize = 0;\n    for c in chars\
    \ {\n        let n = match c {\n            '2' => 2,\n            '3' => 3,\n\
    \            '5' => 5,\n            '7' => 7,\n            'B' => 11,\n      \
    \      'D' => 13,\n            _ => 0,\n        };\n        if n != 0 {\n    \
    \        let mut found: bool = false;\n            for i in 2..n {\n         \
    \       if n % i == 0 {\n                    found = true;\n                 \
    \   break;\n                }\n            }\n            if !found {\n      \
    \          primes += 1;\n            }\n        }\n    }\n    primes\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes: std::collections::HashSet<char> = \n        \"2357BDF\"\
    .chars().collect();\n    num.chars().fold(0, |sum, num| {\n        sum + (primes.contains(&num)\
    \ as isize)\n    })\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpqd61zjxh.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut arr: [bool; 16] = [false; 16];\n    let mut result = 0;\n\
    \    for c in num.chars() {\n        match c {\n            '2' => { arr[2] =\
    \ true; },\n            '3' => { arr[3] = true; },\n            '5' => { arr[5]\
    \ = true; },\n            '7' => { arr[7] = true; },\n            'B' => { arr[11]\
    \ = true; },\n            'D' => { arr[13] = true; },\n            _ => {},\n\
    \        }\n    }\n    for i in arr.iter() {\n        if *i {\n            result\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmprsidbqai.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .map(|c|\
    \ c.to_digit(16).unwrap() as usize)\n        .filter(|c| primes.contains(c))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c.is_ascii_digit()\
    \ {\n            count += match c {\n                '2' | '3' | '5' | '7' =>\
    \ 1,\n                _ => 0,\n            };\n        } else {\n            count\
    \ += match c {\n                'B' | 'D' => 1,\n                _ => 0,\n   \
    \         };\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut result = 0;\n    for c in num.chars() {\n        if \"\
    2357bdf\".contains(c) {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmphp0x1pg_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|c| is_prime(parse_hex(c)))\n    \
    \    .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq4tglzko.rs:24:21\n\
    \   |\n24 |         .filter(|c| is_prime(parse_hex(c)))\n   |                \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parse_hex`\
    \ in this scope\n  --> /tmp/tmpq4tglzko.rs:24:30\n   |\n24 |         .filter(|c|\
    \ is_prime(parse_hex(c)))\n   |                              ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let num_vec: Vec<char> = num.chars().collect();\n    let mut count\
    \ = 0;\n    for v in num_vec {\n        if v == '2' || v == '3' || v == '5' ||\
    \ v == '7' || v == 'B' || v == 'D' {\n            count += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|x| {\n            match x {\n   \
    \             '2' | '3' | '5' | '7' | 'B' | 'D' => true,\n                _ =>\
    \ false,\n            }\n        })\n        .count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = num.chars()\n        .filter(|c| char::is_digit(*c))\n\
    \        .map(|c| c.to_digit(16).unwrap() as isize)\n        .filter(|d| (*d ==\
    \ 2) || (*d == 3) || (*d == 5) || (*d == 7) || (*d == 11) || (*d == 13))\n   \
    \     .count() as isize;\n    nums\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpqukiydzi.rs:24:21\n    |\n24  |         .filter(|c| char::is_digit(*c))\n\
    \    |                     ^^^^^^^^^^^^^^ -- supplied 1 argument\n    |      \
    \               |\n    |                     expected 2 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let x: isize = num.chars().map(|c| \n        match c {\n      \
    \      '2' | '3' | '5' | '7' | 'B' | 'D' => 1,\n            _ => 0\n        }\n\
    \    ).sum();\n    return x;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let digits: Vec<char> = num.chars().collect();\n    let primes:\
    \ Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n    let res = digits.iter().filter(|x|\
    \ primes.contains(x)).count();\n    res as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut n = 0;\n    for i in num.chars() {\n        match i {\n\
    \            '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' => n = n,\n            'A'|'B'|'C'|'D'|'E'|'F'\
    \ => n = n + 1,\n            _ => n = n,\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpzqqkm4kz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars().filter(|&x|\
    \ primes.contains(&x)).count() as isize\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // TODO:\n    // Add your code here\n    0\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpbo_fj1l1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_to_dec: HashMap<char, isize> = vec![\n        ('0', 0),\
    \ ('1', 1), ('2', 2), ('3', 3), ('4', 4),\n        ('5', 5), ('6', 6), ('7', 7),\
    \ ('8', 8), ('9', 9),\n        ('A', 10), ('B', 11), ('C', 12), ('D', 13), ('E',\
    \ 14), ('F', 15),\n    ].into_iter().collect();\n    num.chars().map(|c| hex_to_dec[&c]).filter(|&n|\
    \ n.is_prime()).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp_yiqoim9.rs:23:21\n\
    \   |\n23 |     let hex_to_dec: HashMap<char, isize> = vec![\n   |           \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let hex = [2, 3, 5, 7, 11, 13];\n    for\
    \ i in num.as_bytes() {\n        if *i >= 48 && *i <= 57 {\n            if hex.contains(&(*i\
    \ as isize - 48)) {\n                count += 1;\n            }\n        } else\
    \ if *i >= 65 && *i <= 70 {\n            if hex.contains(&(*i as isize - 55))\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    0\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpklo_92zr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let hx: Vec<_> = num.to_uppercase().chars().collect();\n    for hex in hx\
    \ {\n        let v = match hex {\n            'A' => 10,\n            'B' => 11,\n\
    \            'C' => 12,\n            'D' => 13,\n            'E' => 14,\n    \
    \        'F' => 15,\n            '1' => 1,\n            '2' => 2,\n          \
    \  '3' => 3,\n            '4' => 4,\n            '5' => 5,\n            '6' =>\
    \ 6,\n            '7' => 7,\n            '8' => 8,\n            '9' => 9,\n  \
    \          '0' => 0,\n            _ => continue,\n        };\n        if primes.contains(&v)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let arr: Vec<char> = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        if arr.contains(&c) {\n\
    \            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut hex_num = 0;\n    for digit in num.chars() {\n        hex_num\
    \ *= 16;\n        hex_num += match digit {\n            '0' => 0,\n          \
    \  '1' => 1,\n            '2' => 2,\n            '3' => 3,\n            '4' =>\
    \ 4,\n            '5' => 5,\n            '6' => 6,\n            '7' => 7,\n  \
    \          '8' => 8,\n            '9' => 9,\n            'A' => 10,\n        \
    \    'B' => 11,\n            'C' => 12,\n            'D' => 13,\n            'E'\
    \ => 14,\n            'F' => 15,\n            _ => 0,\n        };\n    }\n   \
    \ let mut is_prime = true;\n    let mut sum = 0;\n    for i in 2..hex_num {\n\
    \        for j in 2..i {\n            if i % j == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if is_prime\
    \ {\n            sum += 1;\n        }\n        is_prime = true;\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `39`,\n right: `1`', /tmp/tmp2gtra_nl.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c ==\
    \ '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010514
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    for c in num.chars() {\n        match\
    \ c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => primes += 1,\n       \
    \     _ => (),\n        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010514
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let hex_symbols = \"2357BDF\";\n    for symbol in num.chars() {\n\
    \        if hex_symbols.contains(symbol) {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpu_5aga4e.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        let c = c.to_string();\n\
    \        if let Ok(v) = u8::from_str_radix(&c, 16) {\n            if v == 2 ||\
    \ v == 3 || v == 5 || v == 7 || v == 11 || v == 13 {\n                cnt += 1;\n\
    \            }\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // Base cases\n    let chars: Vec<char> = num.chars().collect();\n\
    \    let mut count = 0;\n    for c in chars {\n        match c {\n           \
    \ '2' => count += 1,\n            '3' => count += 1,\n            '5' => count\
    \ += 1,\n            '7' => count += 1,\n            'B' => count += 1,\n    \
    \        'D' => count += 1,\n            _ => count += 0,\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut len = 0;\n    let bytes = num.into_bytes();\n    for i\
    \ in bytes {\n        match i {\n            66 | 68 | 100 | 102 => len += 1,\n\
    \            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {}\n         \
    \   _ => {\n                if i % 2 != 0 {\n                    len += 1;\n \
    \               }\n            }\n        }\n    }\n    len\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpp1lsx2zc.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for i in num.chars() {\n        let mut\
    \ n = match i {\n            'A' => 11,\n            'B' => 12,\n            'C'\
    \ => 13,\n            'D' => 14,\n            'E' => 15,\n            'F' => 16,\n\
    \            _ => i.to_digit(16).unwrap() as isize,\n        };\n        let mut\
    \ is_prime = true;\n        for j in 2..n {\n            if n % j == 0 {\n   \
    \             is_prime = false;\n                break;\n            }\n     \
    \   }\n        if is_prime {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmplokdvjqc.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    match num.len() {\n        0 => 0,\n        _ => {\n          \
    \  // let abcdef = ['A', 'B', 'C', 'D', 'E', 'F'];\n            let mut res =\
    \ 0;\n            for char in num.chars() {\n                if let Some(digit)\
    \ = char.to_digit(16) {\n                    if is_prime(digit as isize) {\n \
    \                       res += 1;\n                    }\n                }\n\
    \            }\n            res\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbzi03lmm.rs:30:24\n\
    \   |\n30 |                     if is_prime(digit as isize) {\n   |          \
    \              ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    let mut count =\
    \ 0;\n    for digit in num.chars() {\n        if primes.contains(&digit.to_digit(16).unwrap())\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut res = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let hex_digits = vec!['2', '3', '5', '7', 'B', 'D'];\n    let nums: Vec<char>\
    \ = num.chars().collect();\n    for n in nums {\n        if hex_digits.contains(&n)\
    \ {\n            res += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut sum = 0;\n    for i in num.chars() {\n        let mut j\
    \ = i.to_string();\n        if j == \"A\" {\n            j = \"10\".to_string();\n\
    \        } else if j == \"B\" {\n            j = \"11\".to_string();\n       \
    \ } else if j == \"C\" {\n            j = \"12\".to_string();\n        } else\
    \ if j == \"D\" {\n            j = \"13\".to_string();\n        } else if j ==\
    \ \"E\" {\n            j = \"14\".to_string();\n        } else if j == \"F\" {\n\
    \            j = \"15\".to_string();\n        }\n        let mut j: usize = j.parse().unwrap();\n\
    \        for k in 2..=j {\n            if j % k == 0 && j != k {\n           \
    \     break;\n            } else if j == k {\n                sum += 1;\n    \
    \        }\n        }\n    }\n    sum as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let is_prime = |x: isize| {\n        match x {\n            2 |\
    \ 3 | 5 | 7 | 11 | 13 => true,\n            _ => false,\n        }\n    };\n \
    \   num.chars()\n        .filter(|x| x.is_digit(16))\n        .map(|x| x.to_digit(16).unwrap()\
    \ as isize)\n        .filter(|x| is_prime(*x))\n        .count() as isize\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut vec = vec![0u8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xA, 0xB, 0xC,\
    \ 0xD, 0xE, 0xF];\n    let mut count = 0;\n    for c in num.chars() {\n      \
    \  let d = c.to_digit(16).unwrap();\n        if vec.contains(&d) {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyualzh1o.rs:27:25\n   |\n\
    27 |         if vec.contains(&d) {\n   |                         ^^ expected `u8`,\
    \ found `u32`\n   |\n   = note: expected reference `&u8`\n              found\
    \ reference `&u32`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if (c ==\
    \ '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n       \
    \     count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex = \"ABCDEF\";\n    let mut count = 0;\n    for c in num.chars()\
    \ {\n        let c = c.to_string();\n        if c == \"1\" || c == \"A\" || c\
    \ == \"B\" || c == \"C\" || c == \"D\" || c == \"E\" || c == \"F\" {\n       \
    \     count += 1;\n        } else if c.parse::<isize>().unwrap() > 1 {\n     \
    \       let mut flag = true;\n            for i in 2..c.parse::<isize>().unwrap()\
    \ {\n                if c.parse::<isize>().unwrap() % i == 0 {\n             \
    \       flag = false;\n                    break;\n                }\n       \
    \     }\n            if flag {\n                count += 1;\n            }\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpfi39j6jz.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex = \"0123456789ABCDEF\";\n    num.chars()\n        .filter(|&c|\
    \ hex.contains(c))\n        .map(|c| match c {\n            '0' | '2' | '4' |\
    \ '6' | '8' | 'A' | 'C' | 'E' => 1,\n            '3' | '5' | '7' | '9' | 'B' |\
    \ 'D' | 'F' => 0,\n            _ => panic!(\"Unexpected symbol: {}\", c),\n  \
    \      })\n        .sum()\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Unexpected symbol: 1'', /tmp/tmp9zl52tz3.rs:29:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let strs: Vec<&str> = vec![\"2\", \"3\", \"5\", \"7\", \"B\", \"\
    D\"];\n    num.chars().filter(|x| strs.contains(&x.to_string().as_str())).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex = \"0123456789ABCDEF\";\n    let primes = \"2357BDF\";\n\
    \    let mut count = 0;\n    for c in num.chars() {\n        if primes.contains(c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpvj72wxnk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = vec![2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n\
    \    for n in num.chars() {\n        if nums.contains(&n.to_digit(16).unwrap()\
    \ as isize) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxywfzn0.rs:26:26\n   |\n\
    26 |         if nums.contains(&n.to_digit(16).unwrap() as isize) {\n   |     \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                \
    \          |\n   |                          expected `&{integer}`, found `isize`\n\
    \   |                          help: consider borrowing here: `&(&n.to_digit(16).unwrap()\
    \ as isize)`\n\nerror[E0606]: casting `&u32` as `isize` is invalid\n  --> /tmp/tmpkxywfzn0.rs:26:26\n\
    \   |\n26 |         if nums.contains(&n.to_digit(16).unwrap() as isize) {\n  \
    \ |                          ------------------------^^^^^^^^^\n   |         \
    \                 |\n   |                          cannot cast `&u32` as `isize`\n\
    \   |                          help: dereference the expression: `*&n.to_digit(16).unwrap()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let _primes = vec![2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n\
    \    for c in num.chars() {\n        if c.is_numeric() {\n            let s =\
    \ &c.to_string();\n            if s.parse::<i32>().unwrap() % 2 != 0 {\n     \
    \           count += 1;\n            }\n        } else {\n            let ascii\
    \ = c as u8;\n            if ascii % 2 != 0 {\n                count += 1;\n \
    \           }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpr4uph1to.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        match c {\n\
    \            '2' | '3' | '5' | '7' | 'B' | 'D' => cnt += 1,\n            _ =>\
    \ {}\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    let mut result\
    \ = 0;\n    for i in num.chars() {\n        match i {\n            '0'...'9' =>\
    \ {\n                if primes.contains(&(i.to_digit(10).unwrap() as isize)) {\n\
    \                    result += 1;\n                }\n            },\n       \
    \     'A' => {\n                if primes.contains(&(10 as isize)) {\n       \
    \             result += 1;\n                }\n            },\n            'B'\
    \ => {\n                if primes.contains(&(11 as isize)) {\n               \
    \     result += 1;\n                }\n            },\n            'C' => {\n\
    \                if primes.contains(&(12 as isize)) {\n                    result\
    \ += 1;\n                }\n            },\n            'D' => {\n           \
    \     if primes.contains(&(13 as isize)) {\n                    result += 1;\n\
    \                }\n            },\n            'E' => {\n                if primes.contains(&(14\
    \ as isize)) {\n                    result += 1;\n                }\n        \
    \    },\n            'F' => {\n                if primes.contains(&(15 as isize))\
    \ {\n                    result += 1;\n                }\n            },\n   \
    \         _ => {},\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n  \
    \  for num_char in num.chars() {\n        if primes.contains(&(num_char.to_digit(16).unwrap()\
    \ as isize)) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut iter = num.chars();\n    let primes = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    let mut prime_count = 0;\n    while let Some(ch) = iter.next()\
    \ {\n        if primes.contains(&ch) {\n            prime_count += 1;\n      \
    \  }\n    }\n    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // Your code here\n    let mut prime_count = 0;\n    let hex_digits\
    \ = \"0123456789ABCDEF\";\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    for\
    \ c in num.chars() {\n        if primes.contains(&hex_digits.find(c).unwrap())\
    \ {\n            prime_count += 1;\n        }\n    }\n    prime_count\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for digit in num.chars() {\n        if\
    \ digit == '2' || digit == '3' || digit == '5' || digit == '7'\n        || digit\
    \ == 'B' || digit == 'D' {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c ==\
    \ '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010514
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for i in num.chars() {\n        let c =\
    \ i.to_digit(16).unwrap();\n        if c == 2 || c == 3 || c == 5 || c == 7 ||\
    \ c == 11 || c == 13 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let digits: Vec<char> = num.chars().collect();\n    let mut num_primes\
    \ = 0;\n    for c in digits {\n        if c.is_digit(10) {\n            let digit:\
    \ usize = c.to_digit(10).unwrap() as usize;\n            if digit == 2 || digit\
    \ == 3 || digit == 5 || digit == 7 {\n                num_primes += 1;\n     \
    \       }\n        } else {\n            if c == 'B' || c == 'D' {\n         \
    \       num_primes += 1;\n            }\n        }\n    }\n    num_primes as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut result = 0;\n    let hex_str = \"ABCDEF\";\n    for i in\
    \ num.chars() {\n        let mut is_prime = true;\n        if let Some(i) = i.to_digit(16)\
    \ {\n            if i != 0 && i != 1 {\n                for j in 2..i {\n    \
    \                if i % j == 0 {\n                        is_prime = false;\n\
    \                        break;\n                    }\n                }\n  \
    \              if is_prime {\n                    result += 1;\n             \
    \   }\n            }\n        } else if hex_str.contains(i) {\n            match\
    \ i {\n                'B' => result += 1,\n                'D' => result += 1,\n\
    \                _ => ()\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let chars: Vec<char> = num.chars().collect();\n\
    \    for c in chars {\n        match c {\n            '2' => count += 1,\n   \
    \         '3' => count += 1,\n            '5' => count += 1,\n            '7'\
    \ => count += 1,\n            'B' => count += 1,\n            'D' => count +=\
    \ 1,\n            _ => continue,\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n       .filter(|c| match c {\n           '2' | '3'\
    \ | '5' | '7' | 'B' | 'D' => true,\n           _ => false,\n       })\n      \
    \ .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num = num.into_bytes();\n    let mut counter = 0;\n   \
    \ let primes = [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0];\n    while let\
    \ Some(byte) = num.pop() {\n        if byte < 48 || byte > 57 {\n            counter\
    \ += primes[(byte - 65) as usize];\n        } else {\n            counter += primes[(byte\
    \ - 48) as usize];\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpvhm0hmb8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        let digit\
    \ = match c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => true,\n      \
    \      _ => false,\n        };\n        if digit {\n            cnt += 1;\n  \
    \      }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // your code\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphrn_t5vf.rs:24:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let alpha = \"ABCDEF\";\n    let nums = \"0123456789\";\n    let\
    \ n = num.len();\n    let xs: Vec<char> = num.chars().collect();\n    let mut\
    \ primes = 0;\n    for i in 0..n {\n        let mut c = nums.find(xs[i]);\n  \
    \      if c == None {\n            c = alpha.find(xs[i]);\n        }\n       \
    \ let c = c.unwrap() as isize;\n        if c <= 3 || c == 7 || c >= 11 {\n   \
    \         primes += 1;\n        }\n    }\n    primes\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp9xypr5c4.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut char_vec: Vec<char> = Vec::new();\n\
    \    let mut prime_vec: Vec<i32> = vec![2, 3, 5, 7, 11, 13];\n    for ch in num.chars()\
    \ {\n        char_vec.push(ch);\n    }\n    char_vec.sort();\n    char_vec.dedup();\n\
    \    for i in char_vec {\n        let n = if i == 'A' {\n            10\n    \
    \    } else if i == 'B' {\n            11\n        } else if i == 'C' {\n    \
    \        12\n        } else if i == 'D' {\n            13\n        } else if i\
    \ == 'E' {\n            14\n        } else if i == 'F' {\n            15\n   \
    \     } else {\n            i.to_digit(10).unwrap() as i32\n        };\n     \
    \   if prime_vec.contains(&n) {\n            count += 1;\n        }\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp0c50o_m7.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    let mut hex_primes\
    \ = 0;\n    let mut hex = num.chars();\n    loop {\n        match hex.next() {\n\
    \            Some(d) => {\n                match d {\n                    '0'...'9'\
    \ => {\n                        let dec = d.to_digit(10).unwrap();\n         \
    \               if primes.contains(&dec) {\n                            hex_primes\
    \ += 1;\n                        }\n                    },\n                 \
    \   'A'...'F' => {\n                        let dec = d.to_digit(16).unwrap();\n\
    \                        if primes.contains(&dec) {\n                        \
    \    hex_primes += 1;\n                        }\n                    },\n   \
    \                 _ => {},\n                }\n            },\n            None\
    \ => break,\n        }\n    }\n    hex_primes\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex = num.clone().chars().collect::<Vec<char>>();\n    let\
    \ mut prime = 0;\n    let prime_vec = vec!['2', '3', '5', '7', 'B', 'D'];\n  \
    \  for i in hex {\n        for j in prime_vec.clone() {\n            if i == j\
    \ {\n                prime += 1;\n            }\n        }\n    }\n    prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = ['2', '3', '5', '7', 'B', 'D'];\n    let mut counter\
    \ = 0;\n    for i in num.chars() {\n        if primes.contains(&i) {\n       \
    \     counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n\
    \    let chars = num.chars().collect::<Vec<char>>();\n    for c in chars {\n \
    \       if let Some(digit) = c.to_digit(16) {\n            if primes.contains(&digit)\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut v = 0;\n    let mut x = 0;\n  \
    \  for c in num.chars() {\n        match c {\n            '0'..='9' => x = (c\
    \ as u8 - '0' as u8) as isize,\n            'A'..='F' => x = (c as u8 - 'A' as\
    \ u8 + 10) as isize,\n            _ => return 0,\n        }\n        if (x ==\
    \ 2 || x == 3 || x == 5 || x == 7 || x == 11 || x == 13) && x != v {\n       \
    \     count += 1;\n        }\n        v = x;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp16zvqxez.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = num.into_bytes();\n    let mut count = 0;\n    for i\
    \ in nums {\n        if i > 64 && i < 72 {\n            count += 1;\n        }\n\
    \        if i > 47 && i < 58 {\n            if i & 1 == 1 || i == 52 {\n     \
    \           count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpsrh7sn81.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let map = [\n     \
    \   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E',\
    \ 'F'\n    ];\n    let mut count = 0;\n    for ch in num.chars() {\n        for\
    \ n in 0..map.len() {\n            if ch == map[n] {\n                for p in\
    \ primes.iter() {\n                    if *p == n as isize {\n               \
    \         count += 1;\n                    }\n                }\n            }\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let digits = vec!['0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\
    \    let mut primes_count = 0;\n    let chars: Vec<char> = num.chars().collect();\n\
    \    for c in chars {\n        let i = digits.iter().position(|&r| r == c).unwrap();\n\
    \        if primes.contains(&i) {\n            primes_count += 1;\n        }\n\
    \    }\n    primes_count\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    //your code here\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let mut cnt = 0;\n    let a: Vec<char> = num.chars().collect();\n    for\
    \ i in a {\n        if i >= '0' && i <= '9' {\n            if primes.contains(&((i\
    \ as u8 - '0' as u8) as usize)) {\n                cnt += 1;\n            }\n\
    \        } else {\n            if primes.contains(&((i as u8 - 'A' as u8 + 10)\
    \ as usize)) {\n                cnt += 1;\n            }\n        }\n    }\n \
    \   cnt as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    for c in num.chars() {\n        let n\
    \ = match c {\n            '0' => 0,\n            '1' => 1,\n            '2' =>\
    \ 2,\n            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n  \
    \          '6' => 6,\n            '7' => 7,\n            '8' => 8,\n         \
    \   '9' => 9,\n            'A' => 10,\n            'B' => 11,\n            'C'\
    \ => 12,\n            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n\
    \            _ => panic!(\"ValueError: {}\", c),\n        };\n        if n > 1\
    \ && n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0 {\n            primes\
    \ += 1;\n        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpdi8lx20m.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut nums = num.to_uppercase();\n  \
    \  while nums.len() > 0 {\n        let ch = nums.chars().nth(0).unwrap();\n  \
    \      if ch == '2' || ch == '3' || ch == '5' || ch == '7' || ch == 'B' || ch\
    \ == 'D' {\n            count += 1;\n        }\n        nums.remove(0);\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    0\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpklo_92zr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|&n| vec!['2', '3', '5', '7', 'B',\
    \ 'D'].contains(&n))\n        .count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut vec: Vec<isize> = vec![];\n    for c in num.chars() {\n\
    \        match c {\n            '0' => vec.push(0),\n            '1' => vec.push(1),\n\
    \            '2' => vec.push(2),\n            '3' => vec.push(3),\n          \
    \  '4' => vec.push(4),\n            '5' => vec.push(5),\n            '6' => vec.push(6),\n\
    \            '7' => vec.push(7),\n            '8' => vec.push(8),\n          \
    \  '9' => vec.push(9),\n            'A' => vec.push(10),\n            'B' => vec.push(11),\n\
    \            'C' => vec.push(12),\n            'D' => vec.push(13),\n        \
    \    'E' => vec.push(14),\n            'F' => vec.push(15),\n            _ =>\
    \ panic!(\"Invalid character!\"),\n        }\n    }\n    let mut sum = 0;\n  \
    \  for i in &vec {\n        if *i == 2 || *i == 3 || *i == 5 || *i == 7 || *i\
    \ == 11 || *i == 13 {\n            sum += 1;\n        }\n    }\n    sum\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() {\n        return 0;\n    }\n    num.chars()\n\
    \       .filter(|&x| \"2357BD\".contains(x))\n       .count() as isize\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars().filter(|c|\
    \ hex_primes.contains(c)).count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let digits: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \    num.chars().filter(|c| digits.contains(c)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp3eherre8.rs:23:17\n\
    \   |\n23 |     let digits: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes: Vec<isize> = vec![2, 3, 5, 7, 11, 13];\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    for i in num.chars() {\n        match\
    \ i {\n            '0' => result.push(0),\n            '1' => result.push(1),\n\
    \            '2' => result.push(2),\n            '3' => result.push(3),\n    \
    \        '4' => result.push(4),\n            '5' => result.push(5),\n        \
    \    '6' => result.push(6),\n            '7' => result.push(7),\n            '8'\
    \ => result.push(8),\n            '9' => result.push(9),\n            'A' => result.push(10),\n\
    \            'B' => result.push(11),\n            'C' => result.push(12),\n  \
    \          'D' => result.push(13),\n            'E' => result.push(14),\n    \
    \        'F' => result.push(15),\n            _ => (),\n        }\n    }\n   \
    \ let counter = result.iter().filter(|&i| primes.contains(i)).count();\n    counter\
    \ as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() {\n        return 0;\n    }\n    let mut prime_count\
    \ = 0;\n    let hex_digits = vec!['2', '3', '5', '7', 'B', 'D'];\n    for d in\
    \ num.chars() {\n        if hex_digits.contains(&d) {\n            prime_count\
    \ += 1;\n        }\n    }\n    prime_count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // TODO: Implement your solution here\n    0\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmptljohiei.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let symbol_to_num = |sym: &char| -> isize {\n        match sym\
    \ {\n            '0' => 0,\n            '1' => 1,\n            '2' => 2,\n   \
    \         '3' => 3,\n            '4' => 4,\n            '5' => 5,\n          \
    \  '6' => 6,\n            '7' => 7,\n            '8' => 8,\n            '9' =>\
    \ 9,\n            'A' => 10,\n            'B' => 11,\n            'C' => 12,\n\
    \            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n    \
    \        _ => panic!(\"Illegal argument.\"),\n        }\n    };\n    let is_prime\
    \ = |num: isize| -> bool {\n        let mut is_prime = true;\n        for i in\
    \ 2..num {\n            if num % i == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        is_prime\n    };\n\
    \    let mut nums: Vec<isize> = Vec::new();\n    let mut num_str = String::from(num);\n\
    \    while num_str.len() > 0 {\n        let sym = num_str.pop().unwrap();\n  \
    \      let digit = symbol_to_num(&sym);\n        nums.push(digit);\n    }\n  \
    \  nums.iter().filter(|num| is_prime(**num)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `2`', /tmp/tmpwdtxot7v.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let hex_digits = num.chars().collect::<Vec<char>>();\n\
    \    for x in &hex_digits {\n        match x {\n            '2' => count += 1,\n\
    \            '3' => count += 1,\n            '5' => count += 1,\n            '7'\
    \ => count += 1,\n            'B' => count += 1,\n            'D' => count +=\
    \ 1,\n            _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut n = num.replace(\"A\", \"11\").replace(\"B\", \"11\").replace(\"\
    C\", \"11\").replace(\"D\", \"11\").replace(\"E\", \"11\").replace(\"F\", \"11\"\
    );\n    let n = n.parse::<isize>().unwrap();\n    //for c in n.chars() { println!(\"\
    {}\", c); }\n    let mut primes = 0;\n    for digit in num.chars() {\n       \
    \ match digit {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => primes += 1,\n\
    \            _ => ()\n        }\n    }\n    primes\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmpt3un4zvu.rs:24:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    for c in num.chars() {\n        match c {\n\
    \            '2' | '3' | '5' | '7' | 'B' | 'D' => cnt += 1,\n            _ =>\
    \ (),\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = [2, 3, 5, 7, 11, 13];\n    let hex = \"0123456789ABCDEF\"\
    ;\n    let mut count = 0;\n    for c in num.chars() {\n        if let Some(x)\
    \ = hex.find(c) {\n            if x < 16 && hex_primes.contains(&x) {\n      \
    \          count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums: Vec<usize> = vec![];\n    for i in num.chars() {\n\
    \        match i {\n            '0' => nums.push(0),\n            '1' => nums.push(1),\n\
    \            '2' => nums.push(2),\n            '3' => nums.push(3),\n        \
    \    '4' => nums.push(4),\n            '5' => nums.push(5),\n            '6' =>\
    \ nums.push(6),\n            '7' => nums.push(7),\n            '8' => nums.push(8),\n\
    \            '9' => nums.push(9),\n            'A' => nums.push(10),\n       \
    \     'B' => nums.push(11),\n            'C' => nums.push(12),\n            'D'\
    \ => nums.push(13),\n            'E' => nums.push(14),\n            'F' => nums.push(15),\n\
    \            _ => println!(\"Wrong Char!\"),\n        }\n    }\n    let prime\
    \ = [2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n    for item in nums {\n  \
    \      for p in prime.iter() {\n            if item == *p {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count as isize\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    let digits = vec![\n        '2', '3',\
    \ '5', '7', 'B', 'D',\n    ];\n    let mut str_chars = num.chars();\n    while\
    \ let Some(ch) = str_chars.next() {\n        if digits.contains(&ch) {\n     \
    \       primes += 1;\n        }\n    }\n    primes\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let slice = num.as_bytes();\n    let mut count = 0;\n    for i\
    \ in slice {\n        if i == 50 || i == 51 || i == 53 || i == 55 || i == 66 ||\
    \ i == 68 {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&u8` with `{integer}`\n  --> /tmp/tmp57561bze.rs:26:14\n\
    \   |\n26 |         if i == 50 || i == 51 || i == 53 || i == 55 || i == 66 ||\
    \ i == 68 {\n   |              ^^ no implementation for `&u8 == {integer}`\n \
    \  |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&u8`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&u8` with `{integer}`\n  --> /tmp/tmp57561bze.rs:26:25\n\
    \   |\n26 |         if i == 50 || i == 51 || i == 53 || i == 55 || i == 66 ||\
    \ i == 68 {\n   |                         ^^ no implementation for `&u8 == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&u8`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&u8` with `{integer}`\n  --> /tmp/tmp57561bze.rs:26:36\n\
    \   |\n26 |         if i == 50 || i == 51 || i == 53 || i == 55 || i == 66 ||\
    \ i == 68 {\n   |                                    ^^ no implementation for\
    \ `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not\
    \ implemented for `&u8`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&u8` with\
    \ `{integer}`\n  --> /tmp/tmp57561bze.rs:26:47\n   |\n26 |         if i == 50\
    \ || i == 51 || i == 53 || i == 55 || i == 66 || i == 68 {\n   |             \
    \                                  ^^ no implementation for `&u8 == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&u8`\n\
    \   = help: the following other types impleme"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let chars: Vec<char> = num.chars().collect();\n    let mut count\
    \ = 0;\n    let primes = [2, 3, 5, 7, 11, 13];\n    for c in chars {\n       \
    \ let int = match c {\n            '0' => 0,\n            '1' => 1,\n        \
    \    '2' => 2,\n            '3' => 3,\n            '4' => 4,\n            '5'\
    \ => 5,\n            '6' => 6,\n            '7' => 7,\n            '8' => 8,\n\
    \            '9' => 9,\n            'A' => 10,\n            'B' => 11,\n     \
    \       'C' => 12,\n            'D' => 13,\n            'E' => 14,\n         \
    \   'F' => 15,\n            _ => -1,\n        };\n        if int == -1 {\n   \
    \         break;\n        }\n        if primes.contains(&int) {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    use std::convert::TryInto;\n    let mut cnt = 0;\n    let primes\
    \ = [2, 3, 5, 7, 11, 13];\n    for c in num.chars() {\n        if let Ok(digit)\
    \ = c.to_digit(16) {\n            if primes.contains(&digit) {\n             \
    \   cnt += 1;\n            }\n        }\n    }\n    cnt.try_into().unwrap()\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt6nep2pu.rs:27:16\n   |\n\
    27 |         if let Ok(digit) = c.to_digit(16) {\n   |                ^^^^^^^^^\
    \   -------------- this expression has type `Option<u32>`\n   |              \
    \  |\n   |                expected enum `Option`, found enum `Result`\n   |\n\
    \   = note: expected enum `Option<u32>`\n              found enum `Result<_, _>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0];\n\
    \    let digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n\
    \    let mut res = 0;\n    for i in num.chars() {\n        res += primes[digits[i\
    \ as usize - '0' as usize]];\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 16 but the
    index is 17'', /tmp/tmplxmwfnph.rs:27:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut result = 0;\n    for i in num.chars() {\n        if i ==\
    \ '2' || i == '3' || i == '5' || i == '7' || i == 'B' || i == 'D' {\n        \
    \    result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if c ==\
    \ '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010514
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let n =\
    \ if c.is_digit(10) {\n            c.to_digit(10).unwrap() as isize\n        }\
    \ else {\n            match c {\n                'A' => 10,\n                'B'\
    \ => 11,\n                'C' => 12,\n                'D' => 13,\n           \
    \     'E' => 14,\n                'F' => 15,\n                _ => unreachable!()\n\
    \            }\n        };\n        if (n > 1) && (n <= 15) && (n == 2 || n ==\
    \ 3 || n == 5 || n == 7 || n == 11 || n == 13) {\n            count += 1;\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = [2, 3, 5, 7, 11, 13];\n    let mut output = 0;\n   \
    \ let chars = num.chars();\n    for item in chars {\n        let c_int = match\
    \ item {\n            '0' => 0,\n            '1' => 1,\n            '2' => 2,\n\
    \            '3' => 3,\n            '4' => 4,\n            '5' => 5,\n       \
    \     '6' => 6,\n            '7' => 7,\n            '8' => 8,\n            '9'\
    \ => 9,\n            'A' => 10,\n            'B' => 11,\n            'C' => 12,\n\
    \            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n    \
    \        _ => {\n                continue;\n            }\n        };\n      \
    \  for num in nums.iter() {\n            if *num == c_int {\n                output\
    \ += 1;\n            }\n        }\n    }\n    output\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_digits = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut\
    \ count = 0;\n    for c in num.chars() {\n        if hex_digits.contains(&c) {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let char_vec: Vec<char> = num.chars().collect();\n    let mut counter\
    \ = 0;\n    for c in char_vec {\n        match c {\n            '2' | '3' | '5'\
    \ | '7' | 'B' | 'D' => counter += 1,\n            _ => {},\n        }\n    }\n\
    \    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_digits = \"0123456789ABCDEF\";\n    let primes = \"2357BDF\"\
    ;\n    let hex = num.chars()\n        .map(|x| hex_digits.find(x).unwrap() as\
    \ isize)\n        .filter(|x| primes.contains(x as u8 as char))\n        .count()\
    \ as isize;\n    hex\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `u8` is invalid\n  --> /tmp/tmpbm2_5afe.rs:27:37\n\
    \   |\n27 |         .filter(|x| primes.contains(x as u8 as char))\n   |      \
    \                               -^^^^^^\n   |                                \
    \     |\n   |                                     cannot cast `&isize` as `u8`\n\
    \   |                                     help: dereference the expression: `*x`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut valid = false;\n    let mut count = 0;\n    let prime_hexadecimal\
    \ = vec![0, 2, 3, 5, 7, 11, 13];\n    let mut sum = 0;\n    let mut n = num.chars();\n\
    \    while !valid {\n        let mut d = n.next();\n        if d.is_none() {\n\
    \            valid = true;\n        } else {\n            match d.unwrap() {\n\
    \                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' =>\
    \ sum += d.unwrap().to_digit(10).unwrap() as isize,\n                'A' => sum\
    \ += 10,\n                'B' => sum += 11,\n                'C' => sum += 12,\n\
    \                'D' => sum += 13,\n                'E' => sum += 14,\n      \
    \          'F' => sum += 15,\n                _ => println!(\"Invalid character!\"\
    ),\n            }\n            if prime_hexadecimal.contains(&sum) {\n       \
    \         count += 1;\n            }\n            sum = 0;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `2`', /tmp/tmpkhztlqsg.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    isize::from_str_radix(&num, 16).unwrap()\n    .to_string()\n  \
    \  .chars()\n    .filter(|x| x.is_digit(10))\n    .map(|x| x.to_digit(10).unwrap()\
    \ as isize)\n    .filter(|x| {\n        x == &11 || x == &13 || x == &2 ||\n \
    \       x == &3 || x == &5 || x == &7\n    })\n    .count() as isize\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpplglmphk.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    let mut nums = num.chars();\n    while\
    \ let Some(d) = nums.next() {\n        match d {\n            '0' | '1' | '4'\
    \ | '6' | '8' | '9' | 'C' | 'E' | 'F' => (),\n            _ => primes += 1,\n\
    \        }\n    }\n    primes\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpyymzo7l9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() { return 0; }\n    let hex_nums = vec![\n   \
    \     \"A\".to_string(), \"B\".to_string(), \"C\".to_string(), \"D\".to_string(),\n\
    \        \"E\".to_string(), \"F\".to_string()\n    ];\n    let mut count = 0;\n\
    \    for s in num.chars() {\n        if s.is_numeric() {\n            if s ==\
    \ '1' || s == '3' || s == '5' || s == '7' {\n                count += 1;\n   \
    \         }\n        } else {\n            if hex_nums.contains(&s.to_string())\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp__1xobs4.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut ret: isize = 0;\n    let primes: [char; 6] = ['2', '3',\
    \ '5', '7', 'B', 'D'];\n    for c in num.chars() {\n        for i in 0..6 {\n\
    \            if c == primes[i] {\n                ret += 1;\n                break;\n\
    \            }\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .map(|c| match c {\n            '2' | '3'\
    \ | '5' | '7' | 'B' | 'D' => 1,\n            _ => 0,\n        })\n        .sum()\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    return num.chars().map(|x| x.to_digit(16).unwrap() as usize).map(|x|\
    \ \n        if x < 10 { x } else { x + 1 }\n    ).filter(|x| [2, 3, 5, 7, 11,\
    \ 13].contains(x)).count() as isize;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    let hex_char_vec = vec!['0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let prime_char_vec\
    \ = vec!['2', '3', '5', '7', 'B', 'D'];\n    for c in num.chars() {\n        for\
    \ pc in prime_char_vec.iter() {\n            if c == *pc {\n                cnt\
    \ += 1;\n            }\n        }\n    }\n    return cnt;\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n       .filter(|ch| *ch == '2' || *ch == '3' || *ch\
    \ == '5' || *ch == '7' ||\n                    *ch == 'B' || *ch == 'D')\n   \
    \    .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let hex_str = num.as_str();\n    for hex_char in hex_str.chars() {\n    \
    \    let mut hex_number = 0;\n        if hex_char.is_ascii_digit() {\n       \
    \     hex_number = hex_char.to_digit(10).unwrap() as usize;\n        } else {\n\
    \            match hex_char {\n                'A' => hex_number = 10,\n     \
    \           'B' => hex_number = 11,\n                'C' => hex_number = 12,\n\
    \                'D' => hex_number = 13,\n                'E' => hex_number =\
    \ 14,\n                'F' => hex_number = 15,\n                _ => {}\n    \
    \        }\n        }\n        if primes.contains(&hex_number) {\n           \
    \ result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let key_values = [2, 3, 5, 7, 11, 13];\n\
    \    let hex_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n\
    \    for i in hex_values.iter() {\n        for j in key_values.iter() {\n    \
    \        if i == j {\n                counter += 1;\n            }\n        }\n\
    \    }\n    return counter;\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `1`', /tmp/tmpg0r7jv14.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut idx = 0;\n    while idx < num.len() {\n        let c = num.chars().nth(idx).unwrap();\n\
    \        let n = if c <= '9' {\n            c as isize - '0' as isize\n      \
    \  } else {\n            c as isize - 'A' as isize + 10\n        };\n        if\
    \ n == 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 {\n            count\
    \ += 1;\n        }\n        idx += 1;\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    let hex_base: u32 = 16;\n    let num_chars:\
    \ Vec<char> = num.chars().collect();\n    for elem in num_chars {\n        let\
    \ mut digit: u32 = elem.to_digit(hex_base).unwrap();\n        if digit > 10 {\n\
    \            digit -= 7;\n        }\n        if is_prime(digit) {\n          \
    \  primes += 1;\n        }\n    }\n    primes as isize\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpql7l_fdh.rs:31:12\n\
    \   |\n31 |         if is_prime(digit) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .filter(|c|\
    \ !c.is_numeric())\n        .map(|c| {\n            let n = c.to_digit(16).unwrap();\n\
    \            n as isize\n        })\n        .filter(|&n| primes.contains(&n))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmp7snode99.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let s: Vec<char> = num.chars().collect();\n    let len = s.len();\n\
    \    let mut sum = 0;\n    for i in 0..len {\n        let c = s[i];\n        if\
    \ c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n   \
    \         sum += 1;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    if num.is_empty() {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    for s in num.chars() {\n        match s {\n            '2' | '3' |\
    \ '5' | '7' | 'B' | 'D' => sum += 1,\n            _ => continue,\n        }\n\
    \    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for i in num.chars() {\n        match i\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let digits = num.chars().filter(|c|\
    \ {\n        if let Ok(x) = c.to_digit(16) {\n            return primes.contains(&x);\n\
    \        }\n        false\n    });\n    digits.count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpecizpljw.rs:25:16\n   |\n\
    25 |         if let Ok(x) = c.to_digit(16) {\n   |                ^^^^^   --------------\
    \ this expression has type `Option<u32>`\n   |                |\n   |        \
    \        expected enum `Option`, found enum `Result`\n   |\n   = note: expected\
    \ enum `Option<u32>`\n              found enum `Result<_, _>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let alphabets: HashSet<char> = \"AB\".chars().collect();\n    let\
    \ base: HashSet<char> = \"0123456789\".chars().collect();\n    let primes: HashSet<char>\
    \ = \"2357BD\".chars().collect();\n    let mut ans: isize = 0;\n    let mut tmp:\
    \ isize = 0;\n    for c in num.chars() {\n        if alphabets.contains(&c) {\n\
    \            tmp = c as isize - 'A' as isize + 10;\n        } else if base.contains(&c)\
    \ {\n            tmp = c as isize - '0' as isize;\n        }\n        if primes.contains(&c)\
    \ {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpmpquhv79.rs:23:20\n\
    \   |\n23 |     let alphabets: HashSet<char> = \"AB\".chars().collect();\n   |\
    \                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmpmpquhv79.rs:24:15\n\
    \   |\n24 |     let base: HashSet<char> = \"0123456789\".chars().collect();\n\
    \   |               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmpmpquhv79.rs:25:17\n\
    \   |\n25 |     let primes: HashSet<char> = \"2357BD\".chars().collect();\n  \
    \ |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n\tif num.is_empty() {\n\t\treturn 0;\n\t}\n\tlet v: Vec<char> = num.chars().collect();\n\
    \tlet mut v = v.iter().map(|x| x.to_digit(16).unwrap()).collect::<Vec<u32>>();\n\
    \tlet mut result = 0;\n\tfor i in 0..v.len() {\n\t\tif v[i] == 0 || v[i] == 1\
    \ {\n\t\t\tcontinue;\n\t\t}\n\t\tif v[i] == 2 || v[i] == 3 || v[i] == 5 || v[i]\
    \ == 7 || v[i] == 11 || v[i] == 13 {\n\t\t\tresult += 1;\n\t\t}\n\t}\n\tresult\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .map(|s| match s {\n            '0' | '1'\
    \ | '8' => 0,\n            '2' | '3' | '5' | '7' => 1,\n            '4' | '9'\
    \ | 'A' | 'C' => 0,\n            '6' | 'B' | 'D' | 'F' => 1,\n            _ =>\
    \ 0,\n        })\n        .sum()\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `6`', /tmp/tmpv1rg8gp6.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let s: Vec<char> = num.chars().collect();\n\
    \    for i in 0..s.len() {\n        let mut ch = s[i];\n        if ch >= 'A' &&\
    \ ch <= 'F' {\n            ch = (ch as u8 - 55) as char;\n        }\n        let\
    \ mut num = ch.to_string().parse::<isize>().unwrap();\n        let mut is_prime\
    \ = true;\n        for j in 2..num {\n            if num % j == 0 {\n        \
    \        is_prime = false;\n                break;\n            }\n        }\n\
    \        if is_prime {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpj13pe4ai.rs:30:55

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let chars: Vec<char> = num.chars().collect();\n    let mut cnt\
    \ = 0;\n    for c in chars {\n        let d = match c {\n            '0' => 0,\n\
    \            '1' => 1,\n            '2' => 2,\n            '3' => 3,\n       \
    \     '4' => 4,\n            '5' => 5,\n            '6' => 6,\n            '7'\
    \ => 7,\n            '8' => 8,\n            '9' => 9,\n            'A' => 10,\n\
    \            'B' => 11,\n            'C' => 12,\n            'D' => 13,\n    \
    \        'E' => 14,\n            'F' => 15,\n            _ => 0,\n        };\n\
    \        match d {\n            2 | 3 | 5 | 7 | 11 | 13 => cnt += 1,\n       \
    \     _ => (),\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if \"2357BD\"\
    .contains(c) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => continue,\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|c| vec!['2', '3', '5', '7', 'B',\
    \ 'D'].contains(c))\n        .count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n\tlet mut primes = 0;\n\tfor c in num.chars() {\n\t\tmatch c {\n\t\t\
    \t'2' | '3' | '5' | '7' | 'B' | 'D' => primes += 1,\n\t\t\t_ => {}\n\t\t}\n\t\
    }\n\tprimes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut key = 0;\n    for s in num.chars() {\n        match s {\n\
    \            '2' | '3' | '5' | '7' | 'B' | 'D' => key += 1,\n            _ =>\
    \ {}\n        }\n    }\n    key\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut res = 0;\n    for c in num.chars() {\n        if c == '2'\
    \ || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D' {\n            res\
    \ += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15];\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let mut count = 0;\n \
    \   let mut digits = num.chars().collect::<Vec<char>>();\n    digits.reverse();\n\
    \    for (i, digit) in digits.iter().enumerate() {\n        let mut dec = 0;\n\
    \        if !digit.is_ascii_alphabetic() {\n            dec = digit.to_digit(10).unwrap()\
    \ as isize;\n        } else {\n            let it = digit.to_ascii_uppercase();\n\
    \            let value = match it {\n                'A' => 10,\n            \
    \    'B' => 11,\n                'C' => 12,\n                'D' => 13,\n    \
    \            'E' => 14,\n                'F' => 15,\n                _ => unreachable!(),\n\
    \            };\n            dec = value as isize;\n        }\n        let sixteen\
    \ = 16 as isize;\n        let value = dec * (sixteen.pow(i as u32) as isize);\n\
    \        if primes.contains(&value) {\n            count += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmprzu15nol.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut char_vec: Vec<char> = num.chars().collect();\n    let mut\
    \ result: isize = 0;\n    let prime_vec: Vec<char> = vec!['2', '3', '5', '7',\
    \ 'B', 'D'];\n    for c in &mut char_vec {\n        if *c == 'A' {\n         \
    \   *c = '1';\n        } else if *c == 'B' {\n            *c = '2';\n        }\
    \ else if *c == 'C' {\n            *c = '3';\n        } else if *c == 'D' {\n\
    \            *c = '4';\n        } else if *c == 'E' {\n            *c = '5';\n\
    \        } else if *c == 'F' {\n            *c = '6';\n        }\n    }\n    let\
    \ str_temp: String = char_vec.into_iter().collect();\n    let mut num_temp: isize\
    \ = str_temp.parse::<isize>().unwrap();\n    while num_temp > 0 {\n        let\
    \ i: isize = num_temp % 10;\n        if prime_vec.contains(&(i as u8 as char))\
    \ {\n            result += 1;\n        }\n        num_temp /= 10;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp3chevckt.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut cnt = 0;\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let mut alpha = vec!['B', 'D'];\n    let num_vec: Vec<&str> = num.split(\"\
    \").collect();\n    for x in num_vec {\n        if x == \"\" {\n            continue;\n\
    \        }\n        if x.chars().next().unwrap().is_numeric() {\n            if\
    \ primes.contains(&x.parse::<isize>().unwrap()) {\n                cnt += 1;\n\
    \            }\n        } else {\n            if alpha.contains(&x.chars().next().unwrap())\
    \ {\n                cnt += 1;\n            }\n        }\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpjqa4tzjc.rs:23:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut hex = vec![2, 3, 5, 7, 11, 13];\n\
    \    if num.len() > 0 {\n        for i in num.chars() {\n            if i.is_ascii_alphabetic()\
    \ {\n                let upper = i.to_ascii_uppercase();\n                let\
    \ res = match upper {\n                    'A' => 10,\n                    'B'\
    \ => 11,\n                    'C' => 12,\n                    'D' => 13,\n   \
    \                 'E' => 14,\n                    'F' => 15,\n               \
    \     _ => panic!(\"invalid hex character: {}\", i),\n                };\n   \
    \             hex.push(res);\n            } else {\n                let dec =\
    \ i.to_digit(10).unwrap();\n                hex.push(dec as isize);\n        \
    \    }\n        }\n    }\n    for i in hex {\n        let mut prime = true;\n\
    \        for j in 2..i {\n            if i % j == 0 {\n                prime =\
    \ false;\n                break;\n            }\n        }\n        if prime {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `1`', /tmp/tmpl7y_h5oa.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    let chars = num.chars().map(|i|\
    \ i.to_digit(16).unwrap());\n    let counts = chars.filter(|i| primes.contains(i)).count();\n\
    \    counts as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        let base\
    \ = match ch {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => true,\n     \
    \       _ => false,\n        };\n        if base {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    for c in num.chars() {\n        match c {\n            '0' | '1' | '8' =>\
    \ {}\n            '2' | '3' | '5' | '7' => count += 1,\n            '4' | '6'\
    \ | '9' => {}\n            'A' | 'B' | 'D' | 'E' => count += 1,\n            'C'\
    \ | 'F' => {}\n            _ => return -1,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmpmf20gf16.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .filter(|c| vec!['2', '3', '5', '7', 'B',\
    \ 'D'].contains(c))\n        .count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut is_prime = vec![true; 16];\n    let mut count = 0;\n  \
    \  let num = num.as_bytes();\n    for i in 2..is_prime.len() {\n        if is_prime[i]\
    \ {\n            for j in 2..(is_prime.len() / i + 1) {\n                is_prime[i\
    \ * j] = false;\n            }\n        }\n    }\n    for i in num {\n       \
    \ match *i {\n            b'0'...b'9' => if is_prime[*i as usize - b'0' as usize]\
    \ { count += 1; },\n            b'A'...b'F' => if is_prime[*i as usize - b'A'\
    \ as usize + 10] { count += 1; },\n            _ => unreachable!(),\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 16 but the
    index is 16'', /tmp/tmpe51qqv1q.rs:29:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut hex_primes = vec![2, 3, 5, 7, 11,\
    \ 13];\n    for c in num.chars() {\n        let cur_num = c.to_digit(16).unwrap()\
    \ as usize;\n        if hex_primes.contains(&cur_num) {\n            count +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut acc = 0;\n    for c in num.chars() {\n        if let Some(d)\
    \ = c.to_digit(16) {\n            acc += match d {\n                2 | 3 | 5\
    \ | 7 | 11 | 13 => 1,\n                _ => 0,\n            };\n        }\n  \
    \  }\n    acc\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .map(|x| match x {\n            'A' | 'B'\
    \ | 'D' => 1,\n            '2' | '3' | '5' | '7' => 1,\n            _ => 0,\n\
    \        })\n        .sum()\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `1`', /tmp/tmp3gwsd3ud.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let mut counter = 0;\n\
    \    for i in num.chars() {\n        if let Some(index) = primes.iter().position(|&x|\
    \ x == i as isize) {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp6ano7t3z.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = vec![2, 3, 5, 7, 11, 13];\n    if num.is_empty()\
    \ {\n        return 0;\n    }\n    num.chars()\n        .filter(|c| primes.contains(&c.to_digit(16).unwrap()))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let slice: Vec<char> = num.chars().collect();\n\
    \    let primes: Vec<char> = vec!['2', '3', '5', '7', 'B', 'D'];\n    for s in\
    \ slice {\n        if primes.contains(&s) {\n            counter += 1;\n     \
    \   }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpezyxjpe1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .filter(|c|\
    \ c.is_digit(16))\n        .map(|c| c.to_digit(16).unwrap() as usize)\n      \
    \  .filter(|&d| primes.contains(&d))\n        .count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut hex = Vec::new();\n    let mut count = 0;\n    let values\
    \ = vec![2, 3, 5, 7, 11, 13];\n    for i in num.chars() {\n        if i != '0'\
    \ {\n            hex.push(i);\n        }\n    }\n    for k in hex {\n        let\
    \ mut dec: i32 = match k {\n            '1' => 1,\n            '2' => 2,\n   \
    \         '3' => 3,\n            '4' => 4,\n            '5' => 5,\n          \
    \  '6' => 6,\n            '7' => 7,\n            '8' => 8,\n            '9' =>\
    \ 9,\n            'A' => 10,\n            'B' => 11,\n            'C' => 12,\n\
    \            'D' => 13,\n            'E' => 14,\n            'F' => 15,\n    \
    \        _ => 0,\n        };\n        for v in values.iter() {\n            if\
    \ dec == *v {\n                count += 1;\n            }\n        }\n    }\n\
    \    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let prime_numbers = vec![0, 2, 3, 5, 7, 11, 13];\n    let sum =\
    \ num.as_bytes().iter().map(|a| {\n        match a {\n            b'0'..=b'9'\
    \ => (a - b'0') as isize,\n            b'A'..=b'F' => (a - b'A' + 10) as isize,\n\
    \            _ => 0\n        }\n    }).filter(|a| prime_numbers.contains(a)).fold(0,\
    \ |sum, a| sum + a);\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `1`', /tmp/tmpkhwqogo0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut n = 0;\n    for x in num.chars() {\n        let c = x.to_string();\n\
    \        let m = match c.as_ref() {\n            \"2\" | \"3\" | \"5\" | \"7\"\
    \ | \"B\" | \"D\" => 1,\n            _ => 0,\n        };\n        n += m;\n  \
    \  }\n    n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        match\
    \ ch {\n            '0' | '1' | '8' => continue,\n            '2' | '3' | '5'\
    \ | '7' | 'B' | 'D' => count += 1,\n            _ => continue,\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut ans = 0;\n    for i in 0..num.len() {\n        if is_prime(num.chars().nth(i).unwrap())\
    \ {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpdl_njb2p.rs:25:12\n\
    \   |\n25 |         if is_prime(num.chars().nth(i).unwrap()) {\n   |         \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut\
    \ count = 0;\n    for c in num.chars() {\n        if hex_primes.contains(&c) {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = ['2', '3', '5', '7', 'B', 'D'];\n    let mut count\
    \ = 0;\n    for c in num.chars() {\n        if hex_primes.contains(&c) {\n   \
    \         count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let nums = \"0123456789abcdef\";\n    let hex_primes = [1, 0, 1,\
    \ 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0];\n    num.chars().map(|c| hex_primes[nums.find(c).unwrap()]).sum()\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmptf1vy6w9.rs:25:49

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut total: isize = 0;\n    for ch in num.chars() {\n      \
    \  match ch {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => total += 1,\n\
    \            _ => (),\n        }\n    }\n    total\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let map = vec![\n        (0, \"0\"),\n        (1, \"1\"),\n   \
    \     (2, \"2\"),\n        (3, \"3\"),\n        (4, \"4\"),\n        (5, \"5\"\
    ),\n        (6, \"6\"),\n        (7, \"7\"),\n        (8, \"8\"),\n        (9,\
    \ \"9\"),\n        (10, \"A\"),\n        (11, \"B\"),\n        (12, \"C\"),\n\
    \        (13, \"D\"),\n        (14, \"E\"),\n        (15, \"F\"),\n    ];\n  \
    \  let mut counter = 0;\n    for (_, char) in num.chars().enumerate() {\n    \
    \    let n = map.iter().find(|x| char == **x.1).unwrap().0;\n        if n == 2\
    \ || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 {\n            counter +=\
    \ 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `str` cannot be dereferenced\n  --> /tmp/tmpgn_dwli3.rs:43:45\n\
    \   |\n43 |         let n = map.iter().find(|x| char == **x.1).unwrap().0;\n \
    \  |                                             ^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let a = vec!['2', '3', '5', '7', 'B', 'D'];\n    num.chars().filter(|c|\
    \ a.contains(c)).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for n in num.chars() {\n        match n\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => continue,\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes: Vec<char> = \n        \"2357BD\".chars().collect();\n\
    \    num.chars()\n        .filter(|x| primes.contains(x))\n        .count() as\
    \ isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let valid_nums = vec!['2', '3', '5', '7', 'B', 'D'];\n    let mut\
    \ hex_nums = num.to_uppercase().chars();\n    let mut counter = 0;\n    while\
    \ let Some(n) = hex_nums.next() {\n        if valid_nums.contains(&n) {\n    \
    \        counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpa82b3z5t.rs:24:24\n\
    \   |\n24 |     let mut hex_nums = num.to_uppercase().chars();\n   |         \
    \               ^^^^^^^^^^^^^^^^^^        - temporary value is freed at the end\
    \ of this statement\n   |                        |\n   |                     \
    \   creates a temporary which is freed while still in use\n25 |     let mut counter\
    \ = 0;\n26 |     while let Some(n) = hex_nums.next() {\n   |                 \
    \        --------------- borrow later used here\n   |\n   = note: consider using\
    \ a `let` binding to create a longer lived value\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0716`.\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes: HashSet<u8> = vec![2, 3, 5, 7, 11, 13].into_iter().collect();\n\
    \    let mut digits: Vec<u8> = num.bytes().collect();\n    let mut hex_key = 0;\n\
    \    for &digit in digits.iter() {\n        match digit {\n            65...70\
    \ => {\n                hex_key += 1;\n            }\n            48...57 => {\n\
    \                let number = digit - 48;\n                if primes.contains(&number)\
    \ {\n                    hex_key += 1;\n                }\n            }\n   \
    \         _ => {\n                continue;\n            }\n        }\n    }\n\
    \    hex_key\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8wun7e2k.rs:23:17\n\
    \   |\n23 |     let primes: HashSet<u8> = vec![2, 3, 5, 7, 11, 13].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nwarning: `...`\
    \ range patterns are deprecated\n  --> /tmp/tmp8wun7e2k.rs:28:15\n   |\n28 | \
    \            65...70 => {\n   |               ^^^ help: use `..=` for an inclusive\
    \ range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\
    \   = warning: this is accepted in the current edition (Rust 2015) but is a hard\
    \ error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmp8wun7e2k.rs:31:15\n\
    \   |\n31 |             48...57 => {\n   |               ^^^ help: use `..=` for\
    \ an inclusive range\n   |\n   = warning: this is accepted in the current edition\
    \ (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    return num.chars().filter(|c| \"2357BDF\".contains(*c)).count()\
    \ as isize;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmparqvbozl.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let hex_primes = \"2357BDF\";\n    let key = num.chars().filter(|c|\
    \ hex_primes.contains(*c)).count();\n    key as isize\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmprcc81jip.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // TODO: implement the function\n    // unimplemented!()\n    let\
    \ s = num.as_str();\n    let mut v = vec![];\n    let h = b\"0123456789ABCDEF\"\
    ;\n    for i in s.as_bytes() {\n        for j in h.iter() {\n            if i\
    \ == j {\n                v.push(j);\n            }\n        }\n    }\n    let\
    \ mut count = 0;\n    let mut k = 0;\n    while k < v.len() {\n        if v[k]\
    \ == b'2' || v[k] == b'3' || v[k] == b'5' || v[k] == b'7' ||\n            v[k]\
    \ == b'B' || v[k] == b'D' {\n            count += 1;\n        }\n        k +=\
    \ 1;\n    }\n    count as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&u8` with `u8`\n  --> /tmp/tmpokyheuql.rs:38:17\n\
    \   |\n38 |         if v[k] == b'2' || v[k] == b'3' || v[k] == b'5' || v[k] ==\
    \ b'7' ||\n   |                 ^^ no implementation for `&u8 == u8`\n   |\n \
    \  = help: the trait `PartialEq<u8>` is not implemented for `&u8`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0277]: can't compare `&u8` with `u8`\n  --> /tmp/tmpokyheuql.rs:38:33\n\
    \   |\n38 |         if v[k] == b'2' || v[k] == b'3' || v[k] == b'5' || v[k] ==\
    \ b'7' ||\n   |                                 ^^ no implementation for `&u8\
    \ == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&u8`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&u8` with `u8`\n  --> /tmp/tmpokyheuql.rs:38:49\n\
    \   |\n38 |         if v[k] == b'2' || v[k] == b'3' || v[k] == b'5' || v[k] ==\
    \ b'7' ||\n   |                                                 ^^ no implementation\
    \ for `&u8 == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&u8` with `u8`\n  --> /tmp/tmpokyheuql.rs:38:65\n\
    \   |\n38 |         if v[k] == b'2' || v[k] == b'3' || v[k] == b'5' || v[k] ==\
    \ b'7' ||\n   |                                                              \
    \   ^^ no implementation for `&u8 == u8`\n   |\n   = help: the trait `PartialEq<u8>`\
    \ is not implemented for `&u8`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n  "
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let keys = \"2357BDF\";\n    for i in num.chars()\
    \ {\n        if keys.contains(i) {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpdpvypjz9.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n\tnum.chars().filter(|&c| is_prime_hex_digit(c)).count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_hex_digit` in this scope\n\
    \  --> /tmp/tmp150kxush.rs:23:26\n   |\n23 |     num.chars().filter(|&c| is_prime_hex_digit(c)).count()\
    \ as isize\n   |                             ^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    num.chars()\n        .map(|x| if x.is_digit(16) { x.to_digit(16).unwrap()\
    \ as isize } else { 0 })\n        .filter(|&x| x % 2 != 0 && x % 3 != 0 && x %\
    \ 5 != 0 && x % 7 != 0 && x % 11 != 0 && x % 13 != 0)\n        .count() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpchep_y_7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    // your code\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphrn_t5vf.rs:24:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010624
