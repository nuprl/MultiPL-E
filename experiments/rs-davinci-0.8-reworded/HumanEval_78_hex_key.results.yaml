language: rs
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \    num.chars().filter(|&c| primes.contains(&c)).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpg0cmbgqv.rs:23:17\n\
    \   |\n23 |     let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = [2, 3, 5, 7, 11, 13];\n    num.chars()\n        .map(|x|\
    \ x.to_digit(16).unwrap() as usize)\n        .filter(|x| primes.contains(x))\n\
    \        .count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n \
    \   assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let result = num.chars().filter(|c| {\n        let v = match c\
    \ {\n            '2' => 2,\n            '3' => 3,\n            '5' => 5,\n   \
    \         '7' => 7,\n            'B' => 11,\n            'D' => 13,\n        \
    \    _ => { return false; }\n        };\n        is_prime(v)\n    }).count();\n\
    \    result as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpshayagub.rs:33:9\n\
    \   |\n33 |         is_prime(v)\n   |         ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let v = [2, 3, 5, 7, 11, 13];\n    let mut result = 0;\n    for\
    \ i in num.chars() {\n        let decimal = i.to_digit(16).unwrap();\n       \
    \ if v.contains(&decimal) {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut primes = 0;\n    let mut valid_nums = 0;\n    for c in\
    \ num.chars() {\n        if c == '2' || c == '3' || c == '5' || c == '7' {\n \
    \           primes += 1;\n        } else if c == 'B' || c == 'D' {\n         \
    \   primes += 1;\n        }\n        valid_nums += 1;\n    }\n    primes\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut prime_cnt = 0;\n    let mut hex_num: Vec<char> = num.chars().collect();\n\
    \    for i in 0..hex_num.len() {\n        let mut k = match hex_num[i] {\n   \
    \         '2' => 2,\n            '3' => 3,\n            '5' => 5,\n          \
    \  '7' => 7,\n            'B' => 11,\n            'D' => 13,\n            _ =>\
    \ { continue; }\n        };\n        let mut flag = true;\n        for j in 2..k\
    \ {\n            if k % j == 0 {\n                flag = false;\n            \
    \    break;\n            }\n        }\n        if flag {\n            prime_cnt\
    \ += 1;\n        }\n    }\n    prime_cnt\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13];\n\
    \    let values = vec!['2', '3', '5', '7', 'B', 'D'];\n    for i in num.chars()\
    \ {\n        if values.contains(&i) {\n            counter += 1;\n        }\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for ch in num.chars() {\n        if ch\
    \ >= '2' && ch <= '7' {\n            count += 1;\n        } else if ch == 'B'\
    \ || ch == 'D' {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `6`', /tmp/tmpzhqg3r5r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        let x =\
    \ match c {\n            '2' => 2,\n            '3' => 3,\n            '5' =>\
    \ 5,\n            '7' => 7,\n            'B' => 11,\n            'D' => 13,\n\
    \            _ => continue,\n        };\n        if is_prime(x) {\n          \
    \  count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptlxuc81v.rs:34:12\n\
    \   |\n34 |         if is_prime(x) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c\
    \ {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n          \
    \  _ => (),\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut sum = 0;\n    let vec: Vec<&str> = num.split(\"\").collect();\n\
    \    for v in vec {\n        if v == \"0\" || v == \"1\" || v == \"2\" || v ==\
    \ \"3\" || v == \"4\" || v == \"5\" || v == \"6\" || v == \"7\" || v == \"8\"\
    \ || v == \"9\" {\n            continue;\n        } else if v == \"A\" || v ==\
    \ \"C\" || v == \"E\" {\n            continue;\n        } else if v == \"B\" ||\
    \ v == \"D\" || v == \"F\" {\n            sum += 1;\n        }\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmp9jvol89d.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let primes = vec![2, 3, 5, 7, 11, 13];\n    let s: String = num.chars().filter(|x|\
    \ primes.contains(&x.to_digit(16).unwrap())).collect();\n    s.len() as isize\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let res = num.chars().filter(|&x| vec!['2', '3', '5', '7', 'B',\
    \ 'D'].contains(&x));\n    res.count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    let mut digits = num.chars().collect::<Vec<char>>();\n\
    \    let zero_to_nine = (0..10).collect::<Vec<u8>>();\n    let hex_primes = vec![2,\
    \ 3, 5, 7, 11, 13];\n    digits.sort();\n    for a in digits {\n        if zero_to_nine.contains(&(a\
    \ as u8 - '0' as u8)) || \n            hex_primes.contains(&(a as u8 - '0' as\
    \ u8)) {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpzylawq_x.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut counter = 0;\n    let hex_digits = vec!['2', '3', '5',\
    \ '7', 'B', 'D'];\n    for c in num.chars() {\n        for n in hex_digits.iter()\
    \ {\n            if c == *n {\n                counter += 1;\n            }\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let input = num.chars();\n    let mut primes: Vec<isize> = vec![2,\
    \ 3, 5, 7, 11, 13];\n    let mut prime_count = 0;\n    for i in input {\n    \
    \    if i.is_digit(10) {\n            if primes.contains(&(i.to_digit(10).unwrap()\
    \ as isize)) {\n                prime_count += 1;\n            }\n        } else\
    \ {\n            let hex = i.to_digit(16).unwrap();\n            if primes.contains(&(hex\
    \ as isize)) {\n                prime_count += 1;\n            }\n        }\n\
    \    }\n    prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut sum = 0;\n    for c in num.chars() {\n        match c {\n\
    \            '2' | '3' | '5' | '7' | 'B' | 'D' => sum += 1,\n            _ =>\
    \ {},\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut count = 0;\n    for c in num.chars() {\n        if is_prime_hex(c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_hex` in this scope\n  -->\
    \ /tmp/tmpgatnqnos.rs:25:12\n   |\n25 |         if is_prime_hex(c) {\n   |   \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659824085
- exit_code: 0
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut res = 0;\n    for c in num.chars() {\n        let n = match\
    \ c {\n            '2' => true,\n            '3' => true,\n            '5' =>\
    \ true,\n            '7' => true,\n            'B' => true,\n            'D' =>\
    \ true,\n            _ => false,\n        };\n        if n {\n            res\
    \ += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824085
- exit_code: 101
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let valid_hex_digits = vec!['0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    let prime_hex_digits = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    // implement your code here\n    0\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmgvxjukz.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659824085
