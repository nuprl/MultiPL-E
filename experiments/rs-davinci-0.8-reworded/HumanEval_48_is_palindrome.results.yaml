language: rs
name: HumanEval_48_is_palindrome
results:
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_vec:\
    \ Vec<char> = text.chars().collect();\n    for (i, c) in text_vec.iter().enumerate()\
    \ {\n        if *c != text_vec[text_vec.len() - i - 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().eq(text.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    text.chars().zip(text.chars().rev()).all(|(a, b)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut reversed_chars = text.chars().rev();\n    loop\
    \ {\n        let (f, r) = match (chars.next(), reversed_chars.next()) {\n    \
    \        (Some(f), Some(r)) => (f, r),\n            _ => break,\n        };\n\
    \        if f != r {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut i =\
    \ 0;\n    let mut j = text.len() - 1;\n    let text_chars: Vec<char> = text.chars().collect();\n\
    \    while i < j {\n        if text_chars[i] != text_chars[j] {\n            return\
    \ false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmptbzg2105.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822435
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let mut text_chars = text.chars();\n    loop {\n \
    \       match (text_chars.next(), text_chars.next_back()) {\n            (Some(a),\
    \ Some(b)) => {\n                if a != b {\n                    return false;\n\
    \                }\n            }\n            (None, None) => {\n           \
    \     return true;\n            }\n            _ => {\n                return\
    \ false;\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbh7h2ydu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.len()\
    \ <= 1 ||\n    (text.chars().next().unwrap() == text.chars().last().unwrap() &&\n\
    \     is_palindrome(text[1..text.len() - 1].to_string()))\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let mid = len / 2;\n    let forward: String = text.chars().take(mid).collect();\n\
    \    let backward: String = text.chars().rev().take(mid).collect();\n    forward\
    \ == backward\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let n = text.len();\n\
    \    if n == 0 {\n        return true;\n    }\n    let mut i = 0;\n    let mut\
    \ j = n - 1;\n    while i < j {\n        if text.chars().nth(i) != text.chars().nth(j)\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().eq(text.chars())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp9hzcxaqc.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in\
    \ 0..len / 2 {\n        if chars[i] != chars[len - i - 1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // split string\
    \ to Vec<char>\n    let chars: Vec<char> = text.chars().collect();\n    let len\
    \ = chars.len();\n    // check equality of first and last char\n    // if not\
    \ equal - return false\n    if len == 0 || len == 1 {\n        return true;\n\
    \    } else if chars[0] != chars[len - 1] {\n        return false;\n    }\n  \
    \  // recursively check equality of first and last char\n    // of the rest of\
    \ string\n    is_palindrome(chars[1..len - 1].iter().collect())\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_len\
    \ = text.len();\n    if text_len <= 1 {\n        return true;\n    }\n    if text.chars().nth(0).unwrap()\
    \ != text.chars().nth(text_len - 1).unwrap() {\n        return false;\n    }\n\
    \    return is_palindrome(text[1..text_len - 1].to_string());\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    for _ in 0..text.len() / 2 {\n        let (first, second)\
    \ = (chars.next(), chars.next_back());\n        if first != second {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    let half_length = length / 2;\n    text.chars().take(half_length).eq(text.chars().rev().take(half_length))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut v = Vec::new();\n    while let Some(c) = chars.next()\
    \ {\n        v.push(c);\n    }\n    let v = v;\n    for i in 0..v.len() {\n  \
    \      if v[i] != v[v.len() - i - 1] {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6a9vm_wt.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(l,\
    \ r)| l == r)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let bytes = text.as_bytes();\n    for i in 0..len / 2 {\n        if bytes[i]\
    \ != bytes[len - i - 1] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut first_iter = text.chars();\n\
    \    let mut last_iter = text.chars().rev();\n\n    for _ in 0..text.len() / 2\
    \ {\n        if first_iter.next() != last_iter.next() {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_length\
    \ = text.len();\n    if text_length == 0 {\n        return true;\n    }\n    if\
    \ text_length == 1 {\n        return true;\n    }\n    let mut is_palindrome =\
    \ true;\n    for i in 0..(text_length / 2) {\n        if text.chars().nth(i) !=\
    \ text.chars().nth(text_length - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    is_palindrome\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    for i in 0..length / 2 {\n        if text.chars().nth(i)\
    \ != text.chars().nth(length - i - 1) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let midpoint = chars.len() / 2;\n \
    \   let left = &chars[0..midpoint];\n    let right = &chars[(midpoint + chars.len()\
    \ % 2)..];\n    left == right.iter().rev()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[char]` with `Rev<std::slice::Iter<'_, char>>`\n\
    \  --> /tmp/tmp6711j8q_.rs:15:10\n   |\n15 |     left == right.iter().rev()\n\
    \   |          ^^ no implementation for `&[char] == Rev<std::slice::Iter<'_, char>>`\n\
    \   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, char>>>` is not\
    \ implemented for `&[char]`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n             <&[T]\
    \ as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n   \
    \          <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n\
    \             <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B;\
    \ N]>>\n             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut start = chars.next();\n    let mut end = chars.next_back();\n\
    \    loop {\n        match (start, end) {\n            (Some(s), Some(e)) => {\n\
    \                if s != e {\n                    return false;\n            \
    \    }\n                start = chars.next();\n                end = chars.next_back();\n\
    \            }\n            (None, None) => return true,\n            _ => return\
    \ false,\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0gbt4lp3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    // in order to prevent reallocation\
    \ of the whole string,\n    // we simply take two pointers to the beginning and\
    \ the end of the string,\n    // iterate over them and break out of the loop if\
    \ the pointer values differ\n    let mut front = 0;\n    let mut back = text.len()\
    \ - 1;\n\n    while front < back {\n        if text.chars().nth(front) != text.chars().nth(back)\
    \ {\n            return false;\n        }\n\n        front += 1;\n        back\
    \ -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO: Check\
    \ if string is palindrome. See tests for clues.\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp06bdmdnw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let (mut left, mut right) = (0, text.len() - 1);\n\
    \    while left < right {\n        while !text.is_char_boundary(left) {\n    \
    \        left += 1;\n        }\n        while !text.is_char_boundary(right) {\n\
    \            right -= 1;\n        }\n        if text.chars().nth(left) != text.chars().nth(right)\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmputih2kem.rs:12:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_vec:\
    \ Vec<char> = text.chars().collect();\n    let mut i = 0;\n    let j = text_vec.len()\
    \ - 1;\n    while i < j {\n        if text_vec[i] != text_vec[j] {\n         \
    \   return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `j`\n  --> /tmp/tmp3d0ce4c9.rs:19:9\n\
    \   |\n13 |     let j = text_vec.len() - 1;\n   |         -\n   |         |\n\
    \   |         first assignment to `j`\n   |         help: consider making this\
    \ binding mutable: `mut j`\n...\n19 |         j -= 1;\n   |         ^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let half = len / 2;\n    let mut chars = text.chars();\n    for _ in 0..half\
    \ {\n        let (first, second) = chars.next_back();\n        if first != second\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl11eqxp8.rs:15:13\n   |\n\
    15 |         let (first, second) = chars.next_back();\n   |             ^^^^^^^^^^^^^^^\
    \   ----------------- this expression has type `Option<char>`\n   |          \
    \   |\n   |             expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<char>`\n             found tuple `(_, _)`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut t =\
    \ text.chars();\n    let half_size = t.clone().count() / 2;\n    t.take(half_size).eq(t.rev().take(half_size))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpdwlbkpm7.rs:11:9\n\
    \   |\n11 |     let mut t = text.chars();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `t`\n    --> /tmp/tmpdwlbkpm7.rs:13:26\n\
    \     |\n11   |     let mut t = text.chars();\n     |         ----- move occurs\
    \ because `t` has type `Chars<'_>`, which does not implement the `Copy` trait\n\
    12   |     let half_size = t.clone().count() / 2;\n13   |     t.take(half_size).eq(t.rev().take(half_size))\n\
    \     |       ---------------    ^ value used here after move\n     |       |\n\
    \     |       `t` moved due to this method call\n     |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `t`\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let s = text.chars().collect::<Vec<char>>();\n\
    \    let mid = s.len() / 2;\n    for i in 0..mid {\n        if s[i] != s[s.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    for i in 0..text.len()\
    \ / 2 {\n        if &text[i..i + 1] != &text[text.len() - i - 1..text.len() -\
    \ i] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_rev\
    \ = text.chars().rev().collect::<String>();\n    text_rev == text\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut input\
    \ = text.chars();\n    let mut buf = Vec::new();\n    for ch in input.by_ref()\
    \ {\n        buf.push(ch);\n    }\n    let mut lo = 0;\n    let mut hi = buf.len()\
    \ - 1;\n    while lo < hi {\n        if buf[lo] != buf[hi] {\n            return\
    \ false;\n        }\n        lo += 1;\n        hi -= 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpubtmsld6.rs:17:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO: Implement\
    \ this\n    let t = text.as_str();\n    if t.len() == 0 {\n        return true;\n\
    \    }\n    if t.len() == 1 {\n        return true;\n    }\n    let mut i = 0;\n\
    \    let mut j = t.len() - 1;\n    while i < j {\n        if t.as_bytes()[i] !=\
    \ t.as_bytes()[j] {\n            return false;\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut half_len = text.len() / 2;\n    while half_len\
    \ > 0 {\n        if chars.next() != chars.next_back() {\n            return false;\n\
    \        }\n        half_len -= 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    for i in 0..chars.len() / 2 {\n   \
    \     if chars[i] != chars[chars.len() - i - 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut left\
    \ = 0;\n    let mut right = text.len() - 1;\n    while left < right {\n      \
    \  if text.chars().nth(left) != text.chars().nth(right) {\n            return\
    \ false;\n        }\n        left += 1;\n        right -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_mqs6oeg.rs:12:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chrs:\
    \ Vec<char> = text.chars().collect();\n    chrs.reverse();\n    let rev_str: String\
    \ = chrs.into_iter().collect();\n    text == rev_str\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().collect::<Vec<char>>()\
    \ == text.chars().rev().collect::<Vec<char>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // nie za\u0142\
    o\u017Cy\u0142em, \u017Ce b\u0119dzie d\u0142ugo\u015B\u0107 ci\u0105gu znak\xF3\
    w mniejsza od 2\n    let len = text.len();\n    // Trzeba zwr\xF3ci\u0107 uwag\u0119\
    , \u017Ce dla parzystej d\u0142ugo\u015Bci ci\u0105gu mniejszym z indeks\xF3w\
    \ jest (len/2)-1\n    // dla nieparzystej jest po prostu (len-1)/2\n    let mid\
    \ = if len % 2 == 0 { (len / 2) - 1 } else { (len - 1) / 2 };\n    let mut is_palindrome\
    \ = true;\n    for i in 0..mid + 1 {\n        if text.chars().nth(i) != text.chars().nth(len\
    \ - i - 1) {\n            is_palindrome = false;\n            break;\n       \
    \ }\n    }\n    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_s80ukz1.rs:15:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    is_palindrome_rec(text.as_str())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_rec` in this scope\n\
    \  --> /tmp/tmpdfpxon6s.rs:11:5\n   |\n11 |     is_palindrome_rec(text.as_str())\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.trim().to_lowercase();\n    text.len() == 0 || {\n        let mut i = 0;\n\
    \        let mut j = text.len() - 1;\n        while i < j {\n            if text.chars().nth(i)\
    \ != text.chars().nth(j) {\n                return false;\n            }\n   \
    \         i += 1;\n            j -= 1;\n        }\n        true\n    }\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut rev_chars = text.chars().rev();\n    while let\
    \ (Some(c), Some(rc)) = (chars.next(), rev_chars.next()) {\n        if c != rc\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let text = text.chars().filter(|c| !c.is_whitespace()).collect::<String>();\n\
    \    let text = text.chars().filter(|c| c.is_alphanumeric()).collect::<String>();\n\
    \    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n\
    \    let mut result = true;\n    for i in 0..len {\n        if chars[i] != chars[len\
    \ - i - 1] {\n            result = false;\n            break;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let half_len\
    \ = text.len() / 2;\n    text.chars().take(half_len).eq(text.chars().rev().take(half_len))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut it\
    \ = text.chars();\n    let mut rev = text.chars().rev();\n    loop {\n       \
    \ match (it.next(), rev.next()) {\n            (Some(x), Some(y)) => {\n     \
    \           if x != y {\n                    return false;\n                }\n\
    \            }\n            (None, None) => return true,\n            _ => unreachable!(),\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    for i in 0..chars.len() / 2 {\n   \
    \     if chars[i] != chars[chars.len() - i - 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut rev_text\
    \ = String::new();\n    for ch in text.chars().rev() {\n        rev_text.push(ch);\n\
    \    }\n    rev_text == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    if length < 2 {\n        return true;\n    }\n    let mid\
    \ = length / 2;\n    let first_part = &text[0..mid];\n    let second_part = &text[mid\
    \ + length % 2..length];\n    return first_part == second_part.chars().rev().collect::<String>();\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut v =\
    \ text.chars().collect::<Vec<char>>();\n    v.reverse();\n    let v_rev: String\
    \ = v.into_iter().collect();\n    text == v_rev\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_len\
    \ = text.len();\n    for i in 0..text_len {\n        if text.chars().nth(i) !=\
    \ text.chars().nth(text_len - i - 1) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut p1\
    \ = 0;\n    let mut p2 = text.len() - 1;\n    while p1 < p2 {\n        if text.chars().nth(p1)\
    \ != text.chars().nth(p2) {\n            return false;\n        }\n        p1\
    \ += 1;\n        p2 -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpzyj0qcgf.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut first_idx\
    \ = 0;\n    let mut last_idx = text.len() - 1;\n    let text_chars: Vec<char>\
    \ = text.chars().collect();\n\n    while first_idx < last_idx {\n        if text_chars[first_idx]\
    \ != text_chars[last_idx] {\n            return false;\n        }\n        first_idx\
    \ += 1;\n        last_idx -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp6a08prv5.rs:12:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let chars: Vec<char> = text.chars().collect();\n \
    \   let i = 0;\n    let j = chars.len() - 1;\n    while i < j {\n        if chars[i]\
    \ != chars[j] {\n            return false;\n        }\n        i += 1;\n     \
    \   j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp_e9quwos.rs:19:9\n\
    \   |\n13 |     let i = 0;\n   |         -\n   |         |\n   |         first\
    \ assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n...\n19 |         i += 1;\n   |         ^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `j`\n  --> /tmp/tmp_e9quwos.rs:20:9\n   |\n14 |     let j = chars.len() - 1;\n\
    \   |         -\n   |         |\n   |         first assignment to `j`\n   |  \
    \       help: consider making this binding mutable: `mut j`\n...\n20 |       \
    \  j -= 1;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut rchars = text.chars().rev();\n    loop {\n    \
    \    match (chars.next(), rchars.next()) {\n            (Some(a), Some(b)) if\
    \ a == b => continue,\n            (None, None) => return true,\n            _\
    \ => return false,\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.as_str();\n    let mut it = text.chars();\n    let mut rev = text.chars().rev();\n\
    \    loop {\n        match (it.next(), rev.next()) {\n            (Some(l), Some(r))\
    \ => {\n                if l != r {\n                    return false;\n     \
    \           }\n            }\n            (None, None) => return true,\n     \
    \       _ => return false,\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let letters\
    \ = text.chars().filter(|c| !c.is_whitespace()).collect::<Vec<_>>();\n    letters\
    \ == letters.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `&char`\n  --> /tmp/tmp9dexh_hf.rs:12:13\n\
    \   |\n12 |     letters == letters.iter().rev().collect::<Vec<_>>()\n   |    \
    \         ^^ no implementation for `char == &char`\n   |\n   = help: the trait\
    \ `PartialEq<&char>` is not implemented for `char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n   = note: required because of the requirements on\
    \ the impl of `PartialEq<Vec<&char>>` for `Vec<char>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    let mut index_counter = 0;\n    while index_counter < len / 2 {\n       \
    \ if text.chars().nth(index_counter) != text.chars().nth(len - index_counter -\
    \ 1) {\n            return false;\n        }\n        index_counter += 1;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    for i in 0..len / 2 {\n        if text.chars().nth(i) != text.chars().nth(len\
    \ - i - 1) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n\n    let mut i = 0;\n    let mut j = text.len()\
    \ - 1;\n\n    let mut first = None;\n    let mut second = None;\n\n    for _ in\
    \ 0..text.len() {\n        first = text.chars().nth(i);\n        second = text.chars().nth(j);\n\
    \n        if first != second {\n            return false;\n        }\n\n     \
    \   i += 1;\n        j -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprrsaqejr.rs:30:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let size =\
    \ text.len();\n    if size < 2 {\n        return true;\n    }\n    let mut i =\
    \ 0;\n    let mut j = size - 1;\n    while i < j {\n        let a = text.chars().nth(i).unwrap();\n\
    \        let b = text.chars().nth(j).unwrap();\n        if a != b {\n        \
    \    return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp9hzcxaqc.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut test_char = chars.next();\n    let mut reversed_chars\
    \ = chars.rev();\n    while let (Some(ch), Some(other_ch)) = (test_char, reversed_chars.next())\
    \ {\n        if ch != other_ch {\n            return false;\n        }\n     \
    \   test_char = chars.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `chars`\n    --> /tmp/tmpuqvluee5.rs:18:21\n\
    \     |\n11   |     let mut chars = text.chars();\n     |         --------- move\
    \ occurs because `chars` has type `Chars<'_>`, which does not implement the `Copy`\
    \ trait\n12   |     let mut test_char = chars.next();\n13   |     let mut reversed_chars\
    \ = chars.rev();\n     |                                    ----- `chars` moved\
    \ due to this method call\n...\n18   |         test_char = chars.next();\n   \
    \  |                     ^^^^^^^^^^^^ value borrowed here after move\n     |\n\
    note: this function takes ownership of the receiver `self`, which moves `chars`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().eq(text.chars())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_lower\
    \ = text.to_lowercase();\n    let mut text_chars = text_lower.chars();\n    let\
    \ mut text_chars_rev = text_lower.chars().rev();\n    loop {\n        match (text_chars.next(),\
    \ text_chars_rev.next()) {\n            (Some(ch1), Some(ch2)) => {\n        \
    \        if ch1 != ch2 {\n                    return false;\n                }\n\
    \            }\n            (None, None) => return true,\n            _ => return\
    \ false,\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.as_str();\n    let text_len = text.len();\n    let middle = text_len /\
    \ 2;\n    for i in 0..middle {\n        if text.chars().nth(i) != text.chars().nth(text_len\
    \ - i - 1) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut reverse_chars = text.chars().rev();\n    while\
    \ let (Some(c), Some(r)) = (chars.next(), reverse_chars.next()) {\n        if\
    \ c != r {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.len()\
    \ <= 1 ||\n    text.chars().nth(0) == text.chars().nth(text.len() - 1) &&\n  \
    \  is_palindrome(text[1..text.len() - 1].to_string())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(x,\
    \ y)| x == y)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    for i in 0..text.len() {\n      \
    \  if text.chars().nth(i) != text.chars().nth(text.len() - i - 1) {\n        \
    \    return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len < 2 {\n        return true;\n    }\n    for i in 0..(len / 2) {\n\
    \        if text.chars().nth(i) != text.chars().nth(len - i - 1) {\n         \
    \   return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().eq(text.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut reversed\
    \ = String::new();\n    for c in text.chars().rev() {\n        reversed.push(c);\n\
    \    }\n    return text == reversed;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let s: Vec<char>\
    \ = text.chars().collect();\n    for i in 0..s.len() {\n        if s[i] != s[s.len()\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().eq(text.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    if length <= 1 {\n        return true;\n    }\n    let first\
    \ = text.chars().next().unwrap();\n    let last = text.chars().rev().next().unwrap();\n\
    \    if first != last {\n        return false;\n    }\n    is_palindrome(text[1..length\
    \ - 1].to_string())\n}\n\nfn main() {\n    let candidate = is_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let reverse\
    \ = text.chars().rev().collect::<String>();\n    text == reverse\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    for i in 0..len/2 {\n        if text.chars().nth(i) != text.chars().nth(len\
    \ - i - 1) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut first = chars.next();\n    let mut last = chars.next_back();\n\
    \    loop {\n        if first == last {\n            match (first, last) {\n \
    \               (Some(_), Some(_)) => {\n                    first = chars.next();\n\
    \                    last = chars.next_back();\n                }\n          \
    \      (None, None) => return true,\n                _ => return false,\n    \
    \        }\n        } else {\n            return false;\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8fnnt0jv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    for i in 0..chars.len() / 2 {\n   \
    \     if chars[i] != chars[chars.len() - i - 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.replace(\" \", \"\");\n    let n = text.len();\n    if n <= 1 {\n     \
    \   return true;\n    }\n    let ch1 = text.chars().nth(0).unwrap();\n    let\
    \ ch2 = text.chars().nth(n - 1).unwrap();\n    if ch1 != ch2 {\n        return\
    \ false;\n    }\n    return is_palindrome(text[1..n - 1].to_string());\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let s: Vec<char>\
    \ = text.chars().collect();\n    let len = s.len();\n    for i in 0..len / 2 {\n\
    \        if s[i] != s[len - i - 1] {\n            return false;\n        }\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == String::from(text.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // TODO: your\
    \ code here\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpufe3vhny.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.chars().collect::<Vec<char>>();\n    let left = 0;\n    let right = text.len()\
    \ - 1;\n    while left < right {\n        if text[left] != text[right] {\n   \
    \         return false;\n        }\n        left += 1;\n        right -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `left`\n  --> /tmp/tmp1_sgc8pv.rs:18:9\n\
    \   |\n12 |     let left = 0;\n   |         ----\n   |         |\n   |       \
    \  first assignment to `left`\n   |         help: consider making this binding\
    \ mutable: `mut left`\n...\n18 |         left += 1;\n   |         ^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `right`\n  --> /tmp/tmp1_sgc8pv.rs:19:9\n   |\n13 |     let right =\
    \ text.len() - 1;\n   |         -----\n   |         |\n   |         first assignment\
    \ to `right`\n   |         help: consider making this binding mutable: `mut right`\n\
    ...\n19 |         right -= 1;\n   |         ^^^^^^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut i =\
    \ 0;\n    let mut j = text.len() - 1;\n    let mut result = true;\n    while i\
    \ < j {\n        if text.chars().nth(i) != text.chars().nth(j) {\n           \
    \ result = false;\n            break;\n        }\n        i += 1;\n        j -=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5yms1p3q.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut half_length = chars.clone().count() / 2;\n    while\
    \ half_length > 0 {\n        let left = chars.next().unwrap();\n        let right\
    \ = chars.clone().rev().next().unwrap();\n        if left != right {\n       \
    \     return false;\n        }\n        chars.rev().next();\n        half_length\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `chars`\n    --> /tmp/tmp0pwuk19x.rs:14:20\n\
    \     |\n11   |     let mut chars = text.chars();\n     |         --------- move\
    \ occurs because `chars` has type `Chars<'_>`, which does not implement the `Copy`\
    \ trait\n...\n14   |         let left = chars.next().unwrap();\n     |       \
    \             ^^^^^^^^^^^^ value borrowed here after move\n...\n19   |       \
    \  chars.rev().next();\n     |               ----- `chars` moved due to this method\
    \ call, in previous iteration of loop\n     |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `chars`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len == 0 {\n        return true;\n    }\n    let last_idx = len - 1;\n\
    \    let mut i = 0;\n    let mut j = last_idx;\n    while i < j {\n        if\
    \ text.chars().nth(i) != text.chars().nth(j) {\n            return false;\n  \
    \      }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_lower\
    \ = text.to_lowercase();\n    let mut chars = text_lower.chars();\n    loop {\n\
    \        match (chars.next(), chars.next_back()) {\n            (Some(c1), Some(c2))\
    \ => {\n                if c1 != c2 {\n                    return false;\n   \
    \             }\n            }\n            (None, None) => return true,\n   \
    \         _ => return false,\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo62eyhsh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut forward = chars.next();\n    let mut backward =\
    \ chars.next_back();\n    while forward != backward && forward.is_some() && backward.is_some()\
    \ {\n        if forward != backward {\n            return false;\n        }\n\
    \        forward = chars.next();\n        backward = chars.next_back();\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpth5c0isp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    for i in 0..chars.len() / 2 {\n   \
    \     if chars[i] != chars[chars.len() - i - 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut text_copy = text.clone();\n    loop {\n       \
    \ match (chars.next(), text_copy.pop()) {\n            (Some(c1), Some(c2)) =>\
    \ {\n                if c1 != c2 {\n                    return false;\n      \
    \          }\n            }\n            (None, None) => {\n                return\
    \ true;\n            }\n            _ => {\n                return false;\n  \
    \          }\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut result\
    \ = true;\n    let chars: Vec<char> = text.chars().collect();\n    let chars_len\
    \ = chars.len();\n    let limit = chars_len / 2;\n    for i in 0..limit {\n  \
    \      if chars[i] != chars[chars_len - i - 1] {\n            result = false;\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let length = text.len();\n    let mid = length / 2;\n\
    \    let (_, mid, after) = text.split_at(mid);\n    let after = if length % 2\
    \ == 0 {\n        after\n    } else {\n        &after[1..]\n    };\n    let first\
    \ = mid.chars().rev().collect::<String>();\n    first == after\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiebpucbl.rs:14:9\n   |\n\
    14 |     let (_, mid, after) = text.split_at(mid);\n   |         ^^^^^^^^^^^^^^^\
    \   ------------------ this expression has type `(&str, &str)`\n   |         |\n\
    \   |         expected a tuple with 2 elements, found one with 3 elements\n  \
    \ |\n   = note: expected tuple `(&str, &str)`\n              found tuple `(_,\
    \ _, _)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    if len <= 1 {\n        return true;\n    }\n    if &text[0..1] == &text[len\
    \ - 1..len] {\n        return is_palindrome(text[1..len - 1].to_string());\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    while let (Some(a), Some(b)) = (chars.next(), chars.next_back())\
    \ {\n        if a != b {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiut47l_m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let reversed\
    \ = text.chars().rev().collect::<String>();\n    text == reversed\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_length\
    \ = text.len();\n    if text_length == 0 {\n        return true;\n    }\n    let\
    \ half_length = text_length / 2;\n    for i in 0..half_length {\n        if text.chars().nth(i)\
    \ != text.chars().nth(text_length - i - 1) {\n            return false;\n    \
    \    }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ remove_whitespace(text);\n    if text.len() < 2 {\n        return true;\n  \
    \  }\n    let chars: Vec<char> = text.chars().collect();\n    let size = chars.len();\n\
    \    let half = size / 2;\n    let mut flag = true;\n    for i in 0..half {\n\
    \        if chars[i] != chars[size - i - 1] {\n            flag = false;\n   \
    \         break;\n        }\n    }\n    flag\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `remove_whitespace` in this scope\n\
    \  --> /tmp/tmp29wzhmgt.rs:11:16\n   |\n11 |     let text = remove_whitespace(text);\n\
    \   |                ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let bytes =\
    \ text.into_bytes();\n    let len = bytes.len();\n    for i in 0..len / 2 {\n\
    \        if bytes[i] != bytes[len - i - 1] {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_length\
    \ = text.len();\n    let text_chars: Vec<char> = text.chars().collect();\n   \
    \ for index in 0..text_length {\n        if text_chars[index] != text_chars[text_length\
    \ - index - 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let str_len\
    \ = text.len();\n    (0..str_len / 2).all(|i| text.chars().nth(i) == text.chars().nth(str_len\
    \ - i - 1))\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let mid = chars.len() / 2;\n    let\
    \ left = &chars[0..mid];\n    let right = if chars.len() % 2 == 0 {\n        &chars[mid..]\n\
    \    } else {\n        &chars[mid + 1..]\n    };\n    left == right.iter().rev()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[char]` with `Rev<std::slice::Iter<'_, char>>`\n\
    \  --> /tmp/tmp6pn5ubyt.rs:19:10\n   |\n19 |     left == right.iter().rev()\n\
    \   |          ^^ no implementation for `&[char] == Rev<std::slice::Iter<'_, char>>`\n\
    \   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, char>>>` is not\
    \ implemented for `&[char]`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n             <&[T]\
    \ as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n   \
    \          <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n\
    \             <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B;\
    \ N]>>\n             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    text.chars().zip(text.chars().rev()).all(|(a, b)|\
    \ a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut chars = text.chars();\n \
    \   let first = chars.next().unwrap();\n    let last = chars.next_back().unwrap();\n\
    \n    if first != last {\n        return false;\n    }\n\n    let mut text_iter\
    \ = text.chars();\n    text_iter.next();\n    text_iter.next_back();\n    let\
    \ new_text: String = text_iter.collect();\n\n    is_palindrome(new_text)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    true\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiut47l_m.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.chars().filter(|c| c.is_alphanumeric()).collect::<String>();\n    text.to_lowercase()\
    \ == text.chars().rev().collect::<String>().to_lowercase()\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_len\
    \ = text.len();\n    if text_len <= 1 {\n        return true;\n    }\n    if text.chars().nth(0).unwrap()\
    \ != text.chars().nth(text_len - 1).unwrap() {\n        return false;\n    }\n\
    \n    is_palindrome(text[1..text_len - 1].to_string())\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    return false;\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9viemf4i.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().all(|c|\
    \ text.chars().nth(text.len() / 2) == Some(c))\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0snci2oo.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let mut left = 0;\n    let mut right\
    \ = chars.len() - 1;\n    while left < right {\n        if chars[left] != chars[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwiynzw82.rs:13:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let text_chars: Vec<char> = text.chars().collect();\n\
    \    let last_index = text_chars.len() - 1;\n    let mid_index = last_index /\
    \ 2;\n    for index in 0..=mid_index {\n        if text_chars[index] != text_chars[last_index\
    \ - index] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let bytes =\
    \ text.into_bytes();\n    let len = bytes.len();\n    let last_index = len - 1;\n\
    \    if len == 0 {\n        return true;\n    }\n\n    for index in 0..(len /\
    \ 2) {\n        if bytes[index] != bytes[last_index - index] {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpsyk2gdis.rs:13:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    // Your code\
    \ here\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp4jscl_h.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let s: String\
    \ = text.chars().rev().collect();\n    return s == text;\n}\n\nfn main() {\n \
    \   let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().eq(text.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut rev_chars = text.chars().rev();\n    while let\
    \ (Some(c), Some(rc)) = (chars.next(), rev_chars.next()) {\n        if c != rc\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let i = 0;\n    let j = text.len() -\
    \ 1;\n    while i < j {\n        if text.chars().nth(i) != text.chars().nth(j)\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp44sxm7no.rs:20:9\n\
    \   |\n14 |     let i = 0;\n   |         -\n   |         |\n   |         first\
    \ assignment to `i`\n   |         help: consider making this binding mutable:\
    \ `mut i`\n...\n20 |         i += 1;\n   |         ^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `j`\n  --> /tmp/tmp44sxm7no.rs:21:9\n   |\n15 |     let j = text.len() - 1;\n\
    \   |         -\n   |         |\n   |         first assignment to `j`\n   |  \
    \       help: consider making this binding mutable: `mut j`\n...\n21 |       \
    \  j -= 1;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    while let (Some(a), Some(b)) = (chars.next(), chars.next_back())\
    \ {\n        if a != b {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let str_len\
    \ = text.len();\n    for i in 0..str_len / 2 {\n        if text.chars().nth(i)\
    \ != text.chars().nth(str_len - i - 1) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let is_letter\
    \ = |c: char| c.is_ascii_alphanumeric();\n    let lowercase = |c: char| c.to_ascii_lowercase();\n\
    \    let chars: Vec<char> = text.chars().filter(is_letter).map(lowercase).collect();\n\
    \    chars.iter().eq(chars.iter().rev())\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0631]: type mismatch in closure arguments\n   --> /tmp/tmpk_65l1h7.rs:13:48\n\
    \    |\n11  |     let is_letter = |c: char| c.is_ascii_alphanumeric();\n    |\
    \                     ----------------------------------- found signature of `fn(char)\
    \ -> _`\n12  |     let lowercase = |c: char| c.to_ascii_lowercase();\n13  |  \
    \   let chars: Vec<char> = text.chars().filter(is_letter).map(lowercase).collect();\n\
    \    |                                         ------ ^^^^^^^^^ expected signature\
    \ of `for<'r> fn(&'r char) -> _`\n    |                                      \
    \   |\n    |                                         required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `filter`\n\nerror[E0599]:\
    \ the method `map` exists for struct `Filter<Chars<'_>, [closure@/tmp/tmpk_65l1h7.rs:11:21:\
    \ 11:56]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpk_65l1h7.rs:13:59\n\
    \   |\n11 |       let is_letter = |c: char| c.is_ascii_alphanumeric();\n   | \
    \                      -----------------------------------\n   |             \
    \          |\n   |                       doesn't satisfy `<_ as FnOnce<(&char,)>>::Output\
    \ = bool`\n   |                       doesn't satisfy `_: FnMut<(&char,)>`\n12\
    \ |       let lowercase = |c: char| c.to_ascii_lowercase();\n13 |       let chars:\
    \ Vec<char> = text.chars().filter(is_letter).map(lowercase).collect();\n   | \
    \                                                            ^^^ method cannot\
    \ be called on `Filter<Chars<'_>, [closure@/tmp/tmpk_65l1h7.rs:11:21: 11:56]>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<[closure@/tmp/tmpk_65l1h7.rs:11:21: 11:56]\
    \ as FnOnce<(&char,)>>::Output = bool`\n           which is required by `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpk_65l1h7.rs:11:21: 11:56]>: Iterator`\n           `[closure@/tmp/tmpk_65l1h7.rs:11:21:\
    \ 11:56]: FnMut<(&char,)>`\n           which is required by `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpk_65l1h7.rs:11:21: 11:56]>: Iterator`\n           `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpk_65l1h7.rs:11:21: 11:56]>:"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let mut i = 0;\n    let mut j = text.len()\
    \ - 1;\n\n    while i < j {\n        if text.chars().nth(i) != text.chars().nth(j)\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_chars:\
    \ Vec<char> = text.chars().collect();\n    let len = text_chars.len();\n    for\
    \ i in 0..len/2 {\n        if text_chars[i] != text_chars[len-i-1] {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut reversed = text.chars().rev();\n    loop {\n  \
    \      match (chars.next(), reversed.next()) {\n            (Some(c1), Some(c2))\
    \ => {\n                if c1 != c2 {\n                    return false;\n   \
    \             }\n            }\n            (None, None) => return true,\n   \
    \         _ => return false,\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let reversed:\
    \ String = text.chars().rev().collect();\n    text == reversed\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let length = chars.len();\n    let\
    \ mid = length / 2;\n    for i in 0..mid {\n        if chars[i] != chars[length\
    \ - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    if length <= 1 {\n        return true;\n    }\n    if text.chars().nth(0).unwrap()\
    \ != text.chars().nth(length - 1).unwrap() {\n        return false;\n    }\n \
    \   is_palindrome(text[1..length - 1].to_string())\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    while let (Some(left), Some(right)) = (chars.next(), chars.next_back())\
    \ {\n        if left != right {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let mut chars = text.chars();\n    let\
    \ first = chars.next().unwrap();\n    let last = chars.next_back().unwrap();\n\
    \    if first != last {\n        return false;\n    }\n    let text_without_borders\
    \ = chars.collect::<String>();\n    is_palindrome(text_without_borders)\n}\n\n\
    fn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let text_length = text.len();\n    for _ in 0..text_length\
    \ / 2 {\n        if chars.next().unwrap() != chars.rev().next().unwrap() {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `chars`\n    --> /tmp/tmpqencb3ir.rs:14:12\n\
    \     |\n11   |     let mut chars = text.chars();\n     |         --------- move\
    \ occurs because `chars` has type `Chars<'_>`, which does not implement the `Copy`\
    \ trait\n...\n14   |         if chars.next().unwrap() != chars.rev().next().unwrap()\
    \ {\n     |            ^^^^^^^^^^^^                   ----- `chars` moved due\
    \ to this method call, in previous iteration of loop\n     |            |\n  \
    \   |            value borrowed here after move\n     |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `chars`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let chars_len = chars.len();\n    let\
    \ mut i = 0;\n    while i < chars_len {\n        if chars[i] != chars[chars_len\
    \ - i - 1] {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_length\
    \ = text.len();\n    let text_length_half = text_length / 2;\n    let text_chars\
    \ = text.chars();\n    let mut text_chars_it = text_chars.clone();\n    for _\
    \ in 0..text_length_half {\n        let first_char = text_chars_it.next().unwrap();\n\
    \        let last_char = text_chars.clone().rev().next().unwrap();\n        if\
    \ first_char != last_char {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqtbo_32l.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut a = chars.next();\n    let mut b = chars.next_back();\n\
    \    while a == b {\n        if a == None {\n            return true;\n      \
    \  }\n        a = chars.next();\n        b = chars.next_back();\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt82sullj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    text.chars().zip(text.chars().rev()).all(|(f, s)|\
    \ f == s)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    for i in 0..length / 2 {\n        if text.chars().nth(i)\
    \ != text.chars().nth(length - i - 1) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_chars:\
    \ Vec<char> = text.chars().collect();\n    let text_chars_rev: Vec<char> = text.chars().rev().collect();\n\
    \    text_chars == text_chars_rev\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut is_palindrome = true;\n    let mut head = chars.next();\n\
    \    let mut tail = chars.next_back();\n    while let (Some(h), Some(t)) = (head,\
    \ tail) {\n        if h != t {\n            is_palindrome = false;\n         \
    \   break;\n        }\n        head = chars.next();\n        tail = chars.next_back();\n\
    \    }\n    is_palindrome\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text =\
    \ text.to_lowercase();\n    let len = text.len();\n    let count = len / 2;\n\
    \    text.chars().take(count).eq(text.chars().rev().take(count))\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut reversed_chars = text.chars().rev();\n    loop\
    \ {\n        let char_option = chars.next();\n        let reversed_char_option\
    \ = reversed_chars.next();\n        match (char_option, reversed_char_option)\
    \ {\n            (Some(char), Some(reversed_char)) => {\n                if char\
    \ != reversed_char {\n                    return false;\n                }\n \
    \           }\n            (None, None) => {\n                return true;\n \
    \           }\n            _ => {\n                return false;\n           \
    \ }\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 1
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    is_palindrome_acc(text,\
    \ 0, text.len() - 1)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome_acc` in this scope\n\
    \  --> /tmp/tmph5y0lhuj.rs:11:5\n   |\n11 |     is_palindrome_acc(text, 0, text.len()\
    \ - 1)\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_len\
    \ = text.len();\n    if text_len < 2 {\n        return true;\n    }\n\n    let\
    \ half_len = text_len / 2;\n    for i in 0..half_len {\n        if text.chars().nth(i)\
    \ != text.chars().nth(text_len - i - 1) {\n            return false;\n       \
    \ }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let last_idx = text.len() - 1;\n\
    \    let center_idx = text.len() / 2;\n\n    if text.chars().nth(0).unwrap() !=\
    \ text.chars().nth(last_idx).unwrap() {\n        return false;\n    }\n\n    if\
    \ center_idx == last_idx || center_idx == 0 {\n        return true;\n    }\n\n\
    \    let end_idx = last_idx - 1;\n    return is_palindrome(text[1..end_idx].to_string());\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4tihf85.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().collect::<String>()\
    \ == text\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_len\
    \ = text.len();\n    if text_len == 0 {\n        return true;\n    }\n    let\
    \ half_len = text_len / 2;\n    let half_text = text.chars().take(half_len);\n\
    \    if text_len % 2 == 0 {\n        return half_text.eq(text.chars().rev().take(half_len));\n\
    \    } else {\n        return half_text.eq(text.chars().rev().skip(1).take(half_len));\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1qkrqp9r.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    for i in 0..length / 2 {\n        if text.chars().nth(i)\
    \ != text.chars().nth(length - i - 1) {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let half_length\
    \ = text.len() / 2;\n    text.chars().take(half_length).eq(text.chars().rev().take(half_length))\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n\n    for (i, ch) in text.chars().enumerate()\
    \ {\n        if ch != text.chars().nth(text.len() - i - 1).unwrap() {\n      \
    \      return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut reversed_chars = text.chars().rev();\n    let mut\
    \ forward_iter = chars.next();\n    let mut reverse_iter = reversed_chars.next();\n\
    \    loop {\n        match (forward_iter, reverse_iter) {\n            (Some(a),\
    \ Some(b)) => {\n                if a != b {\n                    return false;\n\
    \                }\n                forward_iter = chars.next();\n           \
    \     reverse_iter = reversed_chars.next();\n            }\n            (None,\
    \ None) => return true,\n            _ => return false,\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let text_lowercase\
    \ = text.to_lowercase();\n    let text_chars: Vec<char> = text_lowercase.chars().collect();\n\
    \    let text_chars_len = text_chars.len();\n    for i in 0..text_chars_len /\
    \ 2 {\n        if text_chars[i] != text_chars[text_chars_len - i - 1] {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut rchars = text.chars().rev();\n    while let (Some(a),\
    \ Some(b)) = (chars.next(), rchars.next()) {\n        if a != b {\n          \
    \  return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n    let mut chars = text.chars();\n   \
    \ let length = text.len();\n    let mut head = chars.next().unwrap();\n    let\
    \ mut tail = chars.nth(length - 2).unwrap();\n    while head == tail {\n     \
    \   if length % 2 == 0 {\n            return head == tail;\n        }\n      \
    \  head = chars.next().unwrap();\n        tail = chars.next_back().unwrap();\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpty3ouy7l.rs:22:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let mut left = 0;\n    let mut right\
    \ = text.len() - 1;\n    while left < right {\n        if text.chars().nth(left)\
    \ != text.chars().nth(right) {\n            return false;\n        }\n       \
    \ left += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n\
    \    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n\n    let mut n = 0;\n    let mut m = text.len()\
    \ - 1;\n\n    let bytes = text.as_bytes();\n\n    while n < m {\n        if bytes[n]\
    \ != bytes[m] {\n            return false;\n        }\n\n        n += 1;\n   \
    \     m -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut trimmed\
    \ = text.trim().to_lowercase();\n    let mut reversed = trimmed.clone();\n   \
    \ reversed.chars().rev().collect::<String>() == trimmed\n}\n\nfn main() {\n  \
    \  let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().rev().eq(text.chars())\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(x,\
    \ y)| x == y)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n\n    let bytes = text.as_bytes();\n   \
    \ for i in 0..(bytes.len() / 2) {\n        if bytes[i] != bytes[bytes.len() -\
    \ i - 1] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text.chars().zip(text.chars().rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822435
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let split =\
    \ text.chars().collect::<Vec<char>>();\n    split.iter().zip(split.iter().rev()).all(|(x,\
    \ y)| x == y)\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let v: Vec<char>\
    \ = text.chars().collect();\n    let mut index = 0;\n    let len = v.len();\n\
    \    let mut is_palindrome = true;\n    while index < len / 2 {\n        if v[index]\
    \ != v[len - index - 1] {\n            is_palindrome = false;\n            break;\n\
    \        }\n        index += 1;\n    }\n    is_palindrome\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let mid = chars.len() / 2;\n    for\
    \ i in 0..mid {\n        if chars[i] != chars[chars.len() - i - 1] {\n       \
    \     return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let mut left = 0;\n    let mut right\
    \ = chars.len() - 1;\n    while left < right {\n        if chars[left] != chars[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwiynzw82.rs:13:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut rchars = text.chars().rev();\n    loop {\n    \
    \    match (chars.next(), rchars.next()) {\n            (Some(x), Some(y)) if\
    \ x == y => continue,\n            (None, None) => return true,\n            _\
    \ => return false,\n        }\n    }\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let rtext:\
    \ String = text.chars().rev().collect();\n    text == rtext\n}\n\nfn main() {\n\
    \    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    return text.chars().zip(text.chars().rev()).all(|(x,\
    \ y)| x == y);\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ <= 1 {\n        return true;\n    }\n    if text.len() == 2 {\n        return\
    \ text.chars().nth(0).unwrap() == text.chars().nth(1).unwrap();\n    }\n    let\
    \ end = text.len() - 1;\n    let mut i = 0;\n    let mut j = end;\n    while i\
    \ < j {\n        if text.chars().nth(i).unwrap() != text.chars().nth(j).unwrap()\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let len = text.len();\n\
    \    len == 0 || len == 1 || {\n        let (first, last) = text.split_at(1);\n\
    \        let (middle, last) = last.split_at(len - 2);\n        first == last &&\
    \ is_palindrome(middle.to_string())\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976057
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let no_spaces_lowercase\
    \ = text.replace(\" \", \"\").to_lowercase();\n    let length = no_spaces_lowercase.len();\n\
    \    let mut chars = no_spaces_lowercase.chars();\n    for _ in 0..length / 2\
    \ {\n        let first = chars.next().unwrap();\n        let last = chars.next_back().unwrap();\n\
    \        if first != last {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let length\
    \ = text.len();\n    let mut i = 0;\n    while i < length / 2 {\n        if text.chars().nth(i)\
    \ != text.chars().nth(length - i - 1) {\n            return false;\n        }\n\
    \        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let s: String\
    \ = text.chars().filter(|x| x.is_alphanumeric()).collect();\n    let s_lower:\
    \ String = s.to_lowercase();\n    let (s_lower, _) = s_lower.split_at(s_lower.len()\
    \ / 2);\n    let (s_lower, s_lower_backwards) = s_lower.split_at(s_lower.len());\n\
    \    let s_lower_backwards: String = s_lower_backwards.chars().rev().collect();\n\
    \    s_lower == s_lower_backwards\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5z26wt60.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ == 0 {\n        return true;\n    }\n    let half_len = text.len() / 2;\n  \
    \  for i in 0..half_len {\n        if text.chars().nth(i) != text.chars().nth(text.len()\
    \ - i - 1) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in\
    \ 0..len/2 {\n        if chars[i] != chars[len-i-1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let mut chars\
    \ = text.chars();\n    let mut v: Vec<char> = vec![];\n    while let Some(c) =\
    \ chars.next() {\n        v.push(c);\n    }\n    for i in 0..v.len() / 2 {\n \
    \       if v[i] != v[v.len() - i - 1] {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars:\
    \ Vec<char> = text.chars().collect();\n    let reversed: Vec<char> = chars.iter().rev().map(|&x|\
    \ x).collect();\n    chars == reversed\n}\n\nfn main() {\n    let candidate =\
    \ is_palindrome;\n    assert_eq!(candidate(String::from(\"\")), true);\n    assert_eq!(candidate(String::from(\"\
    aba\")), true);\n    assert_eq!(candidate(String::from(\"aaaaa\")), true);\n \
    \   assert_eq!(candidate(String::from(\"zbcd\")), false);\n    assert_eq!(candidate(String::from(\"\
    xywyx\")), true);\n    assert_eq!(candidate(String::from(\"xywyz\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywzx\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 0
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let lower_text\
    \ = text.to_lowercase();\n    for (i, c) in lower_text.chars().enumerate() {\n\
    \        if c != lower_text.chars().nth(lower_text.len() - i - 1).unwrap() {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976058
- exit_code: 101
  program: "/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\
    \"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>>\
    \ is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"\
    zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    if text.len()\
    \ < 2 {\n        return true;\n    }\n    let (first, last) = text.split_at(1);\n\
    \    return first == last && is_palindrome(text[1..text.len() - 1].to_string());\n\
    }\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
    aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n\
    \    assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
    xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6b6csq6j.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976058
