name: HumanEval_156_int_to_mini_roman
language: rs
prompt: "/// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  /// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n\
  /// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n\
  /// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"\
  cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = int_to_mini_roman;\n    assert_eq!(candidate(19),\
  \ String::from(\"xix\"));\n    assert_eq!(candidate(152), String::from(\"clii\"\
  ));\n    assert_eq!(candidate(251), String::from(\"ccli\"));\n    assert_eq!(candidate(426),\
  \ String::from(\"cdxxvi\"));\n    assert_eq!(candidate(500), String::from(\"d\"\
  ));\n    assert_eq!(candidate(1), String::from(\"i\"));\n    assert_eq!(candidate(4),\
  \ String::from(\"iv\"));\n    assert_eq!(candidate(43), String::from(\"xliii\"));\n\
  \    assert_eq!(candidate(90), String::from(\"xc\"));\n    assert_eq!(candidate(94),\
  \ String::from(\"xciv\"));\n    assert_eq!(candidate(532), String::from(\"dxxxii\"\
  ));\n    assert_eq!(candidate(900), String::from(\"cm\"));\n    assert_eq!(candidate(994),\
  \ String::from(\"cmxciv\"));\n    assert_eq!(candidate(1000), String::from(\"m\"\
  ));\n}\n"
completions: ["    let mut number = number;\n    let mut result = String::new();\n\
    \    for &(max, min, letter, factor) in &ROMAN_DIGITS {\n        let count = number\
    \ / factor;\n        number = number % factor;\n        if count > 0 {\n     \
    \       result.push_str(&letter.repeat(count as usize));\n            continue;\n\
    \        }\n        if (number + max) / factor > 0 {\n            result.push_str(&min);\n\
    \            result.push_str(&letter);\n            number += max;\n        }\n\
    \    }\n    result", "    let mut roman_numerals = vec![];\n    let divisors =\
    \ vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    let roman_numerals_symbols\
    \ = vec![\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\",\n    ];\n    let mut number = number;\n\
    \    for (symbol, divisor) in roman_numerals_symbols.iter().zip(divisors.iter())\
    \ {\n        if number < *divisor {\n            continue;\n        }\n      \
    \  let times = number / divisor;\n        number = number % divisor;\n       \
    \ for _ in 0..times {\n            roman_numerals.push(symbol.to_string());\n\
    \        }\n    }\n    roman_numerals.join(\"\")", "    // convert to mini_roman\n\
    \    let mut result = String::new();\n    let mut number = number;\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result.push('m');\n \
    \           number -= 1000;\n        } else if number >= 900 {\n            result.push_str(\"\
    cm\");\n            number -= 900;\n        } else if number >= 500 {\n      \
    \      result.push('d');\n            number -= 500;\n        } else if number\
    \ >= 400 {\n            result.push_str(\"cd\");\n            number -= 400;\n\
    \        } else if number >= 100 {\n            result.push('c');\n          \
    \  number -= 100;\n        } else if number >= 90 {\n            result.push_str(\"\
    xc\");\n            number -= 90;\n        } else if number >= 50 {\n        \
    \    result.push('l');\n            number -= 50;\n        } else if number >=\
    \ 40 {\n            result.push_str(\"xl\");\n            number -= 40;\n    \
    \    } else if number >= 10 {\n            result.push('x');\n            number\
    \ -= 10;\n        } else if number >= 9 {\n            result.push_str(\"ix\"\
    );\n            number -= 9;\n        } else if number >= 5 {\n            result.push('v');\n\
    \            number -= 5;\n        } else if number >= 4 {\n            result.push_str(\"\
    iv\");\n            number -= 4;\n        } else if number >= 1 {\n          \
    \  result.push('i');\n            number -= 1;\n        }\n    }\n    result",
  "    let mut romans = String::new();\n    let number_of_hundreds = number / 100;\n\
    \    let number_of_tens = (number % 100) / 10;\n    let number_of_ones = number\
    \ % 10;\n\n    for _ in 0..number_of_hundreds {\n        romans.push('c');\n \
    \   }\n\n    if number_of_tens == 9 {\n        romans.push_str(\"xc\");\n    }\
    \ else if number_of_tens >= 5 {\n        romans.push('l');\n        for _ in 0..(number_of_tens\
    \ - 5) {\n            romans.push('x');\n        }\n    } else if number_of_tens\
    \ == 4 {\n        romans.push_str(\"xl\");\n    } else {\n        for _ in 0..number_of_tens\
    \ {\n            romans.push('x');\n        }\n    }\n\n    if number_of_ones\
    \ == 9 {\n        romans.push_str(\"ix\");\n    } else if number_of_ones >= 5\
    \ {\n        romans.push('v');\n        for _ in 0..(number_of_ones - 5) {\n \
    \           romans.push('i');\n        }\n    } else if number_of_ones == 4 {\n\
    \        romans.push_str(\"iv\");\n    } else {\n        for _ in 0..number_of_ones\
    \ {\n            romans.push('i');\n        }\n    }\n\n    romans", "    let\
    \ units = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"];\n    let tens = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\"\
    , \"lxx\", \"lxxx\", \"xc\"];\n    let hundreds = [\"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    let thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\", \"mmmmm\", \"mmmmmmmmmmm\"];\n\n    let u = number %\
    \ 10;\n    let t = (number / 10) % 10;\n    let h = (number / 100) % 10;\n   \
    \ let th = (number / 1000) % 10;\n\n    format!(\"{}{}{}{}\", thousands[th as\
    \ usize], hundreds[h as usize], tens[t as usize], units[u as usize])", "    let\
    \ mut result = String::new();\n    if number >= 1000 {\n        result.push_str(\"\
    m\");\n        let mut remainder = number - 1000;\n        for _ in 0..remainder\
    \ / 1000 {\n            result.push_str(\"m\");\n        }\n        remainder\
    \ = remainder % 1000;\n        result.push_str(&int_to_mini_roman(remainder));\n\
    \    } else if number >= 900 {\n        result.push_str(\"cm\");\n        let\
    \ mut remainder = number - 900;\n        for _ in 0..remainder / 100 {\n     \
    \       result.push_str(\"c\");\n        }\n        remainder = remainder % 100;\n\
    \        result.push_str(&int_to_mini_roman(remainder));\n    } else if number\
    \ >= 500 {\n        result.push_str(\"d\");\n        let mut remainder = number\
    \ - 500;\n        for _ in 0..remainder / 100 {\n            result.push_str(\"\
    c\");\n        }\n        remainder = remainder % 100;\n        result.push_str(&int_to_mini_roman(remainder));\n\
    \    } else if number >= 400 {\n        result.push_str(\"cd\");\n        let\
    \ mut remainder = number - 400;\n        for _ in 0..remainder / 100 {\n     \
    \       result.push_str(\"c\");\n        }\n        remainder = remainder % 100;\n\
    \        result.push_str(&int_to_mini_roman(remainder));\n    } else if number\
    \ >= 100 {\n        result.push_str(\"c\");\n        let mut remainder = number\
    \ - 100;\n        for _ in 0..remainder / 100 {\n            result.push_str(\"\
    c\");\n        }\n        remainder = remainder % 100;\n        result.push_str(&int_to_mini_roman(remainder));\n\
    \    } else if number >= 90 {\n        result.push_str(\"xc\");\n        let mut\
    \ remainder = number - 90;\n        for _ in 0..remainder / 10 {\n           \
    \ result.push_str(\"x\");\n        }\n        remainder = remainder % 10;\n  \
    \      result.push_str(&int_to_mini_roman(remainder));\n    } else if number",
  "    const NUM_TO_ROMAN: &[(isize, &str)] = &[\n        (1000, \"m\"),\n       \
    \ (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100,\
    \ \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n\
    \        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4,\
    \ \"iv\"),\n        (1, \"i\"),\n    ];\n\n    let mut number = number;\n    let\
    \ mut roman = String::new();\n\n    for &(num, roman_num) in NUM_TO_ROMAN {\n\
    \        let count = number / num;\n        for _ in 0..count {\n            roman.push_str(roman_num);\n\
    \        }\n        number = number % num;\n    }\n\n    roman", "    // TODO:\
    \ Implement the function here\n\n    unimplemented!()", "    let mut res = String::new();\n\
    \    let romans = vec![\n        (\"i\", 1),\n        (\"v\", 5),\n        (\"\
    x\", 10),\n        (\"l\", 50),\n        (\"c\", 100),\n        (\"d\", 500),\n\
    \        (\"m\", 1000),\n    ];\n    let mut num = number;\n    while num > 0\
    \ {\n        for (i, (r, n)) in romans.iter().enumerate() {\n            if num\
    \ < *n {\n                if i == 0 {\n                    res.push_str(r);\n\
    \                    num -= *n;\n                } else {\n                  \
    \  let (x, y) = romans[i - 1];\n                    if num + y < *n {\n      \
    \                  res.push_str(x);\n                        res.push_str(r);\n\
    \                        num += y;\n                    } else {\n           \
    \             res.push_str(r);\n                        num -= *n;\n         \
    \           }\n                }\n                break;\n            }\n    \
    \    }\n    }\n    res", "    let mini_roman = String::from(\"ixcm\");\n    let\
    \ mut roman = String::from(\"\");\n    let mut num = number;\n    let mut pos\
    \ = 0;\n    while num > 0 {\n        let digit = num % 10;\n        num /= 10;\n\
    \        roman = if digit > 0 {\n            repeat(mini_roman.chars().nth(pos).unwrap(),\
    \ digit as usize) + &roman\n        } else {\n            roman\n        }\n \
    \       pos += 1;\n    }\n    roman", "    let mut roman = String::new();\n  \
    \  let mut num = number;\n    // Handle numbers between 1 and 10\n    for _ in\
    \ 0..num / 10 {\n        roman.push('x');\n    }\n    num %= 10;\n    // Handle\
    \ numbers between 10 and 100\n    for _ in 0..num / 50 {\n        roman.push('l');\n\
    \    }\n    num %= 50;\n    // Handle numbers between 100 and 1000\n    for _\
    \ in 0..num / 100 {\n        roman.push('c');\n    }\n    num %= 100;\n    //\
    \ Handle numbers between 1000 and 3000\n    for _ in 0..num / 1000 {\n       \
    \ roman.push('m');\n    }\n    num %= 1000;\n    // Special case 5 and 9\n   \
    \ if num >= 5 {\n        roman.push('v');\n        num -= 5;\n    }\n    // Special\
    \ case 4 and 9\n    if num == 4 {\n        roman.push('i');\n        roman.push('v');\n\
    \    } else {\n        for _ in 0..num {\n            roman.push('i');\n     \
    \   }\n    }\n    roman", "    let mut num = number;\n    let mut roman_num =\
    \ String::new();\n    let roman_vals = vec![\n        (100, 'c'),\n        (90,\
    \ 'x'),\n        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n        (9,\
    \ 'i'),\n        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n    ];\n   \
    \ for (key, value) in roman_vals {\n        while num >= key {\n            roman_num.push(value);\n\
    \            num -= key;\n        }\n    }\n    roman_num", "    let mut string_result\
    \ = String::new();\n    let mut remaining = number;\n    let roman_numerals =\
    \ [\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n \
    \       (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n       \
    \ (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"\
    ),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n \
    \   let roman_numerals_count = roman_numerals.len();\n    for i in 0..roman_numerals_count\
    \ {\n        let (arabic, roman) = roman_numerals[i];\n        let roman_multiplier\
    \ = remaining / arabic;\n        if roman_multiplier > 0 {\n            for _\
    \ in 0..roman_multiplier {\n                string_result.push_str(roman);\n \
    \           }\n            remaining = remaining % arabic;\n        }\n    }\n\
    \    string_result", "    let mut result = String::new();\n    let mut num = number;\n\
    \    let symbol_values = &[(\"i\", 1), (\"v\", 5), (\"x\", 10), (\"l\", 50), (\"\
    c\", 100), (\"d\", 500), (\"m\", 1000)];\n    let mut i = 6;\n\n    while num\
    \ > 0 {\n        let current_base = symbol_values[i].1;\n        let current_symbol\
    \ = symbol_values[i].0;\n        let next_base = symbol_values[i - 1].1;\n   \
    \     let next_symbol = symbol_values[i - 1].0;\n        let next_next_base =\
    \ symbol_values[i - 2].1;\n        let next_next_symbol = symbol_values[i - 2].0;\n\
    \n        if num >= current_base {\n            num -= current_base;\n       \
    \     result.push_str(current_symbol);\n        } else if num >= current_base\
    \ - next_base {\n            num -= current_base - next_base;\n            result.push_str(next_symbol);\n\
    \            result.push_str(current_symbol);\n        } else if num >= current_base\
    \ - next_next_base {\n            num -= current_base - next_next_base;\n    \
    \        result.push_str(next_next_symbol);\n            result.push_str(current_symbol);\n\
    \        } else {\n            i -= 1;\n        }\n    }\n\n    result", "   \
    \ if number < 1 || number > 1000 {\n        panic!(\"int_to_mini_roman() only\
    \ accepts positive integers between 1 and 1000\");\n    }\n    let (mut ans, mut\
    \ num) = (String::new(), number);\n    let num_symbols = [\n        (\"m\", 1000),\n\
    \        (\"cm\", 900),\n        (\"d\", 500),\n        (\"cd\", 400),\n     \
    \   (\"c\", 100),\n        (\"xc\", 90),\n        (\"l\", 50),\n        (\"xl\"\
    , 40),\n        (\"x\", 10),\n        (\"ix\", 9),\n        (\"v\", 5),\n    \
    \    (\"iv\", 4),\n        (\"i\", 1),\n    ];\n    for (symbol, val) in num_symbols.iter()\
    \ {\n        while num >= *val {\n            ans.push_str(symbol);\n        \
    \    num -= *val;\n        }\n    }\n    ans", "    let mut number = number;\n\
    \    let mut answer = String::new();\n    let romans = [(\"m\", 1000), (\"cm\"\
    , 900), (\"d\", 500), (\"cd\", 400), (\"c\", 100),\n                  (\"xc\"\
    , 90), (\"l\", 50), (\"xl\", 40), (\"x\", 10), (\"ix\", 9), (\"v\", 5),\n    \
    \              (\"iv\", 4), (\"i\", 1)];\n    for &(rom, v) in romans.iter() {\n\
    \        let (div, modulo) = number.div_rem(&v);\n        number = modulo;\n \
    \       answer.push_str(&rom.repeat(div as usize));\n    }\n    answer", "   \
    \ if number < 1 || number > 1000 {\n        panic!(\"Expected 1 <= num <= 1000,\
    \ got {}\", number);\n    }\n    let mut s = String::new();\n    let mut n = number;\n\
    \    let (mut i, mut v, mut x, mut l, mut c) = (0, 0, 0, 0, 0);\n    if n >= 100\
    \ {\n        c = n / 100;\n        n %= 100;\n    }\n    if n >= 50 {\n      \
    \  if n < 90 {\n            l = n / 50;\n            n %= 50;\n        } else\
    \ {\n            l = 1;\n            n -= 50;\n        }\n    }\n    if n >= 10\
    \ {\n        if n < 40 {\n            x = n / 10;\n            n %= 10;\n    \
    \    } else {\n            x = 3;\n            n -= 30;\n        }\n    }\n  \
    \  if n >= 5 {\n        if n < 9 {\n            v = n / 5;\n            n %= 5;\n\
    \        } else {\n            v = 1;\n            n -= 5;\n        }\n    }\n\
    \    if n > 0 {\n        if n < 4 {\n            i = n;\n        } else {\n  \
    \          i = 3;\n        }\n    }\n    for _ in 0..c {\n        s.push('c');\n\
    \    }\n    for _ in 0..l {\n        s.push('l');\n    }\n    for _ in 0..x {\n\
    \        s.push('x');\n    }\n    for _ in 0..v {\n        s.push('v');\n    }\n\
    \    for _ in 0..i {\n        s.push('i');\n    }\n    s", "    // TODO: Implement\
    \ solution here\n    unimplemented!();", "    // Obtain digits with modulo\n \
    \   let mut num = number;\n    let mut v: Vec<char> = Vec::new();\n    let mut\
    \ idx = 0;\n    let map: HashMap<isize, char> = [\n        (1000, 'm'),\n    \
    \    (900, 'c'),\n        (500, 'd'),\n        (400, 'c'),\n        (100, 'c'),\n\
    \        (90, 'x'),\n        (50, 'l'),\n        (40, 'x'),\n        (10, 'x'),\n\
    \        (9, 'i'),\n        (5, 'v'),\n        (4, 'i'),\n        (1, 'i'),\n\
    \    ]\n    .iter()\n    .cloned()\n    .collect();\n    while num > 0 {\n   \
    \     let rest = num % 10;\n        num /= 10;\n        let digit = get_digit(rest,\
    \ idx);\n        let mut k = 0;\n        while k < digit {\n            v.push(map[&(10isize.pow(idx)\
    \ as isize)]);\n            k += 1;\n        }\n        idx += 1;\n    }\n   \
    \ v.reverse();\n    v.iter().collect()", "    if number < 1 || number > 1000 {\n\
    \        return \"\".to_string();\n    }\n    let mut number = number;\n    let\
    \ mut result = \"\".to_string();\n    let mut remainders = vec![];\n    let arabic_numerals\
    \ = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    let mini_roman_numerals\
    \ = vec![\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\",\n    ];\n    for i in 0..arabic_numerals.len()\
    \ {\n        remainders.push(number % arabic_numerals[i]);\n        number = number\
    \ / arabic_numerals[i];\n        if number > 0 {\n            for _ in 0..number\
    \ {\n                result.push_str(mini_roman_numerals[i]);\n            }\n\
    \            number = 0;\n        }\n    }\n    result"]
stop_tokens:
- "\n}"
