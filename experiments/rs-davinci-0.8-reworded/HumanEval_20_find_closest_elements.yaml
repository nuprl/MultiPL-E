name: HumanEval_20_find_closest_elements
language: rs
prompt: "/// From a supplied vector of numbers (of length at least two) select and\
  \ return two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) ->\
  \ (f64, f64) {\n"
tests: "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
  \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
  \ (2.2, 3.1));\n}\n"
completions: ["    if numbers.len() < 2 {\n        panic!(\"Invalid vector size!\"\
    );\n    }\n\n    let mut closest_numbers = (numbers[0], numbers[1]);\n    let\
    \ mut closest_distance = f64::abs(closest_numbers.0 - closest_numbers.1);\n\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let current_distance = f64::abs(numbers[i] - numbers[j]);\n     \
    \       if current_distance < closest_distance {\n                closest_numbers\
    \ = (numbers[i], numbers[j]);\n                closest_distance = current_distance;\n\
    \            }\n        }\n    }\n\n    if closest_numbers.0 > closest_numbers.1\
    \ {\n        (closest_numbers.1, closest_numbers.0)\n    } else {\n        closest_numbers\n\
    \    }", "    let mut left = numbers[0];\n    let mut right = numbers[1];\n  \
    \  let mut minimum = (left - right).abs();\n    for i in 0..numbers.len() - 1\
    \ {\n        let tmp = (numbers[i] - numbers[i + 1]).abs();\n        if tmp <\
    \ minimum {\n            minimum = tmp;\n            left = numbers[i];\n    \
    \        right = numbers[i + 1];\n        }\n    }\n    (left, right)", "    assert!(numbers.len()\
    \ >= 2);\n    let mut first = numbers[0];\n    let mut second = numbers[1];\n\
    \    let mut min_diff = second - first;\n    for i in 0..numbers.len() {\n   \
    \     for j in 0..numbers.len() {\n            if i != j {\n                let\
    \ diff = numbers[j] - numbers[i];\n                if diff < min_diff {\n    \
    \                min_diff = diff;\n                    first = numbers[i];\n \
    \                   second = numbers[j];\n                }\n            }\n \
    \       }\n    }\n    if first > second {\n        (second, first)\n    } else\
    \ {\n        (first, second)\n    }", "    let mut min = std::f64::MAX;\n    let\
    \ mut first = 0.0;\n    let mut second = 0.0;\n    for i in 0..numbers.len() -\
    \ 1 {\n        for j in i + 1..numbers.len() {\n            let f = numbers[i];\n\
    \            let s = numbers[j];\n            let diff = (f - s).abs();\n    \
    \        if diff < min {\n                min = diff;\n                first =\
    \ f;\n                second = s;\n            }\n        }\n    }\n    (first,\
    \ second)", '    unimplemented!();', '    unimplemented!()', "    let mut min_diff\
    \ = f64::INFINITY;\n    let mut closest = (0.0, 0.0);\n    for i in 0..numbers.len()\
    \ {\n        for j in (i + 1)..numbers.len() {\n            let diff = (numbers[i]\
    \ - numbers[j]).abs();\n            if diff < min_diff {\n                min_diff\
    \ = diff;\n                closest = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest", "    assert!(numbers.len() >= 2);\n    // TODO:\
    \ think about what you want to return, write it down, use the provided tests to\
    \ write it, and test it\n    unimplemented!()", "    let mut min_dist: f64 = 1.0;\n\
    \    let mut min_idx1: usize = 0;\n    let mut min_idx2: usize = 0;\n    for (i,\
    \ num) in numbers.iter().enumerate() {\n        for (j, num2) in numbers.iter().enumerate()\
    \ {\n            if i == j {\n                continue;\n            }\n     \
    \       let dist = num2 - num;\n            if dist < min_dist {\n           \
    \     min_dist = dist;\n                min_idx1 = i;\n                min_idx2\
    \ = j;\n            }\n        }\n    }\n    let num1 = numbers[min_idx1];\n \
    \   let num2 = numbers[min_idx2];\n    if num1 < num2 {\n        (num1, num2)\n\
    \    } else {\n        (num2, num1)\n    }", "    let mut smallest_diff = (numbers[0],\
    \ numbers[1]);\n    let mut diff = (numbers[0] - numbers[1]).abs();\n    for i\
    \ in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n       \
    \     let tmp_diff = (numbers[i] - numbers[j]).abs();\n            if tmp_diff\
    \ < diff {\n                diff = tmp_diff;\n                smallest_diff =\
    \ (numbers[i], numbers[j]);\n            }\n        }\n    }\n    smallest_diff",
  "    assert!(numbers.len() >= 2);\n    let mut numbers_refs: Vec<_> = numbers.iter().collect();\n\
    \    numbers_refs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    numbers_refs.into_iter().map(|x|\
    \ *x).zip(numbers_refs.into_iter().skip(1).map(|x| *x)).min_by(|(a, b), (c, d)|\
    \ (a - b).abs().partial_cmp(&(c - d).abs()).unwrap()).unwrap()", "    // TODO:\
    \ Finish this function!\n    let mut sorted = numbers.clone();\n    sorted.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    (sorted[0], sorted[1])", "    let mut smallest\
    \ = (1./0., 1./0.);\n    let mut biggest = (0., 0.);\n    let mut current = 0.;\n\
    \    let mut first = true;\n    for i in numbers {\n        if i < smallest.0\
    \ {\n            smallest = (i, current);\n        }\n        if i > biggest.0\
    \ {\n            biggest = (i, current);\n        }\n        if first {\n    \
    \        first = false;\n        } else {\n            let diff = i - current;\n\
    \            if diff < smallest.1 {\n                smallest = (current, diff);\n\
    \            }\n            if diff > biggest.1 {\n                biggest = (current,\
    \ diff);\n            }\n        }\n        current = i;\n    }\n    if smallest.1\
    \ < biggest.1 {\n        (smallest.0, smallest.0 + smallest.1)\n    } else {\n\
    \        (biggest.0 - biggest.1, biggest.0)\n    }", "    if numbers.len() < 2\
    \ {\n        panic!(\"We need at least two numbers\");\n    }\n    let mut closest_elements\
    \ = (numbers[0], numbers[1]);\n    for i in 0..numbers.len() {\n        for j\
    \ in 0..numbers.len() {\n            if i != j {\n                let (low, high)\
    \ = order_pair(numbers[i], numbers[j]);\n                if (high - low) < (closest_elements.1\
    \ - closest_elements.0) {\n                    closest_elements = (low, high);\n\
    \                }\n            }\n        }\n    }\n    closest_elements", " \
    \   let mut closest_number_1 = numbers[0];\n    let mut closest_number_2 = numbers[1];\n\
    \    let mut closest_difference = closest_number_2 - closest_number_1;\n\n   \
    \ for &number_1 in numbers.iter() {\n        for &number_2 in numbers.iter() {\n\
    \            if number_1 == number_2 {\n                continue;\n          \
    \  }\n\n            let difference = number_2 - number_1;\n            if difference\
    \ < closest_difference {\n                closest_number_1 = number_1;\n     \
    \           closest_number_2 = number_2;\n                closest_difference =\
    \ difference;\n            }\n        }\n    }\n\n    (closest_number_1, closest_number_2)",
  "    let mut minimum = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            if ((numbers[i] - numbers[j]).abs()\
    \ < (minimum.0 - minimum.1).abs()) {\n                minimum = (numbers[i], numbers[j]);\n\
    \            }\n        }\n    }\n    return minimum;", '    (0.0, 0.0)', '    unimplemented!();',
  "    if numbers.len() < 2 {\n        panic!(\"`find_closest_elements` requires at\
    \ least two numbers!\");\n    }\n    let mut min_difference = f64::MAX;\n    let\
    \ mut pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len() - 1 {\n\
    \        for j in i + 1..numbers.len() {\n            let diff = (numbers[i] -\
    \ numbers[j]).abs();\n            if diff < min_difference {\n               \
    \ min_difference = diff;\n                pair = (numbers[i], numbers[j]);\n \
    \           }\n        }\n    }\n    pair", "    let (mut min, mut min_i) = (numbers[0]\
    \ - numbers[1], 0);\n    for i in 1..numbers.len() - 1 {\n        let diff = numbers[i]\
    \ - numbers[i + 1];\n        if diff < min {\n            min = diff;\n      \
    \      min_i = i;\n        }\n    }\n    (numbers[min_i], numbers[min_i + 1])"]
stop_tokens:
- "\n}"
