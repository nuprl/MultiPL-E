name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given vector of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n\
  /// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// vec![]\nfn order_by_points(nums:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
  \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
  \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
  \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
  \ 23, 6, 6]);\n}\n"
completions: ["    let mut vec = nums.clone();\n    vec.sort_by(|a, b| sum_of_digits(*a).cmp(&sum_of_digits(*b)));\n\
    \    vec", "    let mut result = Vec::new();\n    let mut helper = Vec::new();\n\
    \    if nums.len() == 0 {\n        return result;\n    }\n    for i in nums {\n\
    \        let (mut new_value, mut value) = (0, i);\n        while value != 0 {\n\
    \            new_value += value % 10;\n            value /= 10;\n        }\n \
    \       helper.push(new_value);\n    }\n    for _ in 0..nums.len() {\n       \
    \ let mut index = 0;\n        let mut min = helper[0];\n        for i in 1..helper.len()\
    \ {\n            if helper[i] < min {\n                min = helper[i];\n    \
    \            index = i;\n            }\n        }\n        result.push(nums[index]);\n\
    \        helper.remove(index);\n    }\n    result", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|n| sum_of_digits(*n));\n    nums", '    unimplemented!();',
  "    let mut nums_with_sum: Vec<(isize, usize)> = vec![];\n    for (i, num) in nums.iter().enumerate()\
    \ {\n        let mut num_with_sum = (num, 0);\n        let mut tmp = num.abs();\n\
    \        while tmp != 0 {\n            num_with_sum.1 += tmp % 10;\n         \
    \   tmp /= 10;\n        }\n        nums_with_sum.push(num_with_sum);\n    }\n\
    \    nums_with_sum.sort_by(|a, b| (a.1, a.0).cmp(&(b.1, b.0)));\n    let mut answer:\
    \ Vec<isize> = vec![];\n    for (_, i) in nums_with_sum {\n        answer.push(nums[i]);\n\
    \    }\n    answer", "    let mut points = vec![];\n    for item in nums.iter()\
    \ {\n        let mut sum = 0;\n        let mut item = *item;\n        while item\
    \ != 0 {\n            sum += item % 10;\n            item /= 10;\n        }\n\
    \        points.push(sum);\n    }\n    let mut pos = 0;\n    while pos < nums.len()\
    \ {\n        let mut i = pos;\n        while i < nums.len() {\n            if\
    \ points[i] < points[pos] {\n                points.swap(i, pos);\n          \
    \      nums.swap(i, pos);\n            }\n            i += 1;\n        }\n   \
    \     pos += 1;\n    }\n    nums", "    let mut digits = nums.iter().map(|n| n.abs()\
    \ as usize).collect::<Vec<usize>>();\n    for (i, n) in digits.iter_mut().enumerate()\
    \ {\n        *n = sum_digits(*n, 0);\n    }\n    let mut ret = nums.clone();\n\
    \    ret.sort_by(|a, b| {\n        let i = digits.iter().position(|x| x == &(a.abs()\
    \ as usize)).unwrap();\n        let j = digits.iter().position(|x| x == &(b.abs()\
    \ as usize)).unwrap();\n        if digits[i] < digits[j] {\n            std::cmp::Ordering::Less\n\
    \        } else if digits[i] > digits[j] {\n            std::cmp::Ordering::Greater\n\
    \        } else {\n            i.cmp(&j)\n        }\n    });\n    ret", "    let\
    \ points: Vec<(isize, isize)> = nums.iter().map(|n| {\n        let digit_sum =\
    \ n.abs()\n            .to_string()\n            .chars()\n            .map(|ch|\
    \ ch.to_digit(10).unwrap())\n            .sum::<u32>() as isize;\n        (digit_sum,\
    \ *n)\n    }).collect();\n    points.iter().sorted_by(|a, b| a.0.cmp(&b.0)).map(|t|\
    \ t.1).collect()", "    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by(|a,\
    \ b| {\n        let a_digit_sum = sum_of_digits(*a);\n        let b_digit_sum\
    \ = sum_of_digits(*b);\n        a_digit_sum.cmp(&b_digit_sum)\n    });\n    sorted_nums",
  '    nums.into_iter().enumerate().map(|(i, x)| (sum_digits(x), i, x)).sorted_by_key(|x|
    (x.0, x.1)).map(|x| x.2).collect()', "    if nums.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut mutable_nums = nums.clone();\n    mutable_nums.sort_by(|a,\
    \ b| a.abs().sum_digits().cmp(&b.abs().sum_digits()));\n    mutable_nums", " \
    \   let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by(|x, y| x.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>().cmp(&y.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>()));\n\
    \    sorted_nums", "    let mut new_nums = nums.clone();\n    new_nums.sort_by(|a,\
    \ b| {\n        let a_sum: isize = get_digits(*a).iter().sum();\n        let b_sum:\
    \ isize = get_digits(*b).iter().sum();\n        if a_sum == b_sum {\n        \
    \    return nums.iter().position(|&x| x == *a).unwrap().cmp(\n               \
    \ &nums.iter().position(|&x| x == *b).unwrap(),\n            );\n        }\n \
    \       a_sum.cmp(&b_sum)\n    });\n    new_nums", "    let mut res = nums.clone();\n\
    \    res.sort_by(|x, y| x.abs().sum_digits().cmp(&y.abs().sum_digits()));\n  \
    \  res", "    let mut sums: Vec<(isize, isize)> = nums.iter().map(|&x| (x, sum_digits(x))).collect();\n\
    \    sums.sort_by(|&(x1, x2), &(y1, y2)| {\n        x2.cmp(&y2).then(x1.cmp(&y1))\n\
    \    });\n    sums.iter().map(|&(x, _)| x).collect()", "    let mut copy = nums.clone();\n\
    \    copy.sort_by(|a, b| get_digit_sum(*a).cmp(&get_digit_sum(*b)));\n    copy",
  "    let mut nums_map: Vec<(isize, isize)> = Vec::new();\n    for (index, num) in\
    \ nums.iter().enumerate() {\n        let mut sum = 0;\n        let mut num_clone\
    \ = *num;\n        if num_clone < 0 {\n            num_clone = -num_clone;\n \
    \       }\n        while num_clone > 0 {\n            sum += num_clone % 10;\n\
    \            num_clone /= 10;\n        }\n        nums_map.push((index as isize,\
    \ sum));\n    }\n    let mut nums_map = nums_map.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for (_, num) in nums_map {\n\
    \        result.push(nums[num as usize]);\n    }\n    result", "    let mut nums\
    \ = nums;\n    nums.sort_by_key(|n| (n.abs() % 10) + (n.abs() / 10));\n    nums",
  "    // TODO\n    vec![]", "    use std::collections::BTreeMap;\n    let mut result:\
    \ BTreeMap<isize, Vec<isize>> = BTreeMap::new();\n    for i in nums {\n      \
    \  let mut sum = 0;\n        let mut num = i;\n        while num != 0 {\n    \
    \        sum += num % 10;\n            num /= 10;\n        }\n        let entry\
    \ = result.entry(sum).or_insert(Vec::new());\n        entry.push(i);\n    }\n\
    \    let mut result_vec: Vec<isize> = Vec::new();\n    for key in result.keys()\
    \ {\n        let mut nums = result.get_mut(key).unwrap();\n        nums.sort();\n\
    \        for num in nums {\n            result_vec.push(*num);\n        }\n  \
    \  }\n    result_vec"]
stop_tokens:
- "\n}"
