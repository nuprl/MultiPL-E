name: HumanEval_134_check_if_last_char_is_a_letter
language: rs
prompt: "/// Create a function that returns true if the last character\n/// of a given\
  \ string is an alphabetical character and is not\n/// a part of a word, and false\
  \ otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n\
  /// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"\
  ))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"\
  ))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"\
  ))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\"))\n/// false\n\
  fn check_if_last_char_is_a_letter(txt: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n  \
  \  assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
  apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
  \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
  Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\"\
  )), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
  eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n\
  \    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"
completions: ['    txt.split_whitespace().last().unwrap().chars().last().unwrap().is_alphabetic()',
  "    let txt = txt.trim();\n    if txt.is_empty() {\n        return false;\n   \
    \ }\n    txt.chars().last().unwrap().is_alphabetic() && !txt.contains(' ')", " \
    \   let mut current_word = false;\n    let mut previous_character = ' ';\n   \
    \ let mut current_character;\n    for (index, character) in txt.chars().enumerate()\
    \ {\n        current_character = character;\n        if current_character == '\
    \ ' {\n            if previous_character.is_alphabetic() && current_word == false\
    \ {\n                return true;\n            }\n            current_word = false;\n\
    \        } else {\n            current_word = true;\n        }\n        if index\
    \ == txt.len() - 1 {\n            if current_character.is_alphabetic() && current_word\
    \ == false {\n                return true;\n            }\n        }\n       \
    \ previous_character = current_character;\n    }\n    false", '    unimplemented!()',
  '    txt.chars().last().unwrap().is_alphabetic() && !txt.contains(" ")', '    unimplemented!()',
  "    for (i, c) in txt.chars().enumerate().rev() {\n        if !c.is_alphabetic()\
    \ {\n            if i == 0 {\n                return false;\n            } else\
    \ {\n                return txt.chars().rev().nth(i - 1).unwrap().is_alphabetic();\n\
    \            }\n        }\n    }\n    true", '    unimplemented!()', "    let\
    \ mut vec: Vec<char> = txt.chars().collect();\n    let mut first = true;\n   \
    \ let mut last_char: char = ' ';\n    while let Some(c) = vec.pop() {\n      \
    \  if first {\n            last_char = c;\n            first = false;\n      \
    \  } else if c == ' ' {\n            break;\n        }\n    }\n    if last_char\
    \ == ' ' {\n        return false;\n    }\n    last_char.is_alphabetic()", "  \
    \  if txt.is_empty() {\n        return false;\n    }\n    let mut vec = txt.chars().collect::<Vec<char>>();\n\
    \    let c = vec.pop().unwrap();\n    match c {\n        'a' | 'b' | 'c' | 'd'\
    \ | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o'\n        |\
    \ 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => true,\n \
    \       _ => false,\n    }", '    unimplemented!()', '    unimplemented!()', '    unimplemented!("{}",
    txt)', "    if txt.len() > 0 {\n        let txt_vec: Vec<char> = txt.chars().collect();\n\
    \        let last_char = txt_vec[txt.len() - 1];\n        last_char.is_alphabetic()\
    \ && txt.chars().rev().next().unwrap().is_whitespace()\n    } else {\n       \
    \ false\n    }", "    let txt = txt.trim();\n    if txt.is_empty() {\n       \
    \ return false;\n    }\n    let last_char = txt.chars().last().unwrap();\n   \
    \ if last_char.is_alphabetic() {\n        return !txt.contains(&last_char.to_string());\n\
    \    }\n    false", "    // TODO: Make this return the correct value\n    true",
  '    txt.chars().rev().skip_while(|&c| c.is_whitespace()).next().unwrap().is_alphabetic()',
  "    // YOUR CODE HERE\n    if txt.len() == 0 {\n        return false;\n    }\n\
    \    let mut check = true;\n    for c in txt.chars() {\n        if c == ' ' {\n\
    \            check = true;\n        } else if check {\n            if c.is_alphabetic()\
    \ {\n                return true;\n            }\n            check = false;\n\
    \        }\n    }\n    false", '    unimplemented!()', "    if txt.len() == 0\
    \ {\n        return false;\n    }\n    for _ in 0..txt.len() {\n        if txt.ends_with('\
    \ ') {\n            txt.trim_end_matches(' ');\n        }\n    }\n    let ch =\
    \ txt.chars().last().unwrap();\n    ch.is_alphabetic()"]
stop_tokens:
- "\n}"
