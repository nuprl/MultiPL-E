name: HumanEval_99_closest_integer
language: rs
prompt: "/// Create a function that takes a value (string) representing a number\n\
  /// and returns the closest integer to it. If the number is equidistant\n/// from\
  \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
  10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
  /// Rounding away from zero means that if the given number is equidistant\n/// from\
  \ two integers, the one you should return is the one that is the\n/// farthest from\
  \ zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
  -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
  10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
  -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
  0\")), 0);\n}\n"
completions: ['    value.parse::<f64>().unwrap().round() as isize', "    let f_value\
    \ = value.parse::<f64>().unwrap();\n    if f_value.fract() == 0.5 {\n        if\
    \ f_value > 0.0 {\n            f_value.ceil() as isize\n        } else {\n   \
    \         f_value.floor() as isize\n        }\n    } else {\n        f_value.round()\
    \ as isize\n    }", '    value.parse::<f64>().unwrap().round() as isize', "  \
    \  // Split on a dot.\n    let parts: Vec<&str> = value.split('.').collect();\n\
    \    // If the string starts with '-' then the value is negative.\n    let mut\
    \ is_negative = false;\n    if value.starts_with('-') {\n        is_negative =\
    \ true;\n    }\n    // If the float has a fractional component then we need to\
    \ compare\n    // against two numbers: the smaller one, and the larger one.\n\
    \    let mut left_of_dot = parts[0].parse::<isize>().unwrap();\n    let mut right_of_dot\
    \ = 0;\n    if parts.len() > 1 {\n        // We found a fractional component.\n\
    \        right_of_dot = parts[1].parse::<isize>().unwrap();\n        if right_of_dot\
    \ >= 500 {\n            // Round up.\n            left_of_dot += 1;\n        }\n\
    \    }\n    // Re-apply the sign if needed.\n    if is_negative {\n        left_of_dot\
    \ *= -1;\n    }\n    left_of_dot", "    let r = value.parse::<f64>().unwrap();\n\
    \    let mut r = if r.fract() < 0.5 { r.floor() } else { r.ceil() };\n    if r\
    \ == -0.0 {\n        r = 0.0;\n    }\n    r as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    let num = value.parse::<f64>().unwrap();\n    if num > 0.0 {\n\
    \        num.ceil() as isize\n    } else {\n        num.floor() as isize\n   \
    \ }", '    value.parse::<f64>().unwrap().round() as isize', "    let mut int =\
    \ value.parse::<f64>().unwrap();\n    int = if int.fract() < 0.5 {\n        int.floor()\n\
    \    } else {\n        int.ceil()\n    };\n    int as isize", '    value.parse::<f64>().unwrap().round()
    as isize', "    // Your code here\n    unimplemented!()", "    let value = value.parse::<f64>().unwrap();\n\
    \    value.round() as isize", "    let number: f64 = value.parse().unwrap();\n\
    \    if number.fract() >= 0.5 {\n        number.ceil() as isize\n    } else {\n\
    \        number.floor() as isize\n    }", "    let value: f64 = value.parse().unwrap();\n\
    \    let (up, down) = (value.ceil(), value.floor());\n    if up - value > value\
    \ - down {\n        down as isize\n    } else {\n        up as isize\n    }",
  "    if value.contains('.') {\n        let mut value_split = value.split('.');\n\
    \        let value_left = value_split.next().unwrap();\n        let value_right\
    \ = value_split.next().unwrap();\n        if value_right.to_string().parse::<f64>().unwrap()\
    \ > 5.0 {\n            value_left.to_string().parse::<isize>().unwrap() + 1\n\
    \        } else {\n            value_left.to_string().parse::<isize>().unwrap()\n\
    \        }\n    } else {\n        value.parse::<isize>().unwrap()\n    }", " \
    \   let float_value = value.parse::<f64>().unwrap();\n    if float_value >= 0.0\
    \ {\n        float_value.ceil() as isize\n    } else {\n        float_value.floor()\
    \ as isize\n    }", "    let parsed_value = value.parse::<f64>().unwrap();\n \
    \   let closest_integer = parsed_value.round();\n    closest_integer as isize",
  "    let value: f64 = value.parse().unwrap();\n    if value == 0.0 {\n        return\
    \ 0;\n    }\n    let mut lower = value.floor() as isize;\n    let mut upper =\
    \ value.ceil() as isize;\n    if (value - lower as f64).abs() > (value - upper\
    \ as f64).abs() {\n        upper\n    } else {\n        lower\n    }", "    let\
    \ mut buffer = value.as_bytes();\n    let neg = *buffer.first().unwrap() == b'-';\n\
    \    if neg {\n        buffer = &buffer[1..];\n    }\n    let len = buffer.len();\n\
    \    let mut integral = 0;\n    let mut fractional = 0;\n    let mut i = 0;\n\
    \    while i < len && buffer[i] != b'.' {\n        integral = integral * 10 +\
    \ (buffer[i] - b'0') as isize;\n        i += 1;\n    }\n    if i < len {\n   \
    \     let mut power = 1;\n        i += 1;\n        while i < len {\n         \
    \   fractional = fractional * 10 + (buffer[i] - b'0') as isize;\n            power\
    \ *= 10;\n            i += 1;\n        }\n        let mut value = integral * power\
    \ + fractional;\n        if value % power * 2 >= power {\n            value +=\
    \ 1;\n        }\n        value /= power;\n        if neg {\n            -value\n\
    \        } else {\n            value\n        }\n    } else {\n        integral\n\
    \    }", '    value.parse::<f64>().unwrap().round() as isize']
stop_tokens:
- "\n}"
