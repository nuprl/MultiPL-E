language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0jpy06xv.rs:17:37\n   |\n17 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // unimplemented!()\n    let sum = q.iter().sum::<isize>();\n    let\
    \ cmp = q.iter().rev().sum::<isize>();\n    (cmp == sum) && (sum <= w)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0kgln7m8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    (sum_all(&q) <= w) && is_balanced(&q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_all` in this scope\n  --> /tmp/tmpmj_ge_id.rs:17:6\n\
    \   |\n17 |     (sum_all(&q) <= w) && is_balanced(&q)\n   |      ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n\
    \  --> /tmp/tmpmj_ge_id.rs:17:27\n   |\n17 |     (sum_all(&q) <= w) && is_balanced(&q)\n\
    \   |                           ^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for q in q.iter() {\n        sum += q;\n    }\n\
    \    if sum <= w {\n        let mut r: Vec<isize> = q.iter().cloned().rev().collect();\n\
    \        if q == r {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let mut flag = true;\n    for i\
    \ in 0..q.len()/2 {\n        if q[i] != q[q.len()-1-i] {\n            flag = false;\n\
    \            break;\n        }\n    }\n    sum <= w && flag\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {{\\\
    n    {}\\n}}\", q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Vec<isize>` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmpdemxhxk3.rs:17:86\n   |\n17 |     unimplemented!(\"fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {{\\n    {}\\n}}\", q)\n   |                 \
    \                                                                     ^ `Vec<isize>`\
    \ cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Vec<isize>`\n   = note: in format strings you may be\
    \ able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::format_args` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let len = q.len();\n    if sum\
    \ <= w && len >= 1 {\n        let mut a = 0;\n        let b = len - 1;\n     \
    \   while a <= b {\n            if q[a] != q[b] {\n                return false;\n\
    \            }\n            a += 1;\n            b -= 1;\n        }\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `b`\n  --> /tmp/tmp3tupti5a.rs:27:13\n\
    \   |\n21 |         let b = len - 1;\n   |             -\n   |             |\n\
    \   |             first assignment to `b`\n   |             help: consider making\
    \ this binding mutable: `mut b`\n...\n27 |             b -= 1;\n   |         \
    \    ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let it_flies = false;\n    let v_length = q.len();\n    let mut sum:\
    \ isize = 0;\n    for i in q {\n        sum += i;\n    }\n    if v_length == 1\
    \ {\n        it_flies = true;\n    } else if sum <= w {\n        let mut i: usize\
    \ = 0;\n        let mut j: usize = v_length - 1;\n        let mut palindrome =\
    \ true;\n        while i < j {\n            if q[i] != q[j] {\n              \
    \  palindrome = false;\n                break;\n            }\n            i +=\
    \ 1;\n            j -= 1;\n        }\n        if palindrome {\n            it_flies\
    \ = true;\n        }\n    }\n    it_flies\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `it_flies`\n  -->\
    \ /tmp/tmp2tp623k6.rs:24:9\n   |\n17 |     let it_flies = false;\n   |       \
    \  --------\n   |         |\n   |         first assignment to `it_flies`\n   |\
    \         help: consider making this binding mutable: `mut it_flies`\n...\n24\
    \ |         it_flies = true;\n   |         ^^^^^^^^^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp2tp623k6.rs:30:16\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for i in q {\n    |              -\n    | \
    \             |\n    |              `q` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&q`\n...\n30  |             if q[i] != q[j] {\n    |                ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `it_flies`\n  --> /tmp/tmp2tp623k6.rs:38:13\n   |\n17 |     let it_flies\
    \ = false;\n   |         --------\n   |         |\n   |         first assignment\
    \ to `it_flies`\n   |         help: consider making this binding mutable: `mut\
    \ it_flies`\n...\n38 |             it_flies = true;\n   |             ^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    let mut sum\
    \ = 0;\n    while left < right {\n        if q[left] != q[right] {\n         \
    \   return false;\n        }\n        left += 1;\n        right -= 1;\n    }\n\
    \    for item in q {\n        sum += item;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    let sum: isize\
    \ = q.iter().sum();\n    while left < right {\n        if q[left] != q[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    if l == 0 {\n        false\n    } else {\n    \
    \    let mut i = 0;\n        let mut sum = 0;\n        while i < l {\n       \
    \     sum += q[i];\n            if sum > w {\n                return false;\n\
    \            }\n            i += 1;\n        }\n        sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5pdhop04.rs:30:23\n\
    \   |\n30 |         sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                       ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Return true if the object q will fly, and false otherwise.\"\
    );\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return true if the object
    q will fly, and false otherwise.'', /tmp/tmpahp5l8jo.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8_9zfo6c.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() % 2 == 0 {\n        return false;\n    }\n    let mut result\
    \ = false;\n    let mut x: isize = 0;\n    let y: isize = q.len() as isize / 2;\n\
    \    for i in q.iter() {\n        if x < y {\n            x += 1;\n        } else\
    \ {\n            x -= 1;\n        }\n        result = result || x == y;\n    }\n\
    \    result && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6da63bsp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    (q.iter().sum::<isize>() <= w) && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpri94o5l7.rs:17:39\n   |\n17 |     (q.iter().sum::<isize>() <= w) &&\
    \ is_palindrome(&q)\n   |                                       ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let n = q.len();\n    let mut sum = 0;\n    for i in 0..n {\n       \
    \ sum += q[i];\n    }\n    if sum > w {\n        return false;\n    }\n    let\
    \ mut palindrome = true;\n    for i in 0..n / 2 {\n        if q[i] != q[n - i\
    \ - 1] {\n            palindrome = false;\n            break;\n        }\n   \
    \ }\n    palindrome\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0jpy06xv.rs:17:37\n   |\n17 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.iter().fold(0, |acc, x| acc + x);\n    let mut q2 = q;\n  \
    \  let mut w = w;\n    let mut i = 0;\n    while q2 > 0 {\n        i += 1;\n \
    \       q2 = q2 / 10;\n    }\n    while i >= 2 {\n        let aux = 10isize.pow(i\
    \ - 1);\n        if q / aux != q % 10 {\n            return false;\n        }\n\
    \        q = q % aux;\n        q = q / 10;\n        i -= 2;\n    }\n    if q <=\
    \ w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9wov9lum.rs:19:9\n\
    \   |\n19 |     let mut w = w;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign twice to immutable variable `q`\n  --> /tmp/tmp9wov9lum.rs:30:9\n\
    \   |\n17 |     let q = q.iter().fold(0, |acc, x| acc + x);\n   |         -\n\
    \   |         |\n   |         first assignment to `q`\n   |         help: consider\
    \ making this binding mutable: `mut q`\n...\n30 |         q = q % aux;\n   | \
    \        ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `q`\n  --> /tmp/tmp9wov9lum.rs:31:9\n\
    \   |\n17 |     let q = q.iter().fold(0, |acc, x| acc + x);\n   |         -\n\
    \   |         |\n   |         first assignment to `q`\n   |         help: consider\
    \ making this binding mutable: `mut q`\n...\n31 |         q = q / 10;\n   |  \
    \       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let mut temp_q = q.clone();\n \
    \   temp_q.reverse();\n    let is_balanced = q == temp_q;\n    sum <= w && is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpb7gqpllw.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // \u5148\u68C0\u67E5\u4E0D\u7B26\u5408\u6761\u4EF6\u7684\u60C5\u51B5\
    \uFF0C\u6392\u9664\u6389\u4E00\u4E9B\u4E0D\u53EF\u80FD\u7684\u60C5\u51B5\u3002\
    \n    if q.len() == 0 || w == 0 {\n        return false;\n    }\n    if q.len()\
    \ == 1 {\n        return q[0] <= w;\n    }\n    // \u5224\u65AD\u662F\u5426\u4E3A\
    \u56DE\u6587\n    let reversed_q = q.clone();\n    let mut temp = reversed_q.iter().rev();\n\
    \    let mut is_palindromic = true;\n    for x in q.iter() {\n        if Some(x)\
    \ != temp.next() {\n            is_palindromic = false;\n            break;\n\
    \        }\n    }\n    if !is_palindromic {\n        return false;\n    }\n  \
    \  // \u5224\u65AD\u662F\u5426\u8D85\u91CD\n    let sum: isize = q.iter().sum();\n\
    \    return sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.reverse();\n    will_it_fly_helper(&q, w)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_helper` in this scope\n\
    \  --> /tmp/tmp06gp4zzb.rs:19:5\n   |\n19 |     will_it_fly_helper(&q, w)\n  \
    \ |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w < 0 {\n        return false;\n    }\n    let sum = q.iter().sum::<isize>();\n\
    \    let size = q.len();\n    if sum > w {\n        return false;\n    }\n   \
    \ for i in 0..size {\n        if q[i] != q[size - i - 1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && is_palindrome(&q)\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsj83yfba.rs:18:20\n   |\n18 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let l = q.len();\n    for i in 0..l / 2 {\n   \
    \     if q[i] != q[l - i - 1] {\n            return false;\n        }\n      \
    \  sum += q[i];\n    }\n    if l % 2 == 1 {\n        sum += q[l / 2];\n    }\n\
    \    return sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, x| acc + x);\n    let len = q.len();\n\
    \    if sum > w {\n        return false;\n    }\n    if len % 2 == 0 {\n     \
    \   return q[0..len / 2] == q[len / 2..len].iter().rev().collect::<Vec<_>>();\n\
    \    }\n    let mid = len / 2;\n    q[0..mid] == q[mid + 1..len].iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_vp3up07.rs:23:30\n\
    \   |\n23 |         return q[0..len / 2] == q[len / 2..len].iter().rev().collect::<Vec<_>>();\n\
    \   |                              ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `[isize]`\n\nerror[E0277]: can't compare `isize`\
    \ with `&isize`\n  --> /tmp/tmp_vp3up07.rs:26:15\n   |\n26 |     q[0..mid] ==\
    \ q[mid + 1..len].iter().rev().collect::<Vec<_>>()\n   |               ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `[isize]`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut it = q.iter();\n    for _ in 0..q.len()/2 {\n        let next\
    \ = it.next().unwrap();\n        let rev = it.next_back().unwrap();\n        if\
    \ next != rev {\n            return false;\n        }\n    }\n    if q.iter().sum::<isize>()\
    \ <= w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    if l == 0 {\n        return true;\n    }\n    let\
    \ mut i = 0;\n    let mut j = l - 1;\n    while i < j {\n        if q[i] != q[j]\
    \ {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && is_palindrome(&q)\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsj83yfba.rs:18:20\n   |\n18 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().cloned().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if !is_balanced(q.clone()) {\n        return false;\n    }\n    q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpxcn4eim9.rs:17:9\n\
    \   |\n17 |     if !is_balanced(q.clone()) {\n   |         ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    (sum <= w) && (q == q.iter().rev().collect::<Vec<_>>())\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpvqdp6k2v.rs:18:22\n\
    \   |\n18 |     (sum <= w) && (q == q.iter().rev().collect::<Vec<_>>())\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Function will_it_fly(Vec<isize> = {:?}, isize = {})\
    \ returns ...\", q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Function will_it_fly(Vec<isize>
    = [3, 2, 3], isize = 9) returns ...'', /tmp/tmp3jwu11p9.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n    let sum: isize =\
    \ q.iter().sum();\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ q_clone = q.clone();\n    q_clone.reverse();\n    q == q_clone\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, x| acc + x);\n    let mut _q = q.clone();\n\
    \    _q.reverse();\n    _q == q && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let mut rev: Vec<isize> = q.clone();\n\
    \    rev.reverse();\n    rev == q && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut ix = 0;\n    let mut sum = 0;\n    for i in &q {\n        sum\
    \ += i;\n        if q[ix] != q[q.len() - 1 - ix] {\n            return false;\n\
    \        }\n        ix += 1;\n    }\n    if sum <= w {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn is_palindrome(q: &[isize]) -> bool {\n        q.iter().eq(q.iter().rev())\n\
    \    }\n\n    // max possible length is w\n    q.len() <= w as usize && is_palindrome(&q)\
    \ && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && is_palindrome(&q) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpg1v53jdg.rs:17:40\n   |\n17 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0jpy06xv.rs:17:37\n   |\n17 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = q.len() - 1;\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        sum += q[i];\n        i += 1;\n        j -= 1;\n    }\n    if\
    \ q.len() % 2 == 1 {\n        sum += q[i];\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut balanced =\
    \ true;\n    let mut sum = 0;\n    for item in q.iter() {\n        sum += item;\n\
    \        if balanced {\n            if *item != q[j] {\n                balanced\
    \ = false;\n            }\n            i += 1;\n            j -= 1;\n        }\n\
    \    }\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpnpj0qfkr.rs:28:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut v: Vec<isize> = q.clone();\n    v.sort();\n    let sum: isize\
    \ = v.iter().sum();\n    if sum <= w {\n        v == q\n    } else {\n       \
    \ false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp98dvskoe.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    (q == q.iter().rev().cloned().collect::<Vec<isize>>())\
    \ && (sum <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut half = q.len() / 2;\n    let mut half_one = 0;\n    let mut half_two\
    \ = 0;\n    let mut sum = 0;\n    for number in q.iter() {\n        sum += number;\n\
    \    }\n    let mut q = q;\n    q.sort();\n    while half > 0 {\n        half_one\
    \ += q[half - 1];\n        half_two += q[q.len() - half];\n        half -= 1;\n\
    \    }\n    if half_one == half_two && sum <= w {\n        return true;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry21g77k.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let front: isize = q.iter().cloned().take(q.len() / 2).sum();\n    let\
    \ back: isize = q.iter().cloned().rev().take(q.len() / 2).sum();\n    front +\
    \ back <= w && front == back\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    sum <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpedb3e034.rs:18:17\n   |\n18 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let len = q.len();\n    let half_len\
    \ = len / 2;\n    if len == 1 {\n        return true;\n    }\n    if sum <= w\
    \ {\n        q[..half_len] == q[len-1..half_len-1].iter().rev().collect::<Vec<&isize>>()\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7894owd2.rs:24:23\n\
    \   |\n24 |         q[..half_len] == q[len-1..half_len-1].iter().rev().collect::<Vec<&isize>>()\n\
    \   |                       ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        sum += q[i];\n        i += 1;\n        j -= 1;\n    }\n    if\
    \ q.len() % 2 == 1 {\n        sum += q[q.len() / 2];\n    }\n    sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q_len = q.len();\n    if q_len <= 1 {\n        return true;\n   \
    \ }\n    if q_len % 2 == 0 {\n        return false;\n    }\n    let mid = q_len\
    \ / 2;\n    let mut is_balanced = true;\n    for (i, v) in q.iter().enumerate()\
    \ {\n        if i != mid {\n            if q[q_len - i - 1] != *v {\n        \
    \        is_balanced = false;\n                break;\n            }\n       \
    \ }\n    }\n    let sum: isize = q.iter().sum();\n    is_balanced && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    if sum > w {\n        return\
    \ false;\n    }\n    for i in 0..q.len() / 2 {\n        if q[i] != q[q.len() -\
    \ i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // TODO: implement this function\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2cn0mb_5.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n\
    \    let mut is_palindrome = true;\n    while i < j {\n        if q[i] != q[j]\
    \ {\n            is_palindrome = false;\n            break;\n        }\n     \
    \   sum += q[i];\n        i += 1;\n        j -= 1;\n    }\n    if i == j {\n \
    \       sum += q[i];\n    }\n    sum <= w && is_palindrome\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_iter = q.iter();\n    let mut q_iter_rev = q.iter().rev();\n\
    \    let mut weight: isize = 0;\n    while q_iter.len() > 1 {\n        weight\
    \ += q_iter.next().unwrap() + q_iter_rev.next().unwrap();\n    }\n    weight +=\
    \ q_iter.next().unwrap_or(&0);\n    weight <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb4s4m6pd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    q.iter().collect::<Vec<_>>()\
    \ == q.iter().rev().collect::<Vec<_>>() && sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmppphamvn4.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n\
    \   |                      ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let reverse: Vec<isize> = q.iter().rev().cloned().collect();\n\
    \    if sum <= w && q == reverse {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, &x| acc + x);\n    if sum > w {\n  \
    \      return false;\n    }\n    let mut head = 0;\n    let mut tail = q.len()\
    \ - 1;\n    while head < tail {\n        if q[head] != q[tail] {\n           \
    \ return false;\n        }\n        head += 1;\n        tail -= 1;\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n    let is_palindrome\
    \ = |q: &Vec<isize>| -> bool {\n        let len = q.len();\n        let n = len\
    \ - 1;\n        for i in 0..len {\n            if q[i] != q[n - i] {\n       \
    \         return false;\n            }\n        }\n        true\n    };\n    let\
    \ is_balance = |q: &Vec<isize>| -> bool {\n        let mut left = 0;\n       \
    \ let mut right = 0;\n        let len = q.len();\n        for i in 0..len / 2\
    \ {\n            left += q[i];\n            right += q[len - 1 - i];\n       \
    \ }\n        if len % 2 == 1 {\n            left += q[len / 2];\n        }\n \
    \       right == left\n    };\n    let sum = q.iter().fold(0, |acc, &x| acc +\
    \ x);\n    return sum <= w && is_palindrome(&q) && is_balance(&q);\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptnnx7wj9.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let len = q.len();\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n\n    if q.iter().eq(q.iter().rev()) {\n        return true;\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, x| acc + x);\n    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpn0ny676h.rs:18:19\n\
    \   |\n18 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_temp = q.clone();\n    q_temp.reverse();\n    if q_temp ==\
    \ q && q.iter().sum::<isize>() <= w {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n    let s: isize = q.iter().sum();\n\
    \    if s > w {\n        return false;\n    }\n    for a in 0..q.len() {\n   \
    \     for b in a..q.len() {\n            let mut weight: isize = 0;\n        \
    \    for i in a..=b {\n                weight += q[i];\n            }\n      \
    \      if weight > w {\n                return false;\n            }\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp14q1mzkr.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, x| acc + x);\n    let q_check = q.iter().fold(true,\
    \ |acc, x| acc && *x == q[q.len() - 1 - x as usize]);\n    if q_check && sum <=\
    \ w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmpai7df8dn.rs:18:77\n\
    \   |\n18 |     let q_check = q.iter().fold(true, |acc, x| acc && *x == q[q.len()\
    \ - 1 - x as usize]);\n   |                                                  \
    \                           -^^^^^^^^^\n   |                                 \
    \                                            |\n   |                         \
    \                                                    cannot cast `&isize` as `usize`\n\
    \   |                                                                        \
    \     help: dereference the expression: `*x`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0606`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // it's balanced\n    // sum is less than or equal to max weight\n  \
    \  let mut is_balanced = true;\n    let mut summed_weight = 0;\n    for i in 0..q.len()\
    \ {\n        summed_weight += q[i];\n        if q[i] != q[q.len() - 1 - i] {\n\
    \            is_balanced = false;\n        }\n    }\n    if is_balanced && summed_weight\
    \ <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Your code here\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpot7lpv4s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    sum <= w && is_balanced(q)\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp_b82wv6r.rs:18:17\n\
    \   |\n18 |     sum <= w && is_balanced(q)\n   |                 ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    if l == 0 {\n        return false;\n    }\n   \
    \ let mut weight: isize = 0;\n    for i in 0..l / 2 {\n        if q[i] != q[l\
    \ - i - 1] {\n            return false;\n        }\n        weight += q[i];\n\
    \    }\n    if l % 2 == 1 {\n        weight += q[l / 2];\n    }\n    weight <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n    let sum: isize =\
    \ q.iter().sum();\n    if sum > w {\n        return false;\n    }\n    q == q.clone().into_iter().rev().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    if sum > w {\n        return\
    \ false;\n    }\n    for i in 0..q.len() / 2 {\n        if q[i] != q[q.len() -\
    \ i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut weight = 0;\n    let mut check_vector = q.clone();\n    for number\
    \ in q {\n        weight += number;\n        if check_vector.is_empty() {\n  \
    \          break;\n        }\n        let number = check_vector.pop().unwrap();\n\
    \        if number != q[0] {\n            return false;\n        }\n    }\n  \
    \  return weight <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpfhfghg3z.rs:25:22\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n19  |     for number in q {\n    |                  \
    \ - `q` moved due to this implicit call to `.into_iter()`\n...\n25  |        \
    \ if number != q[0] {\n    |                      ^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for number in &q {\n \
    \   |                   +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() % 2 == 0 {\n        return false;\n    }\n    let sum: isize\
    \ = q.iter().sum();\n    if sum > w {\n        return false;\n    }\n    q ==\
    \ q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmpgjft3v.rs:24:7\n\
    \   |\n24 |     q == q.iter().rev().collect::<Vec<&isize>>()\n   |       ^^ no\
    \ implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        sum += q[i];\n        i += 1;\n        j -= 1;\n    }\n    if\
    \ i == j {\n        sum += q[i];\n    }\n    sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w < 0 {\n        return false;\n    }\n    let sum: isize = q.iter().sum();\n\
    \    if sum > w {\n        return false;\n    }\n    let mut iter = q.iter();\n\
    \    let mut rev_iter = q.iter().rev();\n    loop {\n        match (iter.next(),\
    \ rev_iter.next()) {\n            (Some(a), Some(b)) => {\n                if\
    \ a != b {\n                    return false;\n                }\n           \
    \ }\n            (None, None) => return true,\n            _ => return false,\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let total_weight = q.iter().sum::<isize>();\n    let is_palindrome =\
    \ q.iter().zip(q.iter().rev()).all(|(a, b)| a == b);\n    total_weight <= w &&\
    \ is_palindrome\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    q == q.iter().rev().collect::<Vec<&isize>>()\
    \ && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpss7x0xlp.rs:18:7\n\
    \   |\n18 |     q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n   |\
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpb7gqpllw.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let weight: isize = q.iter().fold(0, |acc, x| acc + x);\n    let middle\
    \ = (q.len() - 1) / 2;\n    let start = &q[0..middle];\n    let end = &q[q.len()\
    \ - middle..];\n    weight <= w && start == end.iter().rev()\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmp2mrm8xpz.rs:21:26\n   |\n21 |     weight <= w && start == end.iter().rev()\n\
    \   |                          ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, x| acc + x);\n    let vec_len = q.len();\n\
    \    let mut first = 0;\n    let mut last = vec_len - 1;\n    while first < last\
    \ {\n        if q[first] != q[last] {\n            return false;\n        }\n\
    \        first += 1;\n        last -= 1;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"determine if object {:?} will fly with a maximum weight\
    \ of {}\", q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: determine if object [3,
    2, 3] will fly with a maximum weight of 9'', /tmp/tmp58g4wt0x.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.reverse();\n    let sum = q.iter().fold(0, |acc,\
    \ x| acc + x);\n    let balanced = q == q.iter().rev().collect::<Vec<_>>();\n\
    \    balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmptifhria0.rs:20:22\n\
    \   |\n20 |     let balanced = q == q.iter().rev().collect::<Vec<_>>();\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // todo!()\n    let mut left: isize = 0;\n    let mut right: isize =\
    \ q.len() as isize - 1;\n    while left < right {\n        if q[left as usize]\
    \ != q[right as usize] {\n            return false;\n        }\n        left +=\
    \ 1;\n        right -= 1;\n    }\n    let sum: isize = q.iter().sum();\n    if\
    \ sum <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut stack = Vec::new();\n    for item in q.iter() {\n        if stack.len()\
    \ > 0 && *item == stack[stack.len() - 1] {\n            stack.pop();\n       \
    \ } else {\n            stack.push(*item);\n        }\n    }\n    stack.len()\
    \ == 0 && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1l7ru1vb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        false\n    } else {\n        let q_sum: isize\
    \ = q.iter().sum();\n        is_balanced(q) && q_sum <= w\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpk0jt6878.rs:21:9\n\
    \   |\n21 |         is_balanced(q) && q_sum <= w\n   |         ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_ = q.clone();\n    q_.reverse();\n    if q != q_ {\n      \
    \  return false;\n    }\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0jpy06xv.rs:17:37\n   |\n17 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Given the vec {:?} with maximum weight {}, will it fly?\
    \ {}\", q, w, true);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Given the vec [3, 2, 3]
    with maximum weight 9, will it fly? true'', /tmp/tmpn4fipj8j.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    let s: String = q.iter().map(|n|\
    \ n.to_string()).collect();\n    let rev: String = s.chars().rev().collect();\n\
    \    sum <= w && s == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.into_iter().collect::<Bag<_>>();\n    q.is_balanced() && q.total_weight()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Bag` in this scope\n  --> /tmp/tmp78310bn3.rs:17:37\n\
    \   |\n17 |     let q = q.into_iter().collect::<Bag<_>>();\n   |             \
    \                        ^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    let count = q.len();\n    if\
    \ count == 1 {\n        return true;\n    }\n\n    sum <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwus33_i1.rs:23:17\n   |\n23 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().fold(0, |a, &x| a + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp3jxvdeu4.rs:17:47\n\
    \   |\n17 |     q.iter().fold(0, |a, &x| a + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                               ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    q.iter().rev().eq(q.iter()) &&\
    \ sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let balance: bool = q.iter().zip(q.iter().rev()).all(|(x,\
    \ y)| x == y);\n    return balance && sum <= w;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n\n    let s: isize =\
    \ q.iter().sum();\n    if s > w {\n        return false;\n    }\n\n    let mut\
    \ r = q.clone();\n    r.reverse();\n    q == r\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |acc, &x| acc + x);\n    sum <= w && q ==\
    \ q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let s: isize = q.iter().sum();\n    w >= s && is_palindrome(&q)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpildkn2kx.rs:18:15\n   |\n18 |     w >= s && is_palindrome(&q)\n   |\
    \               ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    let l = q.len();\n    sum <=\
    \ w && l <= 1 || l > 1 && sum <= w && q[0..l / 2] == q[l / 2 + l % 2..].iter().rev().cloned()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `[isize]` with `Cloned<Rev<std::slice::Iter<'_,\
    \ isize>>>`\n  --> /tmp/tmp_1bap_dg.rs:19:60\n   |\n19 |     sum <= w && l <=\
    \ 1 || l > 1 && sum <= w && q[0..l / 2] == q[l / 2 + l % 2..].iter().rev().cloned()\n\
    \   |                                                            ^^ no implementation\
    \ for `[isize] == Cloned<Rev<std::slice::Iter<'_, isize>>>`\n   |\n   = help:\
    \ the trait `PartialEq<Cloned<Rev<std::slice::Iter<'_, isize>>>>` is not implemented\
    \ for `[isize]`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U,\
    \ A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as\
    \ PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n          \
    \   <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n\
    \             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp4vgu1yz5.rs:17:42\n\
    \   |\n17 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balance = true;\n    let mut left_sum = 0;\n    let mut right_sum\
    \ = 0;\n    for i in 0..q.len() / 2 {\n        left_sum += q[i];\n        right_sum\
    \ += q[q.len() - 1 - i];\n        if q[i] != q[q.len() - 1 - i] {\n          \
    \  balance = false;\n        }\n    }\n    left_sum + right_sum <= w && balance\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp4vgu1yz5.rs:17:42\n\
    \   |\n17 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for (i, v) in q.iter().enumerate() {\n        if\
    \ *v > w {\n            return false;\n        }\n        sum += v;\n        if\
    \ sum > w {\n            return false;\n        }\n        if sum == w {\n   \
    \         return i == q.len() - 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqzjj6smx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_iter = q.iter();\n    let mut q_reverse_iter = q.iter().rev();\n\
    \    let mut q_sum = 0;\n    let mut is_balanced = true;\n    while let (Some(q_a),\
    \ Some(q_b)) = (q_iter.next(), q_reverse_iter.next()) {\n        q_sum += q_a\
    \ + q_b;\n        if q_a != q_b {\n            is_balanced = false;\n        }\n\
    \    }\n    is_balanced && q_sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv6tttjdk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // TODO: add code here\n    let sum = q.iter().sum();\n    let l = q.len();\n\
    \    if l == 1 {\n        return true;\n    }\n    if (sum <= w) && (q == q.iter().rev().collect::<Vec<_>>())\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpgl92i6uj.rs:23:25\n\
    \   |\n23 |     if (sum <= w) && (q == q.iter().rev().collect::<Vec<_>>()) {\n\
    \   |                         ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if w < sum {\n        return false;\n\
    \    }\n\n    let mut q_len = q.len();\n    for i in 0..q_len {\n        if q[i]\
    \ != q[q_len - i - 1] {\n            return false;\n        }\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.len() == 1 || (q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>())\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfumtu0_u.rs:17:56\n\
    \   |\n17 |     q.len() == 1 || (q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>())\n\
    \   |                                                        ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() % 2 == 0 {\n        false\n    } else {\n        for i in\
    \ 0..q.len() {\n            if i % 2 == 0 {\n                if q[i] != q[q.len()\
    \ - 1 - i] {\n                    return false;\n                }\n         \
    \   }\n        }\n        let mut sum = 0;\n        for i in 0..q.len() {\n  \
    \          sum += q[i];\n        }\n        sum <= w\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let weight = q.iter().sum::<isize>();\n    let len = q.len();\n    let\
    \ mut acc = 0;\n    for i in 0..len {\n        acc += q[i];\n        if 2 * acc\
    \ == weight {\n            return weight <= w;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptuay31z4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    w >= sum && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpv7dt7hoq.rs:18:19\n\
    \   |\n18 |     w >= sum && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let half: usize = q.len() / 2;\n\
    \    if sum <= w && q[..half] == q[half..].iter().rev().collect::<Vec<&isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp6c6_dmd1.rs:19:30\n\
    \   |\n19 |     if sum <= w && q[..half] == q[half..].iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                              ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp4vgu1yz5.rs:17:42\n\
    \   |\n17 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for elem in q.iter() {\n        sum += elem;\n\
    \    }\n    if sum > w {\n        return false;\n    }\n    if q.len() == 1 {\n\
    \        return true;\n    }\n    let mut l = 0;\n    let mut r = q.len() - 1;\n\
    \    while l < r {\n        if q[l] != q[r] {\n            return false;\n   \
    \     }\n        l += 1;\n        r -= 1;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        sum += q[i];\n        sum += q[j];\n        i += 1;\n       \
    \ j -= 1;\n    }\n    if i == j {\n        sum += q[i];\n    }\n    sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q_len = q.len();\n    let mut q_sum = 0;\n    let mut index = 0;\n\
    \    let mut index_rev = q_len - 1;\n    while index <= index_rev {\n        if\
    \ q[index] != q[index_rev] {\n            return false;\n        }\n        q_sum\
    \ += q[index];\n        index += 1;\n        index_rev -= 1;\n    }\n    q_sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9b3x2rvt.rs:27:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp4vgu1yz5.rs:17:42\n\
    \   |\n17 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8_9zfo6c.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.sort();\n    let mid = q.len() / 2;\n    let q_left\
    \ = &q[..mid];\n    let q_right = &q[q.len() % 2..mid + q.len() % 2];\n    let\
    \ sum: isize = q.iter().sum();\n    sum <= w && q_left == q_right\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp09gn64e9.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n  let mut q = q;\n  q.sort();\n  let sum = q.iter().sum::<isize>();\n  q\
    \ == q.iter().rev().collect::<Vec<_>>() && sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpkk9pqgi_.rs:20:5\n\
    \   |\n20 |   q == q.iter().rev().collect::<Vec<_>>() && sum <= w\n   |     ^^\
    \ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && is_palindrome(&q)\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsj83yfba.rs:18:20\n   |\n18 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && is_palindrome(&q) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpg1v53jdg.rs:17:40\n   |\n17 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut it = q.iter();\n    let mut back = q.iter().rev();\n    let mut\
    \ front = it.next();\n    let mut back = back.next();\n    let mut weight = 0;\n\
    \    loop {\n        if front == None || back == None {\n            break;\n\
    \        }\n        weight += front.unwrap() + back.unwrap();\n        front =\
    \ it.next();\n        back = back.next();\n    }\n    weight <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpezlj4iwk.rs:28:21\n   |\n28 |         back = back.next();\n\
    \   |                     ^^^^ method not found in `Option<&isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976535
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n\
    \    while i < j {\n        if q[i] != q[j] {\n            return false;\n   \
    \     }\n        sum += q[i];\n        i += 1;\n        j -= 1;\n    }\n    if\
    \ i == j {\n        sum += q[i];\n    }\n    return sum <= w;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut stack: Vec<isize> = vec![];\n    let mut weight: isize = 0;\n\
    \    let mut fly = true;\n    let mut tmp: isize;\n    for i in q {\n        weight\
    \ += i;\n        if stack.len() > 0 {\n            tmp = stack.pop().unwrap();\n\
    \            if tmp != i {\n                fly = false;\n            }\n    \
    \    } else {\n            stack.push(i);\n        }\n    }\n    if fly && weight\
    \ <= w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplgviw4ve.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8_9zfo6c.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.sort();\n    q.len() % 2 == 0 && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv06nbbic.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let s: isize = q.iter().sum();\n    if s <= w && is_balanced(q) {\n \
    \       true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp2i4odmnn.rs:18:18\n\
    \   |\n18 |     if s <= w && is_balanced(q) {\n   |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for i in &q {\n        sum += i;\n    }\n    if\
    \ q == q.iter().rev().cloned().collect::<Vec<isize>>() && sum <= w {\n       \
    \ true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s = 0;\n    for i in q.iter() {\n        s += i;\n    }\n   \
    \ return q == q.iter().rev().cloned().collect::<Vec<isize>>() && s <= w;\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() < 2 {\n        return true;\n    }\n    if q.iter().sum::<isize>()\
    \ > w {\n        return false;\n    }\n    let half = q.len() / 2;\n    if q.len()\
    \ % 2 == 0 {\n        q[..half] == q[half..].iter().rev().collect::<Vec<_>>()\n\
    \    } else {\n        q[..half] == q[half + 1..].iter().rev().collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1mfmcmje.rs:25:19\n\
    \   |\n25 |         q[..half] == q[half..].iter().rev().collect::<Vec<_>>()\n\
    \   |                   ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1mfmcmje.rs:27:19\n\
    \   |\n27 |         q[..half] == q[half + 1..].iter().rev().collect::<Vec<_>>()\n\
    \   |                   ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q_sum: isize = q.iter().sum();\n    let q_is_balanced = q.iter().zip(q.iter().rev()).all(|(x,\
    \ y)| x == y);\n    q_sum <= w && q_is_balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    //w >= q.iter().sum::<isize>() && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    \    w >= q.iter().sum::<isize>() && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().fold(0, |a, b| a + b) <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpztvvwi5l.rs:17:46\n\
    \   |\n17 |     q.iter().fold(0, |a, b| a + b) <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                              ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n    let mut sum = 0;\n\
    \    for i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n       \
    \ return false;\n    }\n    q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut v = q.clone();\n    v.sort();\n    v == q && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx2297s12.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().fold(0, |sum, x| sum + x);\n    let is_palindrome\
    \ = q.len() % 2 == 0\n        && q.iter().take(q.len() / 2).eq(q.iter().rev().take(q.len()\
    \ / 2));\n    sum <= w && is_palindrome\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxyqvxeii.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmppho_e9x4.rs:17:42\n\
    \   |\n17 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let mut q_iter = q.iter();\n  \
    \  let mut temp = q_iter.next();\n    let mut result = true;\n    for x in q_iter\
    \ {\n        if temp != x {\n            result = false;\n            break;\n\
    \        }\n        temp = x;\n    }\n    sum <= w && result\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnylx8lph.rs:22:20\n   |\n\
    22 |         if temp != x {\n   |                    ^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n22 |         if temp != Some(x) {\n   |                    +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnylx8lph.rs:26:16\n   |\n19 |     let mut temp\
    \ = q_iter.next();\n   |                    ------------- expected due to this\
    \ value\n...\n26 |         temp = x;\n   |                ^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n26 |         temp = Some(x);\n   |                +++++ +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q_len = q.len();\n    let sum: isize = q.iter().sum();\n    if sum\
    \ <= w && is_palindrome(&q, q_len) {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp7ur6yc0p.rs:19:20\n   |\n19 |     if sum <= w && is_palindrome(&q, q_len)\
    \ {\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let is_balanced = q.iter().zip(q.iter().rev()).all(|(x,\
    \ y)| x == y);\n    sum <= w && is_balanced\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpjqlwomg4.rs:21:39\n\
    \   |\n21 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let balanced = q.iter().rev().zip(q.iter()).all(|(a, b)| a == b);\n \
    \   let sum: isize = q.iter().sum();\n    balanced && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    will_it_fly_1(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_1` in this scope\n  -->\
    \ /tmp/tmpniaj7twm.rs:17:5\n   |\n17 |     will_it_fly_1(q, w)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    is_balanced(q.to_vec()) && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpztx2yijc.rs:17:5\n\
    \   |\n17 |     is_balanced(q.to_vec()) && q.iter().sum::<isize>() <= w\n   |\
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let length = q.len();\n    let half = length / 2;\n    let is_odd = length\
    \ % 2 != 0;\n    let mut sum = 0;\n    for index in 0..(half + is_odd as usize)\
    \ {\n        let next_index = length - index - 1;\n        if index == next_index\
    \ {\n            sum += q[index];\n        } else {\n            if q[index] !=\
    \ q[next_index] {\n                return false;\n            }\n            sum\
    \ += q[index] + q[next_index];\n        }\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = 0;\n    let mut sum = 0;\n    let mut j = q.len() - 1;\n\
    \    loop {\n        if i == j || i > j {\n            break;\n        }\n   \
    \     if q[i] != q[j] {\n            return false;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    for num in q {\n        sum += num;\n    }\n    sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    if l == 0 {\n        return false;\n    }\n   \
    \ let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum > w\
    \ {\n        return false;\n    }\n    if l == 1 {\n        return true;\n   \
    \ }\n    if q[0] != q[l - 1] {\n        return false;\n    }\n    will_it_fly(q[1..l\
    \ - 1].to_vec(), w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmphxcm6mxq.rs:31:8\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n22  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n31  |     if q[0] != q[l -\
    \ 1] {\n    |        ^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n22  |     for i in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let len = q.len();\n    let mut weight = 0;\n    for i in 0..len {\n\
    \        weight += q[i];\n    }\n    if weight > w {\n        return false;\n\
    \    }\n    if len == 1 {\n        return true;\n    }\n\n    for i in 0..len\
    \ / 2 {\n        if q[i] != q[len - i - 1] {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Add code here\n    let mut sum = 0;\n    for i in q.iter() {\n   \
    \     sum += i;\n    }\n    if sum <= w {\n        let mut i = 0;\n        let\
    \ mut j = q.len() - 1;\n        while i < j {\n            if q[i] != q[j] {\n\
    \                return false;\n            }\n            i += 1;\n         \
    \   j -= 1;\n        }\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w < 0 {\n        return false;\n    }\n    let mut q: Vec<isize> =\
    \ q;\n    q.sort();\n    let mut sum = 0;\n    for i in q {\n        sum += i;\n\
    \    }\n    if sum <= w {\n        let mid = q.len() / 2;\n        for i in 0..mid\
    \ {\n            if q[i] != q[q.len() - 1 - i] {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpjyhc20t0.rs:27:19\n\
    \    |\n20  |     let mut q: Vec<isize> = q;\n    |         ----- move occurs\
    \ because `q` has type `Vec<isize>`, which does not implement the `Copy` trait\n\
    ...\n23  |     for i in q {\n    |              - `q` moved due to this implicit\
    \ call to `.into_iter()`\n...\n27  |         let mid = q.len() / 2;\n    |   \
    \                ^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n23  |     for i in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s = 0;\n    let len = q.len();\n    for i in 0..(len / 2) {\n\
    \        if q[i] != q[len - i - 1] {\n            return false;\n        }\n \
    \       s += q[i];\n    }\n    if len % 2 == 1 {\n        s += q[len / 2];\n \
    \   }\n    s <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n    let mut sum = 0;\n\
    \    for x in q.iter() {\n        sum += x;\n    }\n    if sum > w {\n       \
    \ return false;\n    }\n    let mut b = true;\n    for i in 0..(q.len() / 2) {\n\
    \        if q[i] != q[q.len() - 1 - i] {\n            b = false;\n           \
    \ break;\n        }\n    }\n    return b;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut l = 0;\n    let mut r = q.len() - 1;\n    let mut sum = 0;\n\
    \    while l < r {\n        if q[l] != q[r] {\n            return false;\n   \
    \     }\n        sum += q[l];\n        l += 1;\n        r -= 1;\n    }\n    if\
    \ l == r {\n        sum += q[l];\n    }\n    sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    // empty queue returns true\n    if l == 0 {\n\
    \        return true;\n    }\n    // single element queue returns true if weight\
    \ is less than or equal to w\n    if l == 1 {\n        return q[0] <= w;\n   \
    \ }\n    // check for balanced queue\n    for i in 0..l / 2 {\n        if q[i]\
    \ != q[l - i - 1] {\n            return false;\n        }\n    }\n    // check\
    \ weight\n    return q.iter().sum::<isize>() <= w;\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && sum == q.iter().rev().sum()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpef_f04c1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum = q.iter().sum::<isize>();\n    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpjjs9nek6.rs:18:19\n\
    \   |\n18 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Return whether the object {} with weight {} will fly\"\
    , q, w);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Vec<isize>` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmpx_ffdhay.rs:17:76\n   |\n17 |     unimplemented!(\"Return whether the\
    \ object {} with weight {} will fly\", q, w);\n   |                          \
    \                                                  ^ `Vec<isize>` cannot be formatted\
    \ with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is\
    \ not implemented for `Vec<isize>`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let rev: Vec<isize> = q.iter().rev().cloned().collect();\n\
    \    if q == rev && sum <= w {\n        true\n    } else {\n        false\n  \
    \  }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() % 2 == 0 {\n        let mid = q.len() / 2;\n        let (left,\
    \ right) = q.split_at(mid);\n        left == right.iter().rev() && left.iter().sum::<isize>()\
    \ <= w\n    } else {\n        let mid = q.len() / 2;\n        let left = &q[..mid];\n\
    \        let right = &q[mid + 1..];\n        left == right.iter().rev() && left.iter().sum::<isize>()\
    \ <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpf0kcohml.rs:20:14\n   |\n20 |         left == right.iter().rev()\
    \ && left.iter().sum::<isize>() <= w\n   |              ^^ no implementation for\
    \ `&[isize] == Rev<std::slice::Iter<'_, isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_,\
    \ isize>>>` is not implemented for `&[isize]`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A;\
    \ N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as\
    \ PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n      \
    \       <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n\
    \             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmpf0kcohml.rs:25:14\n   |\n25 |         left == right.iter().rev()\
    \ && left.iter().sum::<isize>() <= w\n   |              ^^ no implementation for\
    \ `&[isize] == Rev<std::slice::Iter<'_, isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_,\
    \ isize>>>` is not implemented for `&[isize]`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A;\
    \ N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as\
    \ PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n      \
    \       <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n\
    \             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut new_vec = q.clone();\n    new_vec.reverse();\n    if q == new_vec\
    \ && q.iter().sum::<isize>() <= w {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let weight = q.iter().fold(0, |sum, i| sum + i);\n    if weight > w {\n\
    \        return false;\n    }\n    let pivot = q.len() / 2;\n    q[..pivot] ==\
    \ q[pivot..].iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpgwyrd01f.rs:22:16\n\
    \   |\n22 |     q[..pivot] == q[pivot..].iter().rev().collect::<Vec<_>>()\n  \
    \ |                ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp19nx2psy.rs:18:19\n\
    \   |\n18 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q;\n    q.sort();\n    let q_len = q.len();\n    let mut\
    \ sum = 0;\n    for v in q {\n        sum += v;\n    }\n    let max_weight = w\
    \ * (q_len / 2) as isize;\n    if sum <= max_weight {\n        if q_len % 2 ==\
    \ 0 {\n            let mut v1 = q[0..q_len / 2].to_vec();\n            let mut\
    \ v2 = q[q_len / 2..q_len].to_vec();\n            v2.reverse();\n            v1\
    \ == v2\n        } else {\n            let mut v1 = q[0..q_len / 2].to_vec();\n\
    \            let mut v2 = q[q_len / 2 + 1..q_len].to_vec();\n            v2.reverse();\n\
    \            v1 == v2\n        }\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpa37k86ah.rs:27:17\n\
    \   |\n27 |             let mut v1 = q[0..q_len / 2].to_vec();\n   |         \
    \        ----^^\n   |                 |\n   |                 help: remove this\
    \ `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpa37k86ah.rs:32:17\n   |\n32 |   \
    \          let mut v1 = q[0..q_len / 2].to_vec();\n   |                 ----^^\n\
    \   |                 |\n   |                 help: remove this `mut`\n\nerror[E0382]:\
    \ borrow of moved value: `q`\n   --> /tmp/tmpa37k86ah.rs:27:26\n    |\n17  | \
    \    let mut q = q;\n    |         ----- move occurs because `q` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |     for v in q {\n   \
    \ |              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    27  |             let mut v1 = q[0..q_len / 2].to_vec();\n    |              \
    \            ^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `q`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n21  |     for v in &q {\n    |              +\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.iter().sum::<isize>() <= w && is_palindrome(&q) {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpg1v53jdg.rs:17:40\n   |\n17 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Will the object {:?} fly? (max weight = {})\", q, w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Will the object [3, 2, 3]
    fly? (max weight = 9)'', /tmp/tmpoj0l0s48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && (q.len() as isize)\
    \ % 2 == 1 && q.len() >= 3 {\n        return true;\n    }\n    let mut l = 0;\n\
    \    let mut r = q.len() - 1;\n    while l < r {\n        if q[l] != q[r] {\n\
    \            return false;\n        }\n        l += 1;\n        r -= 1;\n    }\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz9hl_wdp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s: isize = 0;\n    let mut b: bool = true;\n    for e in q.iter()\
    \ {\n        s += e;\n        if b {\n            b = false;\n        } else {\n\
    \            b = true;\n        }\n    }\n    if b {\n        q.iter().rev() ==\
    \ q.iter() && s <= w\n    } else {\n        q.iter().rev() != q.iter() && s <=\
    \ w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Rev<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmp6jw2k0ia.rs:28:24\n   |\n28 |         q.iter().rev()\
    \ == q.iter() && s <= w\n   |         -------------- ^^ -------- std::slice::Iter<'_,\
    \ isize>\n   |         |\n   |         Rev<std::slice::Iter<'_, isize>>\n\nerror[E0369]:\
    \ binary operation `!=` cannot be applied to type `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmp6jw2k0ia.rs:30:24\n   |\n30 |         q.iter().rev() != q.iter()\
    \ && s <= w\n   |         -------------- ^^ -------- std::slice::Iter<'_, isize>\n\
    \   |         |\n   |         Rev<std::slice::Iter<'_, isize>>\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpb7gqpllw.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976534
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if is_balanced(q.clone()) && sum(q) <= w {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpelm91_5p.rs:17:8\n\
    \   |\n17 |     if is_balanced(q.clone()) && sum(q) <= w {\n   |        ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `sum` in this\
    \ scope\n  --> /tmp/tmpelm91_5p.rs:17:34\n   |\n17 |     if is_balanced(q.clone())\
    \ && sum(q) <= w {\n   |                                  ^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n\n    // the sum of a\
    \ palindromic vector is equal to the sum of its first and last elements\n    let\
    \ (first, last) = (q[0], q[q.len() - 1]);\n    if first != last {\n        return\
    \ false;\n    }\n\n    // not checking the first and last elements again\n   \
    \ let mut sum = first + last;\n    let mut i = 1;\n    let mut j = q.len() - 2;\n\
    \    while i < j {\n        let (left, right) = (q[i], q[j]);\n        if left\
    \ != right {\n            return false;\n        }\n        sum += left + right;\n\
    \        i += 1;\n        j -= 1;\n    }\n\n    sum <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpquzu4c00.rs:30:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n\n    let sum: isize\
    \ = q.iter().sum();\n    let reversed: Vec<isize> = q.iter().rev().map(|x| *x).collect();\n\
    \n    sum <= w && q == reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut qq = q.clone();\n    qq.sort();\n    let mut i = 0;\n    let\
    \ mut sum = 0;\n    let mut balanced = true;\n    for q in qq {\n        if (q\
    \ > w) {\n            return false;\n        }\n        sum += q;\n        if\
    \ (sum > w) {\n            return false;\n        }\n        if (i >= qq.len()\
    \ / 2) {\n            break;\n        }\n        if (qq[i] != qq[qq.len() - i\
    \ - 1]) {\n            balanced = false;\n        }\n        i += 1;\n    }\n\
    \    return balanced;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe8eludig.rs:23:12\n\
    \   |\n23 |         if (q > w) {\n   |            ^     ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n23 -         if (q > w)\
    \ {\n23 +         if q > w {\n   | \n\nwarning: unnecessary parentheses around\
    \ `if` condition\n  --> /tmp/tmpe8eludig.rs:27:12\n   |\n27 |         if (sum\
    \ > w) {\n   |            ^       ^\n   |\nhelp: remove these parentheses\n  \
    \ |\n27 -         if (sum > w) {\n27 +         if sum > w {\n   | \n\nwarning:\
    \ unnecessary parentheses around `if` condition\n  --> /tmp/tmpe8eludig.rs:30:12\n\
    \   |\n30 |         if (i >= qq.len() / 2) {\n   |            ^              \
    \   ^\n   |\nhelp: remove these parentheses\n   |\n30 -         if (i >= qq.len()\
    \ / 2) {\n30 +         if i >= qq.len() / 2 {\n   | \n\nwarning: unnecessary parentheses\
    \ around `if` condition\n  --> /tmp/tmpe8eludig.rs:33:12\n   |\n33 |         if\
    \ (qq[i] != qq[qq.len() - i - 1]) {\n   |            ^                       \
    \      ^\n   |\nhelp: remove these parentheses\n   |\n33 -         if (qq[i] !=\
    \ qq[qq.len() - i - 1]) {\n33 +         if qq[i] != qq[qq.len() - i - 1] {\n \
    \  | \n\nerror[E0382]: borrow of moved value: `qq`\n   --> /tmp/tmpe8eludig.rs:30:18\n\
    \    |\n17  |     let mut qq = q.clone();\n    |         ------ move occurs because\
    \ `qq` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n\
    22  |     for q in qq {\n    |              -- `qq` moved due to this implicit\
    \ call to `.into_iter()`\n...\n30  |         if (i >= qq.len() / 2) {\n    | \
    \                 ^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `qq`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n22  |     for q in &qq {\n    |              +\n\nerror: aborting due\
    \ to previous error; 4 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976536
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n    let mut accum = 0;\n\
    \    let mut a: Vec<isize> = Vec::new();\n    for item in q {\n        a.push(item);\n\
    \        accum += item;\n    }\n    if accum > w {\n        return false;\n  \
    \  }\n    while a.len() > 0 {\n        let x = a.remove(0);\n        let y = a.pop();\n\
    \        if x != y.unwrap() {\n            return false;\n        }\n    }\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpa6ovtt8f.rs:32:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976536
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().cloned().sum::<isize>() <= w && q == q.iter().cloned().rev().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976536
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    let mut sum\
    \ = 0;\n    for i in q {\n        sum += i;\n    }\n    if sum > w {\n       \
    \ return false;\n    }\n    while left < right {\n        if q[left] != q[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpkjimc_oi.rs:27:12\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n27  |         if q[left] !=\
    \ q[right] {\n    |            ^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `q`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n20  |     for i in &q {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976536
