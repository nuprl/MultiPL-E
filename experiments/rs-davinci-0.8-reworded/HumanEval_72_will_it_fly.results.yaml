language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0jpy06xv.rs:17:37\n   |\n17 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // unimplemented!()\n    let sum = q.iter().sum::<isize>();\n    let\
    \ cmp = q.iter().rev().sum::<isize>();\n    (cmp == sum) && (sum <= w)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0kgln7m8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    (sum_all(&q) <= w) && is_balanced(&q)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_all` in this scope\n  --> /tmp/tmpmj_ge_id.rs:17:6\n\
    \   |\n17 |     (sum_all(&q) <= w) && is_balanced(&q)\n   |      ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n\
    \  --> /tmp/tmpmj_ge_id.rs:17:27\n   |\n17 |     (sum_all(&q) <= w) && is_balanced(&q)\n\
    \   |                           ^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvgw6mp28.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for q in q.iter() {\n        sum += q;\n    }\n\
    \    if sum <= w {\n        let mut r: Vec<isize> = q.iter().cloned().rev().collect();\n\
    \        if q == r {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7rhrx7lh.rs:18:22\n\
    \   |\n18 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() {\n   |\
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let mut flag = true;\n    for i\
    \ in 0..q.len()/2 {\n        if q[i] != q[q.len()-1-i] {\n            flag = false;\n\
    \            break;\n        }\n    }\n    sum <= w && flag\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"fn will_it_fly(q: Vec<isize>, w: isize) -> bool {{\\\
    n    {}\\n}}\", q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `Vec<isize>` doesn't implement `std::fmt::Display`\n  -->\
    \ /tmp/tmpdemxhxk3.rs:17:86\n   |\n17 |     unimplemented!(\"fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {{\\n    {}\\n}}\", q)\n   |                 \
    \                                                                     ^ `Vec<isize>`\
    \ cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display`\
    \ is not implemented for `Vec<isize>`\n   = note: in format strings you may be\
    \ able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error\
    \ originates in the macro `$crate::format_args` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let sum: isize = q.iter().sum();\n    let len = q.len();\n    if sum\
    \ <= w && len >= 1 {\n        let mut a = 0;\n        let b = len - 1;\n     \
    \   while a <= b {\n            if q[a] != q[b] {\n                return false;\n\
    \            }\n            a += 1;\n            b -= 1;\n        }\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `b`\n  --> /tmp/tmp3tupti5a.rs:27:13\n\
    \   |\n21 |         let b = len - 1;\n   |             -\n   |             |\n\
    \   |             first assignment to `b`\n   |             help: consider making\
    \ this binding mutable: `mut b`\n...\n27 |             b -= 1;\n   |         \
    \    ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let it_flies = false;\n    let v_length = q.len();\n    let mut sum:\
    \ isize = 0;\n    for i in q {\n        sum += i;\n    }\n    if v_length == 1\
    \ {\n        it_flies = true;\n    } else if sum <= w {\n        let mut i: usize\
    \ = 0;\n        let mut j: usize = v_length - 1;\n        let mut palindrome =\
    \ true;\n        while i < j {\n            if q[i] != q[j] {\n              \
    \  palindrome = false;\n                break;\n            }\n            i +=\
    \ 1;\n            j -= 1;\n        }\n        if palindrome {\n            it_flies\
    \ = true;\n        }\n    }\n    it_flies\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `it_flies`\n  -->\
    \ /tmp/tmp2tp623k6.rs:24:9\n   |\n17 |     let it_flies = false;\n   |       \
    \  --------\n   |         |\n   |         first assignment to `it_flies`\n   |\
    \         help: consider making this binding mutable: `mut it_flies`\n...\n24\
    \ |         it_flies = true;\n   |         ^^^^^^^^^^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp2tp623k6.rs:30:16\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for i in q {\n    |              -\n    | \
    \             |\n    |              `q` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&q`\n...\n30  |             if q[i] != q[j] {\n    |                ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `it_flies`\n  --> /tmp/tmp2tp623k6.rs:38:13\n   |\n17 |     let it_flies\
    \ = false;\n   |         --------\n   |         |\n   |         first assignment\
    \ to `it_flies`\n   |         help: consider making this binding mutable: `mut\
    \ it_flies`\n...\n38 |             it_flies = true;\n   |             ^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    let mut sum\
    \ = 0;\n    while left < right {\n        if q[left] != q[right] {\n         \
    \   return false;\n        }\n        left += 1;\n        right -= 1;\n    }\n\
    \    for item in q {\n        sum += item;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 0
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    let sum: isize\
    \ = q.iter().sum();\n    while left < right {\n        if q[left] != q[right]\
    \ {\n            return false;\n        }\n        left += 1;\n        right -=\
    \ 1;\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let l = q.len();\n    if l == 0 {\n        false\n    } else {\n    \
    \    let mut i = 0;\n        let mut sum = 0;\n        while i < l {\n       \
    \     sum += q[i];\n            if sum > w {\n                return false;\n\
    \            }\n            i += 1;\n        }\n        sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5pdhop04.rs:30:23\n\
    \   |\n30 |         sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                       ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!(\"Return true if the object q will fly, and false otherwise.\"\
    );\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return true if the object
    q will fly, and false otherwise.'', /tmp/tmpahp5l8jo.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8_9zfo6c.rs:17:39\n\
    \   |\n17 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() % 2 == 0 {\n        return false;\n    }\n    let mut result\
    \ = false;\n    let mut x: isize = 0;\n    let y: isize = q.len() as isize / 2;\n\
    \    for i in q.iter() {\n        if x < y {\n            x += 1;\n        } else\
    \ {\n            x -= 1;\n        }\n        result = result || x == y;\n    }\n\
    \    result && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6da63bsp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823208
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpky72c4vw.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823208
