name: HumanEval_87_get_row
language: rs
prompt: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which is\
  \ similar to matrix, however, unlike matrices,\n/// each row may contain a different\
  \ number of columns.\n/// Given lst, and integer x, find integers x in the vector,\n\
  /// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple\
  \ is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially\
  \ by rows in ascending order.\n/// Also, sort coordinates of the row by columns\
  \ in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1, 2, 3, 4, 5,\
  \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0, 0), (1,\
  \ 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n/// >>> get_row(vec![vec![],\
  \ vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>,\
  \ x: isize) -> Vec<(isize, isize)> {\n"
tests: "}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
  \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
  \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
  \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
  \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1),\
  \ (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
  \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5,\
  \ 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
  \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5,\
  \ 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1),\
  \ Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
  \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]],\
  \ 3), vec![(2, 2)]);\n}\n"
completions: ["    let mut res: Vec<(isize, isize)> = vec![];\n    for (y, row) in\
    \ lst.iter().enumerate() {\n        let mut cur_x = 0;\n        for (x1, &item)\
    \ in row.iter().enumerate() {\n            if item == x {\n                res.push((y\
    \ as isize, x1 as isize));\n                cur_x = x1 as isize;\n           \
    \ }\n        }\n        if cur_x != 0 {\n            res.push((y as isize, 0));\n\
    \        }\n    }\n    res.sort_by(|&(a, b), &(c, d)| match a.cmp(&c) {\n    \
    \    Ordering::Less => Ordering::Less,\n        Ordering::Greater => Ordering::Greater,\n\
    \        Ordering::Equal => d.cmp(&b),\n    });\n    res", "    lst.iter()\n \
    \       .enumerate()\n        .flat_map(|(i, row)| {\n            row.iter()\n\
    \                .enumerate()\n                .filter(|&(_, y)| x == *y)\n  \
    \              .map(move |(j, _)| (i as isize, j as isize))\n        })\n    \
    \    .sorted_by(|&(i1, j1), &(i2, j2)| if i1 != i2 {\n            i1.cmp(&i2)\n\
    \        } else {\n            j2.cmp(&j1)\n        })\n        .collect()", " \
    \   let mut coordinates = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, x) in row.iter().enumerate() {\n            if *x == x {\n\
    \                coordinates.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    coordinates.sort_by(|(x, y), (x1, y1)| x.cmp(x1).then(y1.cmp(y)));\n\
    \    coordinates", "    let mut res: Vec<(isize, isize)> = vec![];\n    let len\
    \ = lst.len();\n    for i in 0..len {\n        let lst_len = lst[i].len();\n \
    \       for j in 0..lst_len {\n            if lst[i][j] == x {\n             \
    \   res.push((i as isize, j as isize));\n            }\n        }\n    }\n   \
    \ res.sort_by(|a, b| {\n        if a.0 == b.0 {\n            return b.1.cmp(&a.1);\n\
    \        }\n        a.0.cmp(&b.0)\n    });\n    res", "    let mut result: Vec<(isize,\
    \ isize)> = vec![];\n    for (y, row) in lst.iter().enumerate() {\n        for\
    \ (x, i) in row.iter().enumerate() {\n            if *i == x {\n             \
    \   result.push((y as isize, x as isize));\n            }\n        }\n    }\n\
    \    result.sort_by(|a, b| {\n        let row_cmp = a.0.cmp(&b.0);\n        if\
    \ row_cmp == Ordering::Equal {\n            return b.1.cmp(&a.1);\n        }\n\
    \        row_cmp\n    });\n    result", "    if lst.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut rows: Vec<(isize, isize)> = vec![];\n    for (r,\
    \ row) in lst.iter().enumerate() {\n        if row.contains(&x) {\n          \
    \  let c = row.iter().position(|&x_| x_ == x).unwrap() as isize;\n           \
    \ rows.push((r as isize, c));\n        }\n    }\n    rows.sort_by(|a, b| {\n \
    \       if a.0 < b.0 {\n            Ordering::Less\n        } else if a.0 > b.0\
    \ {\n            Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    rows", "    let mut res: Vec<(isize, isize)> = Vec::new();\n\
    \    for (i, row) in lst.iter().enumerate() {\n        for (j, item) in row.iter().enumerate()\
    \ {\n            if *item == x {\n                res.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    res.sort_by(|a, b| {\n        if a.0 ==\
    \ b.0 {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    res", "    let mut res: Vec<(isize, isize)> = vec![];\n\
    \    for (i, row) in lst.iter().enumerate() {\n        for (j, elem) in row.iter().enumerate()\
    \ {\n            if *elem == x {\n                res.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    res.sort_by(|(r1, c1), (r2, c2)| {\n   \
    \     match r1.cmp(r2) {\n            Ordering::Equal => c2.cmp(c1),\n       \
    \     _ => r1.cmp(r2),\n        }\n    });\n    res", "    let mut result: Vec<(isize,\
    \ isize)> = vec![];\n    let mut temp_row = 0;\n    for row in lst {\n       \
    \ let mut temp_col = -1;\n        for col in row {\n            if col == x {\n\
    \                temp_col += 1;\n                result.push((temp_row, temp_col));\n\
    \            }\n        }\n        temp_row += 1;\n    }\n    result.sort_by(|a,\
    \ b| {\n        match a.0.cmp(&b.0) {\n            Ordering::Equal => a.1.cmp(&b.1),\n\
    \            other => other,\n        }\n    });\n    result", "    if lst.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut lst: Vec<(isize, isize)> = lst\n\
    \        .iter()\n        .enumerate()\n        .flat_map(|(i, x)| {\n       \
    \     x.iter()\n                .enumerate()\n                .filter(|(_, &x)|\
    \ x == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n    \
    \    })\n        .collect();\n    lst.sort_by(|(row1, _), (row2, _)| row1.cmp(row2));\n\
    \    lst.sort_by(|(row1, _), (row2, _)| row1.cmp(row2));\n    lst", "    // Your\
    \ code here!\n    let mut to_ret = Vec::new();\n    for (y, xs) in lst.iter().enumerate()\
    \ {\n        for (x, x) in xs.iter().enumerate() {\n            if *x == x {\n\
    \                to_ret.push((y as isize, x as isize));\n            }\n     \
    \   }\n    }\n    to_ret.sort_by(|a, b| {\n        if a.0 != b.0 {\n         \
    \   a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n  \
    \  });\n    to_ret", "    let mut res: Vec<(isize, isize)> = vec![];\n    for\
    \ (row, i) in lst.iter().enumerate() {\n        for (col, val) in i.iter().enumerate()\
    \ {\n            if val == &x {\n                res.push((row as isize, col as\
    \ isize));\n            }\n        }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res", "    if lst.is_empty() {\n        return vec![];\n    }\n    let mut\
    \ result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len() {\n   \
    \     for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n          \
    \      result.push((i as isize, j as isize));\n            }\n        }\n    }\n\
    \    result.sort_by(|a, b| (a.0, b.1).cmp(&(b.0, a.1)));\n    result", "    let\
    \ mut v = Vec::new();\n    for i in 0..lst.len() {\n        for j in 0..lst[i].len()\
    \ {\n            if lst[i][j] == x {\n                v.push((i as isize, j as\
    \ isize));\n            }\n        }\n    }\n    v.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    v", "    let mut v = Vec::new();\n    for (i, elem) in lst.iter().enumerate()\
    \ {\n        for (j, num) in elem.iter().enumerate() {\n            if *num ==\
    \ x {\n                v.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n    v.sort_by(|&(_,\
    \ a), &(_, b)| b.cmp(&a));\n    v", "    lst.iter()\n        .enumerate()\n  \
    \      .map(|(i, row)| {\n            row.iter()\n                .enumerate()\n\
    \                .filter(|(_, &e)| e == x)\n                .map(|(j, _)| (i as\
    \ isize, j as isize))\n        })\n        .flatten()\n        .collect::<Vec<(isize,\
    \ isize)>>()", "    lst.iter()\n        .enumerate()\n        .flat_map(|(y, row)|\
    \ {\n            row.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ n)| n == &x)\n                .map(move |(x, _)| (y as isize, x as isize))\n\
    \        })\n        .sorted_by(|&(y1, x1), &(y2, x2)| (y1, -x1).cmp(&(y2, -x2)))\n\
    \        .collect()", "    let mut result: Vec<(isize, isize)> = vec![];\n   \
    \ for (i, row) in lst.iter().enumerate() {\n        for (j, v) in row.iter().enumerate()\
    \ {\n            if *v == x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| (a.0, -a.1).cmp(&(b.0,\
    \ -b.1)));\n    result", "    let mut result: Vec<(isize, isize)> = vec![];\n\
    \    for (y, sub) in lst.iter().enumerate() {\n        for (x, &item) in sub.iter().enumerate()\
    \ {\n            if item == x {\n                result.push((y as isize, x as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| match a.0.cmp(&b.0)\
    \ {\n        Ordering::Equal => b.1.cmp(&a.1),\n        x => x,\n    });\n   \
    \ result", "    // TODO: implement function\n    let mut result = Vec::new();\n\
    \    if lst.len() == 0 {\n        return result;\n    }\n    for (y, line) in\
    \ lst.iter().enumerate() {\n        for (x1, item) in line.iter().enumerate()\
    \ {\n            if *item == x {\n                result.push((y as isize, x1\
    \ as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        let row_cmp = a.0.cmp(&b.0);\n        match row_cmp {\n            Ordering::Equal\
    \ => b.1.cmp(&a.1),\n            _ => row_cmp,\n        }\n    });\n    result"]
stop_tokens:
- "\n}"
