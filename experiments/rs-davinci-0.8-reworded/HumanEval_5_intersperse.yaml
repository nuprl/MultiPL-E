name: HumanEval_5_intersperse
language: rs
prompt: "/// Insert a number 'delimeter' between every two consecutive elements of\
  \ input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>> intersperse(vec![1,\
  \ 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
  \ isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
  \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
  \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2,\
  \ 2, 2]);\n}\n"
completions: ["    let mut result = vec![];\n    if numbers.len() == 0 {\n       \
    \ return result;\n    }\n    result.push(numbers[0]);\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result", "    if numbers.len() <= 1 {\n        return numbers;\n    }\n\n\
    \    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for i in\
    \ 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n\
    \    }\n    result.push(numbers[numbers.len() - 1]);\n    result", "    let mut\
    \ ret: Vec<isize> = Vec::new();\n    for i in 0..numbers.len() {\n        ret.push(numbers[i]);\n\
    \        if i != numbers.len() - 1 {\n            ret.push(delimeter);\n     \
    \   }\n    }\n    ret", "    let mut result = vec![];\n    for num in numbers\
    \ {\n        if result.len() > 0 {\n            result.push(delimeter);\n    \
    \    }\n        result.push(num);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    for x in numbers {\n        result.push(x);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result", '    intersperse_v1(numbers, delimeter)',
  '    unimplemented!();', "    //--- IMPLEMENT HERE --\n    let mut interspersed:\
    \ Vec<isize> = Vec::new();\n    for (i, num) in numbers.iter().enumerate() {\n\
    \        interspersed.push(*num);\n        if i != numbers.len() - 1 {\n     \
    \       interspersed.push(delimeter);\n        }\n    }\n    return interspersed;",
  "    let mut result = vec![];\n    for i in 0..numbers.len() {\n        if i < numbers.len()\
    \ - 1 {\n            result.push(numbers[i]);\n            result.push(delimeter);\n\
    \        } else {\n            result.push(numbers[i]);\n        }\n    }\n  \
    \  result", "    let mut result = vec![];\n    let mut iter = numbers.iter();\n\
    \    if let Some(number) = iter.next() {\n        result.push(*number);\n    \
    \    for number in iter {\n            result.push(delimeter);\n            result.push(*number);\n\
    \        }\n    }\n    result", "    fn intersperse_helper(\n        prefix: Vec<isize>,\n\
    \        numbers: Vec<isize>,\n        delimeter: isize,\n    ) -> Vec<isize>\
    \ {\n        if numbers.is_empty() {\n            prefix\n        } else {\n \
    \           let (first, rest) = (numbers[0], &numbers[1..]);\n            intersperse_helper(\n\
    \                prefix,\n                rest.to_vec(),\n                delimeter,\n\
    \            )\n            .into_iter()\n            .chain(Some(delimeter))\n\
    \            .chain(Some(first))\n            .collect()\n        }\n    }\n \
    \   intersperse_helper(Vec::new(), numbers, delimeter)", "    let mut result =\
    \ Vec::new();\n    match numbers.split_first() {\n        None => {},\n      \
    \  Some((head, tail)) => {\n            result.push(*head);\n            for elem\
    \ in tail {\n                result.push(delimeter);\n                result.push(*elem);\n\
    \            }\n        }\n    }\n    result", "    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    for x in numbers.iter()\
    \ {\n        result.push(*x);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result", "    match numbers.len() {\n        0 => numbers,\n        1 =>\
    \ numbers,\n        _ => {\n            let mut numbers: Vec<isize> = numbers;\n\
    \            numbers.drain(1..).for_each(|n| {\n                numbers.push(delimeter);\n\
    \                numbers.push(n);\n            });\n            numbers\n    \
    \    }\n    }", "    let mut inter = vec![];\n    for i in 0..numbers.len() {\n\
    \        inter.push(numbers[i]);\n        if i < numbers.len() - 1 {\n       \
    \     inter.push(delimeter);\n        }\n    }\n    inter", "    let (mut result,\
    \ mut iter) = (vec![], numbers.into_iter());\n    while let Some(x) = iter.next()\
    \ {\n        result.push(x);\n        if let Some(&y) = iter.next() {\n      \
    \      result.push(delimeter);\n            result.push(y);\n        }\n    }\n\
    \    result", "    let mut output = vec![];\n    if numbers.len() == 0 {\n   \
    \     return output;\n    }\n    output.push(numbers[0]);\n    let mut index =\
    \ 1;\n    while index < numbers.len() {\n        output.push(delimeter);\n   \
    \     output.push(numbers[index]);\n        index += 1;\n    }\n    output", " \
    \   let mut v = Vec::new();\n    for num in numbers {\n        v.push(num);\n\
    \        v.push(delimeter);\n    }\n    if v.len() > 0 {\n        v.pop();\n \
    \   }\n    v", '    numbers.iter().flat_map(|x| vec![x, &delimeter]).collect()',
  "    let mut result = vec![];\n    let length = numbers.len();\n    let last_item\
    \ = numbers.last().unwrap();\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        result.push(*number);\n        if i + 1 != length {\n           \
    \ result.push(delimeter);\n        }\n    }\n    result"]
stop_tokens:
- "\n}"
