language: rs
name: HumanEval_8_sum_product
results:
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let s: isize = numbers.iter().sum();\n\
    \    let p: isize = numbers.iter().product();\n    (s, p)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // This code produces the same result,\
    \ but it is not as concise as the code in the solution.\n    let mut sum = 0;\n\
    \    let mut product = 1;\n    for number in numbers {\n        sum += number;\n\
    \        product *= number;\n    }\n    (sum, product)\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut total_sum = 0;\n    let mut total_product\
    \ = 1;\n    for number in numbers {\n        total_sum += number;\n        total_product\
    \ *= number;\n    }\n    (total_sum, total_product)\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut prod: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for i in numbers {\n        prod *= i;\n        sum += i;\n\
    \    }\n    (sum, prod)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let empty_sum: isize = 0;\n    let empty_product:\
    \ isize = 1;\n    if numbers.len() == 0 {\n        return (empty_sum, empty_product);\n\
    \    } else {\n        let mut sum: isize = empty_sum;\n        let mut product:\
    \ isize = empty_product;\n        for number in numbers {\n            sum +=\
    \ number;\n            product *= number;\n        }\n        return (sum, product);\n\
    \    }\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut acc_sum = 0;\n    let mut acc_prod\
    \ = 1;\n    for n in numbers {\n        acc_sum += n;\n        acc_prod *= n;\n\
    \    }\n    (acc_sum, acc_prod)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |sum,\
    \ num| sum + num),\n        numbers.iter().fold(1, |product, num| product * num),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut res = (0, 1);\n    for n in numbers\
    \ {\n        res.0 += n;\n        res.1 *= n;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO: Implement function here\n    (0,\
    \ 0)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpbt3fl8c3.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for number\
    \ in numbers {\n        sum += number;\n        product *= number;\n    }\n  \
    \  (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 0)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpzjj35oab.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let mut product = 1;\n    let mut sum = 0;\n\n    for\
    \ number in numbers {\n        product *= number;\n        sum += number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc,\
    \ &x| acc + x);\n    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // write your code here\n    (0, 0)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp3f1hvpgb.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976538
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    return (0, 1);\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmp33_fj_dd.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // Write your code here\n    (0, 0)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpmox1jmv7.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for num\
    \ in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let v = if numbers.is_empty() {\n     \
    \   vec![0, 1]\n    } else {\n        vec![numbers.iter().sum(), numbers.iter().product()]\n\
    \    };\n    (v[0], v[1])\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in &numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0\
    \ + x, acc.1 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in\
    \ numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product),\
    \ &x| (sum + x, product * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let (sum, product) = numbers.iter().fold((0, 1), |(a, b),\
    \ c| (a + c, b * c));\n    (sum, product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO\n    let mut sum = 0;\n    let\
    \ mut product = 1;\n    for i in numbers {\n        sum += i;\n        product\
    \ *= i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(a, b), x|\
    \ (a + x, b * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // iterator over the vector can be defined\
    \ with\n    // let mut iter = numbers.iter();\n    // let sum = iter.sum();\n\
    \    // let product = iter.product();\n    // (sum, product)\n    // but it leads\
    \ to wasted computational resources.\n    //\n    // An alternative solution is\
    \ to use fold method\n    // let (sum, product) = numbers.iter().fold((0, 1),\
    \ |(sum, product), &x| (sum + x, product * x));\n    // but it is less readable.\n\
    \    let mut sum = 0;\n    let mut product = 1;\n    for x in numbers {\n    \
    \    sum += x;\n        product *= x;\n    }\n    (sum, product)\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // unimplemented!()\n    let sum = numbers.iter().fold(0,\
    \ |acc, n| acc + n);\n    let product = numbers.iter().fold(1, |acc, n| acc *\
    \ n);\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO: use fold\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpqm0c5tna.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let (sum, product) = numbers.iter().fold((0, 1), |acc,\
    \ &x| (acc.0 + x, acc.1 * x));\n    (sum, product)\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for i in\
    \ numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // Todo: implement this function\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpq58o55f4.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &num|\
    \ (acc.0 + num, acc.1 * num))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product),\
    \ number| (sum + number, product * number))\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for &n in numbers.iter() {\n        sum += n;\n        product *= n;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product()\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // Rust doc refers to the value of references\
    \ as owned values, Borrowed values and\n    // temporarily borrowed values.\n\
    \    // Owned values are what most people mean when they say \u201Cvalue\u201D\
    ; the values which come from\n    // variable bindings and that are moved around\
    \ by assignment.\n    // Borrowed values, on the other hand, are values that reference\
    \ a memory location. A borrowed\n    // value can be read from and written to\
    \ just like owned values, but they don\u2019t have an owner\n    // and they can\u2019\
    t be moved, so they must always be returned with their original binding.\n   \
    \ // Borrowed values can be split into two categories:\n    // 1. Immutable borrows,\
    \ which are references to a value that can\u2019t be written to; and\n    // 2.\
    \ Mutable borrows, which are references to a value that can be written to.\n\n\
    \    // A temporary borrowed value is either a borrowed value or an owned value\
    \ which is implicitly\n    // converted to a borrowed value, either because there\
    \ is no way to move it or because the\n    // programmer has explicitly given\
    \ up the value\u2019s ownership by passing it by reference to\n    // some function.\n\
    \n    // When a temporary borrowed value is implicitly converted to a borrowed\
    \ value, it has the\n    // lifetime of the reference it was converted to.\n \
    \   let mut result: (isize, isize) = (0, 1);\n    for i in numbers {\n       \
    \ result.0 += i;\n        result.1 *= i;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0\
    \ + x, acc.1 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, n| (acc.0\
    \ + n, acc.1 * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |sum,\
    \ &x| sum + x),\n        numbers.iter().fold(1, |sum, &x| sum * x),\n    )\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc,\
    \ x| acc + x);\n    let prod = numbers.iter().fold(1, |acc, x| acc * x);\n   \
    \ (sum, prod)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product()\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO: implement function\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8vgncfm2.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n\
    \    for number in numbers {\n        sum += number;\n        product *= number;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // It's not hard to do this without `fold`,\
    \ but fold is cool.\n    numbers.iter().fold((0, 1), |acc, n| (acc.0 + n, acc.1\
    \ * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    numbers.iter().fold((0, 1), |acc, &item| (acc.0 + item,\
    \ acc.1 * item))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0\
    \ + x, acc.1 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // get an iterator over all the numbers\
    \ and aggregate it\n    numbers.iter().fold((0, 1), |(acc_sum, acc_prod), num|\
    \ {\n        (acc_sum + num, acc_prod * num)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut product = 1;\n    let mut sum =\
    \ 0;\n    for num in numbers {\n        product *= num;\n        sum += num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for x in numbers {\n        sum += x;\n        product *= x;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // It is possible to solve this problem\
    \ with an explicit loop.\n    // But I prefer to use the iterator API.\n    //\
    \ The Iterator API is very powerful, and it is used almost everywhere in Rust.\n\
    \    //\n    // Hint: if you're wondering how to compute a product of integers,\
    \ look at std::iter::Product.\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n\
    \    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n\
    \    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // return (numbers.iter().sum(), numbers.iter().product());\n\
    \    (numbers.iter().sum(), numbers.iter().product())\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut product = 1;\n    let mut sum =\
    \ 0;\n    for number in numbers {\n        product *= number;\n        sum +=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n  \
    \  let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpajxj4hg8.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for n in\
    \ numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().fold(0, |sum, i| sum +\
    \ i), numbers.iter().fold(1, |prod, i| prod * i))\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for num\
    \ in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc,\
    \ x| acc + x);\n    let product = numbers.iter().fold(1, |acc, x| acc * x);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc,\
    \ i| acc + i);\n    let product = numbers.iter().fold(1, |acc, i| acc * i);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut product = 1;\n    let mut sum =\
    \ 0;\n    for number in numbers {\n        product *= number;\n        sum +=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(acc_sum,\
    \ acc_prod), &val| (acc_sum + val, acc_prod * val))\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, &x| acc +\
    \ x), numbers.iter().fold(1, |acc, &x| acc * x))\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n\
    \    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n   \
    \ (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let v: (isize, isize) = numbers.iter().fold((0,\
    \ 1), |acc, num| (acc.0 + num, acc.1 * num));\n    v\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, prod),\
    \ &n| (sum + n, prod * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for number in numbers {\n        sum += number;\n        product *=\
    \ number;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n\n    let sum = numbers.iter().sum();\n    let product = numbers.iter().product();\n\
    \n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz0dk3bqm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut product = 1;\n    let mut sum =\
    \ 0;\n    for x in numbers {\n        product *= x;\n        sum += x;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // implement this function here\n    //\
    \ use it to pass the test\n    (0, 0)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpcga1_6kp.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // YOUR CODE HERE\n    panic!(\"Not implemented\"\
    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Not implemented'', /tmp/tmpdlwxjy5b.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, x| acc +\
    \ x), numbers.iter().fold(1, |acc, x| acc * x))\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0\
    \ + x, acc.1 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n    \
    \    numbers.iter().product(),\n    )\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0\
    \ + x, acc.1 * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for num in numbers {\n        sum += num;\n        product *= num;\n\
    \    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3rad3yx7.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976539
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO: implement the function\n    (0,\
    \ 0)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmpa2je7fu3.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let sum = numbers.iter().sum();\n    let\
    \ product = numbers.iter().product();\n    (sum, product)\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823241
- exit_code: 101
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    // TODO: Implement it\n    (0, 1)\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmptiqkqwfu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976539
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    if numbers.is_empty() {\n        return\
    \ (0, 1);\n    }\n    let mut sum = 0;\n    let mut product = 1;\n    for number\
    \ in numbers {\n        sum += number;\n        product *= number;\n    }\n  \
    \  (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
- exit_code: 0
  program: "/// For a given vector of integers, return a tuple consisting of a sum\
    \ and a product of all the integers in a vector.\n/// Empty sum should be equal\
    \ to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n\
    /// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers:\
    \ Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product =\
    \ 1;\n    for i in numbers {\n        sum += i;\n        product *= i;\n    }\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976538
