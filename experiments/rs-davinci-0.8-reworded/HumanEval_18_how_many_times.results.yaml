language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_vec: Vec<char> = string.chars().collect();\n    let substring_vec:\
    \ Vec<char> = substring.chars().collect();\n    let mut counter = 0;\n    for\
    \ i in 0..(string_vec.len() - substring_vec.len() + 1) {\n        let mut flag\
    \ = false;\n        for j in 0..substring_vec.len() {\n            if string_vec[i\
    \ + j] != substring_vec[j] {\n                flag = true;\n                break;\n\
    \            }\n        }\n        if !flag {\n            counter += 1;\n   \
    \     }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyivmdv_2.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   isize::from(string.matches(&substring).count())\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `isize: From<usize>` is not satisfied\n -->\
    \ /tmp/tmp5j034fhj.rs:9:5\n  |\n9 |     isize::from(string.matches(&substring).count())\n\
    \  |     ^^^^^^^^^^^ the trait `From<usize>` is not implemented for `isize`\n\
    \  |\n  = help: the following other types implement trait `From<T>`:\n       \
    \     <f32 as From<i16>>\n            <f32 as From<i8>>\n            <f32 as From<u16>>\n\
    \            <f32 as From<u8>>\n            <f64 as From<f32>>\n            <f64\
    \ as From<i16>>\n            <f64 as From<i32>>\n            <f64 as From<i8>>\n\
    \          and 67 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let f = string.len() - substring.len();\n    if f < 0 {\n        return 0;\n\
    \    }\n\n    let mut slice_array = Vec::with_capacity(f);\n    for i in 0..f\
    \ {\n        slice_array.push(string.get(i..i + substring.len()).unwrap());\n\
    \    }\n\n    slice_array.iter().filter(|&x| x == substring.as_str()).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpwpxsg7z1.rs:19:38\n\
    \   |\n19 |     slice_array.iter().filter(|&x| x == substring.as_str()).count()\
    \ as isize\n   |                                      ^^ no implementation for\
    \ `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut t = 0;\n    for i in 0..string.len() {\n        let mut idx = i;\n\
    \        let mut sub_idx = 0;\n        while idx < string.len() && sub_idx < substring.len()\
    \ {\n            if string.chars().nth(idx).unwrap() == substring.chars().nth(sub_idx).unwrap()\
    \ {\n                sub_idx += 1;\n            } else {\n                break;\n\
    \            }\n            idx += 1;\n        }\n        if sub_idx == substring.len()\
    \ {\n            t += 1;\n        }\n    }\n    t\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = 0;\n    loop {\n        let found\
    \ = match string[index..].find(&substring) {\n            Some(i) => i,\n    \
    \        None => break,\n        };\n        counter += 1;\n        index += found\
    \ + 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut start_index = 0;\n    loop {\n        let\
    \ found_index = string.find(&substring);\n        match found_index {\n      \
    \      Some(index) => {\n                count += 1;\n                start_index\
    \ = index + 1;\n            }\n            None => break,\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    loop {\n        if start == string_len\
    \ {\n            break;\n        }\n        if let Some(i) = string[start..].find(&substring)\
    \ {\n            n += 1;\n            start += i + substring_len;\n        } else\
    \ {\n            break;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpryr0_o51.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_bytes = string.as_bytes();\n    let substring_bytes\
    \ = substring.as_bytes();\n    for start in 0..(string_bytes.len() - substring_bytes.len()\
    \ + 1) {\n        if &string_bytes[start..(start + substring_bytes.len())] ==\
    \ substring_bytes {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5vwh1hzr.rs:12:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut count = 0;\n    let mut string_index = 0;\n    let mut substring_index\
    \ = 0;\n    while string_index < string_len {\n        if string[string_index..string_index\
    \ + 1] == substring[substring_index..substring_index + 1] {\n            count\
    \ += 1;\n            substring_index += 1;\n            if substring_index ==\
    \ substring_len {\n                substring_index = 0;\n            }\n     \
    \   } else {\n            substring_index = 0;\n        }\n        string_index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmpurajbj0p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // This is a naive implementation of the problem\n    if string.len() < substring.len()\
    \ {\n        return 0;\n    }\n    let mut count = 0;\n    let mut i = 0;\n  \
    \  while i < string.len() - substring.len() + 1 {\n        if &string[i..i + substring.len()]\
    \ == substring {\n            count += 1;\n            i += substring.len();\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4sti_1ha.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   unimplemented!();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp3zyobb2j.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string = string.into_bytes();\n    let substring\
    \ = substring.into_bytes();\n    for i in 0..string.len() - substring.len() +\
    \ 1 {\n        let mut is_substring = true;\n        for j in 0..substring.len()\
    \ {\n            if string[i + j] != substring[j] {\n                is_substring\
    \ = false;\n                break;\n            }\n        }\n        if is_substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpbhv0xf1l.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.as_str();\n    let sub = substring.as_str();\n    let mut i\
    \ = 0;\n    let mut n = 0;\n    while i + sub.len() <= s.len() {\n        if s[i..i\
    \ + sub.len()] == sub {\n            n += 1;\n            i += sub.len();\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpljamz60d.rs:14:32\n\
    \   |\n14 |         if s[i..i + sub.len()] == sub {\n   |                    \
    \            ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut times: isize = 0;\n    let mut string_length = string.len();\n   \
    \ let substring_length = substring.len();\n    for i in 0..(string_length - substring_length\
    \ + 1) {\n        if string[i..(i + substring_length)] == substring {\n      \
    \      times += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqwvmdxtb.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.as_str();\n    let sub = substring.as_str();\n    let mut i\
    \ = 0;\n    let mut sum = 0;\n    while i < s.len() {\n        let range = &s[i..];\n\
    \        if range.starts_with(sub) {\n            sum += 1;\n            i +=\
    \ sub.len();\n        } else {\n            i += 1;\n        }\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj_nzhl2l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut index = 0;\n    while index < string.len() {\n        let mut index_end\
    \ = index + substring.len();\n        if index_end > string.len() {\n        \
    \    index_end = string.len();\n        }\n        let string_slice = &string[index..index_end];\n\
    \        if string_slice == substring {\n            count += 1;\n           \
    \ index += substring.len();\n        } else {\n            index += 1;\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1erqdoxo.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut start = 0;\n    let mut count = 0;\n    while start + substring.len()\
    \ <= string.len() {\n        if &string[start..start + substring.len()] == substring\
    \ {\n            count += 1;\n            start += substring.len();\n        }\
    \ else {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn33x0ffy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut first_index = 0;\n    let mut index = 0;\n \
    \   let string_array: Vec<char> = string.chars().collect();\n    let substring_array:\
    \ Vec<char> = substring.chars().collect();\n    for ch in string_array {\n   \
    \     if index >= substring_array.len() {\n            if ch == substring_array[first_index]\
    \ {\n                first_index += 1;\n            } else {\n               \
    \ first_index = 0;\n            }\n        }\n        if ch == substring_array[index]\
    \ {\n            index += 1;\n        } else {\n            index = 0;\n     \
    \   }\n        if index == substring_array.len() {\n            cnt += 1;\n  \
    \          index = first_index;\n        }\n    }\n    cnt\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppx3g73dq.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   //let mut result = 0;\n    //let mut idx = 0;\n    //let max_idx = string.len()-substring.len();\n\
    \    //while idx < max_idx {\n    //    if string[idx..].starts_with(&substring)\
    \ {\n    //        result += 1;\n    //        idx += substring.len();\n    //\
    \    } else {\n    //        idx += 1;\n    //    }\n    //}\n    //result\n \
    \   string.matches(&substring).count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfijcp_hn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut idx = 0;\n    for _ in 0..string.len() {\n        let\
    \ (a, b) = string.split_at(idx);\n        if a.contains(&substring) {\n      \
    \      count += 1;\n            idx += substring.len();\n        } else {\n  \
    \          idx += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmpyzk5rb27.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let str_len = string.len();\n    let sub_len = substring.len();\n    if sub_len\
    \ == 0 {\n        return 0;\n    }\n\n    let s_arr: Vec<char> = string.chars().collect();\n\
    \    let sub_arr: Vec<char> = substring.chars().collect();\n\n    let mut count\
    \ = 0;\n    for i in 0..str_len {\n        if s_arr[i] == sub_arr[0] {\n     \
    \       if str_len < i + sub_len {\n                break;\n            }\n  \
    \          let mut found = true;\n            for j in 0..sub_len {\n        \
    \        if s_arr[i + j] != sub_arr[j] {\n                    found = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ found {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string = string.as_str();\n    let substring = substring.as_str();\n \
    \   if string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut pos = 0;\n    while let Some(x) = string[pos..].find(substring)\
    \ {\n        count += 1;\n        pos += x + 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976048
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut pos = 0;\n    while let Some(i) = string[pos..].find(&substring)\
    \ {\n        count += 1;\n        pos += i + substring.len();\n    }\n\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp83f7dcsa.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for i in 0..string.len() {\n        if string[i..].starts_with(&substring)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976048
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let mut\
    \ times = 0;\n    let substr_len = substring.len();\n    let str_len = string.len();\n\
    \    let str_chars: Vec<char> = string.chars().collect();\n    let substr_chars:\
    \ Vec<char> = substring.chars().collect();\n    for i in 0..(str_len - substr_len\
    \ + 1) {\n        let mut found = true;\n        for j in 0..substr_len {\n  \
    \          if str_chars[i + j] != substr_chars[j] {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      times += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    // window\
    \ size\n    let n = substring.len();\n    let bytes = string.as_bytes();\n   \
    \ let mut count = 0;\n\n    for i in 0..(bytes.len() - n + 1) {\n        if &bytes[i..(i\
    \ + n)] == substring.as_bytes() {\n            count += 1;\n        }\n    }\n\
    \n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let substring_size = substring.len();\n    if substring_size == 0 {\n    \
    \    return 0;\n    }\n    let string_size = string.len();\n    if string_size\
    \ == 0 {\n        return 0;\n    }\n    let total = string_size - substring_size\
    \ + 1;\n    let mut s = String::new();\n    let mut count = 0;\n    for i in 0..total\
    \ {\n        s.push_str(&string[i..i + substring_size]);\n        if s == substring\
    \ {\n            count += 1;\n        }\n        s.clear();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   fn how_many_times_inner(string: &str, substring: &str) -> isize {\n      \
    \  match string.find(substring) {\n            Some(index) => 1 + how_many_times_inner(&string[index\
    \ + substring.len()..], substring),\n            None => 0,\n        }\n    }\n\
    \n    how_many_times_inner(&string, &substring)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmph9z0dppf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i + substring_len <= string_len\
    \ {\n        if &string[i..(i + substring_len)] == substring {\n            count\
    \ += 1;\n            i += substring_len;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptjwqtpnc.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_bytes = string.into_bytes();\n    let substring_bytes = substring.into_bytes();\n\
    \    if substring_bytes.len() == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut substring_offset = 0;\n    for (i, c) in string_bytes.iter().enumerate()\
    \ {\n        if substring_bytes[substring_offset] == *c {\n            substring_offset\
    \ += 1;\n            if substring_offset == substring_bytes.len() {\n        \
    \        count += 1;\n                substring_offset = 0;\n            }\n \
    \       } else {\n            substring_offset = 0;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpko5rk6or.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut total = 0;\n    let mut index = 0;\n    while index != -1 {\n    \
    \    index = string.find(&substring).unwrap_or(-1);\n        if index != -1 {\n\
    \            total += 1;\n            string = string.replace_range(index..index\
    \ + substring.len(), \"\");\n        }\n    }\n    total\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmphol4f5hs.rs:12:51\n\
    \   |\n12 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmphol4f5hs.rs:11:20\n\
    \   |\n11 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmphol4f5hs.rs:13:21\n   |\n13 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphol4f5hs.rs:15:22\n   |\n8  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                           ------\
    \ expected due to this parameter type\n...\n15 |             string = string.replace_range(index..index\
    \ + substring.len(), \"\");\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmphol4f5hs.rs:15:29\n   |\n15 |         \
    \    string = string.replace_range(index..index + substring.len(), \"\");\n  \
    \ |                      ------ ^^^^^^^^^^^^^ this call modifies `string` in-place\n\
    \   "
  stdout: ''
  timestamp: 1659976048
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe09oqclt.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.clone();\n    let ss = substring.clone();\n    let ss_len =\
    \ ss.len();\n    if ss_len == 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut i = 0;\n    while i <= string.len() - ss_len {\n        if\
    \ string[i..i + ss_len] == substring {\n            count += 1;\n            i\
    \ += ss_len;\n        } else {\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpkqqtltmj.rs:17:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let len = substring.len();\n    let n = string.len();\n\
    \    for i in 0..n {\n        if i + len <= n && &string[i..i + len] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let mut index = 0;\n    loop {\n        match string[index..].find(&substring)\
    \ {\n            Some(i) => {\n                result += 1;\n                index\
    \ += i + 1;\n            }\n            None => {\n                break;\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let mut\
    \ result = 0;\n    let mut current_offset = 0;\n    let mut offset = string.find(&substring);\n\
    \    while offset.is_some() {\n        result += 1;\n        current_offset =\
    \ offset.unwrap() + 1;\n        offset = string[current_offset..].find(&substring);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut\
    \ i = 0;\n    let mut count = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let substring_chars: Vec<char> = substring.chars().collect();\n\n    while\
    \ i <= string.len() - substring.len() {\n        if &string_chars[i..i + substring.len()]\
    \ == &substring_chars[..] {\n            count += 1;\n            i += substring.len();\n\
    \        } else {\n            i += 1;\n        }\n    }\n\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0h5k0vrl.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   how_many_times_rec(string, substring, 0)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_rec` in this scope\n\
    \ --> /tmp/tmp1do6m3jf.rs:9:5\n  |\n9 |     how_many_times_rec(string, substring,\
    \ 0)\n  |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976048
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    for _ in 0..string.len() {\n \
    \       if &string[i..i + substring.len()] == substring {\n            count +=\
    \ 1;\n            i += substring.len() - 1;\n        }\n        i += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s: Vec<char> = string.chars().collect();\n    let mut sub: Vec<char> =\
    \ substring.chars().collect();\n    let sub_len = sub.len();\n    let len = s.len();\n\
    \    let mut count = 0;\n    for i in 0..len {\n        let mut identical = true;\n\
    \        for j in 0..sub_len {\n            if sub[j] != s[i + j] {\n        \
    \        identical = false;\n                break;\n            }\n        }\n\
    \        if identical {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpybvxzjji.rs:17:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   unimplemented!()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpynd21hgq.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let s_length = string.len();\n    let ss_length =\
    \ substring.len();\n    let mut ss_index = 0;\n    let mut s_index = 0;\n    while\
    \ s_index < s_length {\n        if substring.chars().nth(ss_index) == string.chars().nth(s_index)\
    \ {\n            if ss_index == ss_length - 1 {\n                count += 1;\n\
    \                ss_index = 0;\n            } else {\n                ss_index\
    \ += 1;\n            }\n        } else {\n            ss_index = 0;\n        }\n\
    \        s_index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxecly9qn.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let bytes = string.as_bytes();\n\
    \    let sub_bytes = substring.as_bytes();\n    let mut count = 0;\n    let mut\
    \ index = 0;\n    while index < bytes.len() {\n        if bytes[index] == sub_bytes[0]\
    \ {\n            let sub_index = 0;\n            let mut position = index;\n \
    \           while position < bytes.len() && sub_index < sub_bytes.len() {\n  \
    \              if bytes[position] == sub_bytes[sub_index] {\n                \
    \    position += 1;\n                    sub_index += 1;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if sub_index == sub_bytes.len() {\n                count += 1;\n          \
    \      index += sub_bytes.len();\n            } else {\n                index\
    \ += 1;\n            }\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `sub_index`\n \
    \ --> /tmp/tmpkkbfxi52.rs:23:21\n   |\n18 |             let sub_index = 0;\n \
    \  |                 ---------\n   |                 |\n   |                 first\
    \ assignment to `sub_index`\n   |                 help: consider making this binding\
    \ mutable: `mut sub_index`\n...\n23 |                     sub_index += 1;\n  \
    \ |                     ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976048
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    if string_len < substring_len {\n        return 0;\n    }\n    let mut times\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < string_len && j\
    \ < substring_len {\n        if string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        } else {\n            i\
    \ += 1;\n            j = 0;\n        }\n        if j == substring_len {\n    \
    \        times += 1;\n            j = 0;\n        }\n    }\n    times\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2k3kjkes.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    let mut sum = 0;\n    for i in 0..string.len() {\n        if &string[i..]\
    \ == &substring[..substring.len().min(string.len() - i)] {\n            sum +=\
    \ 1;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp3vgxl574.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   use std::ops::Range;\n    fn count_occurences(string: &str, substring: &str)\
    \ -> isize {\n        let mut occurences = 0;\n        let mut last_index = 0;\n\
    \        while let Some(index) = string[last_index..].find(substring) {\n    \
    \        occurences += 1;\n            last_index = index + 1;\n        }\n  \
    \      occurences\n    }\n    // Count the string without overlapping\n    let\
    \ mut occurences = count_occurences(&string, &substring);\n    // Add the count\
    \ for overlaping if there is one\n    if substring.len() > 1 {\n        occurences\
    \ += count_occurences(&string, &substring[1..]);\n    }\n    occurences\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let mut search_from = 0;\n    loop {\n        match\
    \ string[search_from..].find(&substring) {\n            Some(end) => {\n     \
    \           search_from += end + 1;\n                result += 1;\n          \
    \  }\n            None => break,\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ i = 0;\n    let mut count = 0;\n    while i <= string.len() - substring.len()\
    \ {\n        if string[i..i + substring.len()] == substring {\n            count\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2blyy8r4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let (len, slen) = (string.len(), substring.len());\n    match (len, slen)\
    \ {\n        (0, _) => 0,\n        (_, 0) => 0,\n        (_, _) => {\n       \
    \     let mut i = 0;\n            let mut count = 0;\n            while i < len\
    \ - slen + 1 {\n                if &string[i..i + slen] == substring {\n     \
    \               count += 1;\n                    i += slen;\n                }\
    \ else {\n                    i += 1;\n                }\n            }\n    \
    \        count\n        }\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgild7f3m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut found = 0;\n    let mut idx = 0;\n    let mut tmp_idx = 0;\n    let\
    \ mut haystack = string.chars();\n    let mut needle = substring.chars();\n  \
    \  let mut haystack_cur = haystack.next();\n    let mut needle_cur = needle.next();\n\
    \    while let Some(c) = haystack_cur {\n        if c == needle_cur.unwrap() {\n\
    \            tmp_idx += 1;\n            needle_cur = needle.next();\n        \
    \    if tmp_idx == substring.len() {\n                idx += 1;\n            \
    \    found += 1;\n                haystack_cur = haystack.nth(idx);\n        \
    \        needle_cur = needle.next();\n                tmp_idx = 0;\n         \
    \   }\n        } else {\n            idx += 1;\n            haystack_cur = haystack.nth(idx);\n\
    \            needle_cur = needle.next();\n            tmp_idx = 0;\n        }\n\
    \        haystack_cur = haystack.next();\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmptyvskkq0.rs:17:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut times = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut pos = 0;\n    while pos + substring_len <= string_len\
    \ {\n        if &string[pos..pos + substring_len] == substring {\n           \
    \ times += 1;\n            pos += substring_len;\n        } else {\n         \
    \   pos += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9wypzod3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_bytes = string.as_bytes();\n    let substring_bytes\
    \ = substring.as_bytes();\n    let string_len = string_bytes.len();\n    let substring_len\
    \ = substring_bytes.len();\n    for i in 0..string_len {\n        let mut matched\
    \ = true;\n        for j in 0..substring_len {\n            if i + j >= string_len\
    \ || string_bytes[i + j] != substring_bytes[j] {\n                matched = false;\n\
    \                break;\n            }\n        }\n        if matched {\n    \
    \        count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let string_vec: Vec<char>\
    \ = string.chars().collect();\n    let substring_vec: Vec<char> = substring.chars().collect();\n\
    \    let mut count = 0;\n    let substring_len = substring_vec.len();\n    for\
    \ i in 0..string_vec.len() {\n        if i + substring_len > string_vec.len()\
    \ {\n            break;\n        }\n        let string_sub = &string_vec[i..i\
    \ + substring_len];\n        if string_sub == &substring_vec[..] {\n         \
    \   count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    let sub_len = substring.len();\n\
    \    while pos + sub_len <= string.len() {\n        if string[pos..pos + sub_len]\
    \ == substring {\n            counter += 1;\n            pos += sub_len;\n   \
    \     } else {\n            pos += 1;\n        }\n    }\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8jkp1c9v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n = 0;\n    let mut end = 0;\n    for _ in 0..string.len() {\n   \
    \     match string[end..].find(&substring) {\n            Some(i) => {\n     \
    \           end += i + substring.len();\n                n += 1;\n           \
    \ }\n            None => break,\n        }\n    }\n    n\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpntk3kpxd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut idx = 0;\n    let sub_len = substring.len();\n\
    \    let str_len = string.len();\n    while idx < str_len {\n        let mut i\
    \ = 0;\n        while (idx + i) < str_len && i < sub_len && string.chars().nth(idx\
    \ + i).unwrap() == substring.chars().nth(i).unwrap() {\n            i += 1;\n\
    \        }\n        if i == sub_len {\n            count += 1;\n            idx\
    \ += i;\n        } else {\n            idx += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6uco41ke.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut curr = 0;\n    let mut index = string.find(&substring);\n    if index.is_none()\
    \ {\n        return 0;\n    }\n    while index.is_some() {\n        curr += 1;\n\
    \        index = string.find(&substring[1..]);\n    }\n    curr\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let len = substring.len();\n    if len > string.len() {\n        return 0;\n\
    \    }\n    let mut counter = 0;\n    let bytes = string.as_bytes();\n    let\
    \ sub_bytes = substring.as_bytes();\n    let mut i = 0;\n    while i <= bytes.len()\
    \ - len {\n        let sub_slice = &bytes[i..i + len];\n        if sub_slice ==\
    \ sub_bytes {\n            counter += 1;\n            i += len;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn8ftvdxq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cur_string = string;\n    let mut count = 0;\n    while let Some(i)\
    \ = cur_string.find(&substring) {\n        count += 1;\n        cur_string = cur_string[i\
    \ + substring.len()..].to_string();\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpssbu8579.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cursor = 0;\n    let mut count = 0;\n    while cursor <= string.len()\
    \ - substring.len() {\n        let current_substr = &string[cursor..cursor + substring.len()];\n\
    \        if current_substr == substring {\n            count += 1;\n         \
    \   cursor += substring.len();\n        } else {\n            cursor += 1;\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwth1kgis.rs:11:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let haystack = &string[..];\n    let needle = &substring[..];\n    let mut\
    \ result = 0;\n    let mut pos = 0;\n    while let Some(i) = haystack[pos..].find(needle)\
    \ {\n        pos = pos + i + 1;\n        result += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index != -1 {\n    \
    \    index = string.find(&substring).unwrap_or(-1);\n        if index != -1 {\n\
    \            count += 1;\n            let mut string = string;\n            string.remove(index);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp5pnrdyn3.rs:12:51\n\
    \   |\n12 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp5pnrdyn3.rs:11:20\n\
    \   |\n11 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp5pnrdyn3.rs:13:21\n   |\n13 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n_times = 0;\n    let mut idx = 0;\n    while idx != -1 {\n      \
    \  idx = string.find(&substring).map_or(-1, |i| i as isize);\n        if idx !=\
    \ -1 {\n            n_times += 1;\n            let shifted_string = string[(idx\
    \ + 1) as usize..].to_string();\n            string = shifted_string;\n      \
    \  }\n    }\n    n_times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `string`\n  --> /tmp/tmpps9as_mx.rs:16:13\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                   ------ help: consider making this binding mutable: `mut\
    \ string`\n...\n16 |             string = shifted_string;\n   |             ^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_slice = &string;\n    let substring_slice = &substring;\n    let\
    \ slice_len = substring_slice.len();\n    let mut count = 0;\n    for i in 0..(string_slice.len()\
    \ - slice_len + 1) {\n        if &string_slice[i..(i + slice_len)] == substring_slice\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvnuqvoae.rs:13:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n  \
    \      let slice = &string[i..];\n        if slice.starts_with(&substring) {\n\
    \            count += 1;\n            i += substring.len();\n        } else {\n\
    \            i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplrduun36.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string = string.as_str();\n    let substring =\
    \ substring.as_str();\n    let (len_string, len_substring) = (string.len(), substring.len());\n\
    \    if len_substring == 0 {\n        return 0;\n    }\n    for i in 0..len_string\
    \ - len_substring + 1 {\n        let str_slice = &string[i..i + len_substring];\n\
    \        if str_slice == substring {\n            count += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp1xvnvcoq.rs:16:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe09oqclt.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let s = &string[..];\n   \
    \ let sub = &substring[..];\n    while index < s.len() {\n        if let Some(i)\
    \ = s[index..].find(sub) {\n            count += 1;\n            index += i +\
    \ sub.len();\n        } else {\n            break;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1anjw4av.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let len = substring.len();\n    let mut cnt = 0;\n    let mut start = 0;\n\
    \    let mut i = string.find(&substring);\n    while i.is_some() {\n        cnt\
    \ += 1;\n        start = i.unwrap() + len;\n        i = string.get(start..).and_then(|s|\
    \ s.find(&substring));\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut start_index = 0;\n    let mut end_index = 0;\n    let\
    \ substring_size = substring.len();\n\n    while end_index + substring_size <=\
    \ string.len() {\n        if string[start_index..end_index] == substring {\n \
    \           count += 1;\n            start_index += 1;\n        }\n        end_index\
    \ += 1;\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpy_xqkio2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let len = substring.len();\n    if len == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let string_bytes = string.as_bytes();\n    let substring_bytes\
    \ = substring.as_bytes();\n    for i in 0..string.len() {\n        let mut is_match\
    \ = true;\n        for j in 0..len {\n            if i + j > string.len() - 1\
    \ {\n                is_match = false;\n                break;\n            }\n\
    \            if string_bytes[i + j] != substring_bytes[j] {\n                is_match\
    \ = false;\n                break;\n            }\n        }\n        if is_match\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     let s = string.get(i..).unwrap();\n        if s.starts_with(&substring)\
    \ {\n            count += 1;\n            i += substring.len();\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvqld6tos.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut last_match_index = 0;\n    let mut count = 0;\n    while last_match_index\
    \ < string.len() {\n        let next_index = string.get(last_match_index..).unwrap().find(&substring);\n\
    \        if next_index.is_none() {\n            break;\n        }\n        last_match_index\
    \ += next_index.unwrap() + substring.len();\n        count += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpos__12n7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut curr_idx = 0;\n    let mut idx = 0;\n    while\
    \ curr_idx < string.len() {\n        let ch = string.chars().nth(curr_idx).unwrap();\n\
    \        if ch == substring.chars().nth(idx).unwrap() {\n            idx += 1;\n\
    \            if idx == substring.len() {\n                count += 1;\n      \
    \          idx = 0;\n            }\n        } else {\n            idx = 0;\n \
    \       }\n        curr_idx += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp401brtnb.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Number of occurences of the substring in the string\n    let mut occurrences\
    \ = 0;\n    // Length of the substring\n    let substring_len = substring.len();\n\
    \    // The index of the substring in the string\n    let mut index = 0;\n   \
    \ // While the index is smaller than the length of the string minus the length\
    \ of the substring\n    while index < string.len() - substring_len + 1 {\n   \
    \     // Get a slice of the string from the given index to the end of the substring\n\
    \        let slice = &string[index..index + substring_len];\n        // If the\
    \ slice is equal to the substring\n        if slice == substring {\n         \
    \   // Increment the number of occurrences\n            occurrences += 1;\n  \
    \          // Increment the index by the length of the substring - 1\n       \
    \     index += substring_len - 1;\n        }\n        // Increment the index\n\
    \        index += 1;\n    }\n    // Return the number of occurrences\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpc12stfgu.rs:16:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let s = string.as_str();\n\
    \    let sub = substring.as_str();\n    if sub.len() > s.len() {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ - sub.len() + 1 {\n        if s[i..i + sub.len()] == sub {\n            count\
    \ += 1;\n            i += sub.len();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpf6csovv2.rs:20:32\n\
    \   |\n20 |         if s[i..i + sub.len()] == sub {\n   |                    \
    \            ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ sub_i = 0;\n    let mut s_i = 0;\n    let mut count = 0;\n    let (sub_chars,\
    \ chars) = (substring.chars().collect::<Vec<char>>(), string.chars().collect::<Vec<char>>());\n\
    \    while s_i < chars.len() {\n        if sub_i == sub_chars.len() {\n      \
    \      count += 1;\n            sub_i = 0;\n        }\n        if chars[s_i] ==\
    \ sub_chars[sub_i] {\n            sub_i += 1;\n        } else {\n            if\
    \ sub_i > 0 {\n                sub_i = 0;\n            }\n        }\n        s_i\
    \ += 1;\n    }\n    if sub_i == sub_chars.len() {\n        count += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpr8t_fz07.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let len = substring.len();\n    if len == 0 {\n        return 0;\n    }\n\
    \    let str_bytes = string.as_bytes();\n    let substr_bytes = substring.as_bytes();\n\
    \    let mut count = 0;\n    for i in 0..str_bytes.len() - len + 1 {\n       \
    \ let mut j = 0;\n        let mut find = true;\n        while j < len {\n    \
    \        if str_bytes[i + j] != substr_bytes[j] {\n                find = false;\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   if find {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpo79u_r13.rs:16:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut times = 0;\n    let str_len = string.len();\n    let substr_len =\
    \ substring.len();\n    let mut prev_pos = 0;\n    let mut start_pos = 0;\n  \
    \  let mut substr_pos = 0;\n    let mut substr_char = ' ';\n    let mut string_char\
    \ = ' ';\n    if substr_len == 0 {\n        return 0;\n    }\n    if str_len ==\
    \ 0 {\n        return 0;\n    }\n    //println!(\"str_len: {} substr_len: {}\"\
    , str_len, substr_len);\n    while prev_pos < str_len {\n        //println!(\"\
    prev_pos: {}\", prev_pos);\n        substr_pos = 0;\n        while substr_pos\
    \ < substr_len {\n            //println!(\"start_pos: {}\", start_pos);\n    \
    \        string_char = string.chars().nth(start_pos).unwrap();\n            substr_char\
    \ = substring.chars().nth(substr_pos).unwrap();\n            //println!(\"string_char:\
    \ {} substr_char: {}\", string_char, substr_char);\n            if string_char\
    \ == substr_char {\n                start_pos += 1;\n                substr_pos\
    \ += 1;\n            } else {\n                prev_pos += 1;\n              \
    \  start_pos = prev_pos;\n                break;\n            }\n        }\n \
    \       if substr_pos == substr_len {\n            times += 1;\n            prev_pos\
    \ += 1;\n            start_pos = prev_pos;\n        }\n    }\n    times\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp3c6vjjog.rs:29:57

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let substring_chars: Vec<char> =\
    \ substring.chars().collect();\n    let mut index = 0;\n    let mut counter =\
    \ 0;\n    while index < string_chars.len() {\n        let mut index_substring\
    \ = 0;\n        while index_substring < substring_chars.len() && index < string_chars.len()\
    \ {\n            if string_chars[index] == substring_chars[index_substring] {\n\
    \                index_substring += 1;\n                index += 1;\n        \
    \    } else {\n                break;\n            }\n        }\n        if index_substring\
    \ == substring_chars.len() {\n            counter += 1;\n        }\n        index\
    \ += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1ekl_q_a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    if string_len == 0 || substring_len == 0 || substring_len > string_len {\n\
    \        return 0;\n    }\n    if string_len == substring_len {\n        return\
    \ 1;\n    }\n    let mut count = 0;\n    let mut current_index = 0;\n    while\
    \ current_index + substring_len <= string_len {\n        if &string[current_index..current_index\
    \ + substring_len] == substring {\n            count += 1;\n            current_index\
    \ += substring_len;\n        } else {\n            current_index += 1;\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpunb3jnjm.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut count = 0;\n    while let Some(idx) = string[i..].find(&substring)\
    \ {\n        count += 1;\n        i += idx + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpye2q8pzj.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for i in 0..string.len() {\n        let s = &string[i..];\n\
    \        if s.starts_with(&substring) {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let sub_len = substring.len();\n\
    \    for _ in 0..string.len() {\n        if string[i..i + sub_len] == substring\
    \ {\n            count += 1;\n            i += sub_len;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut result = 0;\n    let start_index = match string.find(&substring)\
    \ {\n        Some(x) => x,\n        None => return 0,\n    };\n    result += 1;\n\
    \    let end_index = start_index + substring.len();\n    if end_index < string.len()\
    \ {\n        result += how_many_times(string[end_index..].to_string(), substring);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmvn39jos.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    if string_length == 0 || substring_length == 0 {\n \
    \       return 0;\n    }\n\n    let mut index = 0;\n    while index < string_length\
    \ {\n        let contains = string[index..].contains(&substring);\n        if\
    \ contains {\n            count += 1;\n            index += substring_length;\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmpf40xffse.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string = string.as_str();\n    let substring =\
    \ substring.as_str();\n    let substring_len = substring.len();\n    let string_len\
    \ = string.len();\n    if substring_len == 0 || string_len == 0 {\n        return\
    \ 0;\n    }\n    let mut i = 0;\n    while i < string_len {\n        if &string[i..i\
    \ + substring_len] == substring {\n            count += 1;\n            i += substring_len;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut original_string = string.clone();\n    for\
    \ _ in 0..string.len() {\n        if original_string.contains(&substring) {\n\
    \            count += 1;\n            original_string = original_string[1..].to_string();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp2gvmiqdc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let a: Vec<&str> = string.split(&substring).collect();\n    a.len() as isize\
    \ - 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsae1o2my.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_length = string.len();\n    let substring_length = substring.len();\n\
    \    let mut _index = 0;\n    let mut _counter = 0;\n    let mut _continue = true;\n\
    \    while _continue {\n        let _result = string.find(&substring);\n     \
    \   if _result.is_none() {\n            _continue = false;\n        } else {\n\
    \            let _next_index = _result.unwrap() + substring_length;\n        \
    \    _index = _next_index;\n            _counter += 1;\n        }\n    }\n   \
    \ _counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let len = substring.len();\n    for i in 0..=string.len()\
    \ - len {\n        if substring == string[i..i + len].to_string() {\n        \
    \    count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpz9riuq45.rs:11:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut amount: isize = 0;\n    let mut string_chars = string.chars();\n \
    \   let mut substring_chars = substring.chars();\n    let mut index: usize = 0;\n\
    \    let mut match_index: usize = 0;\n    while let Some(char) = string_chars.next()\
    \ {\n        if char == substring_chars.nth(match_index).unwrap() {\n        \
    \    match_index += 1;\n            if match_index == substring.len() {\n    \
    \            amount += 1;\n                match_index = 0;\n            }\n \
    \       } else {\n            match_index = 0;\n        }\n        index += 1;\n\
    \    }\n    amount\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpm9stxkm3.rs:15:53

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_vec: Vec<char> = string.chars().collect();\n    let substring_vec:\
    \ Vec<char> = substring.chars().collect();\n    let mut times: isize = 0;\n  \
    \  for i in 0..(string_vec.len() - substring_vec.len() + 1) {\n        if string_vec[i..(i\
    \ + substring_vec.len())] == substring_vec {\n            times += 1;\n      \
    \  }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp1ddsu2xo.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   unimplemented!(\"Find how many times '{}' can be found in '{}'\", substring,\
    \ string);\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Find how many times ''x''
    can be found in '''''', /tmp/tmpn_ede0r0.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut counter = 0;\n    for i in 0..string_len {\n        let j = i + substring_len;\n\
    \        if j <= string_len {\n            let substr = &string[i..j];\n     \
    \       if substr == substring {\n                counter += 1;\n            }\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut needle_idx = 0;\n    let needle = substring.chars().collect::<Vec<char>>();\n\
    \    let haystack = string.chars().collect::<Vec<char>>();\n    for &hay in haystack.iter()\
    \ {\n        if hay == needle[needle_idx] {\n            needle_idx += 1;\n  \
    \          if needle_idx == needle.len() {\n                count += 1;\n    \
    \            needle_idx = 0;\n            }\n        } else {\n            needle_idx\
    \ = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7kpmpugu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut start = 0;\n    while let Some(index) =\
    \ string[start..].find(&substring) {\n        counter += 1;\n        start = start\
    \ + index + 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut result =\
    \ 0;\n    let mut start = 0;\n    loop {\n        let found = string.find(&substring,\
    \ start);\n        if found.is_none() {\n            break;\n        }\n     \
    \   result += 1;\n        start = found.unwrap() + 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7_615apw.rs:15:28\n     |\n15   |         let found = string.find(&substring,\
    \ start);\n     |                            ^^^^ ----------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   use std::cmp::min;\n    let sub = substring.as_bytes();\n    let s = string.as_bytes();\n\
    \    let mut count = 0;\n    for i in 0..(s.len() - sub.len() + 1) {\n       \
    \ let mut j = 0;\n        while j < sub.len() && s[i + j] == sub[j] {\n      \
    \      j += 1;\n        }\n        if j == sub.len() {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpnca4agmu.rs:13:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe09oqclt.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut start = 0;\n    while let Some(pos) = string[start..].find(&substring)\
    \ {\n        cnt += 1;\n        start = pos + 1;\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // unimplemented!();\n    // string.chars().rev().collect::<String>()\n  \
    \  let mut count = 0;\n    for i in 0..string.len() {\n        if string[i..].starts_with(&substring)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_vec: Vec<char> = string.chars().collect();\n\
    \    let substring_vec: Vec<char> = substring.chars().collect();\n    let length\
    \ = substring_vec.len();\n    for i in 0..string_vec.len() - length + 1 {\n  \
    \      if string_vec[i..i + length] == substring_vec {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvxmh3ejx.rs:13:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if &string[i..i + substring.len()] == substring {\n            count +=\
    \ 1;\n            i += substring.len();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_bytes = string.into_bytes();\n    let substring_bytes = substring.into_bytes();\n\
    \    if substring_bytes.len() == 0 {\n        return 0;\n    }\n\n    let mut\
    \ count = 0;\n    let mut idx = 0;\n    while idx < string_bytes.len() {\n   \
    \     let sub_idx = match find_sub(&string_bytes[idx..], &substring_bytes) {\n\
    \            Some(v) => v,\n            None => {\n                break;\n  \
    \          }\n        };\n        idx += sub_idx + 1;\n        count += 1;\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_sub` in this scope\n  --> /tmp/tmpg7fp5r_k.rs:18:29\n\
    \   |\n18 |         let sub_idx = match find_sub(&string_bytes[idx..], &substring_bytes)\
    \ {\n   |                             ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0;\n    let mut count = 0;\n    let mut s = string.clone();\n\
    \    let sub = substring.clone();\n    let mut l = sub.len();\n    let len = s.len();\n\
    \    while index < len {\n        let i = s.find(&sub);\n        match i {\n \
    \           Some(n) => {\n                count += 1;\n                let mut\
    \ j = n + l;\n                let len = s.len();\n                let mut k =\
    \ 0;\n                while j < len {\n                    s.remove(k);\n    \
    \                j += 1;\n                    k += 1;\n                }\n   \
    \         }\n            None => {\n                index = len;\n           \
    \ }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `yyy`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let mut s_iter = string.chars();\n    let mut sub_iter\
    \ = substring.chars();\n    let mut index = 0;\n    let mut found = false;\n \
    \   let mut s = String::new();\n    let mut sub = String::new();\n    let mut\
    \ done = false;\n    loop {\n        match s_iter.next() {\n            Some(c)\
    \ => s.push(c),\n            None => {\n                done = true;\n       \
    \         if found {\n                    result += 1;\n                }\n  \
    \              break;\n            }\n        }\n        if index == 0 {\n   \
    \         match sub_iter.next() {\n                Some(c) => sub.push(c),\n \
    \               None => panic!(\"substring is empty\"),\n            }\n     \
    \   }\n        if !found {\n            match s.pop() {\n                Some(c)\
    \ => {\n                    if c == sub.pop().unwrap() {\n                   \
    \     found = true;\n                        index = 0;\n                    }\
    \ else {\n                        sub.push(c);\n                    }\n      \
    \          }\n                None => panic!(\"Should not reach here\"),\n   \
    \         }\n        } else {\n            match s.pop() {\n                Some(c)\
    \ => {\n                    index += 1;\n                    if c == sub.pop().unwrap()\
    \ {\n                        if index == substring.len() {\n                 \
    \           result += 1;\n                            found = false;\n       \
    \                     index = 0;\n                        }\n                \
    \    } else {\n                        sub.push(c);\n                        index\
    \ = 0;\n                        found = false;\n                    }\n      \
    \          }\n                None => panic!(\"Should not reach here\"),\n   \
    \         }\n        }\n        if done {\n            break;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''substring is empty'', /tmp/tmp9lcnhe3i.rs:31:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let slice = string.as_str();\n    let len = substring.len();\n    let mut\
    \ cnt = 0;\n    for i in 0..string.len() {\n        if &slice[i..i + len] == substring.as_str()\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0;\n    let mut count = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeyqd9if_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let s = string.as_str();\n    let mut s_len = s.len();\n\
    \    let ss = substring.as_str();\n    let ss_len = ss.len();\n    if s_len <\
    \ ss_len {\n        return 0;\n    }\n    for (s_i, _) in s.chars().enumerate()\
    \ {\n        if &s[s_i..s_i + ss_len] == ss {\n            cnt += 1;\n       \
    \ }\n        s_len -= 1;\n        if s_len < ss_len {\n            break;\n  \
    \      }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut string_slice = &string[..];\n    let substring_len\
    \ = substring.len();\n    let string_len = string.len();\n    while string_slice.len()\
    \ >= substring_len {\n        if &string_slice[..substring_len] == substring {\n\
    \            counter += 1;\n            string_slice = &string_slice[1..];\n \
    \       } else {\n            string_slice = &string_slice[1..];\n        }\n\
    \    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut index = 0;\n\
    \    let mut count = 0;\n    let mut letters = string.chars();\n    while let\
    \ Some(letter) = letters.next() {\n        if letter == substring.chars().nth(index).unwrap()\
    \ {\n            index += 1;\n            if index == substring.len() {\n    \
    \            count += 1;\n                index = 0;\n            }\n        }\
    \ else {\n            index = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpg2lmomdb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut times = 0;\n    let mut pos = 0;\n    while let Some(new_pos) = string[pos..].find(&substring)\
    \ {\n        times += 1;\n        pos += new_pos + 1;\n    }\n    times\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    for i in 0..string_len {\n        if i + substring_len > string_len {\n \
    \           break;\n        }\n        if string[i..i + substring_len] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string = &string;\n    let substring = &substring;\n    let mut count\
    \ = 0;\n    for i in 0..(string.len() - substring.len() + 1) {\n        if string[i..(i\
    \ + substring.len())] == substring {\n            count += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&String`\n  --> /tmp/tmpy2poaahr.rs:13:45\n\
    \   |\n13 |         if string[i..(i + substring.len())] == substring {\n   | \
    \                                            ^^ no implementation for `str ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let string\
    \ = string.as_str();\n    let substring = substring.as_str();\n    let mut result\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() {\n        if string[i..].starts_with(substring)\
    \ {\n            result += 1;\n            i += substring.len();\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl488p7i9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe09oqclt.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976049
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut c = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let substring_chars: Vec<char> = substring.chars().collect();\n    for i\
    \ in 0..string_chars.len() {\n        if string_chars[i] == substring_chars[0]\
    \ {\n            let mut matched = true;\n            for j in 0..substring_chars.len()\
    \ {\n                if string_chars.get(i + j) != substring_chars.get(j) {\n\
    \                    matched = false;\n                    break;\n          \
    \      }\n            }\n            if matched {\n                c += 1;\n \
    \           }\n        }\n    }\n    c\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.as_str();\n    let sub = substring.as_str();\n    let mut count\
    \ = 0;\n    for i in 0..s.len() - sub.len() + 1 {\n        let start = &s[i..i\
    \ + sub.len()];\n        if start == sub {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpc9pswnrn.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ times = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n  \
    \  let substring_chars: Vec<char> = substring.chars().collect();\n    let substring_len\
    \ = substring.len();\n    for i in 0..(string.len() - substring.len() + 1) {\n\
    \        let mut count = 0;\n        for j in 0..substring_len {\n           \
    \ if string_chars[i + j] == substring_chars[j] {\n                count += 1;\n\
    \            }\n        }\n        if count == substring_len {\n            times\
    \ += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    if string.len()\
    \ == substring.len() {\n        if string == substring {\n            return 1;\n\
    \        } else {\n            return 0;\n        }\n    }\n\n    let mut result\
    \ = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n    let mut\
    \ i = 0;\n    while i < string.len() - substring.len() + 1 {\n        let mut\
    \ j = 0;\n        while j < substring.len() {\n            if string_chars[i +\
    \ j] != substring.chars().nth(j).unwrap() {\n                break;\n        \
    \    }\n            j += 1;\n        }\n        if j == substring.len() {\n  \
    \          result += 1;\n            i += 1;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut index = 0;\n    while index < string.len() {\n     \
    \   let string_slice = &string[index..];\n        if string_slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpoytggw5q.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut _times = 0;\n    let _string = string.chars().collect::<Vec<char>>();\n\
    \    let _substring = substring.chars().collect::<Vec<char>>();\n    if _substring.len()\
    \ > _string.len() {\n        return 0;\n    }\n    for i in 0..(_string.len()\
    \ - _substring.len() + 1) {\n        if _string[i..(i + _substring.len())] ==\
    \ _substring[..] {\n            _times += 1;\n        }\n    }\n    _times\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut search_at = 0;\n    while let Some(found_at) = string[search_at..].find(&substring)\
    \ {\n        count += 1;\n        search_at += found_at + substring.len();\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp860fmef.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let str_len = string.len();\n    let sub_len = substring.len();\n    let mut\
    \ counter = 0;\n    let mut i = 0;\n    while i + sub_len <= str_len {\n     \
    \   if &string[i..i + sub_len] == substring {\n            counter += 1;\n   \
    \         i += sub_len;\n        } else {\n            i += 1;\n        }\n  \
    \  }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplzggniyj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut idx = 0;\n    let mut res = 0;\n    let s = string.as_str();\n   \
    \ let substr = substring.as_str();\n    let sublen = substr.len();\n    let len\
    \ = s.len();\n    while idx + sublen <= len {\n        if &s[idx..idx + sublen]\
    \ == substr {\n            res += 1;\n            idx += sublen;\n        } else\
    \ {\n            idx += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6923y5uw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let max_count = string.len() - substring.len() + 1;\n    let mut count = 0;\n\
    \    for i in 0..max_count {\n        let mut equal = true;\n        for j in\
    \ 0..substring.len() {\n            if string.chars().nth(i + j).unwrap() != substring.chars().nth(j).unwrap()\
    \ {\n                equal = false;\n                break;\n            }\n \
    \       }\n        if equal {\n            count += 1;\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_0hpbhy1.rs:9:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s_slice = &string[..];\n    let sub_slice = &substring[..];\n    let mut\
    \ res = 0;\n    let mut current_start = 0;\n    while let Some(idx) = s_slice[current_start..].find(sub_slice)\
    \ {\n        current_start += idx + 1;\n        res += 1;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let slen = string.len();\n    let sublen = substring.len();\n    if sublen\
    \ == 0 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut idx\
    \ = 0;\n    while idx < slen {\n        let mut subidx = 0;\n        while subidx\
    \ < sublen && idx + subidx < slen {\n            if string.chars().nth(idx + subidx).unwrap()\
    \ != substring.chars().nth(subidx).unwrap() {\n                break;\n      \
    \      }\n            subidx += 1;\n        }\n        if subidx == sublen {\n\
    \            count += 1;\n        }\n        idx += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut times = 0;\n    for i in 0..(string_len - substring_len + 1) {\n\
    \        if string[i..i + substring_len] == substring {\n            times +=\
    \ 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmbpan3oy.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let mut pos = 0;\n    while let Some(x) = string[pos..].find(&substring)\
    \ {\n        result += 1;\n        pos += x + 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut occurrences = 0;\n    for (i, _) in string.match_indices(&substring)\
    \ {\n        occurrences += 1;\n        how_many_times(string[i + 1..].to_string(),\
    \ substring.clone());\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplrninchk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut ocurrences = 0;\n    let mut pos = 0;\n    for char in string.chars()\
    \ {\n        if char == substring.chars().nth(pos).unwrap() {\n            pos\
    \ += 1;\n            if pos == substring.len() {\n                ocurrences +=\
    \ 1;\n                pos = 0;\n            }\n        } else {\n            pos\
    \ = 0;\n        }\n    }\n    ocurrences\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyerrdtvz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let s = string.into_bytes();\n\
    \    let sub = substring.into_bytes();\n    let mut result = 0;\n    for i in\
    \ 0..s.len() {\n        if s[i] == sub[0] {\n            let mut j = 1;\n    \
    \        while j < sub.len() && s[i + j] == sub[j] {\n                j += 1;\n\
    \            }\n            if j == sub.len() {\n                result += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmp07jjwmk0.rs:18:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let l = substring.len();\n    let n = string.len();\n    if l == 0 {\n   \
    \     return 0;\n    }\n    if l > n {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    for i in 0..(n - l + 1) {\n        let substr = &string[i..(i\
    \ + l)];\n        if substring == substr {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.into_bytes();\n    let ss = substring.into_bytes();\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    while i < s.len() {\n        if s[i]\
    \ == ss[0] {\n            let found = s.get(i..).unwrap().windows(ss.len()).any(|x|\
    \ x == &ss[..]);\n            if found {\n                count += 1;\n      \
    \          i += ss.len();\n            } else {\n                i += 1;\n   \
    \         }\n        } else {\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpcfom2ten.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n  \
    \      let a: Vec<char> = string.chars().collect();\n        let b: Vec<char>\
    \ = substring.chars().collect();\n        let mut match_until = i;\n        let\
    \ mut j = 0;\n        while match_until < string.len() && a[match_until] == b[j]\
    \ {\n            match_until += 1;\n            j += 1;\n            if j == substring.len()\
    \ {\n                count += 1;\n                break;\n            }\n    \
    \    }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let size_of_substring = substring.len();\n    let mut counter = 0;\n    let\
    \ mut index = 0;\n    while let Some(idx) = string[index..].find(&substring) {\n\
    \        counter += 1;\n        index = idx + size_of_substring;\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string = string.as_str();\n    let substring = substring.as_str();\n \
    \   let substring_len = substring.len();\n    if substring_len == 0 {\n      \
    \  return 0;\n    }\n    let mut times = 0;\n    let len = string.len();\n   \
    \ for i in 0..(len - substring_len + 1) {\n        if string[i..(i + substring_len)]\
    \ == substring {\n            times += 1;\n        }\n    }\n    times\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmptzfq3tm0.rs:18:43\n\
    \   |\n18 |         if string[i..(i + substring_len)] == substring {\n   |   \
    \                                        ^^ no implementation for `str == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let size_substring = substring.len();\n    let size_string = string.len();\n\
    \    let mut n_substring = 0;\n    for i in 0..size_string {\n        if i + size_substring\
    \ <= size_string {\n            let tmp = string.get(i..(i + size_substring)).unwrap();\n\
    \            if tmp == substring {\n                n_substring += 1;\n      \
    \      }\n        }\n    }\n    n_substring as isize\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut\
    \ num_of_substr: isize = 0;\n    let mut index = 0;\n    let mut substr_index\
    \ = 0;\n    let mut str_index_to_start = 0;\n\n    while index < string.len()\
    \ {\n        if string.chars().nth(index).unwrap() == substring.chars().nth(substr_index).unwrap()\
    \ {\n            index += 1;\n            substr_index += 1;\n            if substr_index\
    \ == substring.len() {\n                num_of_substr += 1;\n                substr_index\
    \ = 0;\n                index = str_index_to_start + 1;\n                str_index_to_start\
    \ = index;\n            }\n        } else {\n            index += 1;\n       \
    \     str_index_to_start = index;\n            substr_index = 0;\n        }\n\
    \    }\n\n    num_of_substr\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Split the string into two substrings, the first containing the substring\
    \ and the last the rest.\n    // Last will always be non-empty because the substring\
    \ is non-empty.\n    let first = if string.find(&substring).is_some() {\n    \
    \    // If the substring is found in the string, get it from the start until the\
    \ first match.\n        &string[..string.find(&substring).unwrap()]\n    } else\
    \ {\n        // If the substring is not found, it's not part of the string, we\
    \ don't need to\n        // search for the substring in this substring.\n    \
    \    &string[..]\n    };\n    let last = &string[first.len()..];\n\n    // If\
    \ the last substring is empty, it means we have found the substring at the end\
    \ of the string.\n    // If it is not empty, call the function recursively with\
    \ the last substring.\n    if last.is_empty() {\n        1\n    } else {\n   \
    \     1 + how_many_times(last.to_string(), substring)\n    }\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmphuxy8p8h.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.matches(&substring).count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpocn0i9x_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    let length = substring.len();\n\
    \    while let Some(offset) = string[index..].find(substring) {\n        count\
    \ += 1;\n        index += offset + length;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa4nir8_8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Example of how to use FFI to use a C implementation\n    unsafe { how_many_times_c(string.as_ptr(),\
    \ string.len(), substring.as_ptr(), substring.len()) }\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_c` in this scope\n \
    \ --> /tmp/tmp9mk9ah3k.rs:10:14\n   |\n10 |     unsafe { how_many_times_c(string.as_ptr(),\
    \ string.len(), substring.as_ptr(), substring.len()) }\n   |              ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let n: usize = string.len();\n    let m: usize = substring.len();\n    let\
    \ mut hash_string: Vec<usize> = vec![0; n];\n    let mut hash_substring: Vec<usize>\
    \ = vec![0; m];\n    let mut p: usize = 53;\n    let mut modulo: usize = 1_000_000_007;\n\
    \    let mut p_in_power: usize = 1;\n    for c in string.chars() {\n        hash_string[0]\
    \ = (hash_string[0] + (c as usize) * p_in_power) % modulo;\n        p_in_power\
    \ = (p_in_power * p) % modulo;\n    }\n    p_in_power = 1;\n    for c in substring.chars()\
    \ {\n        hash_substring[0] = (hash_substring[0] + (c as usize) * p_in_power)\
    \ % modulo;\n        p_in_power = (p_in_power * p) % modulo;\n    }\n    for i\
    \ in 1..n {\n        hash_string[i] = (hash_string[i - 1] * p + string.chars().nth(i).unwrap()\
    \ as usize) % modulo;\n    }\n    for i in 1..m {\n        hash_substring[i] =\
    \ (hash_substring[i - 1] * p + substring.chars().nth(i).unwrap() as usize) % modulo;\n\
    \    }\n    let mut result: isize = 0;\n    for i in 0..(n - m + 1) {\n      \
    \  let mut cur: usize = 0;\n        if i == 0 {\n            cur = hash_string[m\
    \ - 1];\n        } else {\n            cur = (hash_string[i + m - 1] + modulo\
    \ - hash_string[i - 1] * p_in_power % modulo) % modulo;\n        }\n        if\
    \ cur == hash_substring[m - 1] {\n            result += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp64ml9nzs.rs:32:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for (i, _) in string.char_indices() {\n        if\
    \ let Some(j) = string.get(i..) {\n            if j.starts_with(&substring) {\n\
    \                count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // I do not like this unwrap, but all that I tried did not work.\n    let\
    \ haystack = string.into_bytes();\n    let needle = substring.into_bytes();\n\
    \    let string_len = haystack.len();\n    let substring_len = needle.len();\n\
    \    let mut counter = 0;\n    for i in 0..(string_len - substring_len + 1) {\n\
    \        if haystack[i..(i + substring_len)] == needle {\n            counter\
    \ += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpba41gw60.rs:15:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.split(substring.as_str()).count() as isize - 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx28wu27d.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut index = 0;\n    let mut res = 0;\n    while index < string.len() {\n\
    \        let sub_string = String::from(&string[index..]);\n        if let Some(pos)\
    \ = sub_string.find(&substring) {\n            res += 1;\n            index +=\
    \ pos;\n        } else {\n            break;\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let mut previous_index: usize = 0;\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let substring_chars: Vec<char> =\
    \ substring.chars().collect();\n    loop {\n        match string_chars[previous_index..].windows(substring_chars.len()).position(|x|\
    \ x == &substring_chars[..]) {\n            Some(index) => {\n               \
    \ result += 1;\n                previous_index += index + substring_chars.len();\n\
    \            },\n            None => break,\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxrnb2nsw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if !string.contains(&substring) {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let chars: Vec<char> = string.chars().collect();\n    let substring_len\
    \ = substring.len();\n    for i in 0..(chars.len() - substring_len + 1) {\n  \
    \      if substring == chars[i..(i + substring_len)].iter().collect::<String>()\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut last_index = 0;\n    let mut last_index_of = -1;\n    let mut count\
    \ = 0;\n    for char in string.chars() {\n        if last_index < substring.len()\
    \ {\n            if char == substring.chars().nth(last_index).unwrap() {\n   \
    \             last_index += 1;\n            } else {\n                last_index\
    \ = 0;\n            }\n        }\n        if last_index == substring.len() {\n\
    \            count += 1;\n            last_index_of = last_index_of + 1;\n   \
    \         last_index = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo1kdqxs1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976050
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let byte_str = string.into_bytes();\n    let byte_sub\
    \ = substring.into_bytes();\n    for i in 0..(byte_str.len() - byte_sub.len()\
    \ + 1) {\n        if byte_str[i..(i + byte_sub.len())] == byte_sub {\n       \
    \     count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpl83dy3k0.rs:12:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut times = 0;\n    let mut rest = string;\n    loop\
    \ {\n        match rest.find(&substring) {\n            Some(index) => {\n   \
    \             i += index;\n                rest = rest[index..].to_string();\n\
    \                times += 1;\n            }\n            None => break,\n    \
    \    }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let v1:\
    \ Vec<char> = string.chars().collect();\n    let v2: Vec<char> = substring.chars().collect();\n\
    \n    let mut result = 0;\n    let string_len = v1.len();\n    let substring_len\
    \ = v2.len();\n\n    for i in 0..string_len {\n        let mut is_found = true;\n\
    \        for j in 0..substring_len {\n            if i + j >= string_len || v1[i\
    \ + j] != v2[j] {\n                is_found = false;\n                break;\n\
    \            }\n        }\n        if is_found {\n            result += 1;\n \
    \       }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // let string_len = string.len();\n    // let substring_len = substring.len();\n\
    \    // if string_len < substring_len {\n    //     return 0;\n    // }\n    //\
    \ if string_len == substring_len {\n    //     return if string == substring {\
    \ 1 } else { 0 };\n    // }\n    // let string_slice = &string[..];\n    // let\
    \ substring_slice = &substring[..];\n    // let mut result = 0;\n    // for index\
    \ in 0..=(string_len - substring_len) {\n    //     if &string_slice[index..(index\
    \ + substring_len)] == substring_slice {\n    //         result += 1;\n    //\
    \     }\n    // }\n    // result\n    string.matches(substring.as_str()).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsynqhqxy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut string_chars = string.chars();\n    let mut sub_chars = substring.chars();\n\
    \    let mut found = 0;\n    loop {\n        match string_chars.next() {\n   \
    \         Some(c) => {\n                if c == sub_chars.next().unwrap() {\n\
    \                    sub_chars.clone_from(&substring.chars());\n             \
    \       found += 1;\n                }\n            }\n            None => break,\n\
    \        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp169ae279.rs:15:42

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976050
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() > string.len() {\n        return 0;\n    }\n    let chars\
    \ = string.chars().collect::<Vec<char>>();\n    let sub_chars = substring.chars().collect::<Vec<char>>();\n\
    \    let mut i = 0;\n    let mut counter = 0;\n    while i <= chars.len() - sub_chars.len()\
    \ {\n        let mut j = 0;\n        while j < sub_chars.len() && chars[i + j]\
    \ == sub_chars[j] {\n            j += 1;\n        }\n        if j == sub_chars.len()\
    \ {\n            counter += 1;\n            i += 1;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if &string[index..index + substring.len()] == substring {\n     \
    \       counter += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut result = 0;\n    let string_bytes = string.as_bytes();\n    let substring_bytes\
    \ = substring.as_bytes();\n    for (i, _) in string_bytes.iter().enumerate() {\n\
    \        let sub = &string_bytes[i..i + substring_bytes.len()];\n        if sub\
    \ == substring_bytes {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''range end index 10 out of range for slice
    of length 9'', library/core/src/slice/index.rs:73:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut total = 0;\n    let length = substring.len();\n    let mut position\
    \ = 0;\n    while position < string.len() {\n        let sub = &string[position..];\n\
    \        if sub.starts_with(&substring) {\n            total += 1;\n         \
    \   position += length;\n        } else {\n            position += 1;\n      \
    \  }\n    }\n    total\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu65yovso.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for i in 0..(string.len() - substring.len() + 1) {\n\
    \        if string[i..(i + substring.len())] == substring {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfs56mrvv.rs:10:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut found = 0;\n    let mut new_start = 0;\n    let substring_chars: Vec<char>\
    \ = substring.chars().collect();\n    while let Some(start) = string[new_start..].find(&substring)\
    \ {\n        found += 1;\n        new_start = start + 1;\n    }\n    found\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    let mut result = 0;\n    let mut j = 0;\n    let sub_length = substring.len();\n\
    \    for i in 0..string.len() {\n        if string[i] == substring[j] {\n    \
    \        j += 1;\n            if j == sub_length {\n                result +=\
    \ 1;\n                j = 0;\n            }\n        } else {\n            j =\
    \ 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmmoosc9p.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let n = string.len();\n    let m = substring.len();\n    if m > n {\n    \
    \    return 0;\n    }\n    let mut acc = 0;\n    for i in 0..n {\n        let\
    \ is_substring = string[i..n].starts_with(&substring);\n        if is_substring\
    \ {\n            acc += 1;\n        }\n    }\n    acc\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvhxdw7z3.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut cnt = 0;\n    let mut idx = 0;\n    let len = substring.len();\n \
    \   let orig_len = string.len();\n    while idx + len <= orig_len {\n        let\
    \ (_, rem) = string.split_at(idx + len);\n        if &string[idx..idx + len] ==\
    \ substring {\n            cnt += 1;\n            idx += len;\n        } else\
    \ {\n            idx += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6add8nn0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut current_pos = 0;\n    while let Some(pos)\
    \ = string[current_pos..].find(&substring) {\n        count += 1;\n        current_pos\
    \ += pos + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpq47j8eu7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut original = string.as_bytes();\n    let mut result = 0;\n    let mut\
    \ sub = substring.as_bytes();\n    while original.len() > 0 {\n        let n =\
    \ original.windows(sub.len()).position(|w| w == sub);\n        if n.is_none()\
    \ {\n            break;\n        }\n        let n = n.unwrap();\n        result\
    \ += 1;\n        original = &original[n + 1..];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let (s, ss) = (string.as_str(), substring.as_str());\n\
    \    for index in 0..s.len() {\n        if ss.len() <= s.len() - index {\n   \
    \         let slice = &s[index..index + ss.len()];\n            if slice == ss\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let n = string.len();\n    let m = substring.len();\n    if m > n {\n    \
    \    return 0;\n    }\n    let mut dp = vec![vec![0; m + 1]; n + 1];\n    let\
    \ chars_string: Vec<char> = string.chars().collect();\n    let chars_substring:\
    \ Vec<char> = substring.chars().collect();\n    let mut result = 0;\n    for i\
    \ in 1..n + 1 {\n        for j in 1..m + 1 {\n            if chars_string[i -\
    \ 1] == chars_substring[j - 1] {\n                dp[i][j] = dp[i - 1][j - 1]\
    \ + 1;\n            } else {\n                dp[i][j] = 0;\n            }\n \
    \           if dp[i][j] == m {\n                result += 1;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while let Some(i) = string[pos..].find(&substring)\
    \ {\n        pos += i + 1;\n        counter += 1;\n    }\n    counter\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut i = 0;\n    let mut j = 0;\n    let mut n = 0;\n    while i < string.len()\
    \ {\n        if string.chars().nth(i) == substring.chars().nth(j) {\n        \
    \    j += 1;\n            if j == substring.len() {\n                n += 1;\n\
    \                j = 0;\n            }\n        } else {\n            j = 0;\n\
    \        }\n        i += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnzqwr0h5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut times = 0;\n    let mut start = 0;\n    while start < string.len()\
    \ {\n        let found = string[start..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        start += found.unwrap() + substring.len();\n\
    \        times += 1;\n    }\n    times\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3tegk90o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   // Check that the substring is smaller\n    if substring.len() > string.len()\
    \ {\n        return 0;\n    }\n\n    // Convert the strings to char vectors\n\
    \    let string: Vec<char> = string.chars().collect();\n    let substring: Vec<char>\
    \ = substring.chars().collect();\n\n    // The number of times that the substring\
    \ was found\n    let mut num_times = 0;\n\n    // The index of the last match\n\
    \    let mut last_match = 0;\n\n    // The current index\n    let mut i = 0;\n\
    \n    // Loop through the chars in the string\n    for c in string {\n       \
    \ // Check for match\n        if substring[i] == c {\n            // Increment\
    \ the index\n            i += 1;\n\n            // Check if a substring has been\
    \ found\n            if i == substring.len() {\n                // Add a new match\n\
    \                num_times += 1;\n\n                // Set the last match to the\
    \ index of the first match\n                last_match = i - 1;\n\n          \
    \      // Reset the index\n                i = 0;\n            }\n        } else\
    \ {\n            // Check if the substring is partially matching, and reset the\
    \ index if that is the case\n            if i > 0 {\n                i = 0;\n\
    \            }\n        }\n    }\n\n    // Check if the substring is partially\
    \ matching the start of the string\n    if i > 0 {\n        // Decrement the last\
    \ match by the index of the last match\n        last_match -= i;\n\n        //\
    \ Check that the last match is not the same as the start of the string\n     \
    \   if last_match > 0 {\n            // Reset the index\n            i = 0;\n\n\
    \            // Loop through the chars in the string\n            for c in string\
    \ {\n                // Check for match\n                if substring[i] == c\
    \ {\n                    // Increment the index\n                    i += 1;\n\
    \n                    // Check if a substring has been found\n               \
    \     if i == substring.len() {\n                        // Add a new match\n\
    \                        num_times += 1;\n\n                        // Set the\
    \ last match to the index of the first match\n                        last_match\
    \ = i - 1;\n\n                        // Reset the index\n                   \
    \     i = 0;\n                    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx6imwlmb.rs:89:3\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n54 |     if i > 0 {\n   |              - unclosed delimiter\n\
    ...\n59 |         if last_match > 0 {\n   |                           - unclosed\
    \ delimiter\n...\n64 |             for c in string {\n   |                   \
    \          - unclosed delimiter\n65 |                 // Check for match\n66 |\
    \                 if substring[i] == c {\n   |                               \
    \       - this delimiter might not be properly closed...\n...\n81 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n89 | }\n   |  \
    \ ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx6imwlmb.rs:64:13\n   |\n\
    8  |   fn how_many_times(string: String, substring: String) -> isize {\n   | \
    \                                                          ----- expected `isize`\
    \ because of return type\n...\n64 | /             for c in string {\n65 | |  \
    \               // Check for match\n66 | |                 if substring[i] ==\
    \ c {\n67 | |                     // Increment the index\n...  |\n88 | |     assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n89 | | }\n   | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let ss = substring.len();\n    let s = string.len();\n    if ss == 0 || s\
    \ == 0 || ss > s {\n        return 0;\n    }\n    let sub_string_chars: Vec<char>\
    \ = substring.chars().collect();\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let mut total = 0;\n    for start in 0..s {\n        if start + ss > s {\n\
    \            break;\n        }\n        if sub_string_chars[0] == string_chars[start]\
    \ {\n            let mut equals = true;\n            for j in 1..ss {\n      \
    \          if sub_string_chars[j] != string_chars[start + j] {\n             \
    \       equals = false;\n                    break;\n                }\n     \
    \       }\n            if equals {\n                total += 1;\n            }\n\
    \        }\n    }\n    total\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let str_len = string.len();\n    let substr_len = substring.len();\n    if\
    \ str_len < substr_len {\n        return 0;\n    }\n    let mut count = 0;\n \
    \   let mut i = 0;\n    let mut j = 0;\n    while i < str_len {\n        if string.chars().nth(i).unwrap()\
    \ == substring.chars().nth(j).unwrap() {\n            if j == substr_len - 1 {\n\
    \                j = 0;\n                count += 1;\n            } else {\n \
    \               j += 1;\n            }\n        } else {\n            j = 0;\n\
    \        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfhr8nc_h.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let haystack = string.as_str();\n    let needle = substring.as_str();\n  \
    \  let mut n = 0;\n    let mut needle_start = 0;\n    while let Some(needle_start)\
    \ = haystack[needle_start..].find(needle) {\n        n += 1;\n        needle_start\
    \ += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `needle_start` is assigned to, but never used\n  -->\
    \ /tmp/tmpjjppqqfl.rs:13:20\n   |\n13 |     while let Some(needle_start) = haystack[needle_start..].find(needle)\
    \ {\n   |                    ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_needle_start` instead\n\nwarning:\
    \ value assigned to `needle_start` is never read\n  --> /tmp/tmpjjppqqfl.rs:15:9\n\
    \   |\n15 |         needle_start += 1;\n   |         ^^^^^^^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpjjppqqfl.rs:12:9\n\
    \   |\n12 |     let mut needle_start = 0;\n   |         ----^^^^^^^^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign twice to immutable variable `needle_start`\n\
    \  --> /tmp/tmpjjppqqfl.rs:15:9\n   |\n13 |     while let Some(needle_start) =\
    \ haystack[needle_start..].find(needle) {\n   |                    ------------\n\
    \   |                    |\n   |                    first assignment to `needle_start`\n\
    \   |                    help: consider making this binding mutable: `mut needle_start`\n\
    14 |         n += 1;\n15 |         needle_start += 1;\n   |         ^^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error; 3 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut\
    \ offset = 0;\n    let mut count = 0;\n    loop {\n        let o = string[offset..].find(&substring).unwrap_or(string.len());\n\
    \        if o == string.len() {\n            break;\n        }\n        count\
    \ += 1;\n        offset += o + substring.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8zhej6g2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut current = string.find(&substring);\n    let mut total = 0;\n    while\
    \ current.is_some() {\n        total += 1;\n        current = string[current.unwrap()+1..].find(&substring);\n\
    \    }\n    total\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   how_many_times_rec(&string, &substring, 0)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `how_many_times_rec` in this scope\n\
    \ --> /tmp/tmpd0ds85vh.rs:9:5\n  |\n9 |     how_many_times_rec(&string, &substring,\
    \ 0)\n  |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let (short, long) = if string.len() >= substring.len() {\n        (substring,\
    \ string)\n    } else {\n        (string, substring)\n    };\n    let mut i =\
    \ 0;\n    while i < (long.len() - short.len() + 1) {\n        let slice = &long[i..(i\
    \ + short.len())];\n        if slice == short {\n            count += 1;\n   \
    \         i += short.len();\n        } else {\n            i += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   unimplemented!(\"How many times '{}' can be found in '{}'?\", substring, string);\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: How many times ''x'' can
    be found in ''''?'', /tmp/tmpsgang6sj.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let chars = string.chars().collect::<Vec<char>>();\n\
    \    let sub_chars = substring.chars().collect::<Vec<char>>();\n    let mut count\
    \ = 0;\n    let mut i = 0;\n    while i < chars.len() {\n        if chars[i] ==\
    \ sub_chars[0] {\n            count += 1;\n            i += 1;\n            let\
    \ mut j = 1;\n            while j < sub_chars.len() && i < chars.len() {\n   \
    \             if chars[i] != sub_chars[j] {\n                    count -= 1;\n\
    \                    break;\n                }\n                i += 1;\n    \
    \            j += 1;\n            }\n        } else {\n            i += 1;\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpp2f6b77k.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut occurrences = 0;\n    let mut current_slice = &string[..];\n    loop\
    \ {\n        match current_slice.find(&substring) {\n            Some(i) => {\n\
    \                occurrences += 1;\n                current_slice = &current_slice[i\
    \ + 1..];\n            }\n            None => break,\n        }\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let len = substring.len();\n    for i in 0..string.len()\
    \ - len + 1 {\n        let sub = &string[i..i + len];\n        if sub == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpv37lywho.rs:11:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut prev_index = 0;\n    let mut index = string.find(&substring);\n\
    \    while index.is_some() {\n        count += 1;\n        prev_index = index.unwrap()\
    \ + 1;\n        index = string.find(&substring);\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() < substring.len() {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    while i <= string.len() - substring.len()\
    \ {\n        if string[i..i + substring.len()] == substring {\n            count\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo69251c9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut res = 0;\n    let s = string.as_str();\n    let sub = substring.as_str();\n\
    \    let sub_len = sub.len();\n    let mut index = 0;\n    while index < s.len()\
    \ {\n        if s[index..].starts_with(sub) {\n            res += 1;\n       \
    \     index += sub_len;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplitqab99.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   assert!(!string.is_empty() && !substring.is_empty());\n    let mut index =\
    \ 0;\n    let mut result = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    loop {\n        if index + substring_len <= string_len\
    \ {\n            if string[index..index + substring_len] == substring {\n    \
    \            result += 1;\n                index += substring_len;\n         \
    \   } else {\n                index += 1;\n            }\n        } else {\n \
    \           break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: !string.is_empty() && !substring.is_empty()'',
    /tmp/tmpbf0rs21k.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let ans = string[index..].find(&substring);\n        if ans.is_none()\
    \ {\n            break;\n        }\n        index += ans.unwrap() + substring.len();\n\
    \        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgpyialdu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut n = 0;\n    let mut k = 0;\n    while k + substring.len() <= string.len()\
    \ {\n        if &string[k..k + substring.len()] == substring {\n            n\
    \ += 1;\n            k += substring.len();\n        } else {\n            k +=\
    \ 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmphkq2yh6o.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let s = string.as_str();\n    let ss = substring.as_str();\n    if ss.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let rest = &s[i..];\n        let n = rest.find(ss);\n\
    \        if n.is_none() {\n            break;\n        }\n        count += 1;\n\
    \        i += n.unwrap() + ss.len();\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb2oa17ua.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut from = 0;\n    while let Some(i) = string[from..].find(&substring)\
    \ {\n        count += 1;\n        from = from + i + 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let original = string.as_str();\n    let substring = substring.as_str();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ original.len() && j < substring.len() {\n        if original.as_bytes()[i] ==\
    \ substring.as_bytes()[j] {\n            i += 1;\n            j += 1;\n      \
    \  } else {\n            i += 1;\n            j = 0;\n        }\n        if j\
    \ == substring.len() {\n            count += 1;\n            j = 0;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz23nsopw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let substring_chars: Vec<char> = substring.chars().collect();\n    let string_length\
    \ = string_chars.len();\n    let substring_length = substring_chars.len();\n \
    \   if string_length == 0 || substring_length == 0 {\n        return 0;\n    }\n\
    \    for i in 0..string_length {\n        if i + substring_length > string_length\
    \ {\n            break;\n        }\n        let mut is_equal = true;\n       \
    \ for j in 0..substring_length {\n            if string_chars[i + j] != substring_chars[j]\
    \ {\n                is_equal = false;\n                break;\n            }\n\
    \        }\n        if is_equal {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let v = string.as_bytes();\n    let w = substring.as_bytes();\n    let mut\
    \ count = 0;\n    let mut i = 0;\n    let m = v.len();\n    let n = w.len();\n\
    \    while i < m {\n        let mut j = 0;\n        while j < n && i + j < m &&\
    \ v[i + j] == w[j] {\n            j += 1;\n        }\n        if j == n {\n  \
    \          count += 1;\n            i += n;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp52voseaq.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut index = 0;\n    for _ in 0..string_len - substring_len\
    \ + 1 {\n        if &string[index..index + substring_len] == substring {\n   \
    \         count += 1;\n        }\n        index += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpncuytpjn.rs:13:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976051
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let (string, substring) = (string.as_str(), substring.as_str());\n    if substring.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut last_idx\
    \ = 0;\n    while let Some(idx) = string[last_idx..].find(substring) {\n     \
    \   count += 1;\n        last_idx += idx + substring.len();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp04ylwu_5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976051
