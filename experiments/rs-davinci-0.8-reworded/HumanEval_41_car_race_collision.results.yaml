name: HumanEval_41_car_race_collision
language: rs
results:
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Given 2*n cars moving left/right, we can rephrase\
    \ the problem as 2 sequences of n numbers,\n    // where a number represents a\
    \ car location.\n    // The first sequence is in increasing order, and the second\
    \ sequence is in decreasing order.\n    // The task is to merge the two sequences\
    \ such that the overall sequence is also sorted.\n    // Then a car can collide\
    \ with another car if and only if the second car is greater than the first car.\n\
    \    // In other words, we can sum the number of inversions in the merged sequence.\n\
    \    //\n    // Implementation:\n    // We use the divide-and-conquer approach\
    \ to do the merge sort.\n    fn merge_sort(left: &[isize], right: &[isize]) ->\
    \ (Vec<isize>, isize) {\n        // The merge step combines a sorted left and\
    \ right subsequence into a sorted sequence.\n        // To do that, we use two\
    \ indices i and j (i for left, j for right), and a flag c (for collision)\n  \
    \      // to keep track of the number of inversions.  We always compare the numbers\
    \ at i and j.\n        // If the number at i is smaller, we put it in the output,\
    \ and increment i;\n        // if the number at j is smaller, we put it in the\
    \ output, and increment j.\n        // In addition, we also set c += len(left)\
    \ - i.\n        // When either i or j is exhausted, we put the rest of the other\
    \ subsequence in the output.\n        // The output vector is the merged sequence.\
    \  The return value is the number of inversions.\n        let mut out = Vec::with_capacity(left.len()\
    \ + right.len());\n        let mut i = 0;\n        let mut j = 0;\n        let\
    \ mut c = 0;\n        while i < left.len() && j < right.len() {\n            if\
    \ left[i] <= right[j] {\n                out.push(left[i]);\n                i\
    \ += 1;\n            } else {\n                out.push(right[j]);\n         \
    \       j += 1;\n                c += left.len() - i;\n            }\n       \
    \ }\n        for k in i..left.len() {\n            out.push(left\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9932qxt0.rs:53:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n19 |     fn merge_sort(left:\
    \ &[isize], right: &[isize]) -> (Vec<isize>, isize) {\n   |                  \
    \                                                         - unclosed delimiter\n\
    ...\n42 |         for k in i..left.len() {\n   |                             \
    \   - this delimiter might not be properly closed...\n43 |             out.push(left\n\
    44 | }\n   | - ...as it matches this but it has different indentation\n...\n53\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp9932qxt0.rs:43:21\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - closing delimiter possibly meant for this\n...\n43\
    \ |             out.push(left\n   |                     ^ unclosed delimiter\n\
    44 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9932qxt0.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize\
    \ {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9932qxt0.rs:43:22\n\
    \   |\n43 |             out.push(left\n   |                      ^^^^ expected\
    \ `isize`, found `&[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9932qxt0.rs:19:55\n\
    \   |\n19 |     fn merge_sort(left: &[isize], right: &[isize]) -> (Vec<isize>,\
    \ isize) {\n   |        ----------                                     ^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `()`\n   |        |\n   |        implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note:  expected tuple\
    \ `(Vec<isize>, isize)`\n           found unit type `()`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut left_cars:\
    \ Vec<i32> = Vec::new();\n    let mut right_cars: Vec<i32> = Vec::new();\n   \
    \ for i in 0..n {\n        left_cars.push(i as i32);\n        right_cars.push(n\
    \ as i32 - i - 1);\n    }\n    let mut collisions = 0;\n    left_cars.sort();\n\
    \    right_cars.sort();\n    for l in left_cars {\n        collisions += left_cars.binary_search(&l).unwrap_err()\n\
    \            - right_cars.binary_search(&l).unwrap_err();\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfvsn81c.rs:17:36\n   |\n\
    17 |         right_cars.push(n as i32 - i - 1);\n   |                        \
    \            ^ expected `i32`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `isize` from `i32`\n  --> /tmp/tmpsfvsn81c.rs:17:34\n   |\n17 |         right_cars.push(n\
    \ as i32 - i - 1);\n   |                                  ^ no implementation\
    \ for `i32 - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfvsn81c.rs:26:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n26 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmphydhw42_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut d_n\
    \ = std::iter::repeat(1).take(n as usize).collect::<Vec<isize>>();\n    let mut\
    \ d_p = std::iter::repeat(-1).take(n as usize).collect::<Vec<isize>>();\n    let\
    \ mut s_n = std::iter::repeat(0).take(n as usize).collect::<Vec<isize>>();\n \
    \   let mut s_p = std::iter::repeat(0).take(n as usize).collect::<Vec<isize>>();\n\
    \    for i in 1..n {\n        s_n[i as usize] = i;\n        s_p[i as usize] =\
    \ -i;\n    }\n    let mut ret = 0;\n    let mut i = 0;\n    while i < n {\n  \
    \      // move the cars\n        for j in 0..n {\n            s_n[j as usize]\
    \ += d_n[j as usize];\n            s_p[j as usize] += d_p[j as usize];\n     \
    \   }\n        // detect collision\n        let mut j = 0;\n        while j <\
    \ n {\n            if s_n[j as usize] == s_p[j as usize] {\n                ret\
    \ += 1;\n                d_n[j as usize] = 0;\n                d_p[j as usize]\
    \ = 0;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpsb9w3g4h.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = n;\n    if n < 0 {\n        panic!(\"n cannot\
    \ be negative\");\n    }\n    let mut collisions = 0;\n    while n != 0 {\n  \
    \      collisions += n;\n        n -= 1;\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp9f7vuxcb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmplv95jfhj.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut last_position:\
    \ Option<(bool, isize)> = None;\n    let mut count = 0;\n    for i in 0..n {\n\
    \        let car_i_position = if i % 2 == 0 {\n            //  car coming from\
    \ left.\n            let car_i_left_to_right_position = if let Some((_, last_position))\
    \ = last_position {\n                last_position + 1\n            } else {\n\
    \                0\n            };\n            last_position = Some((true, car_i_left_to_right_position));\n\
    \            car_i_left_to_right_position\n        } else {\n            //  car\
    \ coming from right.\n            let car_i_right_to_left_position = if let Some((_,\
    \ last_position)) = last_position {\n                last_position - 1\n     \
    \       } else {\n                0\n            };\n            last_position\
    \ = Some((false, car_i_right_to_left_position));\n            car_i_right_to_left_position\n\
    \        };\n        for j in (i + 1)..n {\n            let car_j_position = if\
    \ j % 2 == 0 {\n                //  car coming from left.\n                let\
    \ car_j_left_to_right_position = if let Some((_, last_position)) = last_position\
    \ {\n                    last_position + 1\n                } else {\n       \
    \             0\n                };\n                last_position = Some((true,\
    \ car_j_left_to_right_position));\n                car_j_left_to_right_position\n\
    \            } else {\n                //  car coming from right.\n          \
    \      let car_j_right_to_left_position = if let Some((_, last_position)) = last_position\
    \ {\n                    last_position - 1\n                } else {\n       \
    \             0\n                };\n                last_position = Some((false,\
    \ car_j_right_to_left_position));\n                car_j_right_to_left_position\n\
    \            };\n            if car_i_position == car_j_position {\n         \
    \       count += 1;\n            }\n        }\n    }\n\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwivh3d_u.rs:15:5\n   |\n\
    9  |   fn car_race_collision(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n15 | /  \
    \   for i in 0..n {\n16 | |         let car_i_position = if i % 2 == 0 {\n17 |\
    \ |             //  car coming from left.\n18 | |             let car_i_left_to_right_position\
    \ = if let Some((_, last_position)) = last_position {\n...  |\n58 | |        \
    \ }\n59 | |     }\n   | |_____^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        collisions += (n - i) * i;\n        i += 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuizw_drh.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num = 0;\n    let mut set: HashSet<isize> = HashSet::new();\n\
    \    for i in 1..n+1 {\n        let x = i*2-1;\n        let mut j = n;\n     \
    \   while j >= 1 {\n            let y = j*2;\n            if x == y {\n      \
    \          set.insert(j);\n            }\n            j -= 1;\n        }\n   \
    \ }\n    for x in 1..n+1 {\n        let y = x*2;\n        if set.contains(&x)\
    \ {\n            num += y-1;\n        } else {\n            num += y;\n      \
    \  }\n    }\n    num\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpbozr4m2l.rs:11:18\n\
    \   |\n11 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpbozr4m2l.rs:11:35\n\
    \   |\n11 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut cars_l2r\
    \ = BTreeSet::new();\n    let mut cars_r2l = BTreeSet::new();\n    for i in 1..=n\
    \ {\n        cars_l2r.insert(i);\n        cars_r2l.insert(-i);\n    }\n    let\
    \ mut collisions = 0;\n    while !cars_l2r.is_empty() && !cars_r2l.is_empty()\
    \ {\n        let car_l2r = *cars_l2r.iter().next().unwrap();\n        let car_r2l\
    \ = *cars_r2l.iter().next().unwrap();\n        cars_l2r.remove(&car_l2r);\n  \
    \      cars_r2l.remove(&car_r2l);\n        if car_l2r > -car_r2l {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  -->\
    \ /tmp/tmp4rkppfdz.rs:13:24\n   |\n13 |     let mut cars_l2r = BTreeSet::new();\n\
    \   |                        ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmp4rkppfdz.rs:14:24\n\
    \   |\n14 |     let mut cars_r2l = BTreeSet::new();\n   |                    \
    \    ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::BTreeSet;\n   |\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let (s1, r1) = chan::sync(0);\n    let (s2, r2) = chan::sync(0);\n\
    \    let (s3, r3) = chan::sync(0);\n    let (s4, r4) = chan::sync(0);\n    let\
    \ (s5, r5) = chan::sync(0);\n    let (s6, r6) = chan::sync(0);\n    let (s7, r7)\
    \ = chan::sync(0);\n    let (s8, r8) = chan::sync(0);\n    let (s9, r9) = chan::sync(0);\n\
    \    spawn(proc() {\n        let mut left_to_right = 0;\n        for _ in range(0,\
    \ n) {\n            left_to_right += 1;\n            s1.send(left_to_right);\n\
    \            s2.send(left_to_right);\n            s3.send(left_to_right);\n  \
    \          s4.send(left_to_right);\n            s5.send(left_to_right);\n    \
    \        s6.send(left_to_right);\n            s7.send(left_to_right);\n      \
    \      s8.send(left_to_right);\n            s9.send(left_to_right);\n        }\n\
    \    });\n    spawn(proc() {\n        let mut left_to_right = 0;\n        for\
    \ _ in range(0, n) {\n            left_to_right += 1;\n            r1.recv();\n\
    \            r2.recv();\n            r3.recv();\n            r4.recv();\n    \
    \        r5.recv();\n            r6.recv();\n            r7.recv();\n        \
    \    r8.recv();\n            r9.recv();\n        }\n    });\n    spawn(proc()\
    \ {\n        let mut right_to_left = 0;\n        for _ in range(0, n) {\n    \
    \        right_to_left += 1;\n            s1.send(right_to_left);\n          \
    \  s2.send(right_to_left);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1rauuctx.rs:64:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n49 |     spawn(proc() {\n\
    \   |          -       - unclosed delimiter\n   |          |\n   |          unclosed\
    \ delimiter\n50 |         let mut right_to_left = 0;\n51 |         for _ in range(0,\
    \ n) {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n55 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n64 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found `{`\n  --> /tmp/tmp1rauuctx.rs:19:18\n   |\n19 |     spawn(proc() {\n\
    \   |                 -^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                 |\n   |                 help: missing `,`\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, or an operator, found `{`\n  --> /tmp/tmp1rauuctx.rs:34:18\n\
    \   |\n34 |     spawn(proc() {\n   |                 -^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n   |                 |\n   |                 help:\
    \ missing `,`\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found\
    \ `{`\n  --> /tmp/tmp1rauuctx.rs:49:18\n   |\n49 |     spawn(proc() {\n   |  \
    \               -^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |  \
    \               |\n   |                 help: missing `,`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:10:20\n\
    \   |\n10 |     let (s1, r1) = chan::sync(0);\n   |                    ^^^^ use\
    \ of undeclared crate or module `chan`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:11:20\n   |\n\
    11 |     let (s2, r2) = chan::sync(0);\n   |                    ^^^^ use of undeclared\
    \ crate or module `chan`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:12:20\n   |\n12 |     let\
    \ (s3, r3) = chan::sync(0);\n   |                    ^^^^ use of undeclared crate\
    \ or module `chan`\n\nerror[E04"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars: BTreeSet<isize> = BTreeSet::new();\n  \
    \  let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n    let mut count =\
    \ 0;\n    for i in 0..n {\n        cars.insert(i);\n        cars_right.insert(-i);\n\
    \    }\n    while cars.len() > 0 {\n        if cars_right.contains(&cars.iter().next().unwrap())\
    \ {\n            count += 1;\n        }\n        cars.remove(&cars.iter().next().unwrap());\n\
    \        cars_right.remove(&cars_right.iter().next().unwrap());\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n  --> /tmp/tmplcwpflah.rs:10:19\n\
    \   |\n10 |     let mut cars: BTreeSet<isize> = BTreeSet::new();\n   |       \
    \            ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmplcwpflah.rs:10:37\n\
    \   |\n10 |     let mut cars: BTreeSet<isize> = BTreeSet::new();\n   |       \
    \                              ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0412]: cannot find type `BTreeSet` in this scope\n  --> /tmp/tmplcwpflah.rs:11:25\n\
    \   |\n11 |     let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n   | \
    \                        ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmplcwpflah.rs:11:43\n\
    \   |\n11 |     let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n   | \
    \                                          ^^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::BTreeSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut p: Vec<isize> = vec![];\n    let mut q: Vec<isize>\
    \ = vec![];\n    for i in 0..n {\n        p.push(i);\n        q.push(n - i - 1);\n\
    \    }\n    assert_eq!(p.len(), q.len());\n    let mut ret: isize = 0;\n    while\
    \ !p.is_empty() {\n        if p[0] > q[0] {\n            q.remove(0);\n      \
    \      ret += 1;\n        } else {\n            p.remove(0);\n        }\n    }\n\
    \    return ret;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp47_5e6ql.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n + 1 {\n      \
    \  for j in 1..n + 1 {\n            if i > j {\n                result += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpgghenp4u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, 0)\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpgxbb_38s.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    panic!(\"#TODO\")\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at '#TODO', /tmp/tmpk5k5zk7q.rs:10:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = BinaryHeap::new();\n    let mut cars_right\
    \ = BinaryHeap::new();\n    for i in 1..n+1 {\n        cars_left.push(Car{id:\
    \ i, position: -i as f64});\n        cars_right.push(Car{id: i, position: i as\
    \ f64});\n    }\n    let mut collisions = 0;\n    while !cars_left.is_empty()\
    \ && !cars_right.is_empty() {\n        let car_left = cars_left.pop().unwrap();\n\
    \        let car_right = cars_right.pop().unwrap();\n        if car_left.position\
    \ > car_right.position {\n            collisions += 1;\n            cars_left.push(car_left);\n\
    \            cars_right.push(Car{id: car_right.id, position: car_right.position\
    \ - n as f64});\n        } else {\n            cars_left.push(Car{id: car_left.id,\
    \ position: car_left.position + n as f64});\n            cars_right.push(car_right);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmps6ncu29b.rs:10:25\n   |\n10 |     let mut cars_left = BinaryHeap::new();\n\
    \   |                         ^^^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmps6ncu29b.rs:11:26\n   |\n11 |     let mut cars_right = BinaryHeap::new();\n\
    \   |                          ^^^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n\
    \   |\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:13:24\n   |\n13 |         cars_left.push(Car{id:\
    \ i, position: -i as f64});\n   |                        ^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:14:25\n   |\n14 |         cars_right.push(Car{id:\
    \ i, position: i as f64});\n   |                         ^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:23:29\n   |\n23 |             cars_right.push(Car{id:\
    \ car_right.id, position: car_right.position - n as f64});\n   |             \
    \                ^^^ not found in this scope\n\nerror[E0422]: cannot find struct,\
    \ variant or union type `Car` in this scope\n  --> /tmp/tmps6ncu29b.rs:25:28\n\
    \   |\n25 |             cars_left.push(Car{id: car_left.id, position: car_left.position\
    \ + n as f64});\n   |                            ^^^ not found in this scope\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Write this code in Lisp.\n    let mut collision\
    \ = 0;\n    for i in 0..n {\n        for j in n..0 {\n            collision +=\
    \ 1;\n        }\n    }\n    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp4hsyzash.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    for x in 1..n {\n  \
    \      for y in x + 1..n + 1 {\n            if y % x == 0 {\n                num_collisions\
    \ += 1;\n            }\n        }\n    }\n    num_collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnq2v8egl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
