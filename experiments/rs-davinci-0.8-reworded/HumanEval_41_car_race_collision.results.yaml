language: rs
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Given 2*n cars moving left/right, we can rephrase\
    \ the problem as 2 sequences of n numbers,\n    // where a number represents a\
    \ car location.\n    // The first sequence is in increasing order, and the second\
    \ sequence is in decreasing order.\n    // The task is to merge the two sequences\
    \ such that the overall sequence is also sorted.\n    // Then a car can collide\
    \ with another car if and only if the second car is greater than the first car.\n\
    \    // In other words, we can sum the number of inversions in the merged sequence.\n\
    \    //\n    // Implementation:\n    // We use the divide-and-conquer approach\
    \ to do the merge sort.\n    fn merge_sort(left: &[isize], right: &[isize]) ->\
    \ (Vec<isize>, isize) {\n        // The merge step combines a sorted left and\
    \ right subsequence into a sorted sequence.\n        // To do that, we use two\
    \ indices i and j (i for left, j for right), and a flag c (for collision)\n  \
    \      // to keep track of the number of inversions.  We always compare the numbers\
    \ at i and j.\n        // If the number at i is smaller, we put it in the output,\
    \ and increment i;\n        // if the number at j is smaller, we put it in the\
    \ output, and increment j.\n        // In addition, we also set c += len(left)\
    \ - i.\n        // When either i or j is exhausted, we put the rest of the other\
    \ subsequence in the output.\n        // The output vector is the merged sequence.\
    \  The return value is the number of inversions.\n        let mut out = Vec::with_capacity(left.len()\
    \ + right.len());\n        let mut i = 0;\n        let mut j = 0;\n        let\
    \ mut c = 0;\n        while i < left.len() && j < right.len() {\n            if\
    \ left[i] <= right[j] {\n                out.push(left[i]);\n                i\
    \ += 1;\n            } else {\n                out.push(right[j]);\n         \
    \       j += 1;\n                c += left.len() - i;\n            }\n       \
    \ }\n        for k in i..left.len() {\n            out.push(left\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9932qxt0.rs:53:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n19 |     fn merge_sort(left:\
    \ &[isize], right: &[isize]) -> (Vec<isize>, isize) {\n   |                  \
    \                                                         - unclosed delimiter\n\
    ...\n42 |         for k in i..left.len() {\n   |                             \
    \   - this delimiter might not be properly closed...\n43 |             out.push(left\n\
    44 | }\n   | - ...as it matches this but it has different indentation\n...\n53\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp9932qxt0.rs:43:21\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - closing delimiter possibly meant for this\n...\n43\
    \ |             out.push(left\n   |                     ^ unclosed delimiter\n\
    44 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmp9932qxt0.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize\
    \ {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9932qxt0.rs:43:22\n\
    \   |\n43 |             out.push(left\n   |                      ^^^^ expected\
    \ `isize`, found `&[isize]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9932qxt0.rs:19:55\n\
    \   |\n19 |     fn merge_sort(left: &[isize], right: &[isize]) -> (Vec<isize>,\
    \ isize) {\n   |        ----------                                     ^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `()`\n   |        |\n   |        implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note:  expected tuple\
    \ `(Vec<isize>, isize)`\n           found unit type `()`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut left_cars:\
    \ Vec<i32> = Vec::new();\n    let mut right_cars: Vec<i32> = Vec::new();\n   \
    \ for i in 0..n {\n        left_cars.push(i as i32);\n        right_cars.push(n\
    \ as i32 - i - 1);\n    }\n    let mut collisions = 0;\n    left_cars.sort();\n\
    \    right_cars.sort();\n    for l in left_cars {\n        collisions += left_cars.binary_search(&l).unwrap_err()\n\
    \            - right_cars.binary_search(&l).unwrap_err();\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsfvsn81c.rs:17:36\n   |\n\
    17 |         right_cars.push(n as i32 - i - 1);\n   |                        \
    \            ^ expected `i32`, found `isize`\n\nerror[E0277]: cannot subtract\
    \ `isize` from `i32`\n  --> /tmp/tmpsfvsn81c.rs:17:34\n   |\n17 |         right_cars.push(n\
    \ as i32 - i - 1);\n   |                                  ^ no implementation\
    \ for `i32 - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfvsn81c.rs:26:5\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                   ----- expected `isize` because of return type\n...\n26 | \
    \    collisions\n   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n26 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmphydhw42_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut d_n\
    \ = std::iter::repeat(1).take(n as usize).collect::<Vec<isize>>();\n    let mut\
    \ d_p = std::iter::repeat(-1).take(n as usize).collect::<Vec<isize>>();\n    let\
    \ mut s_n = std::iter::repeat(0).take(n as usize).collect::<Vec<isize>>();\n \
    \   let mut s_p = std::iter::repeat(0).take(n as usize).collect::<Vec<isize>>();\n\
    \    for i in 1..n {\n        s_n[i as usize] = i;\n        s_p[i as usize] =\
    \ -i;\n    }\n    let mut ret = 0;\n    let mut i = 0;\n    while i < n {\n  \
    \      // move the cars\n        for j in 0..n {\n            s_n[j as usize]\
    \ += d_n[j as usize];\n            s_p[j as usize] += d_p[j as usize];\n     \
    \   }\n        // detect collision\n        let mut j = 0;\n        while j <\
    \ n {\n            if s_n[j as usize] == s_p[j as usize] {\n                ret\
    \ += 1;\n                d_n[j as usize] = 0;\n                d_p[j as usize]\
    \ = 0;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpsb9w3g4h.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = n;\n    if n < 0 {\n        panic!(\"n cannot\
    \ be negative\");\n    }\n    let mut collisions = 0;\n    while n != 0 {\n  \
    \      collisions += n;\n        n -= 1;\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp9f7vuxcb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmplv95jfhj.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut last_position:\
    \ Option<(bool, isize)> = None;\n    let mut count = 0;\n    for i in 0..n {\n\
    \        let car_i_position = if i % 2 == 0 {\n            //  car coming from\
    \ left.\n            let car_i_left_to_right_position = if let Some((_, last_position))\
    \ = last_position {\n                last_position + 1\n            } else {\n\
    \                0\n            };\n            last_position = Some((true, car_i_left_to_right_position));\n\
    \            car_i_left_to_right_position\n        } else {\n            //  car\
    \ coming from right.\n            let car_i_right_to_left_position = if let Some((_,\
    \ last_position)) = last_position {\n                last_position - 1\n     \
    \       } else {\n                0\n            };\n            last_position\
    \ = Some((false, car_i_right_to_left_position));\n            car_i_right_to_left_position\n\
    \        };\n        for j in (i + 1)..n {\n            let car_j_position = if\
    \ j % 2 == 0 {\n                //  car coming from left.\n                let\
    \ car_j_left_to_right_position = if let Some((_, last_position)) = last_position\
    \ {\n                    last_position + 1\n                } else {\n       \
    \             0\n                };\n                last_position = Some((true,\
    \ car_j_left_to_right_position));\n                car_j_left_to_right_position\n\
    \            } else {\n                //  car coming from right.\n          \
    \      let car_j_right_to_left_position = if let Some((_, last_position)) = last_position\
    \ {\n                    last_position - 1\n                } else {\n       \
    \             0\n                };\n                last_position = Some((false,\
    \ car_j_right_to_left_position));\n                car_j_right_to_left_position\n\
    \            };\n            if car_i_position == car_j_position {\n         \
    \       count += 1;\n            }\n        }\n    }\n\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwivh3d_u.rs:15:5\n   |\n\
    9  |   fn car_race_collision(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n15 | /  \
    \   for i in 0..n {\n16 | |         let car_i_position = if i % 2 == 0 {\n17 |\
    \ |             //  car coming from left.\n18 | |             let car_i_left_to_right_position\
    \ = if let Some((_, last_position)) = last_position {\n...  |\n58 | |        \
    \ }\n59 | |     }\n   | |_____^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        collisions += (n - i) * i;\n        i += 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuizw_drh.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num = 0;\n    let mut set: HashSet<isize> = HashSet::new();\n\
    \    for i in 1..n+1 {\n        let x = i*2-1;\n        let mut j = n;\n     \
    \   while j >= 1 {\n            let y = j*2;\n            if x == y {\n      \
    \          set.insert(j);\n            }\n            j -= 1;\n        }\n   \
    \ }\n    for x in 1..n+1 {\n        let y = x*2;\n        if set.contains(&x)\
    \ {\n            num += y-1;\n        } else {\n            num += y;\n      \
    \  }\n    }\n    num\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpbozr4m2l.rs:11:18\n\
    \   |\n11 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpbozr4m2l.rs:11:35\n\
    \   |\n11 |     let mut set: HashSet<isize> = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut cars_l2r\
    \ = BTreeSet::new();\n    let mut cars_r2l = BTreeSet::new();\n    for i in 1..=n\
    \ {\n        cars_l2r.insert(i);\n        cars_r2l.insert(-i);\n    }\n    let\
    \ mut collisions = 0;\n    while !cars_l2r.is_empty() && !cars_r2l.is_empty()\
    \ {\n        let car_l2r = *cars_l2r.iter().next().unwrap();\n        let car_r2l\
    \ = *cars_r2l.iter().next().unwrap();\n        cars_l2r.remove(&car_l2r);\n  \
    \      cars_r2l.remove(&car_r2l);\n        if car_l2r > -car_r2l {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  -->\
    \ /tmp/tmp4rkppfdz.rs:13:24\n   |\n13 |     let mut cars_l2r = BTreeSet::new();\n\
    \   |                        ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmp4rkppfdz.rs:14:24\n\
    \   |\n14 |     let mut cars_r2l = BTreeSet::new();\n   |                    \
    \    ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::BTreeSet;\n   |\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let (s1, r1) = chan::sync(0);\n    let (s2, r2) = chan::sync(0);\n\
    \    let (s3, r3) = chan::sync(0);\n    let (s4, r4) = chan::sync(0);\n    let\
    \ (s5, r5) = chan::sync(0);\n    let (s6, r6) = chan::sync(0);\n    let (s7, r7)\
    \ = chan::sync(0);\n    let (s8, r8) = chan::sync(0);\n    let (s9, r9) = chan::sync(0);\n\
    \    spawn(proc() {\n        let mut left_to_right = 0;\n        for _ in range(0,\
    \ n) {\n            left_to_right += 1;\n            s1.send(left_to_right);\n\
    \            s2.send(left_to_right);\n            s3.send(left_to_right);\n  \
    \          s4.send(left_to_right);\n            s5.send(left_to_right);\n    \
    \        s6.send(left_to_right);\n            s7.send(left_to_right);\n      \
    \      s8.send(left_to_right);\n            s9.send(left_to_right);\n        }\n\
    \    });\n    spawn(proc() {\n        let mut left_to_right = 0;\n        for\
    \ _ in range(0, n) {\n            left_to_right += 1;\n            r1.recv();\n\
    \            r2.recv();\n            r3.recv();\n            r4.recv();\n    \
    \        r5.recv();\n            r6.recv();\n            r7.recv();\n        \
    \    r8.recv();\n            r9.recv();\n        }\n    });\n    spawn(proc()\
    \ {\n        let mut right_to_left = 0;\n        for _ in range(0, n) {\n    \
    \        right_to_left += 1;\n            s1.send(right_to_left);\n          \
    \  s2.send(right_to_left);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1rauuctx.rs:64:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n49 |     spawn(proc() {\n\
    \   |          -       - unclosed delimiter\n   |          |\n   |          unclosed\
    \ delimiter\n50 |         let mut right_to_left = 0;\n51 |         for _ in range(0,\
    \ n) {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n55 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n64 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found `{`\n  --> /tmp/tmp1rauuctx.rs:19:18\n   |\n19 |     spawn(proc() {\n\
    \   |                 -^ expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                 |\n   |                 help: missing `,`\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, or an operator, found `{`\n  --> /tmp/tmp1rauuctx.rs:34:18\n\
    \   |\n34 |     spawn(proc() {\n   |                 -^ expected one of `)`, `,`,\
    \ `.`, `?`, or an operator\n   |                 |\n   |                 help:\
    \ missing `,`\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found\
    \ `{`\n  --> /tmp/tmp1rauuctx.rs:49:18\n   |\n49 |     spawn(proc() {\n   |  \
    \               -^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |  \
    \               |\n   |                 help: missing `,`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:10:20\n\
    \   |\n10 |     let (s1, r1) = chan::sync(0);\n   |                    ^^^^ use\
    \ of undeclared crate or module `chan`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:11:20\n   |\n\
    11 |     let (s2, r2) = chan::sync(0);\n   |                    ^^^^ use of undeclared\
    \ crate or module `chan`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `chan`\n  --> /tmp/tmp1rauuctx.rs:12:20\n   |\n12 |     let\
    \ (s3, r3) = chan::sync(0);\n   |                    ^^^^ use of undeclared crate\
    \ or module `chan`\n\nerror[E04"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars: BTreeSet<isize> = BTreeSet::new();\n  \
    \  let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n    let mut count =\
    \ 0;\n    for i in 0..n {\n        cars.insert(i);\n        cars_right.insert(-i);\n\
    \    }\n    while cars.len() > 0 {\n        if cars_right.contains(&cars.iter().next().unwrap())\
    \ {\n            count += 1;\n        }\n        cars.remove(&cars.iter().next().unwrap());\n\
    \        cars_right.remove(&cars_right.iter().next().unwrap());\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `BTreeSet` in this scope\n  --> /tmp/tmplcwpflah.rs:10:19\n\
    \   |\n10 |     let mut cars: BTreeSet<isize> = BTreeSet::new();\n   |       \
    \            ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmplcwpflah.rs:10:37\n\
    \   |\n10 |     let mut cars: BTreeSet<isize> = BTreeSet::new();\n   |       \
    \                              ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0412]: cannot find type `BTreeSet` in this scope\n  --> /tmp/tmplcwpflah.rs:11:25\n\
    \   |\n11 |     let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n   | \
    \                        ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmplcwpflah.rs:11:43\n\
    \   |\n11 |     let mut cars_right: BTreeSet<isize> = BTreeSet::new();\n   | \
    \                                          ^^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::BTreeSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut p: Vec<isize> = vec![];\n    let mut q: Vec<isize>\
    \ = vec![];\n    for i in 0..n {\n        p.push(i);\n        q.push(n - i - 1);\n\
    \    }\n    assert_eq!(p.len(), q.len());\n    let mut ret: isize = 0;\n    while\
    \ !p.is_empty() {\n        if p[0] > q[0] {\n            q.remove(0);\n      \
    \      ret += 1;\n        } else {\n            p.remove(0);\n        }\n    }\n\
    \    return ret;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp47_5e6ql.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n + 1 {\n      \
    \  for j in 1..n + 1 {\n            if i > j {\n                result += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpgghenp4u.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, 0)\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpgxbb_38s.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    panic!(\"#TODO\")\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''#TODO'', /tmp/tmpk5k5zk7q.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = BinaryHeap::new();\n    let mut cars_right\
    \ = BinaryHeap::new();\n    for i in 1..n+1 {\n        cars_left.push(Car{id:\
    \ i, position: -i as f64});\n        cars_right.push(Car{id: i, position: i as\
    \ f64});\n    }\n    let mut collisions = 0;\n    while !cars_left.is_empty()\
    \ && !cars_right.is_empty() {\n        let car_left = cars_left.pop().unwrap();\n\
    \        let car_right = cars_right.pop().unwrap();\n        if car_left.position\
    \ > car_right.position {\n            collisions += 1;\n            cars_left.push(car_left);\n\
    \            cars_right.push(Car{id: car_right.id, position: car_right.position\
    \ - n as f64});\n        } else {\n            cars_left.push(Car{id: car_left.id,\
    \ position: car_left.position + n as f64});\n            cars_right.push(car_right);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmps6ncu29b.rs:10:25\n   |\n10 |     let mut cars_left = BinaryHeap::new();\n\
    \   |                         ^^^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmps6ncu29b.rs:11:26\n   |\n11 |     let mut cars_right = BinaryHeap::new();\n\
    \   |                          ^^^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n\
    \   |\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:13:24\n   |\n13 |         cars_left.push(Car{id:\
    \ i, position: -i as f64});\n   |                        ^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:14:25\n   |\n14 |         cars_right.push(Car{id:\
    \ i, position: i as f64});\n   |                         ^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmps6ncu29b.rs:23:29\n   |\n23 |             cars_right.push(Car{id:\
    \ car_right.id, position: car_right.position - n as f64});\n   |             \
    \                ^^^ not found in this scope\n\nerror[E0422]: cannot find struct,\
    \ variant or union type `Car` in this scope\n  --> /tmp/tmps6ncu29b.rs:25:28\n\
    \   |\n25 |             cars_left.push(Car{id: car_left.id, position: car_left.position\
    \ + n as f64});\n   |                            ^^^ not found in this scope\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Write this code in Lisp.\n    let mut collision\
    \ = 0;\n    for i in 0..n {\n        for j in n..0 {\n            collision +=\
    \ 1;\n        }\n    }\n    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp4hsyzash.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    for x in 1..n {\n  \
    \      for y in x + 1..n + 1 {\n            if y % x == 0 {\n                num_collisions\
    \ += 1;\n            }\n        }\n    }\n    num_collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnq2v8egl.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = (0..n).map(|x| x * 2 + 1).collect::<Vec<isize>>();\n\
    \    let mut right_to_left = (0..n).map(|x| x * 2).collect::<Vec<isize>>();\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() {\n        let\
    \ left_current = left_to_right.remove(0);\n        collisions +=\n           \
    \ right_to_left.iter().filter(|&&x| x < left_current).count() as isize;\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpk_1l9xrq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut all_cars = Vec::new();\n    for i in 0..n {\n\
    \        let new_car = Car::new(i);\n        all_cars.push(new_car);\n    }\n\
    \    all_cars.sort_by(|a, b| a.cmp(b));\n    println!(\"{:?}\", all_cars);\n \
    \   let mut collisions = 0;\n    for i in 0..n {\n        let mut left_i = i +\
    \ 1;\n        while left_i < n && all_cars[left_i].velocity == all_cars[i].velocity\
    \ {\n            left_i += 1;\n        }\n        let mut right_i = i - 1;\n \
    \       while right_i >= 0 && all_cars[right_i].velocity == all_cars[i].velocity\
    \ {\n            right_i -= 1;\n        }\n        collisions += (i - right_i)\
    \ * (left_i - i);\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpis2_k9fz.rs:12:23\n\
    \   |\n12 |         let new_car = Car::new(i);\n   |                       ^^^\
    \ use of undeclared type `Car`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp__44kncu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        panic!(\"illegal value of n\");\n\
    \    }\n    let mut right_to_left = Vec::new();\n    let mut left_to_right = Vec::new();\n\
    \    for i in 0..n {\n        right_to_left.push(i);\n        left_to_right.push(n\
    \ - i - 1);\n    }\n    let mut counter = 0;\n    while right_to_left.len() >\
    \ 0 && left_to_right.len() > 0 {\n        let car_right_to_left = right_to_left.remove(0);\n\
    \        let car_left_to_right = left_to_right.remove(0);\n        if car_right_to_left\
    \ <= car_left_to_right {\n            right_to_left.push(car_right_to_left);\n\
    \            left_to_right.push(car_left_to_right);\n        } else {\n      \
    \      counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977902
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    let mut num_cars_ahead = 0;\n\n\
    \    for i in 0..n {\n        if i == 0 {\n            num_cars_ahead += 1;\n\
    \        } else {\n            num_cars_ahead += i;\n        }\n    }\n\n    num_cars_ahead\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdb031rq4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        0\n    } else {\n        n * (n\
    \ - 1) / 2\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpsy3dpwpx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        // Each\
    \ car that's going left to right will hit all the cars\n        // going right\
    \ to left; however, it won't hit itself.  So, we subtract 1.\n        (n * (n\
    \ - 1)) / 2\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2lca7c8s.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0a6ltuj3.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut arr = Vec::new();\n    // 1. Scan the input n\
    \ and construct a vector of n integers;\n    //    each integer is the position\
    \ of the corresponding car.\n    // 2. Sort the array\n    for _ in 0..n {\n \
    \       let mut buf = String::new();\n        std::io::stdin().read_line(&mut\
    \ buf).unwrap();\n        let i: isize = buf.trim().parse().unwrap();\n      \
    \  arr.push(i);\n    }\n    arr.sort();\n    // 3. Use merge sort's merge to count\
    \ the collisions.\n    merge_sort(arr)\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmpwa0_hlz9.rs:22:5\n\
    \   |\n22 |     merge_sort(arr)\n   |     ^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The post condition should be:\n    // We use a map\
    \ that holds the positions of all cars going from left to right.\n    // The key\
    \ is the position, the value is the number of cars in that position.\n    // Similarly,\
    \ we use a map for cars going from right to left.\n    // Note that there can\
    \ be at most 1 car in each position.\n    //\n    // We iterate over all the cars\
    \ going from left to right, and for each one\n    // we find out if there's a\
    \ car going from right to left.  If there is, then\n    // we add 1 to the number\
    \ of collisions.  At the end of this iteration, we have\n    // all cars going\
    \ from left to right in our map.  Then we do the same thing again\n    // for\
    \ the cars going from right to left.\n    //\n    // After the iteration, we have\
    \ the number of collisions in the map, and the\n    // cars in the maps.  We return\
    \ the number of collisions.\n    let mut left_to_right: HashMap<isize, isize>\
    \ = HashMap::new();\n    let mut right_to_left: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in 1..n+1 {\n        left_to_right.insert(i, 1);\n        right_to_left.insert(-i,\
    \ 1);\n    }\n    let mut collisions = 0;\n    for i in 1..n+1 {\n        let\
    \ possible_collision = left_to_right.get(&i);\n        if possible_collision.is_some()\
    \ {\n            collisions += 1;\n        }\n    }\n    for i in 1..n+1 {\n \
    \       let possible_collision = right_to_left.get(&-i);\n        if possible_collision.is_some()\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpvmjmx61m.rs:24:28\n\
    \   |\n24 |     let mut left_to_right: HashMap<isize, isize> = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpvmjmx61m.rs:24:52\n   |\n24 |     let mut left_to_right: HashMap<isize,\
    \ isize> = HashMap::new();\n   |                                             \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]: cannot find\
    \ type `HashMap` in this scope\n  --> /tmp/tmpvmjmx61m.rs:25:28\n   |\n25 |  \
    \   let mut right_to_left: HashMap<isize, isize> = HashMap::new();\n   |     \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpvmjmx61m.rs:25:52\n\
    \   |\n25 |     let mut right_to_left: HashMap<isize, isize> = HashMap::new();\n\
    \   |                                                    ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ count = 0;\n    while left_to_right.len() > 0 && right_to_left.len() > 0 {\n\
    \        let left = left_to_right[0];\n        let right = right_to_left[0];\n\
    \        if left < right {\n            left_to_right.remove(0);\n        } else\
    \ if left > right {\n            right_to_left.remove(0);\n        } else {\n\
    \            count += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8h_0docu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    for i in 1..=n {\n   \
    \     count += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp_euxr4qm.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        panic!(\"Invalid input\");\n    }\n\
    \n    let mut right_to_left = (1..n + 1).rev().collect::<Vec<isize>>();\n    let\
    \ mut left_to_right = (1..n + 1).collect::<Vec<isize>>();\n\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else {\n            left_to_right.remove(0);\n        }\n    }\n\n\
    \    n - left_to_right.len() as isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj0pu2gqc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // In order to understand the problem, it's best to observe\
    \ a few examples.\n    // 1. n = 1.\n    //   left_to_right:  [1]\n    //   right_to_left:\
    \  [1]\n    //   Answer:  1\n    // 2. n = 2.\n    //   left_to_right:  [1, 2]\n\
    \    //   right_to_left:  [2, 1]\n    //   Answer:  1\n    // 3. n = 3.\n    //\
    \   left_to_right:  [1, 2, 3]\n    //   right_to_left:  [3, 2, 1]\n    //   Answer:\
    \  3\n    // 4. n = 4.\n    //   left_to_right:  [1, 2, 3, 4]\n    //   right_to_left:\
    \  [4, 3, 2, 1]\n    //   Answer:  6\n    //\n    // Based on these observations,\
    \ one can conclude that the total number of collisions\n    // is a function of\
    \ (n * (n - 1)) / 2.\n    (n * (n - 1)) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfszc53j0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    n\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0__hpwwu.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    return 1\
    \ + car_race_collision(n - 1);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmph9bzhkd9.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut total_collisions\
    \ = 0;\n    // Fill up the vector with numbers 1 to n representing the cars.\n\
    \    for i in 0..n {\n        cars[i as usize] = i + 1;\n    }\n    // Shuffle\
    \ the vector.\n    let mut rng = rand::thread_rng();\n    cars.shuffle(&mut rng);\n\
    \    // cars now represents the cars of the left to right set of cars.\n    //\
    \ We will create a new vector that contains the right to left cars.\n    let mut\
    \ cars_rev = vec![0; n as usize];\n    for i in 0..n {\n        cars_rev[i as\
    \ usize] = cars[(n - i - 1) as usize];\n    }\n    // Now count the number of\
    \ collisions.\n    for i in 0..n {\n        for j in 0..n {\n            if cars[i\
    \ as usize] == cars_rev[j as usize] {\n                total_collisions += 1;\n\
    \            }\n        }\n    }\n    total_collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpu8wbf_j9.rs:17:19\n   |\n17 |     let mut rng = rand::thread_rng();\n\
    \   |                   ^^^^ use of undeclared crate or module `rand`\n\nerror[E0599]:\
    \ no method named `shuffle` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpu8wbf_j9.rs:18:10\n   |\n18 |     cars.shuffle(&mut rng);\n   |\
    \          ^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Basically it's a linear function of the form y = mx\
    \ + c\n    // We can track the count of how many left cars hit right cars\n  \
    \  // To do this, we can just keep track of the number of left cars\n    // that\
    \ are to the left of the right cars\n    let mut num_left = 0;\n    let mut num_collisions\
    \ = 0;\n    for i in 0..n {\n        num_collisions += num_left;\n        if i\
    \ % 2 == 0 {\n            num_left += 1;\n        }\n    }\n    num_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpqeqwvp5a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // generate the permutations of the cars driving left\
    \ to right\n    let mut permutations = permutation_of(0..n).collect::<Vec<_>>();\n\
    \    permutations.sort();\n    // let permutations = permutations.into_iter().map(|p|\
    \ p.into_iter().map(|x| x as f64).collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \    // let mut prev_perm = permutations[0].clone();\n    // let mut count = 0;\n\
    \    // for i in 1..permutations.len() {\n    //     let current_perm = permutations[i].clone();\n\
    \    //     let mut has_swap = false;\n    //     for j in 0..current_perm.len()\
    \ {\n    //         if prev_perm[j] > current_perm[j] {\n    //             has_swap\
    \ = true;\n    //             break;\n    //         }\n    //     }\n    // \
    \    if has_swap {\n    //         count += 1;\n    //     }\n    //     prev_perm\
    \ = current_perm;\n    // }\n    // count\n    let n = n as usize;\n    let mut\
    \ permutations = permutation_of(0..n).collect::<Vec<_>>();\n    permutations.sort();\n\
    \    let left = permutations.clone();\n    let right = permutations.clone().into_iter().map(|v|\
    \ v.into_iter().rev().collect::<Vec<_>>()).collect::<Vec<_>>();\n    let mut count\
    \ = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if left[i][j]\
    \ < right[i][j] {\n                count += 1;\n            }\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `permutation_of` in this scope\n  -->\
    \ /tmp/tmpccokafoz.rs:11:28\n   |\n11 |     let mut permutations = permutation_of(0..n).collect::<Vec<_>>();\n\
    \   |                            ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `permutation_of` in this scope\n  --> /tmp/tmpccokafoz.rs:32:28\n\
    \   |\n32 |     let mut permutations = permutation_of(0..n).collect::<Vec<_>>();\n\
    \   |                            ^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `permutations`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmplv95jfhj.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = vec![];\n    let mut right = vec![];\n\
    \    for i in 0..n {\n        left.push(i as isize);\n        right.push((n -\
    \ i - 1) as isize);\n    }\n    let mut collision = 0;\n    while left.len() >\
    \ 0 {\n        if left[0] == right[0] {\n            collision += 1;\n       \
    \ }\n        left.remove(0);\n        right.remove(0);\n    }\n    collision\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp35bi3hx4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp__44kncu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut collision_count\
    \ = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if i < j {\n\
    \                collision_count += 1;\n            }\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp20l2ps36.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let car_positions = car_positions(n);\n    let mut out\
    \ = 0;\n    for i in 0..n {\n        let right_boundary = car_positions[i];\n\
    \        let mut left_index = i;\n        while left_index > 0 && car_positions[left_index\
    \ - 1] > right_boundary {\n            left_index -= 1;\n        }\n        out\
    \ += i - left_index;\n    }\n    out\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_positions` in this scope\n  -->\
    \ /tmp/tmpzmhrr_7g.rs:10:25\n   |\n10 |     let car_positions = car_positions(n);\n\
    \   |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut ret:\
    \ isize = 0;\n    for nx in 1..n {\n        // When the cars start at position\
    \ nx,\n        // the left car is moving right and the right car is moving left.\n\
    \        // They collide when the right car reaches position 0\n        // and\
    \ the left car reaches position 2n.\n        // The right car needs to travel\
    \ 2nx distance.\n        // The left car needs to travel (2n - 2nx) distance.\n\
    \        // The right car is \"faster\", meaning that it's distance\n        //\
    \ is smaller than the left car's distance.\n        // Therefore the two cars\
    \ will collide when the\n        // right car reaches position 0.\n        ret\
    \ += nx;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprsrszfmp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n {\n        for\
    \ j in (i + 1)..(n + 1) {\n            if gcd(i, j) == 1 {\n                result\
    \ += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `gcd` in this scope\n  --> /tmp/tmp69vrazgq.rs:13:16\n\
    \   |\n13 |             if gcd(i, j) == 1 {\n   |                ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = vec![0; n as usize];\n \
    \   let mut cars_right_to_left = vec![0; n as usize];\n    for i in 0..n {\n \
    \       cars_left_to_right[i as usize] = i;\n        cars_right_to_left[i as usize]\
    \ = n - i - 1;\n    }\n    let mut collision_count = 0;\n    for i in 0..n {\n\
    \        for j in 0..n {\n            if cars_left_to_right[i as usize] > cars_right_to_left[j\
    \ as usize] {\n                collision_count += 1;\n            }\n        }\n\
    \    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4wa5q5qn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // since only two possible directions of the car, -1\
    \ and 1\n    // there is collision only if the same number is hit twice\n    n.abs()\
    \ - (1..n.abs()).count() as isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp7gelj4jm.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = vec![0; n as usize];\n    let mut right\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left[i as usize] = i;\n\
    \        right[i as usize] = n - i - 1;\n    }\n    car_race_collision_with_positions(left,\
    \ right)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_with_positions`\
    \ in this scope\n  --> /tmp/tmpusyl80t9.rs:16:5\n   |\n16 |     car_race_collision_with_positions(left,\
    \ right)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    panic!(\"here\");\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''here'', /tmp/tmppy488v90.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut j = n - 1;\n    while i < n {\n        if i == j {\n            collisions\
    \ += 1;\n        } else {\n            collisions += 2;\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `9`', /tmp/tmpp9ra2_ah.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = vec![(rand::random::<f64>()\
    \ * 100.0) as isize; n as usize];\n    let mut cars_right_to_left = vec![(rand::random::<f64>()\
    \ * 100.0) as isize; n as usize];\n    car_race_collision_helper(&mut cars_left_to_right,\
    \ &mut cars_right_to_left)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpzw723hi1.rs:10:40\n   |\n10 |     let mut cars_left_to_right =\
    \ vec![(rand::random::<f64>() * 100.0) as isize; n as usize];\n   |          \
    \                              ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpzw723hi1.rs:11:40\n   |\n11 |     let mut cars_right_to_left =\
    \ vec![(rand::random::<f64>() * 100.0) as isize; n as usize];\n   |          \
    \                              ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0425]: cannot find function `car_race_collision_helper` in this scope\n\
    \  --> /tmp/tmpzw723hi1.rs:12:5\n   |\n12 |     car_race_collision_helper(&mut\
    \ cars_left_to_right, &mut cars_right_to_left)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut cars\
    \ = Vec::with_capacity(n as usize);\n    let mut collisions = 0;\n    for i in\
    \ 0..n {\n        cars.push(i);\n    }\n    cars.sort();\n    // after sorted,\
    \ the lower # means moving faster\n    for i in 0..n {\n        collisions +=\
    \ n - 1 - i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8dfry40y.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut l = n;\n    let mut r = n;\n    let mut ret =\
    \ 0;\n    for _ in 0..(n << 1) {\n        ret += l * r;\n        l -= 1;\n   \
    \     r -= 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmpustbtye3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        0\n    } else {\n        n * (n\
    \ - 1)\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpq96v7_r3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    2 * n * (n - 1)\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `9`', /tmp/tmp0_lqjbu5.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    let mut count\
    \ = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if left_to_right[i]\
    \ == right_to_left[j] {\n                count += 1;\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8rg6jvea.rs:15:16\n\
    \   |\n15 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8rg6jvea.rs:15:36\n\
    \   |\n15 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    n * (n - 1) / 2\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpw7sesd1o.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    2 * n * (n - 1) + n\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmp11klqhtp.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut res\
    \ = 0;\n    let mut left_to_right: Vec<usize> = (0..n as usize).collect();\n \
    \   let mut right_to_left: Vec<usize> = (0..n as usize).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    for i in 0..n as\
    \ usize {\n        res += left_to_right[i] + right_to_left[i];\n    }\n    return\
    \ res;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2pe1hyyj.rs:22:12\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n22 |     return\
    \ res;\n   |            ^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n22 |     return res.try_into().unwrap();\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = std::collections::HashMap::new();\n  \
    \  cars.insert(0, n);\n    let mut c = 0;\n    for car in 1..n {\n        c +=\
    \ cars.get(&car).unwrap_or(&0);\n        let mut l = car - 1;\n        if l <\
    \ 0 {\n            l = n + l;\n        }\n        cars.insert(l, cars.get(&l).unwrap_or(&0)\
    \ + 1);\n    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpa72ai43i.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    // TODO: implement this function\n\
    \    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpgx0fayzz.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n - n / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2xhgsd10.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    let mut curr_collisions = 0;\n\
    \    for i in 0..n {\n        total += curr_collisions;\n        curr_collisions\
    \ += n - i;\n    }\n    total\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpr23qwnvy.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // todo\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp3jkz5qsn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp9koibpaz.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // this is a simple binary search solution\n    // the\
    \ key is to show that a simple binary search would work\n    // with the following\
    \ constraints\n    // 1. the position is in [-infinity, infinity]\n    // 2. two\
    \ cars will eventually collide when we keep putting cars\n    //    with this\
    \ position\n    let mut lo = -1000000000000;\n    let mut hi =  1000000000000;\n\
    \    while lo <= hi {\n        let mid = (lo + hi) / 2;\n        let num_left\
    \ = (0..n).map(|i| i + mid).count() as isize;\n        let num_right = (0..n).map(|i|\
    \ -(i + mid)).count() as isize;\n        if num_left <= num_right {\n        \
    \    lo = mid + 1;\n        } else {\n            hi = mid - 1;\n        }\n \
    \   }\n    hi\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1000000000000`,\n right: `4`', /tmp/tmp24aqllre.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize an array of size n+1 of 0.  This is the\
    \ number of cars moving right to left\n    // in each of the 1st n positions on\
    \ the road and in the n+1th position, it is the\n    // number of cars moving\
    \ left to right in each of the 1st n positions.\n    let mut right = vec![0; (n\
    \ + 1) as usize];\n    let mut left = vec![0; (n + 1) as usize];\n    // Initially,\
    \ there are n cars driving right to left in the first n positions on the road\n\
    \    // and there are n cars driving left to right in the first n positions on\
    \ the road.\n    for i in 0..n {\n        right[i as usize] = n;\n        left[i\
    \ as usize] = n;\n    }\n    // In each timestep, each car moves to a different\
    \ position in the road.\n    // If a car moves to the leftmost position of the\
    \ road, that car is no longer\n    // driving to the right, but to the left.\n\
    \    // Update the array accordingly.\n    // In each timestep, the number of\
    \ cars from the left moving to the right\n    // is the same as the number of\
    \ cars from the right moving to the left.\n    // The number of collisions happening\
    \ in each timestep is the number of cars\n    // moving to the right in a position.\n\
    \    let mut count = 0;\n    for _ in 0..n {\n        for i in 0..n {\n      \
    \      left[i as usize] += right[(i + 1) as usize];\n            right[i as usize]\
    \ = left[i as usize];\n            count += right[i as usize];\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `4`', /tmp/tmp6bek561e.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // let mut i = 0;\n    // let mut j = 0;\n    // let\
    \ mut collisions = 0;\n    // while i < n && j < n {\n    //     i += 1;\n   \
    \ //     j += 1;\n    //     collisions += 1;\n    // }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmsj7cs_c.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // your code goes here\n    car_race_collision_loop(n,\
    \ 0)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_loop` in this scope\n\
    \  --> /tmp/tmp0bea5q7o.rs:11:5\n   |\n11 |     car_race_collision_loop(n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    let mut cars_from_left: Vec<isize>\
    \ = (0..n).map(|i| i as isize).collect();\n    let mut cars_from_right: Vec<isize>\
    \ = (0..n).map(|i| n as isize - i as isize - 1).collect();\n    let mut result\
    \ = 0;\n    while !cars_from_left.is_empty() && !cars_from_right.is_empty() {\n\
    \        if cars_from_left[0] < cars_from_right[0] {\n            result += 1;\n\
    \            cars_from_left.remove(0);\n            cars_from_right.remove(0);\n\
    \        } else {\n            cars_from_left.remove(0);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp36zf3tw8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let cars_r2l: Vec<usize> = (0..n).collect();\n    let\
    \ cars_l2r: Vec<usize> = (0..n).collect();\n    /// if n is odd, then at least\
    \ one car will meet a car coming from the other\n    /// direction.  If n is even,\
    \ then that at least 2 cars will meet.\n    if n % 2 == 0 {\n        cars_r2l.iter().enumerate().map(|(i,\
    \ &c)| {\n            if cars_l2r[i] == c {\n                // if i is even,\
    \ then (n - i) is odd\n                // if i is odd, then (n - i) is even\n\
    \                // therefore:\n                (n - i) % 2\n            } else\
    \ {\n                // if i is even, then (n - i) is even\n                //\
    \ if i is odd, then (n - i) is odd\n                // therefore:\n          \
    \      1 - (n - i) % 2\n            }\n        }).sum()\n    } else {\n      \
    \  n\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "warning: unused doc comment\n  --> /tmp/tmpv77mpy5z.rs:12:5\n   |\n12 |\
    \ /     /// if n is odd, then at least one car will meet a car coming from the\
    \ other\n13 | |     /// direction.  If n is even, then that at least 2 cars will\
    \ meet.\n   | |______________________________________________________________________^\n\
    14 | /     if n % 2 == 0 {\n15 | |         cars_r2l.iter().enumerate().map(|(i,\
    \ &c)| {\n16 | |             if cars_l2r[i] == c {\n17 | |                 //\
    \ if i is even, then (n - i) is odd\n...  |\n29 | |         n\n30 | |     }\n\
    \   | |_____- rustdoc does not generate documentation for expressions\n   |\n\
    \   = note: `#[warn(unused_doc_comments)]` on by default\n   = help: use `//`\
    \ for a plain comment\n\nerror[E0277]: a value of type `Vec<usize>` cannot be\
    \ built from an iterator over elements of type `isize`\n    --> /tmp/tmpv77mpy5z.rs:10:39\n\
    \     |\n10   |     let cars_r2l: Vec<usize> = (0..n).collect();\n     |     \
    \                                  ^^^^^^^ value of type `Vec<usize>` cannot be\
    \ built from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait\
    \ `FromIterator<isize>` is not implemented for `Vec<usize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0277]: a value of type `Vec<usize>` cannot be built from\
    \ an iterator over elements of type `isize`\n    --> /tmp/tmpv77mpy5z.rs:11:39\n\
    \     |\n11   |     let cars_l2r: Vec<usize> = (0..n).collect();\n     |     \
    \                                  ^^^^^^^ value of type `Vec<usize>` cannot be\
    \ built from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait\
    \ `FromIterator<isize>` is not implemented for `Vec<usize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv77mpy5z.rs:20:22\n\
    \   |\n20 |                 (n - i) % 2\n   |                      ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `isize`\n\
    \  --> /tmp/tmpv77mpy5z.rs:20:20\n   |\n20 |                 (n -"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0a6ltuj3.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initially, let the cars left-to-right be at positions\
    \ [0..n).\n    // Let the cars right-to-left be at positions [n..0).\n    let\
    \ mut ltr = vec![0; n as usize];\n    let mut rtl = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        ltr[i as usize] = i;\n        rtl[(n - i - 1) as usize]\
    \ = -i;\n    }\n    // Now perform the simulation.\n    let mut collision_count\
    \ = 0;\n    while let Some(ltri) = ltr.pop() {\n        while let Some(rtli) =\
    \ rtl.pop() {\n            if ltri == -rtli {\n                collision_count\
    \ += 1;\n            } else {\n                ltr.push(ltri);\n             \
    \   rtl.push(rtli);\n                break;\n            }\n        }\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977903
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    if n % 2\
    \ == 0 {\n        return n * (n - 2);\n    }\n\n    // n is odd.\n    n * (n -\
    \ 1) - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpad83jq2k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut position_of_right_to_left_car = vec![0; n as\
    \ usize];\n    let mut position_of_left_to_right_car = vec![0; n as usize];\n\
    \    for i in 0..n {\n        position_of_right_to_left_car[i as usize] = n -\
    \ i;\n        position_of_left_to_right_car[i as usize] = i;\n    }\n    let mut\
    \ collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ position_of_right_to_left_car[i as usize] == position_of_left_to_right_car[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2tr7gjpy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function.\n    if n <= 1 {\n\
    \        return 0;\n    }\n    let a: Vec<isize> = (0..n).collect();\n    let\
    \ b: Vec<isize> = (0..n).rev().collect();\n    a.iter().fold(0, |acc, x| {\n \
    \       let c: Vec<isize> = b.iter().filter(|&y| x < y).collect();\n        acc\
    \ + c.len() as isize\n    })\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmpfs9s6bdx.rs:17:57\n     |\n\
    17   |         let c: Vec<isize> = b.iter().filter(|&y| x < y).collect();\n  \
    \   |                                                         ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    /// This function implements an insertion-sort-like algorithm\
    \ that keeps track of\n    /// collisions, and outputs the total number of collisions.\n\
    \    /// It is assumed that the input array contains values in [0,n]\n    fn insertion_sort_and_count_collisions(mut\
    \ arr: Vec<isize>) -> isize {\n        let n = arr.len() as isize;\n        let\
    \ mut collisions = 0;\n        for i in 1..n {\n            let mut j = i;\n \
    \           while j > 0 && arr[j as usize] < arr[(j - 1) as usize] {\n       \
    \         collisions += 1;\n                j -= 1;\n            }\n         \
    \   arr.swap(i as usize, j as usize);\n        }\n        collisions\n    }\n\n\
    \    // Generate a random vector of n numbers in [0,n]\n    let mut rng = rand::thread_rng();\n\
    \    let mut vec: Vec<isize> = (0..n).map(|_| rng.gen_range(0, n)).collect();\n\
    \n    // The number of collisions for left-to-right cars is given by the insertion\n\
    \    // sort algorithm.\n    let left_to_right_collisions = insertion_sort_and_count_collisions(vec.clone());\n\
    \n    // The number of collisions for right-to-left cars is given by the insertion\n\
    \    // sort algorithm.\n    vec.reverse();\n    let right_to_left_collisions\
    \ = insertion_sort_and_count_collisions(vec);\n\n    left_to_right_collisions\
    \ + right_to_left_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp1lrtf8qb.rs:28:19\n   |\n28 |     let mut rng = rand::thread_rng();\n\
    \   |                   ^^^^ use of undeclared crate or module `rand`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0;\n    let mut left_cars = vec![true; n as usize];\n    let mut right_cars\
    \ = vec![true; n as usize];\n    let mut i = 0;\n    while i < n {\n        //\
    \ the cars in the ith lane will collide.\n        if left_cars[i as usize] &&\
    \ right_cars[i as usize] {\n            collisions += 1;\n            left_cars[i\
    \ as usize] = false;\n            right_cars[i as usize] = false;\n        }\n\
    \        i += 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpc3gyxv06.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // the output is n * (n-1) / 2.  The n-1 is because we\
    \ don't count the case of\n    // a car hitting itself.  The factor of 2 is because\
    \ we only count the case of\n    // a car moving to the right hitting a car moving\
    \ to the left; but the case of\n    // a car moving to the left hitting a car\
    \ moving to the right is counted\n    // separately.\n    n * (n - 1) / 2\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp1ko7k57p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpf359pjk2.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    //list of all the cars on the left lane\n    let mut\
    \ cars_left = Vec::new();\n    //list of all the cars on the right lane\n    let\
    \ mut cars_right = Vec::new();\n    //the time counter\n    let mut time = 0;\n\
    \    //the number of car collisions\n    let mut num_collisions = 0;\n\n    //first,\
    \ fill the left lane cars\n    for x in 0..n {\n        cars_left.push(x);\n \
    \   }\n    //repeat n times\n    for _i in 0..n {\n        //pop a car from the\
    \ left\n        let car_left = cars_left.pop().unwrap();\n        //pop a car\
    \ from the right\n        let car_right = cars_right.pop().unwrap();\n       \
    \ //increment the time counter\n        time += 1;\n        //check if they will\
    \ collide, if they will we increment the collision counter\n        if car_left\
    \ == car_right {\n            num_collisions += 1;\n        }\n        //otherwise,\
    \ we push the cars back to their respective lanes\n        else {\n          \
    \  cars_left.push(car_left);\n            cars_right.push(car_right);\n      \
    \  }\n    }\n    //return the number of collisions\n    num_collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpszvco5qd.rs:28:42

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    if n == 0 {\n        return 0;\n\
    \    }\n    car_race_collision_help(n as usize, n as usize, 0)\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_help` in this scope\n\
    \  --> /tmp/tmp2dzu4_28.rs:14:5\n   |\n14 |     car_race_collision_help(n as usize,\
    \ n as usize, 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    n * (n - 1)\
    \ / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvebhwn5d.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    car_race_collision_helper(&left_to_right, &right_to_left)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmptheq6il6.rs:14:5\n   |\n14 |     car_race_collision_helper(&left_to_right,\
    \ &right_to_left)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    if n == 2\
    \ {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return car_race_collision(n\
    \ - 1) + n / 2 - 1;\n    } else {\n        return car_race_collision(n - 1) +\
    \ n / 2;\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6yaovobm.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Given a vector of cars driving left to right and a\
    \ vector of cars driving right to left,\n    // return the number of collisions\n\
    \    fn count_collisions(left: &[isize], right: &[isize]) -> isize {\n       \
    \ // We have at most n cars moving in either direction, so the total number of\
    \ collisions\n        // is the minimum of n and the number of collisions between\
    \ the left and right cars.\n        // If there are more cars than min(n, m),\
    \ we only have to iterate over those, because\n        // those are the only ones\
    \ that can possibly collide.\n        let m = cmp::min(left.len(), right.len());\n\
    \        let mut collisions = 0;\n        for i in 0..m {\n            if left[i]\
    \ > right[i] {\n                collisions += 1;\n            }\n        }\n \
    \       collisions\n    }\n\n    // Given a vector of cars driving left to right\
    \ and a vector of cars driving right to left,\n    // return a tuple containing\
    \ the vectors of cars that survived the collision\n    fn resolve_collisions(left:\
    \ &[isize], right: &[isize]) -> (Vec<isize>, Vec<isize>) {\n        let mut i\
    \ = 0;\n        let mut j = 0;\n        let mut a = Vec::new();\n        let mut\
    \ b = Vec::new();\n        while i < left.len() && j < right.len() {\n       \
    \     // If there is a collision, only push the slower car\n            if left[i]\
    \ > right[j] {\n                a.push(left[i]);\n            } else {\n     \
    \           b.push(right[j]);\n            }\n            i += 1;\n          \
    \  j += 1;\n        }\n        // Once we pass the end of one of the vectors,\
    \ we just push the rest of the other\n        while i < left.len() {\n       \
    \     a.push(left[i]);\n            i += 1;\n        }\n        while j < right.len()\
    \ {\n            b.push(right[j]);\n            j += 1;\n        }\n        (a,\
    \ b)\n    }\n\n    // If there are no cars, there are no collisions\n    if n\
    \ == 0 {\n        return 0;\n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3ao9lo62.rs:69:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n57 |     if n == 0 {\n  \
    \ |               - this delimiter might not be properly closed...\n...\n60 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n69 |\
    \ }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmp3ao9lo62.rs:17:17\n   |\n17 |         let m = cmp::min(left.len(),\
    \ right.len());\n   |                 ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp3ao9lo62.rs:9:36\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    return n * (n - 1) / 2;\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmphne8sf0t.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo3ckj1g7.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    let car_set = [0..n].iter().filter(|&&x|\
    \ x % 2 == 0).map(|&x| x).collect::<Vec<isize>>();\n    let mut prev_right_car_pos\
    \ = 0;\n    let mut prev_left_car_pos = 0;\n    for i in (0..n).rev() {\n    \
    \    let this_right_car_pos = i / 2;\n        let this_left_car_pos = i - this_right_car_pos;\n\
    \        if this_right_car_pos > prev_right_car_pos {\n            prev_right_car_pos\
    \ = this_right_car_pos;\n        }\n        if this_left_car_pos > prev_left_car_pos\
    \ {\n            prev_left_car_pos = this_left_car_pos;\n        }\n        if\
    \ prev_right_car_pos > prev_left_car_pos {\n            result += 1;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `std::ops::Range<isize>` by `{integer}`\n  -->\
    \ /tmp/tmpllvf3lg8.rs:11:48\n   |\n11 |     let car_set = [0..n].iter().filter(|&&x|\
    \ x % 2 == 0).map(|&x| x).collect::<Vec<isize>>();\n   |                     \
    \                         - ^ - {integer}\n   |                              \
    \                |\n   |                                              std::ops::Range<isize>\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `std::ops::Range<isize>`\n    --> /tmp/tmpllvf3lg8.rs:11:70\n\
    \     |\n11   |     let car_set = [0..n].iter().filter(|&&x| x % 2 == 0).map(|&x|\
    \ x).collect::<Vec<isize>>();\n     |                                        \
    \                              ^^^^^^^ value of type `Vec<isize>` cannot be built\
    \ from `std::iter::Iterator<Item=std::ops::Range<isize>>`\n     |\n     = help:\
    \ the trait `FromIterator<std::ops::Range<isize>>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // approach: see the line of the road as a y=0 line in\
    \ 2d space, and the cars as 1d\n    // lines in 2d space.  Then, a line_line intersection\
    \ is a sign of a collision.\n    // An algorithm to find all such intersections\
    \ would require O(n^2) operations.\n    // However, we can do this in O(n lg n)\
    \ time using divide and conquer:\n    // 1. sort the cars by x-coordinate; this\
    \ takes O(n lg n) time\n    // 2. partition them into two halves\n    // 3. recursively\
    \ compute the number of collisions within each half; this takes\n    //    O(n)\
    \ time, because the cars are sorted by x-coordinate.\n    // 4. combine the results\n\
    \    let mut cars = vec![];\n    // Generate n cars with random start positions.\n\
    \    for _ in 0..n {\n        cars.push(Car::random());\n    }\n    // Sort the\
    \ cars by start position.\n    cars.sort_by(|a, b| a.x.partial_cmp(&b.x).unwrap());\n\
    \    count_collisions(&cars, n)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpcs2zkdma.rs:22:19\n\
    \   |\n22 |         cars.push(Car::random());\n   |                   ^^^ use\
    \ of undeclared type `Car`\n\nerror[E0425]: cannot find function `count_collisions`\
    \ in this scope\n  --> /tmp/tmpcs2zkdma.rs:26:5\n   |\n26 |     count_collisions(&cars,\
    \ n)\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field\
    \ `x` on type `&_`\n  --> /tmp/tmpcs2zkdma.rs:25:27\n   |\n25 |     cars.sort_by(|a,\
    \ b| a.x.partial_cmp(&b.x).unwrap());\n   |                           ^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // First, convert the given number of cars into a binary\
    \ number whose digits are 1s\n    // For example, if n = 7, then the binary number\
    \ would be \"1111\" (and not \"111\")\n    let mut num_cars = n;\n    let mut\
    \ cars = String::new();\n    loop {\n        if num_cars % 2 == 1 {\n        \
    \    cars.push('1');\n        } else {\n            cars.push('0');\n        }\n\
    \        num_cars /= 2;\n        if num_cars == 0 {\n            break;\n    \
    \    }\n    }\n    cars = cars.chars().rev().collect();\n\n    // Then, run a\
    \ collision simulation.\n    let mut num_collisions = 0;\n    for (i, car) in\
    \ cars.chars().enumerate() {\n        if car == '1' {\n            num_collisions\
    \ += i as isize;\n        }\n    }\n    num_collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpa_8dcmgf.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let left = (0..n).map(|_| rand::random::<f64>()).collect::<Vec<f64>>();\n\
    \    let right = (0..n).map(|_| rand::random::<f64>()).collect::<Vec<f64>>();\n\
    \    let mut cnt = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left[i] > right[j] {\n                cnt += 1;\n            }\n     \
    \   }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpepx91ghs.rs:10:31\n   |\n10 |     let left = (0..n).map(|_| rand::random::<f64>()).collect::<Vec<f64>>();\n\
    \   |                               ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpepx91ghs.rs:11:32\n   |\n11 |     let right = (0..n).map(|_| rand::random::<f64>()).collect::<Vec<f64>>();\n\
    \   |                                ^^^^ use of undeclared crate or module `rand`\n\
    \nerror[E0277]: the type `[f64]` cannot be indexed by `isize`\n  --> /tmp/tmpepx91ghs.rs:15:16\n\
    \   |\n15 |             if left[i] > right[j] {\n   |                ^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[f64]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpepx91ghs.rs:15:26\n   |\n15 |  \
    \           if left[i] > right[j] {\n   |                          ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[f64]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<f64>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_cars: HashSet<isize> = HashSet::new();\n\
    \    let mut right_cars: HashSet<isize> = HashSet::new();\n    let mut curr =\
    \ 1;\n    while left_cars.len() < n as usize {\n        left_cars.insert(curr);\n\
    \        curr += 1;\n    }\n    curr = -1;\n    while right_cars.len() < n as\
    \ usize {\n        right_cars.insert(curr);\n        curr -= 1;\n    }\n    let\
    \ mut collision = 0;\n    for car in &left_cars {\n        if right_cars.contains(car)\
    \ {\n            collision += 1;\n        }\n    }\n    collision\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4v3x7eur.rs:10:24\n\
    \   |\n10 |     let mut left_cars: HashSet<isize> = HashSet::new();\n   |    \
    \                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp4v3x7eur.rs:10:41\n\
    \   |\n10 |     let mut left_cars: HashSet<isize> = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4v3x7eur.rs:11:25\n\
    \   |\n11 |     let mut right_cars: HashSet<isize> = HashSet::new();\n   |   \
    \                      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp4v3x7eur.rs:11:42\n\
    \   |\n11 |     let mut right_cars: HashSet<isize> = HashSet::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    if n % 2 ==\
    \ 0 {\n        return n / 2 * (n - 1);\n    }\n    (n / 2) * (n - 1) + n / 2 +\
    \ 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmut_v9z7.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in n..i {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpx6vk4fzd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    for i in 1..=n {\n \
    \       for j in 1..=n {\n            if j > i {\n                num_collisions\
    \ += 1;\n            }\n        }\n    }\n    num_collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnqweklj6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..n {\n      \
    \  collisions += i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpebar_5kx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).map(|x| 2 * x - 1).sum()\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnhqin00t.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            if i > j {\n                c += 1;\n            }\n   \
    \     }\n    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpa7bgvva7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    let mut cars_left = (0..n).map(|i|\
    \ Car { pos: n as isize + i as isize }).collect::<Vec<_>>();\n    let mut cars_right\
    \ = (0..n).map(|i| Car { pos: i as isize }).collect::<Vec<_>>();\n    let mut\
    \ car_cnt = 0;\n    while !cars_left.is_empty() {\n        car_cnt += cars_left.iter().map(|car|\
    \ {\n            let idx = cars_right.iter().position(|c| c.pos == car.pos).unwrap();\n\
    \            cars_right.remove(idx);\n            idx\n        }).collect::<Vec<_>>();\n\
    \        cars_left.drain(..).for_each(|car| car.pos += 1);\n    }\n    car_cnt\
    \ as isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0422]: cannot find struct, variant or union type `Car` in this scope\n\
    \  --> /tmp/tmpy7b7hfnr.rs:11:40\n   |\n11 |     let mut cars_left = (0..n).map(|i|\
    \ Car { pos: n as isize + i as isize }).collect::<Vec<_>>();\n   |           \
    \                             ^^^ not found in this scope\n\nerror[E0422]: cannot\
    \ find struct, variant or union type `Car` in this scope\n  --> /tmp/tmpy7b7hfnr.rs:12:41\n\
    \   |\n12 |     let mut cars_right = (0..n).map(|i| Car { pos: i as isize }).collect::<Vec<_>>();\n\
    \   |                                         ^^^ not found in this scope\n\n\
    error[E0609]: no field `pos` on type `&_`\n  --> /tmp/tmpy7b7hfnr.rs:16:56\n \
    \  |\n16 |             let idx = cars_right.iter().position(|c| c.pos == car.pos).unwrap();\n\
    \   |                                                        ^^^\n\nerror[E0609]:\
    \ no field `pos` on type `&_`\n  --> /tmp/tmpy7b7hfnr.rs:16:67\n   |\n16 |   \
    \          let idx = cars_right.iter().position(|c| c.pos == car.pos).unwrap();\n\
    \   |                                                                   ^^^\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0422, E0609.\nFor more information about an error, try `rustc --explain E0422`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // WRITE YOUR CODE HERE!\n    let left_side = n;\n  \
    \  let right_side = n;\n    let collisions = n - n.min(n);\n    println!(\"{}\"\
    , collisions);\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpz6bokdnk.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '0

    '
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    use std::cmp::{min, max};\n    let mut res = 0;\n   \
    \ for i in 1..n {\n        res += max(0, (n - i) * i);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2sc5_rj1.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = HashSet::<isize>::new();\n  \
    \  let mut right_to_left = HashSet::<isize>::new();\n    for x in 1..n + 1 {\n\
    \        left_to_right.insert(x);\n        right_to_left.insert(-x);\n    }\n\
    \    loop {\n        let mut left_to_right_clone = left_to_right.clone();\n  \
    \      let mut right_to_left_clone = right_to_left.clone();\n        let mut moved_left_to_right\
    \ = HashSet::<isize>::new();\n        let mut moved_right_to_left = HashSet::<isize>::new();\n\
    \        let mut collided = 0;\n        for x in left_to_right_clone {\n     \
    \       if right_to_left_clone.contains(&(x + 1)) {\n                collided\
    \ += 1;\n            } else {\n                moved_left_to_right.insert(x +\
    \ 1);\n            }\n        }\n        for x in right_to_left_clone {\n    \
    \        if left_to_right_clone.contains(&(x - 1)) {\n                collided\
    \ += 1;\n            } else {\n                moved_right_to_left.insert(x -\
    \ 1);\n            }\n        }\n        if left_to_right == moved_left_to_right\
    \ && right_to_left == moved_right_to_left {\n            return collided;\n  \
    \      }\n        left_to_right = moved_left_to_right;\n        right_to_left\
    \ = moved_right_to_left;\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpm3fo5h67.rs:10:29\n   |\n10 |     let mut left_to_right = HashSet::<isize>::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpm3fo5h67.rs:11:29\n   |\n11 |     let mut right_to_left = HashSet::<isize>::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpm3fo5h67.rs:19:39\n   |\n19 |         let mut moved_left_to_right\
    \ = HashSet::<isize>::new();\n   |                                       ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpm3fo5h67.rs:20:39\n   |\n20\
    \ |         let mut moved_right_to_left = HashSet::<isize>::new();\n   |     \
    \                                  ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    if n % 2 ==\
    \ 0 {\n        return n / 2;\n    }\n    (n / 2) + 1\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxk4whof3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // your code here\n    let mut cars: Vec<(isize, isize)>\
    \ = Vec::new();\n    for i in 1..=n {\n        cars.push((i, 1));\n        cars.push((-i,\
    \ 0));\n    }\n    cars.sort_by(|a, b| {\n        if a.0 != b.0 {\n          \
    \  return a.0.cmp(&b.0);\n        }\n        return a.1.cmp(&b.1);\n    });\n\
    \    let mut total = 0;\n    let mut last_car = cars[0];\n    for i in 1..cars.len()\
    \ {\n        if cars[i].0 == last_car.0 && cars[i].1 != last_car.1 {\n       \
    \     total += 1;\n        }\n        last_car = cars[i];\n    }\n    total\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmppm8of4ch.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut\
    \ right_to_left: Vec<isize> = Vec::new();\n    let mut i = 0;\n    let mut k =\
    \ 0;\n    while i < n {\n        i += 1;\n        if i % 2 == 0 {\n          \
    \  stack.push(i);\n        } else {\n            right_to_left.push(i);\n    \
    \    }\n    }\n    // check for collisions\n    i = 0;\n    k = 0;\n    while\
    \ i < stack.len() && k < right_to_left.len() {\n        if stack[i] < right_to_left[k]\
    \ {\n            i += 1;\n        } else {\n            k += 1;\n        }\n \
    \   }\n    let collisions = i as isize;\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd01_47oi.rs:25:15\n   |\n\
    25 |     while i < stack.len() && k < right_to_left.len() {\n   |            \
    \   ^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n25\
    \ |     while i < stack.len().try_into().unwrap() && k < right_to_left.len() {\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpd01_47oi.rs:26:12\n  \
    \ |\n26 |         if stack[i] < right_to_left[k] {\n   |            ^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut track = Track::new(n);\n    for _ in 0..n {\n\
    \        track.add_left_to_right_car();\n        track.add_right_to_left_car();\n\
    \    }\n    track.get_collision_count()\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Track`\n  -->\
    \ /tmp/tmp51_ub1za.rs:10:21\n   |\n10 |     let mut track = Track::new(n);\n \
    \  |                     ^^^^^ use of undeclared type `Track`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, 0)\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpgxbb_38s.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut nums = Vec::new();\n\
    \    let mut nums_left = Vec::new();\n    for i in 0..n {\n        nums.push(i);\n\
    \        nums_left.push(i + 1);\n    }\n    nums.sort();\n    nums_left.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if\
    \ nums[i as usize] < nums_left[j as usize] {\n            result += j;\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n    }\n   \
    \ result += n * (n - 1) / 2 - n * i + i * (i - 1) / 2;\n    result\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `4`', /tmp/tmp936wwfvd.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut a\
    \ = vec![0; n as usize];\n    let mut b = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        a[i as usize] = i;\n        b[i as usize] = -i;\n    }\n    merge_sort(&mut\
    \ a);\n    merge_sort(&mut b);\n    count_collisions(&a, &b)\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmpjc1i0_tw.rs:19:5\n\
    \   |\n19 |     merge_sort(&mut a);\n   |     ^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmpjc1i0_tw.rs:20:5\n\
    \   |\n20 |     merge_sort(&mut b);\n   |     ^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `count_collisions` in this scope\n  --> /tmp/tmpjc1i0_tw.rs:21:5\n\
    \   |\n21 |     count_collisions(&a, &b)\n   |     ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // There are n cars going in the same direction,\n  \
    \  // each one of them collides with n-1 cars.\n    // So, there are n * (n-1)\
    \ collisions.\n    // The cars that go in different directions do not collide\
    \ with each other\n    // because they are offset.\n    n * (n - 1)\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxot9cky2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = (0..n).rev().collect::<Vec<isize>>();\n    let mut right_to_left = (0..n).collect::<Vec<isize>>();\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() {\n        let\
    \ left_car = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            collisions += 1;\n        } else\
    \ {\n            left_to_right.push(left_car);\n            right_to_left.push(right_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977903
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    // I didn't bother with checking\
    \ overflow, but if you don't trust me,\n    // you can also memoize car_race_collision\
    \ and return\n    // car_race_collision(n/2) + car_race_collision(n - n/2) + n\n\
    \    (n * (n + 1)) / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpyc5gx3ti.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp9koibpaz.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut count\
    \ = 1;\n    let mut log = 0;\n    let mut c = n;\n    while c > 1 {\n        count\
    \ += c;\n        log += 1;\n        c /= 2;\n    }\n    count + ((n - 2).pow(log\
    \ as u32))\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpnmagcceu.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    return n *\
    \ (n - 1) / 2;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppscpl8fh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    n * n\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut d = BinaryHeap::new();\n    for c in 0..n {\n\
    \        d.push(c);\n    }\n    for c in 0..n {\n        d.push(-c);\n    }\n\
    \    let mut count = 0;\n    while let Some(x) = d.pop() {\n        if x > 0 {\n\
    \            while d.peek() == Some(&-x) {\n                d.pop();\n       \
    \         count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n\
    \  --> /tmp/tmpxdozaocb.rs:10:17\n   |\n10 |     let mut d = BinaryHeap::new();\n\
    \   |                 ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BinaryHeap;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n + 1 {\n       \
    \ count += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp42dgqod0.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // This is a typical divide-and-conquer problem.   On\
    \ every iteration,\n    // we split the problem into two halves, solve each half\n\
    \    // as a separate recursion, and then combine the results.\n    //\n    //\
    \ The base case is when there are 0 cars on the road.   In this case\n    // the\
    \ number of collisions is 0.\n    if n == 0 {\n        return 0;\n    }\n\n  \
    \  // Divide the problem in half.   Note that if n is odd, then\n    // n / 2\
    \ will actually slightly overestimate the number of cars\n    // that are on the\
    \ road.   But this does not matter for the correctness\n    // of the solution.\n\
    \    let left_to_right = car_race_collision(n / 2);\n    let right_to_left = car_race_collision(n\
    \ / 2);\n\n    // When a car from the left side collides with a car from the right\
    \ side,\n    // it is equivalent to a car from the left side colliding with a\
    \ car from\n    // the left side, but that car is now shifted by n / 2.   There\
    \ are exactly\n    // n / 2 such cars.   Hence, the result of this recursion is\
    \ to add\n    // n / 2 to the result of solving the left side of the problem.\n\
    \    left_to_right + right_to_left + n / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz36oxc8q.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            if j > i {\n                c += 1;\n            }\n   \
    \     }\n    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpcjydge6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    // for a set\
    \ of n cars going in the same direction, there are (n-1) times\n    // of collision\
    \ (considering the cars as points on a line).\n    // If a car was going the opposite\
    \ direction, its collision with the ith car\n    // would be counted by (n-i-1).\
    \  So the total number of collisions is\n    // 2*(n-1) + 2*(n-2) + 2*(n-3) +\
    \ ... + 2*2 + 2*1\n    // = 2*n*(n-1)\n    return 2 * n * (n - 1);\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `9`', /tmp/tmp62sgyc61.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        let a = (i as f64) * 0.5;\n    \
    \    let b = (i as f64) * (-0.3);\n        left_to_right.push(a);\n        right_to_left.push(b);\n\
    \    }\n    let mut collided = 0;\n    for i in 0..n {\n        for j in 0..n\
    \ {\n            if left_to_right[i as usize] <= right_to_left[j as usize] {\n\
    \                collided += 1;\n            }\n        }\n    }\n    collided\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpkrd10jm9.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Returns the number of collisions for cars moving in\
    \ opposite directions.\n    // Assume that each car is moving at a constant non-zero\
    \ speed.\n    // Assume that there are infinitely many cars.\n    let left_bound_car_index\
    \ = -(n - 1);\n    let right_bound_car_index = n - 1;\n    let mut right_to_left_car_position\
    \ = right_bound_car_index;\n    let mut left_to_right_car_position = left_bound_car_index;\n\
    \    let mut num_collisions = 0;\n    while right_to_left_car_position > left_to_right_car_position\
    \ {\n        while left_to_right_car_position < right_to_left_car_position {\n\
    \            left_to_right_car_position += 1;\n        }\n        num_collisions\
    \ += 1;\n        right_to_left_car_position -= 1;\n    }\n    return num_collisions;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprxn858ue.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut i = 1;\n    while i <=\
    \ n {\n        count += (i - 1) * 2;\n        i += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdu1trge.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    else if n\
    \ == 1 {\n        return 1;\n    }\n    else {\n        let mut s = 0;\n     \
    \   for i in 2..(n+1) {\n            s += i;\n        }\n        return s;\n \
    \   }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_v3kx930.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // current coordinate for left-to-right moving cars\n\
    \    let mut c0 = 0;\n    // current coordinate for right-to-left moving cars\n\
    \    let mut c1 = n - 1;\n    // count of cars that have moved out of the n-cell\
    \ road\n    let mut count = 0;\n    // count of collisions\n    let mut collisions\
    \ = 0;\n    loop {\n        // if the two cars are at the same position\n    \
    \    if c0 == c1 {\n            // increment the count of collisions\n       \
    \     collisions += 1;\n        }\n        // advance the left-to-right moving\
    \ car by one cell\n        c0 += 1;\n        // this car is now out of road; increment\
    \ the count of cars that have\n        // moved out of the n-cell road\n     \
    \   if c0 == n {\n            count += 1;\n        }\n        // advance the right-to-left\
    \ moving car by one cell\n        c1 -= 1;\n        // this car is now out of\
    \ road; increment the count of cars that have\n        // moved out of the n-cell\
    \ road\n        if c1 == -1 {\n            count += 1;\n        }\n        //\
    \ we are done when all the cars have moved out of the n-cell road\n        if\
    \ count == 2 * n {\n            break;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977903
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    if n == 1\
    \ {\n        return 0;\n    }\n    // Number of cars driving right to left is\
    \ n-1, because the rightmost car\n    // is driving left to right.\n    n - 1\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8c_rdo5m.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    let mut left_to_right = [0usize;\
    \ 100000];\n    let mut right_to_left = [0usize; 100000];\n    for i in 0..n {\n\
    \        let position = i * 10;\n        left_to_right[position] += 1;\n     \
    \   right_to_left[99999 - position] += 1;\n    }\n    let mut count = 0;\n   \
    \ for (left, right) in left_to_right.iter().zip(right_to_left.iter()) {\n    \
    \    count += left * right;\n    }\n    count as isize\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpcqe3u30w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Imagine a line with two x-coordinates at each end\
    \ of the line;\n    // this line is -infinity to +infinity long.\n    // A car\
    \ driving left to right has a x coordinate that's increasing, and\n    // a car\
    \ driving right to left has a x coordinate that's decreasing.\n    // To make\
    \ it easier to keep track of, we will use the absolute value of\n    // the car\
    \ position.  Cars driving left to right will have positive x coordinates,\n  \
    \  // and cars driving right to left will have negative x coordinates.\n    //\
    \ We will keep track of cars using a sorted vector,\n    // where the elements\
    \ are the car's x coordinates in increasing order.\n    // We will have two vectors:\n\
    \    // cars_left_to_right keeps track of the cars that are driving left to right,\n\
    \    // and cars_right_to_left keeps track of the cars that are driving right\
    \ to left.\n    // Whenever a car reaches the end of the line (x coordinate is\
    \ +infinity for\n    // a car driving left to right, and -infinity for a car driving\
    \ right to left),\n    // it disappears; we will remove it from the vector.\n\n\
    \    // For example, if there are 3 cars driving left to right and 2 cars driving\
    \ right to left,\n    // and each car is at x coordinate 10, then cars_left_to_right\
    \ is [10, 10, 10],\n    // and cars_right_to_left is [-10, -10].\n    // Now imagine\
    \ the 5 cars continue moving at the same speed,\n    // and the leftmost car reaches\
    \ the end of the line.\n    // Then the cars_left_to_right becomes [10, 10],\n\
    \    // and the cars_right_to_left becomes [-10, -10].\n    // What happens to\
    \ the leftmost car?  It disappears.\n\n    // Now, at what point will a collision\
    \ happen?\n    // The leftmost car will collide with the rightmost car if they\
    \ are in the same position.\n    // If there are no collisions, then how can the\
    \ cars move?\n    // The rightmost car can never move to the left, and the leftmost\
    \ car can never move to the right.\n    // So when a car collides with another\
    \ car, the car will move to the same position as\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpqlovbjkd.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    // Assume\
    \ cars are moving in the range [start, end]\n    let mut start = -1;\n    let\
    \ mut end = n;\n    let mut collisions = 0;\n\n    while start + 1 < end {\n \
    \       let mid = (start + end) / 2;\n        // Case 1: Collision\n        if\
    \ mid >= 0 {\n            collisions += n - mid;\n            start = mid;\n \
    \       }\n        // Case 2: No collision\n        else {\n            end =\
    \ mid;\n        }\n    }\n\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpm_nz8z87.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    for x in 1..n + 1 {\n\
    \        for y in 1..n + 1 {\n            if x % y == 0 {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5i4pmt3r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n+1).sum()\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpu51afvk0.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp9koibpaz.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_start_left: Vec<isize> = Vec::new();\n \
    \   let mut cars_start_right: Vec<isize> = Vec::new();\n    for car in 0..n {\n\
    \        cars_start_left.push(car);\n        cars_start_right.push(n - car - 1);\n\
    \    }\n    let mut collisions = 0;\n    while cars_start_left.len() > 0 && cars_start_right.len()\
    \ > 0 {\n        // While we have cars traveling in each direction...\n      \
    \  let left_car = cars_start_left.pop().unwrap();\n        let right_car = cars_start_right.pop().unwrap();\n\
    \        if left_car > right_car {\n            // The left car overtook the right\
    \ car\n            collisions += 1;\n        } else {\n            // The right\
    \ car overtook the left car.\n            // Put the cars back into their lineups,\
    \ at the end of their lines.\n            cars_start_left.push(left_car);\n  \
    \          cars_start_right.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977903
- exit_code: 0
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    let mut left_to_right = vec![false;\
    \ n];\n    let mut right_to_left = vec![false; n];\n    let mut left_count = 0;\n\
    \    let mut right_count = 0;\n    let mut count = 0;\n    for i in 0..n {\n \
    \       left_to_right[i] = true;\n        if right_to_left[i] {\n            count\
    \ += 1;\n        }\n        if left_count != i {\n            break;\n       \
    \ }\n        left_count += 1;\n        for j in 0..i {\n            if left_to_right[j]\
    \ {\n                count += 1;\n            }\n        }\n        for j in (i\
    \ + 1)..n {\n            if right_to_left[j] {\n                count += 1;\n\
    \            }\n        }\n        right_to_left[i] = true;\n        if left_to_right[i]\
    \ {\n            count += 1;\n        }\n        if right_count != i {\n     \
    \       break;\n        }\n        right_count += 1;\n        for j in 0..i {\n\
    \            if right_to_left[j] {\n                count += 1;\n            }\n\
    \        }\n        for j in (i + 1)..n {\n            if left_to_right[j] {\n\
    \                count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    return (n as f64 * (n - 1) as f64 / 2 as f64) as isize;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmph6dt18jw.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut m = 0;\n    let mut left = 0;\n    let mut right\
    \ = 0;\n    while left < n || right < n {\n        if left < n {\n           \
    \ left += 1;\n        }\n        if right < n {\n            right += 1;\n   \
    \     }\n        if left == right {\n            m += 1;\n        }\n    }\n \
    \   m\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp773fgda0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: HashSet<isize> = HashSet::new();\n\
    \    let mut right_to_left: HashSet<isize> = HashSet::new();\n    for x in 0..n\
    \ {\n        left_to_right.insert(x);\n        right_to_left.insert(-x);\n   \
    \ }\n    let mut collision = 0;\n    for x in 0..n {\n        // collision if\
    \ left car is at same location as right car\n        if left_to_right.contains(&x)\
    \ && right_to_left.contains(&-x) {\n            collision += 1;\n        }\n \
    \       left_to_right.remove(&x);\n        right_to_left.remove(&-x);\n    }\n\
    \    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnf80qjbg.rs:10:28\n\
    \   |\n10 |     let mut left_to_right: HashSet<isize> = HashSet::new();\n   |\
    \                            ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnf80qjbg.rs:10:45\n\
    \   |\n10 |     let mut left_to_right: HashSet<isize> = HashSet::new();\n   |\
    \                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpnf80qjbg.rs:11:28\n\
    \   |\n11 |     let mut right_to_left: HashSet<isize> = HashSet::new();\n   |\
    \                            ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnf80qjbg.rs:11:45\n\
    \   |\n11 |     let mut right_to_left: HashSet<isize> = HashSet::new();\n   |\
    \                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Initialize left_car[i] to the location of the ith\
    \ car\n    // moving left to right\n    let mut left_car = Vec::with_capacity(n\
    \ as usize);\n    for i in 0..n {\n        left_car.push(i);\n    }\n\n    //\
    \ Initialize right_car[i] to the location of the ith car\n    // moving right\
    \ to left\n    let mut right_car = Vec::with_capacity(n as usize);\n    for i\
    \ in 0..n {\n        right_car.push(i);\n    }\n\n    // At each step, move each\
    \ car one step forward.  Check for collisions\n    // and count them.\n    let\
    \ mut num_collisions = 0;\n    for _ in 0..n {\n        for i in 0..n {\n    \
    \        left_car[i as usize] += 1;\n            right_car[i as usize] -= 1;\n\
    \            if left_car[i as usize] == right_car[i as usize] {\n            \
    \    num_collisions += 1;\n            }\n        }\n    }\n    num_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpii9c0efo.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<bool> = vec![true; n as usize];\n    let mut right_to_left: Vec<bool> =\
    \ vec![false; n as usize];\n    let mut count = 0;\n    while !(left_to_right.is_empty()\
    \ && right_to_left.is_empty()) {\n        count += (left_to_right.len() as isize)\
    \ * (right_to_left.len() as isize);\n        let mut updated_left_to_right: Vec<bool>\
    \ = vec![];\n        let mut updated_right_to_left: Vec<bool> = vec![];\n    \
    \    for car in left_to_right {\n            if car {\n                updated_left_to_right.push(true);\n\
    \            }\n        }\n        for car in right_to_left {\n            if\
    \ !car {\n                updated_right_to_left.push(false);\n            }\n\
    \        }\n        left_to_right = updated_left_to_right;\n        right_to_left\
    \ = updated_right_to_left;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977903
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..n {\n      \
    \  collisions += i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpebar_5kx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut v\
    \ = vec![true; (n * 2) as usize];\n    let mut c = 0;\n    for i in 0..n {\n \
    \       let mut j = i + 1;\n        while j < n {\n            if !v[(j + n) as\
    \ usize] {\n                c += 1;\n            }\n            v[(j + n) as usize]\
    \ = false;\n            j += 1;\n        }\n    }\n    c\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpjl8m1myy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_naive(n)\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_naive` in this scope\n\
    \  --> /tmp/tmp33cu0dra.rs:10:5\n   |\n10 |     car_race_collision_naive(n)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for x in 0..n {\n      \
    \  for y in 0..n {\n            if x == y {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa0fyiy0r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpv9nwnrje.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We will use a union find data structure.\n    let\
    \ mut uf = UnionFind::new(2 * n);\n    // This will store the cars that are driving\
    \ left to right.\n    let mut left_cars = Vec::new();\n    // This will store\
    \ the cars that are driving right to left.\n    let mut right_cars = Vec::new();\n\
    \    // We will store the collisions here.\n    let mut collisions = 0;\n    //\
    \ We will create 2 * n cars, with indices 0..2 * n - 1.\n    for index in 0..2\
    \ * n {\n        // We randomly set this car to be either left-going or right-going.\n\
    \        if rand::random() {\n            // This car will be left-going.\n  \
    \          left_cars.push(index);\n        } else {\n            // This car will\
    \ be right-going.\n            right_cars.push(index);\n        }\n    }\n   \
    \ // We set up the cars to be in their starting positions.\n    for i in 0..n\
    \ {\n        // We put the left-going cars at position -i and the right-going\
    \ cars at position n + i.\n        uf.union(left_cars[i as usize], right_cars[i\
    \ as usize]);\n    }\n    // We keep simulating until all the cars have crashed.\n\
    \    while !left_cars.is_empty() {\n        // We randomly pick a car that's left-going.\n\
    \        let left_index = left_cars[rand::random::<usize>() % left_cars.len()];\n\
    \        // We randomly pick a car that's right-going.\n        let right_index\
    \ = right_cars[rand::random::<usize>() % right_cars.len()];\n        // We check\
    \ whether these two cars have already collided.\n        if uf.find(left_index)\
    \ != uf.find(right_index) {\n            // These two cars have not collided.\n\
    \            // Therefore, this is a new collision.\n            collisions +=\
    \ 1;\n            // We union the two cars, so they will be considered as one.\n\
    \            uf.union(left_index, right_index);\n        }\n        // We move\
    \ the left-going car forward by one\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl1c0vot_.rs:58:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n35 |     while !left_cars.is_empty()\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n49 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n58 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `UnionFind`\n  --> /tmp/tmpl1c0vot_.rs:11:18\n   |\n11 |     let mut uf = UnionFind::new(2\
    \ * n);\n   |                  ^^^^^^^^^ use of undeclared type `UnionFind`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n  -->\
    \ /tmp/tmpl1c0vot_.rs:21:12\n   |\n21 |         if rand::random() {\n   |    \
    \        ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpl1c0vot_.rs:37:36\n\
    \   |\n37 |         let left_index = left_cars[rand::random::<usize>() % left_cars.len()];\n\
    \   |                                    ^^^^ use of undeclared crate or module\
    \ `rand`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `rand`\n  --> /tmp/tmpl1c0vot_.rs:39:38\n   |\n39 |         let right_index\
    \ = right_cars[rand::random::<usize>() % right_cars.len()];\n   |            \
    \                          ^^^^ use of undeclared crate or module `rand`\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpl1c0vot_.rs:9:36\n  |\n9 | fn car_race_collision(n:\
    \ isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`,\
    \ found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let mut sum\
    \ = 1;\n    let mut i = 3;\n    while i <= n {\n        sum += i - 1;\n      \
    \  i += 1;\n    }\n    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpzkt3ul1t.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Given two cars, car i moving left to right and car\
    \ j moving right to left,\n    // their path will intersect at (i + j) * (n -\
    \ 1).  Furthermore, they'll intersect\n    // at that point twice.  We count those\
    \ intersections by summing all the divisors\n    // of (i + j) * (n - 1).\n  \
    \  let mut count = 0;\n    for i in 1..n + 1 {\n        for j in 1..n + 1 {\n\
    \            let t = (i + j) * (n - 1);\n            for d in 1..t + 1 {\n   \
    \             if t % d == 0 {\n                    count += 1;\n             \
    \   }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `4`', /tmp/tmpp9ngwpci.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    // the number\
    \ of collisions of the left-to-right cars is the number of cars moving\n    //\
    \ in the opposite direction.  The total number of collisions is the sum of the\n\
    \    // collisions of the cars moving in both directions.\n    return car_race_collision(n\
    \ - 1) + n;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp_i8u3iph.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = Vec::new();\n    let mut\
    \ cars_right_to_left = Vec::new();\n    for i in 0..n {\n        let car_left_to_right\
    \ = Car {\n            location: i,\n            velocity: 1,\n        };\n  \
    \      cars_left_to_right.push(car_left_to_right);\n        let car_right_to_left\
    \ = Car {\n            location: -i,\n            velocity: -1,\n        };\n\
    \        cars_right_to_left.push(car_right_to_left);\n    }\n    let mut collision_count\
    \ = 0;\n    while cars_left_to_right.len() > 0 && cars_right_to_left.len() > 0\
    \ {\n        let left_to_right_car = cars_left_to_right.pop().unwrap();\n    \
    \    let right_to_left_car = cars_right_to_left.pop().unwrap();\n        if left_to_right_car.location\
    \ == right_to_left_car.location {\n            collision_count += 1;\n       \
    \ } else if left_to_right_car.location > right_to_left_car.location {\n      \
    \      cars_left_to_right.push(left_to_right_car);\n            cars_right_to_left.push(right_to_left_car);\n\
    \        } else {\n            cars_left_to_right.push(left_to_right_car);\n \
    \           cars_right_to_left.push(right_to_left_car);\n        }\n    }\n  \
    \  collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0422]: cannot find struct, variant or union type `Car` in this scope\n\
    \  --> /tmp/tmp9dhsnx5w.rs:13:33\n   |\n13 |         let car_left_to_right = Car\
    \ {\n   |                                 ^^^ not found in this scope\n\nerror[E0422]:\
    \ cannot find struct, variant or union type `Car` in this scope\n  --> /tmp/tmp9dhsnx5w.rs:18:33\n\
    \   |\n18 |         let car_right_to_left = Car {\n   |                      \
    \           ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0422`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n - n.min(64)\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp0txvi560.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We do not need to simulate the entire race; it suffices\
    \ to determine the point where the\n    // two sets of cars meet.\n    // Note:\
    \ there may be several solutions; this function will return the smallest one.\n\
    \    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp62t3ffm8.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    return (n\
    \ * (n - 1)) / 2;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvpjh5rzt.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpmgtedu6s.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Edge case\n    if n <= 0 {\n        return 0;\n  \
    \  }\n\n    // There are always n cars heading left to right,\n    // and n cars\
    \ heading right to left, which means\n    // there can only be a collision if\
    \ one set of cars\n    // has a car at the same index as the other set of cars.\n\
    \    // This can only happen (n + 1) / 2 times.\n    if n % 2 == 0 {\n       \
    \ return n / 2;\n    } else {\n        return (n + 1) / 2;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpb7krav_a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // dp[n] = 0\n    // dp[n+1] = dp[n] + n\n    // dp[n+2]\
    \ = dp[n+1] + n\n    // dp[n+3] = dp[n+2] + n\n    // dp[n+4] = dp[n+3] + n\n\
    \    // ...\n    // dp[2n] = 2n\n    // dp[2n+1] = 2n\n    // dp[2n+2] = 2n\n\
    \    // ...\n    let mut dp = vec![0; n as usize + 2];\n    for i in 1..dp.len()\
    \ {\n        dp[i] = dp[i - 1] + (i as isize);\n    }\n    dp[dp.len() - 1]\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `4`', /tmp/tmpff8y3oro.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    let q =\
    \ n / 2;\n    if n % 2 == 0 {\n        q * (n - q)\n    } else {\n        q *\
    \ (n - q) + q\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0_xz3fs7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Add code here\n    let mut l = vec![0; n as usize];\n\
    \    let mut r = vec![0; n as usize];\n    let mut res = 0;\n    for i in 0..n\
    \ {\n        l[i as usize] = i;\n        r[i as usize] = i + 1;\n    }\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if l[i as usize] == r[j as\
    \ usize] {\n                res += 1;\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfnj5hyj_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut cars = vec![0; n\
    \ as usize];\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for\
    \ i in 0..n {\n        for j in i + 1..n {\n            if cars[i as usize] >\
    \ cars[j as usize] {\n                collisions += 1;\n            }\n      \
    \  }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp1c3awi10.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let nn = n * 2;\n    let mut count = 0;\n    let mut\
    \ pos_count = 0;\n    let mut neg_count = 0;\n    let mut pos_arr = vec![];\n\
    \    let mut neg_arr = vec![];\n    for i in 0..nn {\n        if i < n {\n   \
    \         pos_arr.push(i);\n        } else {\n            neg_arr.push(i);\n \
    \       }\n    }\n    neg_arr.reverse();\n    for i in 0..n {\n        if pos_arr[i\
    \ as usize] >= 0 && neg_arr[i as usize] < 0 {\n            count += 1;\n     \
    \   }\n    }\n    pos_count = n - count;\n    neg_count = n - count;\n    let\
    \ mut cur_pos = count;\n    let mut cur_neg = count;\n    let mut i = 0;\n   \
    \ while i < nn - 1 {\n        if pos_arr[cur_pos as usize] == neg_arr[cur_neg\
    \ as usize] {\n            count += 1;\n            cur_pos += 1;\n          \
    \  cur_neg += 1;\n        } else if pos_arr[cur_pos as usize] < neg_arr[cur_neg\
    \ as usize] {\n            cur_pos += 1;\n        } else {\n            cur_neg\
    \ += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 2 but the
    index is 2'', /tmp/tmprhhxos_f.rs:35:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut cur_collision\
    \ = 0;\n    for i in 0..n {\n        cur_collision += i;\n    }\n    return cur_collision;\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfsstjj3k.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    return n *\
    \ (n - 1) / 2;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9pnkmmh6.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        0\n    } else {\n        let mut\
    \ result = 0;\n        for i in 0..n {\n            for j in 0..n {\n        \
    \        result += car_race_collision_single(i, j);\n            }\n        }\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `car_race_collision_single` in this\
    \ scope\n  --> /tmp/tmp2nzzlh_u.rs:16:27\n   |\n16 |                 result +=\
    \ car_race_collision_single(i, j);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // *******************************\n    // ***** YOUR\
    \ IMPLEMENTATION *****\n    // *******************************\n    0\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpns8j27es.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // (1) Write the body of this function\n    if n < 1\
    \ {\n        return 0;\n    }\n    return race_helper(n, 0);\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `race_helper` in this scope\n  --> /tmp/tmp4unx4uz0.rs:14:12\n\
    \   |\n14 |     return race_helper(n, 0);\n   |            ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).sum()\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9io1rc8_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    if n == 1\
    \ {\n        return 1;\n    }\n    n - 1\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8qw9kp4b.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    println!(\"There are {} cars in total.\", n);\n    //\
    \ Write code here\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpr3sk1aht.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: 'There are 2 cars in total.

    '
  timestamp: 1659977899
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The pseudocode is:\n    //   1. sort the left-to-right\
    \ cars by the position where they start\n    //   2. sort the right-to-left cars\
    \ by the position where they start\n    //   3. find the number of left-to-right\
    \ cars that are ahead of some\n    //      right-to-left car, and that number\
    \ is the answer.\n    let mut l2r = Vec::with_capacity(n as usize);\n    let mut\
    \ r2l = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        l2r.push(i);\n\
    \        r2l.push(n - i - 1);\n    }\n    l2r.sort();\n    r2l.sort();\n    let\
    \ mut cnt = 0;\n    for c in l2r {\n        if c < r2l[cnt] {\n            return\
    \ cnt;\n        }\n        cnt += 1;\n    }\n    return cnt;\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7khjys93.rs:26:20\n   |\n\
    26 |             return cnt;\n   |                    ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |             return cnt.try_into().unwrap();\n\
    \   |                       ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num = 0;\n    for i in 0..n {\n        for j\
    \ in 0..n {\n            if i > j {\n                num += 1;\n            }\n\
    \        }\n    }\n    num\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8ivk7tcv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    return n -\
    \ 1;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp27tndhxl.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    if n % 2\
    \ == 0 {\n        // even number\n        n / 2\n    } else {\n        // odd\
    \ number\n        (n - 1) / 2\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmphlyzgs2j.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: complete this function\n    let mut left = Vec::new();\n\
    \    let mut right = Vec::new();\n    for i in 0..n {\n        left.push(i);\n\
    \        right.push(n + i);\n    }\n    let mut collision_count = 0;\n    let\
    \ mut left_count = 0;\n    let mut right_count = 0;\n    while left_count < n\
    \ && right_count < n {\n        if left[left_count] < right[right_count] {\n \
    \           right_count += 1;\n        } else if left[left_count] > right[right_count]\
    \ {\n            left_count += 1;\n        } else {\n            left_count +=\
    \ 1;\n            right_count += 1;\n            collision_count += 1;\n     \
    \   }\n    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbq2jo61t.rs:21:12\n\
    \   |\n21 |         if left[left_count] < right[right_count] {\n   |         \
    \   ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpbq2jo61t.rs:21:31\n\
    \   |\n21 |         if left[left_count] < right[right_count] {\n   |         \
    \                      ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpbq2jo61t.rs:23:19\n   |\n23 |         } else if left[left_count]\
    \ > right[right_count] {\n   |                   ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpbq2jo61t.rs:23:38\n   |\n23 |         } else\
    \ if left[left_count] > right[right_count] {\n   |                           \
    \           ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpptjwmr69.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut coll_count = 0;\n    for i in 0..n {\n      \
    \  coll_count += i;\n    }\n    coll_count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpsw993gri.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut curr = 0;\n    let mut count = 0;\n    for i\
    \ in (1..n + 1).rev() {\n        curr += i;\n        count += curr;\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `4`', /tmp/tmpcuw3wkmp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_l2r = Vec::new();\n    for _ in 0..n {\n\
    \        cars_l2r.push(rand::random::<isize>());\n    }\n    let mut cars_r2l\
    \ = Vec::new();\n    for _ in 0..n {\n        cars_r2l.push(rand::random::<isize>());\n\
    \    }\n    cars_l2r.sort();\n    cars_r2l.sort();\n    println!(\"cars_l2r =\
    \ {:?}\", cars_l2r);\n    println!(\"cars_r2l = {:?}\", cars_r2l);\n    let mut\
    \ result = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j <\
    \ n {\n        if cars_l2r[i as usize] < cars_r2l[j as usize] {\n            result\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    result += (n - i) * j;\n    result\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp1_1hrufz.rs:12:23\n   |\n12 |         cars_l2r.push(rand::random::<isize>());\n\
    \   |                       ^^^^ use of undeclared crate or module `rand`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n  -->\
    \ /tmp/tmp1_1hrufz.rs:16:23\n   |\n16 |         cars_r2l.push(rand::random::<isize>());\n\
    \   |                       ^^^^ use of undeclared crate or module `rand`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collision = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if i + j >= n - 1 {\n                collision\
    \ += 1;\n            }\n        }\n    }\n    collision\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpf6juia4q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = HashSet::new();\n    let mut right = HashSet::new();\n\
    \    let mut i = 0;\n    while i < n {\n        left.insert(i);\n        right.insert(-i);\n\
    \        i += 1;\n    }\n    let mut j = 0;\n    let mut collision = 0;\n    while\
    \ j < n {\n        if !left.insert(j) {\n            collision += 1;\n       \
    \ }\n        if !right.insert(-j) {\n            collision += 1;\n        }\n\
    \        j += 1;\n    }\n    collision\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_7d1n_9z.rs:10:20\n   |\n10 |     let mut left = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_7d1n_9z.rs:11:21\n\
    \   |\n11 |     let mut right = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        (n - 1)\
    \ * n / 2\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxvvo13bw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut x: isize = 0;\n    let mut x_squared: isize =\
    \ 0;\n    let mut y: isize = 0;\n    let mut y_squared: isize = 0;\n    for i\
    \ in 0..n {\n        x += 1;\n        x_squared += x;\n        y -= 1;\n     \
    \   y_squared += y;\n    }\n    return x_squared + y_squared;\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqwkniwq4.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    let mut collision_count = 0;\n\
    \    for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut l = 0;\n    let mut r = n - 1;\n\
    \    while l < n && r >= 0 {\n        if left_to_right[l as usize] == right_to_left[r\
    \ as usize] {\n            if left_to_right[l as usize] == r {\n             \
    \   collision_count += 1;\n            }\n            l += 1;\n            r -=\
    \ 1;\n        } else if left_to_right[l as usize] < right_to_left[r as usize]\
    \ {\n            l += 1;\n        } else {\n            r -= 1;\n        }\n \
    \   }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpfqi_u_0n.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_cars = vec![false; n as usize];\n    let\
    \ mut right_cars = vec![false; n as usize];\n    for x in 0..n {\n        for\
    \ y in 0..n {\n            let x_pos = 2 * x;\n            let y_pos = 2 * y +\
    \ 1;\n            // println!(\"{}, {}\", x_pos, y_pos);\n            if x_pos\
    \ == y_pos {\n                // println!(\"Collision: {}\", x_pos);\n       \
    \         left_cars[x as usize] = true;\n                right_cars[y as usize]\
    \ = true;\n            }\n        }\n    }\n    left_cars.iter().filter(|&l| *l).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp6cs_jb5n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The solution is to imagine the two cars as integers.\
    \  The left to right cars\n    // are numbered 1..n;  the right to left cars are\
    \ numbered -1..-n.\n    // The number of collisions is the number of pairs of\
    \ positive numbers a, b s.t. a > b.\n    // (a and b cannot both be negative or\
    \ both be positive, because one of them is moving\n    // left to right and the\
    \ other is moving right to left).\n    // You can imagine there are n such pairs\
    \ of positive numbers.\n    // The number of collisions is therefore n * (n-1)\
    \ / 2.\n    // It's a basic fact about n * (n-1) that it's even.  Because we're\
    \ dividing by 2,\n    // we can just return the value of n * (n-1) and it's guaranteed\
    \ to be even.\n    // (See:  https://en.wikipedia.org/wiki/Even_and_odd_functions#Parity)\n\
    \    n * (n - 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjyrvc5oc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: -1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut fast_car_index = 0;\n    let mut slow_car_index\
    \ = n - 1;\n    let mut collisions = 0;\n    while fast_car_index != slow_car_index\
    \ {\n        collisions += 1;\n        fast_car_index += 1;\n        slow_car_index\
    \ -= 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977904
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_map = HashMap::new();\n    let mut num_collisions\
    \ = 0;\n    for i in 0..n {\n        car_map.insert(i as f64 / n as f64, 1);\n\
    \    }\n    for i in 0..n {\n        let entry = car_map.entry(1.0 - i as f64\
    \ / n as f64);\n        if let Occupied(occupied_entry) = entry {\n          \
    \  let _ = occupied_entry.remove();\n        } else {\n            num_collisions\
    \ += 1;\n        }\n    }\n    num_collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpoxaeq30o.rs:10:23\n   |\n10 |     let mut car_map = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `Occupied` in this scope\n  --> /tmp/tmpoxaeq30o.rs:17:16\n\
    \   |\n17 |         if let Occupied(occupied_entry) = entry {\n   |          \
    \      ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::collections::btree_map::Entry::Occupied;\n\
    \   |\n1  | use std::collections::hash_map::Entry::Occupied;\n   |\n1  | use std::collections::hash_map::RawEntryMut::Occupied;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0531.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo3ckj1g7.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977898
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0a6ltuj3.rs:10:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977897
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        for\
    \ j in i + 1..n + 1 {\n            count += (i * j) % n;\n        }\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpwtkwbjgr.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut right_to_left = vec![false; n as usize];\n  \
    \  let mut left_to_right = vec![false; n as usize];\n    let mut collisions =\
    \ 0;\n    for i in 0..n {\n        left_to_right[i as usize] = true;\n       \
    \ for j in 0..n {\n            if right_to_left[j as usize] {\n              \
    \  collisions += 1;\n            }\n        }\n        right_to_left[i as usize]\
    \ = true;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpbed8ceit.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The number of left-to-right cars that would not collide\
    \ with any right-to-left cars\n    let left_right_not_collide: isize = n * (n\
    \ - 1) / 2;\n    // The number of right-to-left cars that would not collide with\
    \ any left-to-right cars\n    let right_left_not_collide: isize = n * (n - 1)\
    \ / 2;\n    // Total number of cars on the road\n    let total_cars: isize = n\
    \ * 2;\n    // Number of cars that would collide with some other car\n    let\
    \ total_collision: isize = total_cars - (left_right_not_collide + right_left_not_collide);\n\
    \    // Our answer is this\n    total_collision\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwzlhbm6o.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    if n <= 1 {\n        return 0;\n\
    \    }\n    // The number of pairs of cars is (n*(n-1))/2.\n    // We want to\
    \ return the number of pairs of cars that collide.\n    // Let x_i be the position\
    \ of the i'th car from the left.\n    // Let y_i be the position of the i'th car\
    \ from the right.\n    // Let D = max(x_i) - min(y_i).\n    // When two cars collide,\
    \ we have x_i + y_j < D.\n    // Therefore, the number of collisions is\n    //\
    \ the number of pairs (i,j) such that x_i + y_j < D.\n    // We have x_i + y_j\
    \ = max_pos - y_j + y_j = max_pos + y_j\n    // and 0 <= y_j <= max_pos.\n   \
    \ // The last fact is because y_j >= 0 and y_j <= max_pos (since the\n    // road\
    \ is a straight line of length at most max_pos.)\n    // Therefore, the number\
    \ of collisions is the number of integer\n    // points between 0 and max_pos\
    \ (inclusive) that are smaller than D.\n    // Since max_pos = n-1, the answer\
    \ is D = n-1 - D = (n-1) - (max_pos + y_j)\n    // = (n-1) - (max_pos + min_neg)\
    \ = (n-1) - min_neg.\n    // Since min_neg = -(max_pos - 1) = -(n-2), the answer\
    \ is (n-1) + (n-2) = 2n-3.\n    2 * n - 3\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpbcb2rdkf.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 101
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i * (n - i);\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp68e_v0m6.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977899
- exit_code: 1
  program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // This is essentially the same as the two_sum problem.\n\
    \    // If there are n cars travelling left to right, and n cars travelling right\
    \ to left,\n    // there are 2n cars in total.\n    // The key is for each car\
    \ to travel exactly 1 unit.\n    // So, if there are 2n cars, there are 2n total\
    \ units of travel.\n    // As a result, the cars are bound to collide at some\
    \ point, because they are infinitely\n    // sturdy.\n    // So, we can essentially\
    \ do the same thing as a one pass hash map approach,\n    // and compute the collisions.\n\
    \    // It is not exactly the same as the two_sum problem, because in this case,\
    \ we know\n    // there are n cars travelling in each direction.\n    //\n   \
    \ // It is also possible to count the collisions:\n    // Essentially, each time\
    \ a car from one direction passes a car from the other direction,\n    // we count\
    \ a collision.\n    // So, we can implement this using a two pass hash map approach.\n\
    \    //\n    // (1)\n    // for each car travelling left to right, we want to\
    \ find out how many cars it has passed.\n    // We can achieve this by maintaining\
    \ a hash map for cars travelling left to right;\n    // for each car travelling\
    \ left to right, we increment the value of the hash map by 1.\n    // This gives\
    \ us the number of cars that have passed.\n    // For each car travelling right\
    \ to left, we check if the number of cars that have passed\n    // is greater\
    \ than 0; if so, we decrease it by 1.\n    // We then count the number of collisions.\n\
    \    // As a result, we get the answer.\n    // However, in this case, we need\
    \ to iterate over 2n cars, as we are doing a two pass approach.\n    //\n    //\
    \ (2)\n    // We can use a similar one pass approach to above, but instead of\
    \ using hash maps,\n    // we can use a vector of size 2n.\n    // The vector\
    \ indicates the number of cars that have passed the car travelling in the opposite\
    \ direction.\n    // For example, if a car travelling left to right is at index\
    \ 3,\n    // and a car travelling right to left is at index 0,\n    // then the\
    \ car travelling\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpw5udr42x.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659977899
