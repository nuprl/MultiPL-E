name: HumanEval_132_is_nested
language: rs
prompt: "/// Create a function that takes a string as input which contains only square\
  \ brackets.\n/// The function should return true if and only if there is a valid\
  \ subsequence of brackets \n/// where at least one bracket in the subsequence is\
  \ nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
  []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n\
  /// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
  [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn\
  \ is_nested(string: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
  [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
  \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
  []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
  \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
  [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
  \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
  [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
  \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
  [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
  }\n"
completions: ["    let mut stack = Vec::new();\n    for char in string.chars() {\n\
    \        match char {\n            '[' => stack.push(char),\n            ']' =>\
    \ {\n                if stack.last() == Some(&'[') {\n                    stack.pop();\n\
    \                } else {\n                    stack.push(char);\n           \
    \     }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Vec::new();\n    for s in string.chars() {\n        if s ==\
    \ '[' {\n            stack.push(s);\n        } else if s == ']' {\n          \
    \  match stack.pop() {\n                Some(_) => (),\n                None =>\
    \ return false,\n            }\n        }\n    }\n    stack.is_empty()", "   \
    \ let mut chars = string.chars();\n    let mut is_prev_open = false;\n    let\
    \ mut is_prev_close = false;\n    let mut is_valid = false;\n    for bracket in\
    \ chars {\n        match bracket {\n            '[' => {\n                if is_prev_close\
    \ {\n                    return false;\n                }\n                is_prev_open\
    \ = true;\n            },\n            ']' => {\n                if is_prev_open\
    \ {\n                    is_valid = true;\n                }\n               \
    \ is_prev_close = true;\n            },\n            _ => {},\n        }\n   \
    \ }\n    is_valid", "    let mut left: usize = 0;\n    let mut right: usize =\
    \ 0;\n    for c in string.chars() {\n        if c == '[' {\n            left +=\
    \ 1;\n        } else {\n            right += 1;\n        }\n        if right >\
    \ left {\n            return false;\n        }\n    }\n    right == left", " \
    \   string.chars().fold(vec![], |mut stack, x| {\n        if stack.len() == 0\
    \ || stack[stack.len() - 1] != x {\n            stack.push(x);\n        } else\
    \ {\n            stack.pop();\n        }\n        stack\n    }).len() == 0", " \
    \   let mut count = 0;\n    let mut found_nested = false;\n    for ch in string.chars()\
    \ {\n        if ch == '[' {\n            count += 1;\n        } else if ch ==\
    \ ']' {\n            count -= 1;\n        }\n        if count < 0 {\n        \
    \    break;\n        }\n        if count > 1 {\n            found_nested = true;\n\
    \        }\n    }\n    count == 0 && found_nested", '    false', "    let mut\
    \ stack = Vec::new();\n    for s in string.chars() {\n        if s == '[' {\n\
    \            stack.push(s);\n        } else if s == ']' {\n            if let\
    \ Some(_) = stack.pop() {\n                continue;\n            } else {\n \
    \               return false;\n            }\n        }\n    }\n    stack.is_empty()",
  "    let mut open = 0;\n    let mut close = 0;\n    for c in string.chars() {\n\
    \        if c == '[' {\n            open += 1;\n        } else if c == ']' {\n\
    \            close += 1;\n        }\n        if close > open {\n            return\
    \ false;\n        }\n    }\n    open != close", "    let mut stack = Vec::new();\n\
    \    for ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => return false,\n        }\n    }\n    stack.is_empty()",
  "    string.chars().filter(|c| *c == '[' || *c == ']').fold(0, |acc, c| if c ==\
    \ '[' { acc + 1 } else { acc - 1 }).abs() == 1", "    let mut iter = string.chars();\n\
    \    let mut depth = 0;\n    while let Some(next) = iter.next() {\n        if\
    \ next == '[' {\n            depth += 1;\n        } else if next == ']' {\n  \
    \          depth -= 1;\n        } else {\n            panic!(\"Tried to parse\
    \ a non-bracket character\");\n        }\n        if depth < 0 {\n           \
    \ return false;\n        }\n    }\n    depth != 0", "    let left = String::from(\"\
    [\");\n    let right = String::from(\"]\");\n    let mut stack = vec![];\n   \
    \ for c in string.chars() {\n        if stack.is_empty() {\n            stack.push(c);\n\
    \        } else {\n            let current = stack.pop().unwrap();\n         \
    \   if current == left && c == right {\n                stack.pop();\n       \
    \     } else {\n                stack.push(current);\n                stack.push(c);\n\
    \            }\n        }\n    }\n    stack.is_empty()", "    let mut depth =\
    \ 0;\n    let mut non_zero_depth = false;\n    for ch in string.chars() {\n  \
    \      if ch == '[' {\n            depth += 1;\n        } else {\n           \
    \ depth -= 1;\n        }\n        if depth > 0 {\n            non_zero_depth =\
    \ true;\n        }\n        if depth < 0 {\n            return false;\n      \
    \  }\n    }\n    return non_zero_depth;", "    string.chars().fold(vec![], |mut\
    \ stack, c| {\n        match c {\n            '[' => stack.push(c),\n        \
    \    ']' => {\n                match stack.pop() {\n                    Some(_)\
    \ => (),\n                    None => stack.push(c),\n                }\n    \
    \        }\n            _ => (),\n        }\n        stack\n    }).is_empty()",
  "    let mut seen_opening_brackets = 0;\n    let mut seen_nested_brackets = 0;\n\
    \    for bracket in string.chars() {\n        if bracket == '[' {\n          \
    \  seen_opening_brackets += 1;\n        } else if bracket == ']' {\n         \
    \   if seen_opening_brackets > 0 {\n                seen_opening_brackets -= 1;\n\
    \                seen_nested_brackets += 1;\n            } else {\n          \
    \      return false;\n            }\n        }\n    }\n    seen_nested_brackets\
    \ > 0", "    let mut st = vec![];\n    for ch in string.chars() {\n        if\
    \ ch == '[' {\n            st.push(ch);\n        } else {\n            if st.len()\
    \ == 0 {\n                return false;\n            }\n            st.pop();\n\
    \        }\n    }\n    st.len() == 0", "    string.chars().fold(vec![], |mut stack,\
    \ ch| {\n        match ch {\n            '[' => stack.push(ch),\n            ']'\
    \ => {\n                if stack.last() == Some(&'[') {\n                    stack.pop();\n\
    \                } else {\n                    stack.push(ch);\n             \
    \   }\n            }\n            _ => ()\n        }\n        stack\n    }).into_iter().any(|ch|\
    \ ch == '[')", "    // TODO: implement function\n    false", '    unimplemented!();']
stop_tokens:
- "\n}"
