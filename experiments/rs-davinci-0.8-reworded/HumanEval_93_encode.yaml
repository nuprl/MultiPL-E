name: HumanEval_93_encode
language: rs
prompt: "/// Write a function that takes a message, and encodes in such a \n/// way\
  \ that it swaps case of all letters, replaces all vowels in \n/// the message with\
  \ the letter that appears 2 places ahead of that \n/// vowel in the english alphabet.\
  \ \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"\
  ))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"\
  ))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
  TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
  )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")),\
  \ String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\"\
  )), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
  I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
completions: ["    let mut encoded_message = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            let encoded_letter = match letter {\n                'a' => 'c',\n\
    \                'e' => 'g',\n                'i' => 'k',\n                'o'\
    \ => 'q',\n                'u' => 's',\n                _ => letter,\n       \
    \     };\n            encoded_message.push(encoded_letter);\n        } else {\n\
    \            encoded_message.push(letter);\n        }\n    }\n    encoded_message",
  "    message.chars().map(|c| \n        match c {\n            'a' => 'c',\n    \
    \        'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n     \
    \       'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n      \
    \      'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n       \
    \     _ => c,\n        }\n    ).collect()", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        let num = c as u8;\n        let encoded_num\
    \ = if num >= 65 && num <= 90 {\n            num + 33\n        } else if num >=\
    \ 97 && num <= 122 {\n            num - 31\n        } else {\n            num\n\
    \        };\n        encoded_message.push(encoded_num as char);\n    }\n    encoded_message",
  "    message.chars().map(|x|\n        match x {\n            x if x.is_ascii_uppercase()\
    \ => x.to_ascii_lowercase(),\n            x if x.is_ascii_lowercase() => x.to_ascii_uppercase(),\n\
    \            x if (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u') =>\
    \ 'c',\n            _ => x\n        }\n    ).collect()", "    // TODO: implement\n\
    \    unimplemented!();", "    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        let mut ch = ch.to_ascii_lowercase();\n        if ch == 'a' {\n \
    \           ch = 'c';\n        } else if ch == 'e' {\n            ch = 'g';\n\
    \        } else if ch == 'i' {\n            ch = 'k';\n        } else if ch ==\
    \ 'o' {\n            ch = 'q';\n        } else if ch == 'u' {\n            ch\
    \ = 'y';\n        }\n        result.push(ch);\n    }\n    result", "    let mut\
    \ result = String::new();\n    for c in message.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            let mut ch = c.to_ascii_lowercase();\n            if ch == 'z'\
    \ {\n                ch = 'b';\n            } else if ch == 'y' {\n          \
    \      ch = 'a';\n            } else {\n                match ch {\n         \
    \           'a' | 'b' | 'c' => ch = 'd',\n                    'd' | 'e' | 'f'\
    \ => ch = 'g',\n                    'g' | 'h' | 'i' => ch = 'j',\n           \
    \         'j' | 'k' | 'l' => ch = 'm',\n                    'm' | 'n' | 'o' =>\
    \ ch = 'p',\n                    'p' | 'q' | 'r' => ch = 's',\n              \
    \      's' | 't' | 'u' => ch = 'v',\n                    'v' | 'w' | 'x' => ch\
    \ = 'y',\n                    'y' | 'z' => unreachable!(),\n                 \
    \   _ => unreachable!(),\n                }\n            }\n            result.push(ch);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    message.chars().map(|c| match c {\n        'a'...'e' => c.to_uppercase().next().unwrap_or(c),\n\
    \        'f'...'j' => c.to_lowercase().next().unwrap_or(c),\n        'k'...'o'\
    \ => c.to_uppercase().next().unwrap_or(c),\n        'p'...'t' => c.to_lowercase().next().unwrap_or(c),\n\
    \        'u'...'y' => c.to_uppercase().next().unwrap_or(c),\n        'z' => 'a',\n\
    \        'Z' => 'A',\n        _ => c,\n    }).collect()", "    message.chars().map(|c|\
    \ {\n        match c {\n            'A' | 'a' => 'C',\n            'E' | 'e' =>\
    \ 'G',\n            'I' | 'i' => 'K',\n            'O' | 'o' => 'M',\n       \
    \     'U' | 'u' => 'Q',\n            'Y' | 'y' => 'U',\n            _ => c.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let vowels = [String::from(\"A\"), String::from(\"\
    E\"), String::from(\"I\"), String::from(\"O\"), String::from(\"U\")];\n    let\
    \ mut output = String::new();\n    for c in message.chars() {\n        let mut\
    \ is_vowel = false;\n        for i in 0..vowels.len() {\n            if vowels[i]\
    \ == c.to_string().to_uppercase() {\n                is_vowel = true;\n      \
    \          output.push_str(&vowels[(i + 2) % vowels.len()].to_lowercase());\n\
    \            }\n        }\n        if !is_vowel {\n            output.push(c);\n\
    \        }\n    }\n    output", "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if character.is_ascii_uppercase() {\n            encoded_message.push(character.to_ascii_lowercase());\n\
    \        } else if character.is_ascii_lowercase() {\n            if vowels.contains(&character)\
    \ {\n                encoded_message.push(get_next_vowel(character));\n      \
    \      } else {\n                encoded_message.push(character.to_ascii_uppercase());\n\
    \            }\n        }\n    }\n    encoded_message", "    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n    for\
    \ character in message.chars() {\n        let new_character = match character\
    \ {\n            'A'...'Z' => match character.to_lowercase().next().unwrap() {\n\
    \                'a' => 'c',\n                'e' => 'g',\n                'i'\
    \ => 'k',\n                'o' => 'q',\n                'u' => 's',\n        \
    \        _ => character.to_lowercase().next().unwrap(),\n            },\n    \
    \        'a'...'z' => match character {\n                'a' => 'c',\n       \
    \         'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 's',\n                _ => character,\n            },\n\
    \            _ => character,\n        };\n        encoded_message.push(new_character);\n\
    \    }\n    encoded_message", "    let mut result = String::new();\n    for c\
    \ in message.chars() {\n        let is_upper = c.is_uppercase();\n        let\
    \ c = c.to_lowercase().next().unwrap();\n        let encode_ch = match c {\n \
    \           'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n  \
    \          'o' => 'q',\n            'u' => 'y',\n            _ => c,\n       \
    \ };\n        result.push(if is_upper {\n            encode_ch.to_uppercase().next().unwrap()\n\
    \        } else {\n            encode_ch\n        });\n    }\n    result", " \
    \   // convert to uppercase\n    let mut result = message.to_uppercase();\n  \
    \  // convert to lowercase\n    result = result.to_lowercase();\n    // replace\
    \ vowels with the letter that appears 2 places ahead\n    result = result.replace(\"\
    a\", \"c\");\n    result = result.replace(\"e\", \"g\");\n    result = result.replace(\"\
    i\", \"k\");\n    result = result.replace(\"o\", \"q\");\n    result = result.replace(\"\
    u\", \"s\");\n    result", '    message.chars().map(|c| encode_char(c)).collect()',
  "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  if c != 'u' {\n                encoded_message.push((c as u8 + 2) as char);\n\
    \            } else {\n                encoded_message.push('a');\n          \
    \  }\n        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message", "    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut message_list: Vec<char> = message.chars().collect();\n\
    \    let mut out_string = String::new();\n    for i in 0..message_list.len() {\n\
    \        let c = message_list[i];\n        if c.is_uppercase() {\n           \
    \ if c.is_ascii_lowercase() {\n                out_string.push(c.to_ascii_uppercase());\n\
    \            } else {\n                out_string.push(c);\n            }\n  \
    \      } else {\n            if c.is_ascii_uppercase() {\n                out_string.push(c.to_ascii_lowercase());\n\
    \            } else {\n                out_string.push(c);\n            }\n  \
    \      }\n        if vowels.contains(&message_list[i]) {\n            let mut\
    \ index = vowels.iter().position(|&r| r == message_list[i]).unwrap();\n      \
    \      index += 2;\n            index %= vowels.len();\n            out_string.push(vowels[index]);\n\
    \        }\n    }\n    out_string", "    // first map all letters to lowercase\
    \ to get rid of case issues\n    let message = message.to_lowercase();\n    //\
    \ create a bool vector, mapping whether the char at the same index\n    // is\
    \ a vowel or not\n    let message: Vec<char> = message.chars().collect();\n  \
    \  let is_vowel: Vec<bool> = message.iter().map(|&x| x == 'a' || x == 'e' || x\
    \ == 'i' || x == 'o' || x == 'u').collect();\n    // create an iterator, which\
    \ maps each char to the char two positions\n    // up in the alphabet, or is a\
    \ vowel that does the same, but if the index\n    // of the char is at the end\
    \ of the alphabet, it moves back to the beginning\n    let message: Vec<char>\
    \ = message.iter().enumerate().map(|(i, &x)| {\n        let is_vowel = is_vowel[i];\n\
    \        let x = if x == 'z' {\n            'a'\n        } else if x == 'z' {\n\
    \            'a'\n        } else {\n            ((x as u8 + 2) as char)\n    \
    \    };\n        if is_vowel {\n            x\n        } else {\n            x.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect();\n    // put everything together, and return\n  \
    \  message.iter().collect()", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        let encoded_char = if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        encoded_message.push(encoded_char);\n    }\n    encoded_message",
  "    message.chars().map(|c| {\n        let vowel = match c {\n            'a' |\
    \ 'e' | 'i' | 'o' | 'u' => true,\n            _ => false,\n        };\n      \
    \  if vowel {\n            let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  \
    \          alphabet.find(c).map(|i| {\n                let i = i + 2;\n      \
    \          if i >= alphabet.len() {\n                    alphabet.chars().nth(i\
    \ - alphabet.len()).unwrap()\n                } else {\n                    alphabet.chars().nth(i).unwrap()\n\
    \                }\n            }).unwrap()\n        } else {\n            c.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect()"]
stop_tokens:
- "\n}"
