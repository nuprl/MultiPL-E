name: HumanEval_93_encode
language: rs
prompt: "/// Write a function that takes a message, and encodes in such a \n/// way\
  \ that it swaps case of all letters, replaces all vowels in \n/// the message with\
  \ the letter that appears 2 places ahead of that \n/// vowel in the english alphabet.\
  \ \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"\
  ))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"\
  ))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
  TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
  )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")),\
  \ String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\"\
  )), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
  I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
completions: ["    let mut encoded_message = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            let encoded_letter = match letter {\n                'a' => 'c',\n\
    \                'e' => 'g',\n                'i' => 'k',\n                'o'\
    \ => 'q',\n                'u' => 's',\n                _ => letter,\n       \
    \     };\n            encoded_message.push(encoded_letter);\n        } else {\n\
    \            encoded_message.push(letter);\n        }\n    }\n    encoded_message",
  "    message.chars().map(|c| \n        match c {\n            'a' => 'c',\n    \
    \        'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n     \
    \       'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n      \
    \      'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n       \
    \     _ => c,\n        }\n    ).collect()", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        let num = c as u8;\n        let encoded_num\
    \ = if num >= 65 && num <= 90 {\n            num + 33\n        } else if num >=\
    \ 97 && num <= 122 {\n            num - 31\n        } else {\n            num\n\
    \        };\n        encoded_message.push(encoded_num as char);\n    }\n    encoded_message",
  "    message.chars().map(|x|\n        match x {\n            x if x.is_ascii_uppercase()\
    \ => x.to_ascii_lowercase(),\n            x if x.is_ascii_lowercase() => x.to_ascii_uppercase(),\n\
    \            x if (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u') =>\
    \ 'c',\n            _ => x\n        }\n    ).collect()", "    // TODO: implement\n\
    \    unimplemented!();", "    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        let mut ch = ch.to_ascii_lowercase();\n        if ch == 'a' {\n \
    \           ch = 'c';\n        } else if ch == 'e' {\n            ch = 'g';\n\
    \        } else if ch == 'i' {\n            ch = 'k';\n        } else if ch ==\
    \ 'o' {\n            ch = 'q';\n        } else if ch == 'u' {\n            ch\
    \ = 'y';\n        }\n        result.push(ch);\n    }\n    result", "    let mut\
    \ result = String::new();\n    for c in message.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            let mut ch = c.to_ascii_lowercase();\n            if ch == 'z'\
    \ {\n                ch = 'b';\n            } else if ch == 'y' {\n          \
    \      ch = 'a';\n            } else {\n                match ch {\n         \
    \           'a' | 'b' | 'c' => ch = 'd',\n                    'd' | 'e' | 'f'\
    \ => ch = 'g',\n                    'g' | 'h' | 'i' => ch = 'j',\n           \
    \         'j' | 'k' | 'l' => ch = 'm',\n                    'm' | 'n' | 'o' =>\
    \ ch = 'p',\n                    'p' | 'q' | 'r' => ch = 's',\n              \
    \      's' | 't' | 'u' => ch = 'v',\n                    'v' | 'w' | 'x' => ch\
    \ = 'y',\n                    'y' | 'z' => unreachable!(),\n                 \
    \   _ => unreachable!(),\n                }\n            }\n            result.push(ch);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  "    message.chars().map(|c| match c {\n        'a'...'e' => c.to_uppercase().next().unwrap_or(c),\n\
    \        'f'...'j' => c.to_lowercase().next().unwrap_or(c),\n        'k'...'o'\
    \ => c.to_uppercase().next().unwrap_or(c),\n        'p'...'t' => c.to_lowercase().next().unwrap_or(c),\n\
    \        'u'...'y' => c.to_uppercase().next().unwrap_or(c),\n        'z' => 'a',\n\
    \        'Z' => 'A',\n        _ => c,\n    }).collect()", "    message.chars().map(|c|\
    \ {\n        match c {\n            'A' | 'a' => 'C',\n            'E' | 'e' =>\
    \ 'G',\n            'I' | 'i' => 'K',\n            'O' | 'o' => 'M',\n       \
    \     'U' | 'u' => 'Q',\n            'Y' | 'y' => 'U',\n            _ => c.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let vowels = [String::from(\"A\"), String::from(\"\
    E\"), String::from(\"I\"), String::from(\"O\"), String::from(\"U\")];\n    let\
    \ mut output = String::new();\n    for c in message.chars() {\n        let mut\
    \ is_vowel = false;\n        for i in 0..vowels.len() {\n            if vowels[i]\
    \ == c.to_string().to_uppercase() {\n                is_vowel = true;\n      \
    \          output.push_str(&vowels[(i + 2) % vowels.len()].to_lowercase());\n\
    \            }\n        }\n        if !is_vowel {\n            output.push(c);\n\
    \        }\n    }\n    output", "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if character.is_ascii_uppercase() {\n            encoded_message.push(character.to_ascii_lowercase());\n\
    \        } else if character.is_ascii_lowercase() {\n            if vowels.contains(&character)\
    \ {\n                encoded_message.push(get_next_vowel(character));\n      \
    \      } else {\n                encoded_message.push(character.to_ascii_uppercase());\n\
    \            }\n        }\n    }\n    encoded_message", "    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n    for\
    \ character in message.chars() {\n        let new_character = match character\
    \ {\n            'A'...'Z' => match character.to_lowercase().next().unwrap() {\n\
    \                'a' => 'c',\n                'e' => 'g',\n                'i'\
    \ => 'k',\n                'o' => 'q',\n                'u' => 's',\n        \
    \        _ => character.to_lowercase().next().unwrap(),\n            },\n    \
    \        'a'...'z' => match character {\n                'a' => 'c',\n       \
    \         'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 's',\n                _ => character,\n            },\n\
    \            _ => character,\n        };\n        encoded_message.push(new_character);\n\
    \    }\n    encoded_message", "    let mut result = String::new();\n    for c\
    \ in message.chars() {\n        let is_upper = c.is_uppercase();\n        let\
    \ c = c.to_lowercase().next().unwrap();\n        let encode_ch = match c {\n \
    \           'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n  \
    \          'o' => 'q',\n            'u' => 'y',\n            _ => c,\n       \
    \ };\n        result.push(if is_upper {\n            encode_ch.to_uppercase().next().unwrap()\n\
    \        } else {\n            encode_ch\n        });\n    }\n    result", " \
    \   // convert to uppercase\n    let mut result = message.to_uppercase();\n  \
    \  // convert to lowercase\n    result = result.to_lowercase();\n    // replace\
    \ vowels with the letter that appears 2 places ahead\n    result = result.replace(\"\
    a\", \"c\");\n    result = result.replace(\"e\", \"g\");\n    result = result.replace(\"\
    i\", \"k\");\n    result = result.replace(\"o\", \"q\");\n    result = result.replace(\"\
    u\", \"s\");\n    result", '    message.chars().map(|c| encode_char(c)).collect()',
  "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  if c != 'u' {\n                encoded_message.push((c as u8 + 2) as char);\n\
    \            } else {\n                encoded_message.push('a');\n          \
    \  }\n        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message", "    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut message_list: Vec<char> = message.chars().collect();\n\
    \    let mut out_string = String::new();\n    for i in 0..message_list.len() {\n\
    \        let c = message_list[i];\n        if c.is_uppercase() {\n           \
    \ if c.is_ascii_lowercase() {\n                out_string.push(c.to_ascii_uppercase());\n\
    \            } else {\n                out_string.push(c);\n            }\n  \
    \      } else {\n            if c.is_ascii_uppercase() {\n                out_string.push(c.to_ascii_lowercase());\n\
    \            } else {\n                out_string.push(c);\n            }\n  \
    \      }\n        if vowels.contains(&message_list[i]) {\n            let mut\
    \ index = vowels.iter().position(|&r| r == message_list[i]).unwrap();\n      \
    \      index += 2;\n            index %= vowels.len();\n            out_string.push(vowels[index]);\n\
    \        }\n    }\n    out_string", "    // first map all letters to lowercase\
    \ to get rid of case issues\n    let message = message.to_lowercase();\n    //\
    \ create a bool vector, mapping whether the char at the same index\n    // is\
    \ a vowel or not\n    let message: Vec<char> = message.chars().collect();\n  \
    \  let is_vowel: Vec<bool> = message.iter().map(|&x| x == 'a' || x == 'e' || x\
    \ == 'i' || x == 'o' || x == 'u').collect();\n    // create an iterator, which\
    \ maps each char to the char two positions\n    // up in the alphabet, or is a\
    \ vowel that does the same, but if the index\n    // of the char is at the end\
    \ of the alphabet, it moves back to the beginning\n    let message: Vec<char>\
    \ = message.iter().enumerate().map(|(i, &x)| {\n        let is_vowel = is_vowel[i];\n\
    \        let x = if x == 'z' {\n            'a'\n        } else if x == 'z' {\n\
    \            'a'\n        } else {\n            ((x as u8 + 2) as char)\n    \
    \    };\n        if is_vowel {\n            x\n        } else {\n            x.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect();\n    // put everything together, and return\n  \
    \  message.iter().collect()", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        let encoded_char = if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        encoded_message.push(encoded_char);\n    }\n    encoded_message",
  "    message.chars().map(|c| {\n        let vowel = match c {\n            'a' |\
    \ 'e' | 'i' | 'o' | 'u' => true,\n            _ => false,\n        };\n      \
    \  if vowel {\n            let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n  \
    \          alphabet.find(c).map(|i| {\n                let i = i + 2;\n      \
    \          if i >= alphabet.len() {\n                    alphabet.chars().nth(i\
    \ - alphabet.len()).unwrap()\n                } else {\n                    alphabet.chars().nth(i).unwrap()\n\
    \                }\n            }).unwrap()\n        } else {\n            c.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect()", "    let mut message = message.to_lowercase();\n\
    \    for (i, c) in message.chars().enumerate() {\n        if c == 'a' {\n    \
    \        message.replace_range(i..i+1, \"c\");\n        } else if c == 'e' {\n\
    \            message.replace_range(i..i+1, \"g\");\n        } else if c == 'i'\
    \ {\n            message.replace_range(i..i+1, \"k\");\n        } else if c ==\
    \ 'o' {\n            message.replace_range(i..i+1, \"m\");\n        } else if\
    \ c == 'u' {\n            message.replace_range(i..i+1, \"o\");\n        } else\
    \ if c == 'y' {\n            message.replace_range(i..i+1, \"a\");\n        }\n\
    \    }\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let alphabet = ['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n            let index = alphabet.iter().position(|&r|\
    \ r == c).unwrap();\n            encoded_message.push(alphabet[(index + 2) % 26]);\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    // TODO implement this function\n    String::from(\"\
    TODO\")", "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let alphabet = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut result = String::new();\n\
    \    for char in message.chars() {\n        if char.is_alphabetic() {\n      \
    \      if char.is_uppercase() {\n                let index = alphabet.iter().position(|&r|\
    \ r == char.to_lowercase().next().unwrap()).unwrap();\n                if vowels.contains(&alphabet[index])\
    \ {\n                    result.push(alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap());\n\
    \                } else {\n                    result.push(alphabet[index].to_uppercase().next().unwrap());\n\
    \                }\n            } else {\n                let index = alphabet.iter().position(|&r|\
    \ r == char).unwrap();\n                if vowels.contains(&alphabet[index]) {\n\
    \                    result.push(alphabet[(index + 2) % alphabet.len()]);\n  \
    \              } else {\n                    result.push(alphabet[index]);\n \
    \               }\n            }\n        } else {\n            result.push(char);\n\
    \        }\n    }\n    result", "    let vowels = String::from(\"aeiou\");\n \
    \   let mut m = message.chars().collect::<Vec<char>>();\n    for (i, v) in m.iter_mut().enumerate()\
    \ {\n        let vowels = vowels.chars().collect::<Vec<char>>();\n        if vowels.contains(v)\
    \ {\n            let index = vowels.iter().position(|&r| r == *v).unwrap();\n\
    \            let index = match index+2 {\n                _ if index == 4 => 0,\n\
    \                _ if index == 5 => 1,\n                n => n,\n            };\n\
    \            *v = vowels[index];\n        }\n        *v = match *v {\n       \
    \     'a' ... 'z' => (*v as u8 - 32) as char,\n            'A' ... 'Z' => (*v\
    \ as u8 + 32) as char,\n            _ => *v,\n        };\n    }\n    m.iter().collect()",
  "    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        encoded_message.push(match c {\n            'A' => 'C',\n           \
    \ 'a' => 'c',\n            'E' => 'G',\n            'e' => 'g',\n            'I'\
    \ => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n            'o' =>\
    \ 'q',\n            'U' => 'Y',\n            'u' => 'y',\n            'a'...'z'\
    \ => ((c as u8) - 32) as char,\n            'A'...'Z' => ((c as u8) + 32) as char,\n\
    \            _ => c,\n        });\n    }\n    encoded_message", "    let mut encoded_message\
    \ = String::new();\n    let mut vowels = Vec::new();\n    vowels.push('a');\n\
    \    vowels.push('e');\n    vowels.push('i');\n    vowels.push('o');\n    vowels.push('u');\n\
    \    vowels.push('A');\n    vowels.push('E');\n    vowels.push('I');\n    vowels.push('O');\n\
    \    vowels.push('U');\n    for c in message.chars() {\n        match c {\n  \
    \          'a' => encoded_message.push('c'),\n            'e' => encoded_message.push('g'),\n\
    \            'i' => encoded_message.push('k'),\n            'o' => encoded_message.push('m'),\n\
    \            'u' => encoded_message.push('q'),\n            'A' => encoded_message.push('C'),\n\
    \            'E' => encoded_message.push('G'),\n            'I' => encoded_message.push('K'),\n\
    \            'O' => encoded_message.push('M'),\n            'U' => encoded_message.push('Q'),\n\
    \            _ => encoded_message.push(c.to_ascii_uppercase()),\n        }\n \
    \   }\n    encoded_message", "    let mut result = String::new();\n    for c in\
    \ message.chars() {\n        if c.is_alphabetic() {\n            let c = if c.is_uppercase()\
    \ {\n                c.to_lowercase().to_string()\n            } else {\n    \
    \            c.to_uppercase().to_string()\n            };\n            result.push_str(&match\
    \ c.as_str() {\n                \"a\" => \"c\",\n                \"e\" => \"g\"\
    ,\n                \"i\" => \"k\",\n                \"o\" => \"q\",\n        \
    \        \"u\" => \"w\",\n                _ => &c,\n            });\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    result", "    let\
    \ mut encoded_message = String::from(\"\");\n    for c in message.chars() {\n\
    \        if c == ' ' {\n            encoded_message.push(' ');\n        } else\
    \ {\n            let mut letter_number = c as u8;\n            // If lowercase\
    \ letter\n            if letter_number < 91 {\n                letter_number +=\
    \ 32;\n            }\n            // If vowel\n            if letter_number ==\
    \ 97 || letter_number == 101 || letter_number == 105 || letter_number == 111 ||\
    \ letter_number == 117 {\n                letter_number += 2;\n            }\n\
    \            // If uppercase\n            if letter_number > 109 {\n         \
    \       letter_number -= 26;\n            }\n            encoded_message.push(letter_number\
    \ as char);\n        }\n    }\n    encoded_message", "    let mut encoded_message\
    \ = String::new();\n    for c in message.chars() {\n        let new_char = match\
    \ c {\n            'a' | 'A' => 'c',\n            'e' | 'E' => 'g',\n        \
    \    'i' | 'I' => 'k',\n            'o' | 'O' => 'q',\n            'u' | 'U' =>\
    \ 'y',\n            'b' | 'B' => 'd',\n            'c' | 'C' => 'e',\n       \
    \     'd' | 'D' => 'f',\n            'f' | 'F' => 'h',\n            'g' | 'G'\
    \ => 'i',\n            'h' | 'H' => 'j',\n            'j' | 'J' => 'l',\n    \
    \        'k' | 'K' => 'm',\n            'l' | 'L' => 'n',\n            'm' | 'M'\
    \ => 'o',\n            'n' | 'N' => 'p',\n            'p' | 'P' => 'r',\n    \
    \        'q' | 'Q' => 's',\n            'r' | 'R' => 't',\n            's' | 'S'\
    \ => 'u',\n            't' | 'T' => 'v',\n            'v' | 'V' => 'x',\n    \
    \        'w' | 'W' => 'z',\n            'x' | 'X' => 'a',\n            'y' | 'Y'\
    \ => 'b',\n            'z' | 'Z' => 'c',\n            ' ' => ' ',\n          \
    \  _ => c,\n        };\n        encoded_message.push(new_char);\n    }\n    encoded_message",
  "    let mut encoded_message = String::new();\n    for ch in message.chars() {\n\
    \        if ch.is_alphabetic() {\n            encoded_message.push(match ch {\n\
    \                'a' => 'c',\n                'A' => 'C',\n                'e'\
    \ => 'g',\n                'E' => 'G',\n                'i' => 'k',\n        \
    \        'I' => 'K',\n                'o' => 'q',\n                'O' => 'Q',\n\
    \                'u' => 'y',\n                'U' => 'Y',\n                _ =>\
    \ ch.to_ascii_uppercase(),\n            });\n        }\n    }\n    encoded_message",
  "    let letters = message.to_lowercase();\n    let mut encoded = String::from(\"\
    \");\n    for c in letters.chars() {\n        let idx = (c as u8 - 'a' as u8)\
    \ as usize;\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n\
    \                encoded.push(ALPHABET[(idx + 2) % 26] as char);\n           \
    \ },\n            _ => {\n                encoded.push(ALPHABET[idx] as char);\n\
    \            }\n        }\n    }\n    encoded", "    message.chars().map(|c| {\n\
    \        match c {\n            'A' => 'C',\n            'E' => 'G',\n       \
    \     'I' => 'K',\n            'O' => 'Q',\n            'U' => 'S',\n        \
    \    'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n         \
    \   'o' => 'q',\n            'u' => 's',\n            _ => c.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", '    message.chars().map(swap_case).map(encode_char).collect()',
  "    message.chars().map(|c| {\n        let start = if c.is_uppercase() { 'A' }\
    \ else { 'a' };\n        match c {\n            'A'|'E'|'I'|'O'|'U' => ((c as\
    \ u8 + 2 - start as u8) % 26 + start as u8) as char,\n            'a'|'e'|'i'|'o'|'u'\
    \ => ((c as u8 + 2 - start as u8) % 26 + start as u8) as char,\n            _\
    \ => c,\n        }\n    }).collect()", "    message.chars().map(|x| match x {\n\
    \        'a'...'z' => (((x as u8) - ('a' as u8) + 2) % 26 + ('a' as u8)) as char,\n\
    \        'A'...'Z' => (((x as u8) - ('A' as u8) + 2) % 26 + ('A' as u8)) as char,\n\
    \        _ => x,\n    }).collect()", "    let mut encoded = String::new();\n \
    \   for c in message.chars() {\n        let new_char = match c {\n           \
    \ 'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o'\
    \ => 'q',\n            'u' => 'w',\n            'A' => 'C',\n            'E' =>\
    \ 'G',\n            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n\
    \            _ => c,\n        };\n        encoded.push(new_char);\n    }\n   \
    \ encoded", "    message.chars().map(|c| match c {\n        'a' => 'c',\n    \
    \    'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'w',\n\
    \        'y' => 'a',\n        'A' => 'C',\n        'E' => 'G',\n        'I' =>\
    \ 'K',\n        'O' => 'Q',\n        'U' => 'W',\n        'Y' => 'A',\n      \
    \  _ => c,\n    }).collect()", "    let mut encoded_message = String::new();\n\
    \    let mut characters = message.chars();\n    while let Some(character) = characters.next()\
    \ {\n        if character.is_alphabetic() {\n            let mut character = character.to_ascii_lowercase();\n\
    \            let offset = match character {\n                'a' | 'e' | 'i' |\
    \ 'o' | 'u' => 2,\n                _ => 0,\n            };\n            character\
    \ = (character as u8 + offset) as char;\n            if character > 'z' {\n  \
    \              character = (character as u8 - 26) as char;\n            }\n  \
    \          encoded_message.push(character);\n        } else {\n            encoded_message.push(character);\n\
    \        }\n    }\n    encoded_message", "    let mut result = String::new();\n\
    \    for c in message.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        let c_num = c as u8;\n        if c_num >= 97 && c_num <= 122 {\n    \
    \        if c_num < 101 {\n                c = (c_num + 26) as char;\n       \
    \     }\n            c = (c_num - 2) as char;\n        }\n        result.push(c);\n\
    \    }\n    result", "    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded_c = c;\n        if c.is_alphabetic() {\n        \
    \    encoded_c = if c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n\
    \            } else {\n                c.to_lowercase().next().unwrap()\n    \
    \        };\n            if \"aeiou\".contains(encoded_c) {\n                encoded_c\
    \ = ((encoded_c as u8) + 2) as char;\n            }\n        }\n        encoded.push(encoded_c);\n\
    \    }\n    encoded", '    unimplemented!()', "    let vowels = ['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut encoded = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_lowercase() {\n            encoded.push(ch.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_uppercase() {\n            encoded.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded.push(ch);\n        }\n    }\n    for ch\
    \ in encoded.chars() {\n        if vowels.contains(&ch) {\n            let index\
    \ = vowels.iter().position(|&v| v == ch).unwrap();\n            encoded.push(vowels[(index\
    \ + 2) % vowels.len()]);\n        }\n    }\n    encoded", "    let mut encoded\
    \ = String::new();\n    let vowels = String::from(\"aeiou\");\n    for character\
    \ in message.chars() {\n        if character.is_alphabetic() {\n            encoded.push(match\
    \ character.is_uppercase() {\n                true => match character.to_lowercase().next().unwrap()\
    \ {\n                    'z' => 'b',\n                    'a'..='y' => (character\
    \ as u8 + 2) as char,\n                    _ => character\n                },\n\
    \                false => match character {\n                    'z' => 'B',\n\
    \                    'a'..='y' => (character as u8 + 2) as char,\n           \
    \         _ => character\n                }\n            });\n        } else {\n\
    \            encoded.push(character);\n        }\n    }\n    encoded", "  let\
    \ mut result = String::new();\n  let mut c = message.chars();\n  while let Some(ch)\
    \ = c.next() {\n    let mut ch = ch;\n    if ch.is_lowercase() {\n      ch = ch.to_uppercase().next().unwrap();\n\
    \    }\n    if ch.is_uppercase() {\n      ch = ch.to_lowercase().next().unwrap();\n\
    \    }\n    if ch == 'A' {\n      ch = 'C';\n    } else if ch == 'E' {\n     \
    \ ch = 'G';\n    } else if ch == 'I' {\n      ch = 'K';\n    } else if ch == 'O'\
    \ {\n      ch = 'Q';\n    } else if ch == 'U' {\n      ch = 'S';\n    } else if\
    \ ch == 'Y' {\n      ch = 'A';\n    }\n    result.push(ch);\n  }\n  result", " \
    \   let mut out = String::from(\"\");\n    for ch in message.chars() {\n     \
    \   let mut uc = ch.to_uppercase().next().unwrap();\n        if \"AEIOU\".contains(uc)\
    \ {\n            uc = match uc {\n                'A' => 'C',\n              \
    \  'E' => 'I',\n                'I' => 'O',\n                'O' => 'U',\n   \
    \             'U' => 'A',\n                _ => uc,\n            }\n        }\
    \ else {\n            uc = match uc {\n                'B' => 'D',\n         \
    \       'C' => 'E',\n                'D' => 'F',\n                'F' => 'H',\n\
    \                'G' => 'J',\n                'H' => 'K',\n                'J'\
    \ => 'L',\n                'K' => 'M',\n                'L' => 'N',\n        \
    \        'M' => 'P',\n                'N' => 'Q',\n                'P' => 'R',\n\
    \                'Q' => 'S',\n                'R' => 'T',\n                'S'\
    \ => 'V',\n                'T' => 'W',\n                'V' => 'X',\n        \
    \        'W' => 'Y',\n                'X' => 'Z',\n                'Y' => 'B',\n\
    \                'Z' => 'C',\n                _ => uc,\n            }\n      \
    \  }\n        if ch.is_uppercase() {\n            out.push(uc);\n        } else\
    \ {\n            out.push(uc.to_lowercase().next().unwrap());\n        }\n   \
    \ }\n    out", "    let mut encoded_string = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            encoded_string.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded_string.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_string.push(c);\n        }\n    }\n   \
    \ encoded_string", "    let mut res = String::new();\n    for ch in message.chars()\
    \ {\n        let ch = match ch {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n\
    \            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n \
    \           'O' => 'Q',\n            'U' => 'Y',\n            ' ' => ' ',\n  \
    \          _ => if ch.is_lowercase() { ch.to_uppercase().to_string() } else {\
    \ ch.to_lowercase().to_string() }\n        };\n        res.push_str(&ch);\n  \
    \  }\n    res", "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ encoded = String::new();\n    for c in message.chars() {\n        let encoded_char\
    \ = if c.is_ascii_uppercase() {\n            (c as u8 + 2) as char\n        }\
    \ else if c.is_ascii_lowercase() {\n            (c as u8 + 2) as char\n      \
    \  } else {\n            c\n        };\n        if vowels.contains(&encoded_char)\
    \ {\n            encoded_char.to_lowercase().collect::<String>()\n        } else\
    \ {\n            encoded_char.to_string()\n        }\n    }\n    encoded", " \
    \   let mut encoded = String::new();\n    for c in message.chars() {\n       \
    \ if let Some(code) = code_char(c) {\n            encoded.push(code);\n      \
    \  } else {\n            encoded.push(c);\n        }\n    }\n    encoded", " \
    \   message.chars().map(|c| {\n        let mut c = c.to_ascii_lowercase();\n \
    \       match c {\n            'a' => 'c',\n            'e' => 'g',\n        \
    \    'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n         \
    \   _ => c\n        }\n    }).map(|c| {\n        if c.is_ascii_lowercase() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()", "    let v = message.into_bytes();\n    let mut res =\
    \ vec![];\n    for c in v {\n        let is_upper = c >= 65 && c <= 90;\n    \
    \    let is_lower = c >= 97 && c <= 122;\n        let is_vowel = c == 97 || c\
    \ == 101 || c == 105 || c == 111 || c == 117;\n        if is_upper || is_lower\
    \ {\n            if is_upper {\n                res.push(c.to_ascii_lowercase());\n\
    \            } else {\n                res.push(c);\n            }\n         \
    \   if is_vowel {\n                res.push(\n                    (c as i8 + 2)\
    \ as u8\n                );\n            }\n        }\n    }\n    String::from_utf8(res).unwrap()",
  "    let mut encoded = String::new();\n    for character in message.chars() {\n\
    \        let character = character.to_ascii_lowercase();\n        match character\
    \ {\n            'a' => encoded.push('c'),\n            'e' => encoded.push('g'),\n\
    \            'i' => encoded.push('k'),\n            'o' => encoded.push('q'),\n\
    \            'u' => encoded.push('s'),\n            'y' => encoded.push('a'),\n\
    \            _ => encoded.push(\n                character.to_ascii_uppercase()\n\
    \            )\n        }\n    }\n    encoded", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let alphabet_upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        let mut found = false;\n\
    \        for (i, letter) in alphabet.chars().enumerate() {\n            if letter\
    \ == c {\n                let next_letter = alphabet.chars().nth(i + 2).unwrap();\n\
    \                encoded.push(next_letter);\n                found = true;\n \
    \               break;\n            }\n        }\n        if !found {\n      \
    \      for (i, letter) in alphabet_upper.chars().enumerate() {\n             \
    \   if letter == c {\n                    let next_letter = alphabet_upper.chars().nth(i\
    \ + 2).unwrap();\n                    encoded.push(next_letter);\n           \
    \         break;\n                }\n            }\n        }\n    }\n    encoded",
  "    let mut encoded = String::new();\n    let mut skip = false;\n    for c in message.chars()\
    \ {\n        if skip {\n            skip = false;\n            continue;\n   \
    \     }\n        let mut i = c.to_string();\n        match c {\n            'A'\
    \ | 'a' => {\n                i = \"C\".to_string();\n                skip = true;\n\
    \            }\n            'E' | 'e' => {\n                i = \"G\".to_string();\n\
    \                skip = true;\n            }\n            'I' | 'i' => {\n   \
    \             i = \"K\".to_string();\n                skip = true;\n         \
    \   }\n            'O' | 'o' => {\n                i = \"M\".to_string();\n  \
    \              skip = true;\n            }\n            'U' | 'u' => {\n     \
    \           i = \"Q\".to_string();\n                skip = true;\n           \
    \ }\n            'a' => i = \"c\".to_string(),\n            'b' => i = \"d\".to_string(),\n\
    \            'c' => i = \"e\".to_string(),\n            'd' => i = \"f\".to_string(),\n\
    \            'e' => i = \"g\".to_string(),\n            'f' => i = \"h\".to_string(),\n\
    \            'g' => i = \"i\".to_string(),\n            'h' => i = \"j\".to_string(),\n\
    \            'i' => i = \"k\".to_string(),\n            'j' => i = \"l\".to_string(),\n\
    \            'k' => i = \"m\".to_string(),\n            'l' => i = \"n\".to_string(),\n\
    \            'm' => i = \"o\".to_string(),\n            'n' => i = \"p\".to_string(),\n\
    \            'o' => i = \"q\".to_string(),\n            'p' => i = \"r\".to_string(),\n\
    \            'q' => i = \"s\".to_string(),\n            'r' => i = \"t\".to_string(),\n\
    \            's' => i = \"u\".to_string(),\n            't' => i =", "  let mut\
    \ encoded = String::new();\n  let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n  let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n  for ch\
    \ in message.chars() {\n    let ch_string = ch.to_string();\n    let ch_lower\
    \ = ch_string.to_lowercase();\n    if vowels.contains(&ch_lower.chars().nth(0).unwrap())\
    \ {\n      let mut index = alphabet.iter().position(|&x| x == ch_lower.chars().nth(0).unwrap()).unwrap();\n\
    \      index += 2;\n      if index > alphabet.len() - 1 {\n        index -= alphabet.len();\n\
    \      }\n      encoded.push(alphabet[index]);\n    } else {\n      encoded.push(ch);\n\
    \    }\n  }\n  encoded", "    let mut result = String::new();\n    let alphabet\
    \ = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n    \
    \    let mut index = alphabet.iter().position(|&r| r == letter).unwrap();\n  \
    \      if vowels.contains(&letter) {\n            if index + 2 >= alphabet.len()\
    \ {\n                index = 0 + (index + 2 - alphabet.len());\n            }\
    \ else {\n                index += 2;\n            }\n        }\n        if letter.is_lowercase()\
    \ {\n            result.push(alphabet[index].to_ascii_uppercase());\n        }\
    \ else {\n            result.push(alphabet[index]);\n        }\n    }\n    result",
  "    let mut encoded_message = String::new();\n    let vowels = \"aeiou\";\n   \
    \ for c in message.chars() {\n        if c.is_lowercase() {\n            encoded_message.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  for (i, c) in encoded_message.chars().enumerate() {\n        if vowels.contains(c)\
    \ {\n            let vowel_idx = vowels.find(c).unwrap();\n            let encoded_vowel_idx\
    \ = (vowel_idx + 2) % 5;\n            let encoded_vowel = vowels.chars().nth(encoded_vowel_idx).unwrap();\n\
    \            encoded_message.replace_range(i..=i, &encoded_vowel.to_string());\n\
    \        }\n    }\n    encoded_message", "    let mut encoded = String::from(\"\
    \");\n    let mut vowel_index = 0;\n    for character in message.chars() {\n \
    \       match character {\n            'a' => {\n                encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n                vowel_index += 1;\n            },\n\
    \            'e' => {\n                encoded.push(VOWELS[(vowel_index + 2) %\
    \ VOWELS.len()]);\n                vowel_index += 1;\n            },\n       \
    \     'i' => {\n                encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n\
    \                vowel_index += 1;\n            },\n            'o' => {\n   \
    \             encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n      \
    \          vowel_index += 1;\n            },\n            'u' => {\n         \
    \       encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n            \
    \    vowel_index += 1;\n            },\n            character => {\n         \
    \       if character.is_uppercase() {\n                    encoded.push(character.to_lowercase().next().unwrap());\n\
    \                } else {\n                    encoded.push(character.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        }\n    }\n    encoded", "    let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut encoded_message = String::new();\n\
    \    for ch in message.chars() {\n        match ch {\n            'a' => encoded_message.push_str(\"\
    c\"),\n            'e' => encoded_message.push_str(\"i\"),\n            'i' =>\
    \ encoded_message.push_str(\"m\"),\n            'o' => encoded_message.push_str(\"\
    s\"),\n            'u' => encoded_message.push_str(\"y\"),\n            'A' =>\
    \ encoded_message.push_str(\"C\"),\n            'E' => encoded_message.push_str(\"\
    I\"),\n            'I' => encoded_message.push_str(\"M\"),\n            'O' =>\
    \ encoded_message.push_str(\"S\"),\n            'U' => encoded_message.push_str(\"\
    Y\"),\n            _ => encoded_message.push(ch),\n        }\n    }\n    encoded_message",
  "    let mut output = String::new();\n    let mut chars = message.chars();\n   \
    \ while let Some(c) = chars.next() {\n        if c.is_ascii_lowercase() {\n  \
    \          output.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            output.push(c.to_ascii_lowercase());\n        } else {\n    \
    \        output.push(c);\n        }\n    }\n    output", "    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut encode_message = String::new();\n    for letter\
    \ in message.chars() {\n        if letter.is_alphabetic() {\n            if letter.is_lowercase()\
    \ {\n                if let Some(vowel) = vowels.iter().position(|&x| x == letter)\
    \ {\n                    let pos = (vowel + 2) % vowels.len();\n             \
    \       encode_message.push(vowels[pos]);\n                } else {\n        \
    \            encode_message.push(letter.to_uppercase().next().unwrap());\n   \
    \             }\n            } else {\n                if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter.to_lowercase().next().unwrap()) {\n                    let pos =\
    \ (vowel + 2) % vowels.len();\n                    encode_message.push(vowels[pos].to_uppercase().next().unwrap());\n\
    \                } else {\n                    encode_message.push(letter.to_lowercase().next().unwrap());\n\
    \                }\n            }\n        } else {\n            encode_message.push(letter);\n\
    \        }\n    }\n    encode_message", "    let mut result = String::from(\"\"\
    );\n    let vowels = String::from(\"aeiou\");\n    for c in message.chars() {\n\
    \        if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            if vowels.contains(c)\
    \ {\n                let index = c as u8 - 'a' as u8;\n                result.push((index\
    \ + 2) as char);\n            } else {\n                result.push(c);\n    \
    \        }\n        }\n    }\n    result", "    let mut output = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n\
    \        match c {\n            x if is_vowel(x, &vowels) => output.push(encode_vowel(x)),\n\
    \            x if x.is_lowercase() => output.push(x.to_uppercase().next().unwrap()),\n\
    \            x if x.is_uppercase() => output.push(x.to_lowercase().next().unwrap()),\n\
    \            _ => output.push(c),\n        }\n    }\n    output", "    let message_chars:\
    \ Vec<char> = message.chars().collect();\n    let mut encoded_message = String::new();\n\
    \    for c in message_chars {\n        let mut swap_lower = false;\n        let\
    \ mut swap_upper = false;\n        if c.is_lowercase() {\n            swap_lower\
    \ = true;\n        } else if c.is_uppercase() {\n            swap_upper = true;\n\
    \        }\n        let mut result = c as u8;\n        if c == 'a' || c == 'A'\
    \ {\n            result = result + 2;\n        } else if c == 'e' || c == 'E'\
    \ {\n            result = result + 2;\n        } else if c == 'i' || c == 'I'\
    \ {\n            result = result + 2;\n        } else if c == 'o' || c == 'O'\
    \ {\n            result = result + 2;\n        } else if c == 'u' || c == 'U'\
    \ {\n            result = result + 2;\n        } else if c == 'y' || c == 'Y'\
    \ {\n            result = result + 2;\n        } else {\n            result =\
    \ result + 1;\n        }\n        let mut result_char = result as char;\n    \
    \    if swap_lower {\n            result_char = result_char.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        } else if swap_upper {\n            result_char = result_char.to_uppercase().collect::<Vec<char>>()[0];\n\
    \        }\n        encoded_message.push(result_char);\n    }\n    encoded_message",
  '    message.chars().map(|c| swap_case(vowel_shift(c))).collect()', '    unimplemented!();',
  '    unimplemented!()', "    let mut result = message.chars().map(|c| match c {\n\
    \        'a' | 'A' => 'C',\n        'e' | 'E' => 'G',\n        'i' | 'I' => 'K',\n\
    \        'o' | 'O' => 'M',\n        'u' | 'U' => 'Q',\n        'y' | 'Y' => 'U',\n\
    \        _ => c,\n    }).collect::<String>();\n    let mut index = 0;\n    for\
    \ c in result.chars() {\n        let case = c.is_uppercase();\n        result.remove(index);\n\
    \        let c_uppercase = if case {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        };\n\
    \        result.insert(index, c_uppercase);\n        index += 1;\n    }\n    result",
  "    let mut encoded_message = message.chars().map(|c| encode_char(c)).collect::<String>();\n\
    \    return encoded_message;", "    let mut encoded = String::from(\"\");\n  \
    \  for c in message.chars() {\n        if c.is_ascii_uppercase() {\n         \
    \   encoded.push(c.to_ascii_lowercase());\n        } else if c.is_ascii_lowercase()\
    \ {\n            encoded.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         encoded.push(c);\n        }\n    }\n    return encoded;", "    let mut\
    \ result = String::new();\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    for c in message.chars() {\n        if c.is_alphabetic() {\n         \
    \   if c.is_uppercase() {\n                if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n                    result.push(\n                        c.to_lowercase()\n\
    \                            .to_string()\n                            .chars()\n\
    \                            .nth(1)\n                            .unwrap()\n\
    \                            .to_uppercase()\n                            .next()\n\
    \                            .unwrap(),\n                    );\n            \
    \    } else {\n                    result.push(c.to_lowercase().next().unwrap());\n\
    \                }\n            } else {\n                if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n                    result.push(\n                        c.to_lowercase()\n\
    \                            .to_string()\n                            .chars()\n\
    \                            .nth(1)\n                            .unwrap()\n\
    \                            .next()\n                            .unwrap(),\n\
    \                    );\n                } else {\n                    result.push(c.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        }\n    }\n    result", "    message.to_uppercase()\n\
    \        .chars()\n        .map(|c| {\n            if !c.is_alphabetic() {\n \
    \               c\n            } else {\n                let mut c = c as i8;\n\
    \                if c > 'Z' as i8 {\n                    c -= 32;\n          \
    \      }\n                c += 2;\n                c = (c - 'A' as i8) % 26 +\
    \ 'A' as i8;\n                c as u8 as char\n            }\n        })\n   \
    \     .collect()", '    unimplemented!()', "    //todo!()\n    message.chars().map(|c|\
    \ encode_char(c)).collect()", '    unimplemented!()', "    let mut encoded_message\
    \ = String::new();\n    for letter in message.chars() {\n        encoded_message.push(if\
    \ letter.is_ascii_lowercase() {\n            let letter_idx = letter.to_ascii_lowercase()\
    \ as u8 - b'a';\n            let encoded_letter_idx = match letter_idx {\n   \
    \             0...8 => (letter_idx + 2) % 26,\n                9...15 => letter_idx\
    \ + 2,\n                16...25 => (letter_idx + 2) % 26,\n                _ =>\
    \ panic!(\"letter index out of range 0...25 ({})\", letter_idx),\n           \
    \ };\n            (encoded_letter_idx + b'a') as char\n        } else {\n    \
    \        let letter_idx = letter.to_ascii_uppercase() as u8 - b'A';\n        \
    \    let encoded_letter_idx = match letter_idx {\n                0...8 => (letter_idx\
    \ + 2) % 26,\n                9...15 => letter_idx + 2,\n                16...25\
    \ => (letter_idx + 2) % 26,\n                _ => panic!(\"letter index out of\
    \ range 0...25 ({})\", letter_idx),\n            };\n            (encoded_letter_idx\
    \ + b'A') as char\n        });\n    }\n    encoded_message", "    message.chars().map(|c|\
    \ {\n        if c == ' ' {\n            ' '\n        } else {\n            let\
    \ c = c.to_ascii_lowercase();\n            let c = match c {\n               \
    \ 'a' => 'c',\n                'e' => 'g',\n                'i' => 'k',\n    \
    \            'o' => 'q',\n                'u' => 'y',\n                'y' =>\
    \ 'a',\n                _ => (c as u8 + 2) as char,\n            };\n        \
    \    c.to_ascii_uppercase()\n        }\n    }).collect()", "    let mut encoded\
    \ = String::new();\n    let mut chars = message.chars();\n    while let Some(c)\
    \ = chars.next() {\n        if c.is_ascii_alphabetic() {\n            if let Some(vowel)\
    \ = encode_vowel(c) {\n                encoded.push(vowel);\n            } else\
    \ {\n                encoded.push(c.to_ascii_uppercase());\n            }\n  \
    \      } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    message.chars().map(|c| {\n        if c == ' ' {\n            ' '\n       \
    \ } else {\n            let idx = match c.is_uppercase() {\n                true\
    \ => ALPHABET.to_uppercase().find(c).unwrap(),\n                false => ALPHABET.to_lowercase().find(c).unwrap(),\n\
    \            };\n            let idx = idx + 2;\n            if idx < 26 {\n \
    \               ALPHABET[idx..].chars().next().unwrap()\n            } else {\n\
    \                ALPHABET[idx - 26..].chars().next().unwrap()\n            }\n\
    \        }\n    }).collect()", "    // your code here\n    unimplemented!();",
  '    unimplemented!();', "    let mut result = message.to_ascii_uppercase();\n \
    \   let chars = \"AEIOU\".chars();\n    for c in chars {\n        result = result.replace(c,\
    \ &((c as u8 + 2) as char).to_string());\n    }\n    result", "    let vowels\
    \ = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\",\
    \ \"U\"\n    ];\n    let mut encoded_message = String::new();\n    for ch in message.chars()\
    \ {\n        let mut encoded_ch = match ch {\n            'a'...'z' => (ch as\
    \ u8 + 2) as char,\n            'A'...'Z' => (ch as u8 + 2) as char,\n       \
    \     _ => ch\n        };\n        if encoded_ch > 'z' {\n            encoded_ch\
    \ = (encoded_ch as u8 - 26) as char;\n        }\n        if encoded_ch > 'Z' &&\
    \ encoded_ch < 'a' {\n            encoded_ch = (encoded_ch as u8 - 26) as char;\n\
    \        }\n        if vowels.contains(&encoded_ch.to_string().as_str()) {\n \
    \           encoded_ch = match encoded_ch {\n                'a'...'z' => (encoded_ch\
    \ as u8 + 2) as char,\n                'A'...'Z' => (encoded_ch as u8 + 2) as\
    \ char,\n                _ => encoded_ch\n            };\n            if encoded_ch\
    \ > 'z' {\n                encoded_ch = (encoded_ch as u8 - 26) as char;\n   \
    \         }\n            if encoded_ch > 'Z' && encoded_ch < 'a' {\n         \
    \       encoded_ch = (encoded_ch as u8 - 26) as char;\n            }\n       \
    \ }\n        encoded_message.push(encoded_ch);\n    }\n    encoded_message", " \
    \   let mut chars = message.chars();\n    let mut encoded = String::new();\n \
    \   while let Some(c) = chars.next() {\n        let mut char_to_add = encode_character(c);\n\
    \        encoded.push(char_to_add);\n    }\n    encoded", "    let alphabet =\
    \ vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let uppercase_alphabet\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let uppercase_vowels = vec!['A', 'E',\
    \ 'I', 'O', 'U'];\n    let mut message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut alphabet_index = 0;\n    let mut is_uppercase: bool = false;\n  \
    \  let mut encoded_message = String::new();\n\n    for ch in message_chars.iter()\
    \ {\n        is_uppercase = false;\n        if uppercase_alphabet.contains(ch)\
    \ {\n            alphabet_index = match uppercase_alphabet.iter().position(|&x|\
    \ x == *ch) {\n                Some(number) => number,\n                None =>\
    \ 0,\n            };\n            is_uppercase = true;\n        } else {\n   \
    \         alphabet_index = match alphabet.iter().position(|&x| x == *ch) {\n \
    \               Some(number) => number,\n                None => 0,\n        \
    \    };\n        }\n\n        if is_uppercase {\n            if uppercase_vowels.contains(ch)\
    \ {\n                encoded_message.push(uppercase_alphabet[(alphabet_index +\
    \ 3) % 26]);\n            } else {\n                encoded_message.push(uppercase_alphabet[alphabet_index]);\n\
    \            }\n", "  let mut result = message.chars().collect::<Vec<char>>();\n\
    \  for i in 0..result.len() {\n    if result[i].is_ascii_alphabetic() {\n    \
    \  result[i] = result[i].to_ascii_uppercase();\n      result[i] = match result[i]\
    \ {\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n        'O'\
    \ => 'Q',\n        'U' => 'Y',\n        _ => (result[i] as u8 + 2) as char,\n\
    \      };\n    }\n  }\n  result.iter().collect()", "    let mut output = String::from(\"\
    \");\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            let next_c = \n           \
    \     match c {\n                    'a' => 'c',\n                    'e' => 'g',\n\
    \                    'i' => 'k',\n                    'o' => 'q',\n          \
    \          'u' => 'y',\n                    _ => panic!(\"Unexpected vowel\"),\n\
    \                };\n            output.push(next_c);\n        } else {\n    \
    \        output.push(c);\n        }\n    }\n    output", "    // TODO\n    String::from(\"\
    Not yet implemented\")", '    message.chars().map(encode_char).collect()', " \
    \   let mut encoded_message = message.to_uppercase();\n    let vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    for i in 0..encoded_message.len() {\n        if vowels.contains(&encoded_message.chars().nth(i).unwrap())\
    \ {\n            encoded_message.replace_range(i..i+1, &alphabet()[alphabet().iter().position(|&x|\
    \ x == encoded_message.chars().nth(i).unwrap()).unwrap() + 2].to_string());\n\
    \        }\n    }\n    encoded_message", "    // TODO: implement the function\
    \ here\n    unimplemented!()", "    // first, change case of letters\n    let\
    \ mut case_message = message.to_lowercase();\n    for c in case_message.chars_mut()\
    \ {\n        if c.is_ascii_lowercase() {\n            *c = c.to_ascii_uppercase();\n\
    \        }\n    }\n    // next, replace vowels with the letter that is 2 places\
    \ ahead of the vowel\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut new_message = String::new();\n    for c in case_message.chars() {\n\
    \        if !c.is_ascii_alphabetic() {\n            new_message.push(c);\n   \
    \     } else {\n            let alphabets = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \            let alphabets_char = alphabets.chars();\n            let mut alphabet_iter\
    \ = alphabets_char.into_iter();\n            // skip letters in alphabet_iter\
    \ and push letters ahead of vowels\n            let c_lower = c.to_ascii_lowercase();\n\
    \            if vowels.contains(&c_lower.to_string().as_str()) {\n           \
    \     for _ in 0..4 {\n                    alphabet_iter.next();\n           \
    \     }\n                new_message.push(*alphabet_iter.next().unwrap());\n \
    \           } else {\n                for _ in 0..2 {\n                    alphabet_iter.next();\n\
    \                }\n                new_message.push(*alphabet_iter.next().unwrap());\n\
    \            }\n        }\n    }\n    new_message", "    message.to_lowercase()\n\
    \        .chars()\n        .map(encode_char)\n        .collect()", "    let mut\
    \ encoded = String::new();\n    for c in message.chars() {\n        if !c.is_alphabetic()\
    \ {\n            encoded.push(c);\n            continue;\n        }\n        let\
    \ c_upper = c.to_uppercase().next().unwrap();\n        if c_upper == 'A' || c_upper\
    \ == 'E' || c_upper == 'I' || c_upper == 'O' || c_upper == 'U' {\n           \
    \ if c_upper == 'U' {\n                encoded.push('B');\n            } else\
    \ {\n                encoded.push((c_upper as u8 + 2) as char);\n            }\n\
    \        } else {\n            encoded.push(c_upper);\n        }\n    }\n    encoded",
  "    let mut result = String::new();\n    let vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    for (i, ch) in message.chars().enumerate() {\n        if vowels.contains(&ch.to_lowercase().to_string().as_str())\
    \ {\n            let position = ch.to_lowercase().to_string().as_str().to_string().as_bytes()[0]\
    \ - 97;\n            result.push(((position + 2) % 26 + 97) as char);\n      \
    \  } else {\n            result.push(ch);\n        }\n    }\n    result", '    String::from("Function
    not implemented yet!")', '    "".to_string()', "    let mut encoded_message =\
    \ String::new();\n    for c in message.chars() {\n        let (character, lower_case)\
    \ = match c {\n            'a' => ('c', false),\n            'A' => ('C', true),\n\
    \            'e' => ('g', false),\n            'E' => ('G', true),\n         \
    \   'i' => ('k', false),\n            'I' => ('K', true),\n            'o' =>\
    \ ('q', false),\n            'O' => ('Q', true),\n            'u' => ('s', false),\n\
    \            'U' => ('S', true),\n            _ => {\n                let lower_case\
    \ = (c as u8) > 96;\n                (c, lower_case)\n            }\n        };\n\
    \        let character = if lower_case { character.to_ascii_lowercase() } else\
    \ { character.to_ascii_uppercase() };\n        encoded_message.push(character);\n\
    \    }\n    encoded_message", "    let mut output = String::new();\n    let vowels\
    \ = String::from(\"AEIOUaeiou\");\n    let alphabet = String::from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    );\n    for x in message.chars() {\n        if !vowels.contains(x) {\n       \
    \     let mut new_char = x.to_ascii_uppercase();\n            let alphabet_pos\
    \ = alphabet.find(new_char).unwrap();\n            let new_pos = (alphabet_pos\
    \ + 2) % 52;\n            let new_char = alphabet.chars().nth(new_pos).unwrap();\n\
    \            output.push(new_char);\n        } else {\n            let alphabet_pos\
    \ = alphabet.find(x).unwrap();\n            let new_pos = (alphabet_pos + 2) %\
    \ 52;\n            let new_char = alphabet.chars().nth(new_pos).unwrap();\n  \
    \          output.push(new_char);\n        }\n    }\n    output", "    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut result = String::new();\n   \
    \ for ch in message.chars() {\n        if ch.is_ascii_alphabetic() {\n       \
    \     let mut new_char: char = match ch.is_ascii_lowercase() {\n             \
    \   true => alphabet[if alphabet.find(ch).unwrap() + 2 > 25 {\n              \
    \      alphabet.find(ch).unwrap() + 2 - 26\n                } else {\n       \
    \             alphabet.find(ch).unwrap() + 2\n                }],\n          \
    \      false => alphabet[if alphabet.find(ch.to_ascii_lowercase()).unwrap() +\
    \ 2 > 25 {\n                    alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2 - 26\n                } else {\n                    alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2\n                }].to_ascii_uppercase(),\n            };\n            for\
    \ vowel in \"aeiou\".chars() {\n                if vowel == new_char {\n     \
    \               match new_char {\n                        'a' => new_char = 'c',\n\
    \                        'e' => new_char = 'g',\n                        'i' =>\
    \ new_char = 'k',\n                        'o' => new_char = 'm',\n          \
    \              'u' => new_char = 'w',\n                        _ => new_char =\
    \ new_char,\n                    }\n                }\n            }\n       \
    \     result.push(new_char);\n        } else {\n            result.push(ch);\n\
    \        }\n    }\n    result", "    message.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            match c {\n                'A' => 'C',\n                'B' =>\
    \ 'D',\n                'C' => 'E',\n                'D' => 'F',\n           \
    \     'E' => 'G',\n                'F' => 'H',\n                'G' => 'I',\n\
    \                'H' => 'J',\n                'I' => 'K',\n                'J'\
    \ => 'L',\n                'K' => 'M',\n                'L' => 'N',\n        \
    \        'M' => 'O',\n                'N' => 'P',\n                'O' => 'Q',\n\
    \                'P' => 'R',\n                'Q' => 'S',\n                'R'\
    \ => 'T',\n                'S' => 'U',\n                'T' => 'V',\n        \
    \        'U' => 'W',\n                'V' => 'X',\n                'W' => 'Y',\n\
    \                'X' => 'Z',\n                'Y' => 'A',\n                'Z'\
    \ => 'B',\n                _ => c,\n            }\n        } else {\n        \
    \    match c {\n                'a' => 'c',\n                'b' => 'd',\n   \
    \             'c' => 'e',\n                'd' => 'f',\n                'e' =>\
    \ 'g',\n                'f' => 'h',\n                'g' => 'i',\n           \
    \     'h' => 'j',\n                'i' => 'k',\n                'j' => 'l',\n\
    \                'k' => 'm',\n                'l' => 'n',\n                'm'\
    \ => 'o',\n                'n' => 'p',\n                'o' => 'q',\n        \
    \        'p' => 'r',\n                'q' => 's',\n                'r' => 't',\n\
    \                's' => 'u',\n                't' => 'v',\n                'u'\
    \ => 'w',\n                'v' => 'x',\n                'w' => 'y',\n        \
    \        'x' => 'z',\n                'y' => 'a',", "    let mut encoded = String::new();\n\
    \    for ch in message.chars() {\n        let next_ch = match ch {\n         \
    \   'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n          \
    \  'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n           \
    \ 'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n            'U'\
    \ => 'W',\n            _ => ch,\n        };\n        encoded.push(next_ch);\n\
    \    }\n    encoded", '    unimplemented!()', "  message.chars().map(|c| match\
    \ c {\n    'a' => 'c',\n    'A' => 'C',\n    'e' => 'g',\n    'E' => 'G',\n  \
    \  'i' => 'k',\n    'I' => 'K',\n    'o' => 'q',\n    'O' => 'Q',\n    'u' =>\
    \ 'y',\n    'U' => 'Y',\n    'y' => 'a',\n    'Y' => 'A',\n    a => a.to_ascii_uppercase(),\n\
    \  }).collect()", "    let mut result = message.to_lowercase();\n    for (i, c)\
    \ in result.chars().enumerate() {\n        if c == 'a' {\n            result.replace_range(i..i+1,\
    \ \"c\");\n        } else if c == 'e' {\n            result.replace_range(i..i+1,\
    \ \"g\");\n        } else if c == 'i' {\n            result.replace_range(i..i+1,\
    \ \"k\");\n        } else if c == 'o' {\n            result.replace_range(i..i+1,\
    \ \"m\");\n        } else if c == 'u' {\n            result.replace_range(i..i+1,\
    \ \"o\");\n        }\n    }\n    result", "    message.to_lowercase()\n      \
    \  .chars()\n        .map(|x| {\n            match x {\n                'a' =>\
    \ 'c',\n                'e' => 'g',\n                'i' => 'k',\n           \
    \     'o' => 'q',\n                'u' => 'w',\n                x => x,\n    \
    \        }\n        })\n        .map(|x| {\n            match x {\n          \
    \      'b' => 'a',\n                'c' => 'b',\n                'd' => 'c',\n\
    \                'f' => 'e',\n                'g' => 'f',\n                'h'\
    \ => 'g',\n                'j' => 'i',\n                'k' => 'j',\n        \
    \        'l' => 'k',\n                'm' => 'l',\n                'n' => 'm',\n\
    \                'p' => 'o',\n                'q' => 'p',\n                'r'\
    \ => 'q',\n                's' => 'r',\n                't' => 's',\n        \
    \        'v' => 'u',\n                'w' => 'v',\n                'x' => 'w',\n\
    \                'y' => 'x',\n                'z' => 'y',\n                x =>\
    \ x,\n            }\n        })\n        .collect()", "    let vowels = \"aeiou\"\
    ;\n    let mut encoded = String::new();\n    for c in message.chars() {\n    \
    \    if vowels.contains(c) {\n            encoded.push(get_next_vowel(c));\n \
    \       } else {\n            encoded.push(get_opposite_case(c));\n        }\n\
    \    }\n    encoded", "    const LOWERCASE_VOWELS: [char; 5] = ['a', 'e', 'i',\
    \ 'o', 'u'];\n    const UPPERCASE_VOWELS: [char; 5] = ['A', 'E', 'I', 'O', 'U'];\n\
    \    const ALPHABET: [char; 26] = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n        's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z',\n    ];\n\n    let mut encoded = String::new();\n \
    \   for c in message.chars() {\n        let mut ch = c;\n        if ch.is_lowercase()\
    \ {\n            for vowel in LOWERCASE_VOWELS.iter() {\n                if ch\
    \ == *vowel {\n                    let idx = ALPHABET.iter().position(|&x| x ==\
    \ *vowel).unwrap();\n                    ch = ALPHABET[(idx + 2) % 26];\n    \
    \                break;\n                }\n            }\n        } else if ch.is_uppercase()\
    \ {\n            for vowel in UPPERCASE_VOWELS.iter() {\n                if ch\
    \ == *vowel {\n                    let idx = ALPHABET.iter().position(|&x| x ==\
    \ *vowel).unwrap();\n                    ch = ALPHABET[(idx + 2) % 26].to_uppercase().to_string().chars().next().unwrap();\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     encoded.push(ch);\n    }\n    encoded", "    // define a function to handle\
    \ each letter\n    fn encode_letter(ch: char) -> char {\n        // define a list\
    \ of vowels\n        const VOWELS: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n  \
    \      // check for lowercase\n        if ch.is_lowercase() {\n            //\
    \ check for vowel\n            if VOWELS.contains(&ch) {\n                // get\
    \ the next two letters in the alphabet\n                let next_letter = (ch\
    \ as u8 + 2) as char;\n                let next_letter_2 = (next_letter as u8\
    \ + 1) as char;\n                // check for z\n                if next_letter\
    \ == 'z' {\n                    return 'b';\n                }\n             \
    \   // check for zz\n                if next_letter_2 == 'z' {\n             \
    \       return 'c';\n                }\n                // return\n          \
    \      return next_letter_2;\n            }\n            // return the letter\n\
    \            return ch.to_uppercase().next().unwrap();\n        }\n        //\
    \ check for uppercase\n        if ch.is_uppercase() {\n            // check for\
    \ vowel\n            if VOWELS.contains(&ch.to_lowercase().next().unwrap()) {\n\
    \                // get the next two letters in the alphabet\n               \
    \ let next_letter = (ch as u8 + 2) as char;\n                let next_letter_2\
    \ = (next_letter as u8 + 1) as char;\n                // check for z\n       \
    \         if next_letter == 'Z' {\n                    return 'B';\n         \
    \       }\n                // check for zz\n                if next_letter_2 ==\
    \ 'Z' {\n                    return 'C';\n                }\n                //\
    \ return\n                return next_letter_2;\n            }\n            //\
    \ return the letter\n            return ch.to_lowercase().next().unwrap();\n \
    \       }\n        // return the letter\n        return ch;\n    }\n    // iterate\
    \ through letters\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        result.push(encode_letter(ch));\n    }\n    // return result\n  \
    \  return result;", "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let replace\
    \ = ['c', 'f', 'j', 'n', 'r'];\n    let mut new_message = String::new();\n   \
    \ for c in message.chars() {\n        if vowels.contains(&c) {\n            let\
    \ mut i = 0;\n            while i < 5 {\n                if c == vowels[i] {\n\
    \                    new_message.push(replace[i]);\n                    break;\n\
    \                }\n                i += 1;\n            }\n        } else if\
    \ c.is_uppercase() {\n            new_message.push(c.to_lowercase().to_string());\n\
    \        } else {\n            new_message.push(c.to_uppercase().to_string());\n\
    \        }\n    }\n    new_message", "    message.chars().map(|c| {\n        let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n        let mut c_char = c.to_ascii_lowercase();\n\
    \        if vowels.contains(&c_char) {\n            let index = vowels.iter().position(|&r|\
    \ r == c_char).unwrap();\n            c_char = match index {\n               \
    \ 0 => 'c',\n                1 => 'f',\n                2 => 'i',\n          \
    \      3 => 'l',\n                4 => 'o',\n                _ => panic!(\"failed\
    \ to find vowel\")\n            };\n        }\n        if c.is_lowercase() {\n\
    \            c_char.to_ascii_uppercase()\n        } else {\n            c_char\n\
    \        }\n    }).collect()", "    let mut result = String::from(\"\");\n   \
    \ for c in message.chars() {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                let c_uppercase = c.to_ascii_uppercase();\n             \
    \   let index = c_uppercase as usize - 65;\n                result.push(((index\
    \ + 2) % 26 + 65) as u8 as char);\n            } else {\n                let c_lowercase\
    \ = c.to_ascii_lowercase();\n                let index = c_lowercase as usize\
    \ - 97;\n                result.push(((index + 2) % 26 + 97) as u8 as char);\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result", "    message.chars().map(|char| {\n        let original_char\
    \ = char.to_lowercase().next().unwrap();\n        let ascii_code = original_char\
    \ as u8;\n        if ascii_code == b'z' {\n            (b'a' + 1) as char\n  \
    \      } else if ascii_code == b'y' {\n            (b'a' + 0) as char\n      \
    \  } else if ascii_code == b'x' {\n            (b'a' - 1) as char\n        } else\
    \ if ascii_code >= b'a' && ascii_code <= b'z' {\n            (ascii_code + 2)\
    \ as char\n        } else {\n            char\n        }\n    }).collect()", " \
    \   fn is_vowel(ch: char) -> bool {\n        vec!['a', 'e', 'i', 'o', 'u'].contains(&ch)\n\
    \    }\n\n    let letters: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n\
    \    let mut output = String::new();\n    for ch in message.chars() {\n      \
    \  if ch.is_uppercase() {\n            let index = letters.iter().position(|x|\
    \ x == &ch.to_lowercase().next().unwrap()).unwrap();\n            let ch2 = letters[(index\
    \ + 2) % letters.len()];\n            output.push(ch2.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_lowercase() {\n            let index = letters.iter().position(|x|\
    \ x == &ch).unwrap();\n            let ch2 = letters[(index + 2) % letters.len()];\n\
    \            output.push(ch2);\n        } else {\n            output.push(ch);\n\
    \        }\n    }\n    output", "    message.chars().map(|c| {\n        let next\
    \ = if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n    \
    \    } else {\n            c\n        };\n        match next {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            _ => c,\n        }\n    }).collect()",
  "    message.chars().map(|ch| {\n        if ch.is_uppercase() {\n            let\
    \ shift = ((ch as u8) - 65 + 2) % 26;\n            (shift + 65) as char\n    \
    \    } else if ch.is_lowercase() {\n            let shift = ((ch as u8) - 97 +\
    \ 2) % 26;\n            (shift + 97) as char\n        } else {\n            ch\n\
    \        }\n    }).collect()", "    let mut encoded = String::new();\n    for\
    \ c in message.chars() {\n        let c = match c {\n            'a' => 'c',\n\
    \            'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n \
    \           'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n  \
    \          'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n   \
    \         _ => c.to_ascii_uppercase(),\n        };\n        encoded.push(c);\n\
    \    }\n    encoded", "    message.chars().map(|c| {\n        match c {\n    \
    \        'a' => 'c',\n            'A' => 'C',\n            'e' => 'g',\n     \
    \       'E' => 'G',\n            'i' => 'k',\n            'I' => 'K',\n      \
    \      'o' => 'q',\n            'O' => 'Q',\n            'u' => 'y',\n       \
    \     'U' => 'Y',\n            _ => c.to_uppercase().next().unwrap()\n       \
    \ }\n    }).collect()", "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n   \
    \ let mut result = String::new();\n    for c in message.chars() {\n        if\
    \ c.is_lowercase() {\n            if vowels.contains(&c) {\n                let\
    \ idx = find_idx(c, vowels);\n                let new_char = vowels[(idx + 2)\
    \ % vowels.len()];\n                result.push(new_char);\n            } else\
    \ {\n                result.push(c.to_uppercase().next().unwrap());\n        \
    \    }\n        } else {\n            if vowels.contains(&c.to_lowercase().next().unwrap())\
    \ {\n                let idx = find_idx(c.to_lowercase().next().unwrap(), vowels);\n\
    \                let new_char = vowels[(idx + 2) % vowels.len()];\n          \
    \      result.push(new_char);\n            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        }\n    }\n    result", "    let mut encoded_message =\
    \ String::new();\n    for c in message.chars() {\n        let letter = match c\
    \ {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n \
    \           'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n  \
    \          'U' => 'W',\n            _ => c,\n        };\n        encoded_message.push(letter);\n\
    \    }\n    encoded_message", "    let vowels = \"aeiou\";\n    let mut result\
    \ = String::from(\"\");\n    for c in message.chars() {\n        let mut current_char\
    \ = String::from(\"\");\n        if vowels.contains(c) {\n            current_char.push(next_vowel(c));\n\
    \        } else {\n            current_char.push(c);\n        }\n        if current_char.as_str().is_lowercase()\
    \ {\n            current_char = current_char.to_uppercase();\n        } else {\n\
    \            current_char = current_char.to_lowercase();\n        }\n        result.push_str(current_char.as_str());\n\
    \    }\n    result", "    let encoded = message.chars().map(|c| match c {\n  \
    \      'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n\
    \        'u' => 'y',\n        'A' => 'C',\n        'E' => 'G',\n        'I' =>\
    \ 'K',\n        'O' => 'Q',\n        'U' => 'Y',\n        _ => if c.is_lowercase()\
    \ { c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap()\
    \ }\n    }).collect();\n    encoded", "    let mut chars = message.chars();\n\
    \    let mut result = String::new();\n    while let Some(c) = chars.next() {\n\
    \        if c.is_ascii_alphabetic() {\n            if c.is_ascii_uppercase() {\n\
    \                if c == 'Z' {\n                    result.push('B');\n      \
    \          } else if c == 'Y' {\n                    result.push('A');\n     \
    \           } else {\n                    let num = c as u8;\n               \
    \     let num = num + 2;\n                    let c = num as char;\n         \
    \           result.push(c);\n                }\n            } else {\n       \
    \         if c == 'z' {\n                    result.push('b');\n             \
    \   } else if c == 'y' {\n                    result.push('a');\n            \
    \    } else {\n                    let num = c as u8;\n                    let\
    \ num = num + 2;\n                    let c = num as char;\n                 \
    \   result.push(c);\n                }\n            }\n        } else {\n    \
    \        result.push(c);\n        }\n    }\n    result", "    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        let mut case = c.is_uppercase();\n\
    \        let mut c = c.to_lowercase().to_string();\n        if c == \"a\" {\n\
    \            c = \"c\".to_string();\n        } else if c == \"e\" {\n        \
    \    c = \"g\".to_string();\n        } else if c == \"i\" {\n            c = \"\
    k\".to_string();\n        } else if c == \"o\" {\n            c = \"q\".to_string();\n\
    \        } else if c == \"u\" {\n            c = \"s\".to_string();\n        }\
    \ else if c == \"y\" {\n            c = \"a\".to_string();\n        }\n      \
    \  if case {\n            encoded.push_str(&c.to_uppercase());\n        } else\
    \ {\n            encoded.push_str(&c);\n        }\n    }\n    encoded", "    let\
    \ mut chars = message.chars();\n    let mut encoded = String::new();\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    while let Some(c) = chars.next() {\n\
    \        if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n        if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            if let Some(c) = chars.next() {\n                encoded.push(c);\n\
    \            }\n        }\n    }\n    encoded", "    let mut encoded = String::new();\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            let\
    \ c = (b'a' + (c as u8 + 2 - b'a') % 26) as char;\n            encoded.push(c);\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    let mut result = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    for character in message.chars() {\n        let result_character: char;\n\
    \        if character.is_uppercase() {\n            result_character = character.to_lowercase().next().unwrap();\n\
    \        } else {\n            result_character = character.to_uppercase().next().unwrap();\n\
    \        }\n        if vowels.contains(&result_character) {\n            let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n            let mut index = alphabet.find(result_character).unwrap();\n\
    \            index += 2;\n            if index > 25 {\n                index -=\
    \ 26;\n            }\n            result.push(alphabet.chars().nth(index).unwrap());\n\
    \        } else {\n            result.push(result_character);\n        }\n   \
    \ }\n    result", "    // break the message into a vector of chars\n    let message:\
    \ Vec<char> = message.chars().collect();\n    // iterate the message, swapping\
    \ case and replacing each char\n    let encoded_message: String = message.iter().map(|c|\
    \ {\n        // println!(\"c: {}\", c);\n        let c = if c.is_lowercase() {\n\
    \            c.to_uppercase().collect::<Vec<char>>()[0]\n        } else {\n  \
    \          c.to_lowercase().collect::<Vec<char>>()[0]\n        };\n        //\
    \ println!(\"swapped case: {}\", c);\n        // encode each vowel\n        if\
    \ VOWELS.contains(&c) {\n            let mut encode_char = c as u8 + 2;\n    \
    \        // println!(\"{} is a vowel, encoding it\", c);\n            // if we're\
    \ past Z, wrap around to the beginning\n            if encode_char > 90 {\n  \
    \              encode_char = 65 + (encode_char - 90);\n            }\n       \
    \     // return the resulting char\n            (encode_char as char).to_string()\n\
    \        } else {\n            // not a vowel, return original char\n        \
    \    c.to_string()\n        }\n    }).collect();\n    encoded_message", "    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let alphabet = (b'a'..=b'z').collect::<Vec<u8>>();\n\
    \    let mut result = message.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            (c as u8 + 32) as char\n        } else {\n            c\n   \
    \     }\n    }).collect::<String>();\n    for vowel in vowels {\n        if let\
    \ Some(idx) = alphabet.iter().position(|c| *c == vowel as u8) {\n            let\
    \ idx = if idx == alphabet.len() - 1 {\n                0\n            } else\
    \ if idx == alphabet.len() - 2 {\n                1\n            } else {\n  \
    \              idx + 2\n            };\n            result = result.replace(vowel,\
    \ alphabet[idx] as char);\n        }\n    }\n    result", "    let lowercase =\
    \ \"abcdefghijklmnopqrstuvwxyz\";\n    let uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n    let mut encoded = String::new();\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if lowercase.contains(c) {\n            encoded.push(match c {\n\
    \                'a' => 'c',\n                'e' => 'g',\n                'i'\
    \ => 'k',\n                'o' => 'q',\n                'u' => 'w',\n        \
    \        _ => lowercase.chars().nth((lowercase.find(c).unwrap() + 2) % 26).unwrap(),\n\
    \            });\n        } else if uppercase.contains(c) {\n            encoded.push(match\
    \ c {\n                'A' => 'C',\n                'E' => 'G',\n            \
    \    'I' => 'K',\n                'O' => 'Q',\n                'U' => 'W',\n \
    \               _ => uppercase.chars().nth((uppercase.find(c).unwrap() + 2) %\
    \ 26).unwrap(),\n            });\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded", '    return String::from("")', "    message.chars().map(|c|\
    \ {\n        let is_upper = c.is_uppercase();\n        let char_pos = encode_character(c);\n\
    \        let char_pos = (char_pos + 2) % 26;\n        let c = letter_from_char_pos(char_pos);\n\
    \        if is_upper { c.to_uppercase().next().unwrap() } else { c }\n    }).collect()",
  "    message.chars().map(|c| {\n        match c {\n            'a'...'y' => char::from(((c\
    \ as u8 - b'a' + 2) % 26) + b'a'),\n            'A'...'Y' => char::from(((c as\
    \ u8 - b'A' + 2) % 26) + b'A'),\n            _ => c,\n        }\n    }).collect()",
  "    let mut encoded = String::from(\"\");\n    for c in message.chars() {\n   \
    \     if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message =\
    \ String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.push(((c as u8 + 2) as char));\n        } else\
    \ {\n            encoded_message.push(c);\n        }\n    }\n    encoded_message",
  "    let mut encoded = String::new();\n    for c in message.chars() {\n        if\
    \ (c.is_ascii_lowercase() && c != 'y') || (c.is_ascii_uppercase() && c != 'Y')\
    \ {\n            encoded.push(c.to_ascii_uppercase());\n        } else if c ==\
    \ 'y' || c == 'Y' {\n            encoded.push('B');\n        } else if c == 'z'\
    \ || c == 'Z' {\n            encoded.push('C');\n        } else {\n          \
    \  encoded.push(c);\n        }\n    }\n    encoded", "    let vowels = [false,\
    \ false, true, false, true, false, false, true, false, false, false, true, false,\
    \ true, false, false, true, false, false, false, true, false, true, false, false,\
    \ true, false, false];\n    let mut message_bytes = message.into_bytes();\n  \
    \  let vowels_count = message_bytes.iter().filter(|&&b| vowels[(b - 97) as usize]).count();\n\
    \    message_bytes.reserve(vowels_count * 2);\n    let mut last_index = message_bytes.len()\
    \ - 1;\n    for _ in 0..vowels_count {\n        message_bytes.push(0);\n    }\n\
    \    for i in (0..last_index).rev() {\n        let item = message_bytes[i];\n\
    \        let new_item = if vowels[(item - 97) as usize] {\n            item +\
    \ 2\n        } else {\n            item\n        };\n        message_bytes[last_index]\
    \ = new_item;\n        last_index -= 1;\n    }\n    if vowels[(message_bytes[0]\
    \ - 97) as usize] {\n        message_bytes[last_index] = message_bytes[0] + 2;\n\
    \    } else {\n        message_bytes[last_index] = message_bytes[0];\n    }\n\
    \    for b in &mut message_bytes {\n        if *b < 97 {\n            *b += 26;\n\
    \        } else if *b > 122 {\n            *b -= 26;\n        }\n        if *b\
    \ > 90 && *b < 97 {\n            *b -= 26;\n        }\n    }\n    unsafe {\n \
    \       String::from_utf8_unchecked(message_bytes)\n    }", "    let mut encoded_str\
    \ = String::new();\n    let mut swap = true;\n    for c in message.chars() {\n\
    \        if c.is_alphabetic() {\n            swap = !swap;\n            if swap\
    \ {\n                encoded_str.push(c.to_ascii_uppercase());\n            }\
    \ else {\n                encoded_str.push(c.to_ascii_lowercase());\n        \
    \    }\n        } else {\n            encoded_str.push(c);\n        }\n    }\n\
    \    encoded_str", '    unimplemented!()', "    let mut encoded = String::new();\n\
    \    let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut alphabet_index = 0;\n    let mut count_index = 0;\n    let message_chars:\
    \ Vec<char> = message.chars().collect();\n    for i in message_chars {\n     \
    \   for x in alphabet.iter() {\n            count_index += 1;\n            if\
    \ i == *x {\n                alphabet_index = count_index;\n            }\n  \
    \      }\n        count_index = 0;\n        if alphabet_index > 0 {\n        \
    \    let encoded_letter = match i {\n                'a' => 'c',\n           \
    \     'b' => 'd',\n                'c' => 'e',\n                'd' => 'f',\n\
    \                'e' => 'g',\n                'f' => 'h',\n                'g'\
    \ => 'i',\n                'h' => 'j',\n                'i' => 'k',\n        \
    \        'j' => 'l',\n                'k' => 'm',\n                'l' => 'n',\n\
    \                'm' => 'o',\n                'n' => 'p',\n                'o'\
    \ => 'q',\n                'p' => 'r',\n                'q' => 's',\n        \
    \        'r' => 't',\n                's' => 'u',\n                't' => 'v',\n\
    \                'u' => 'w',\n                'v' => 'x',\n                'w'\
    \ => 'y',\n                'x' => 'z',\n                'y' => 'a',\n        \
    \        'z' => 'b',\n                _ => '0',\n            };\n            encoded.push(encoded_letter);\n\
    \        } else {\n            encoded.push(i);\n        }\n        alphabet_index\
    \ = 0;\n    }\n    encoded", "    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           let next = c.to_lowercase().next().unwrap();\n                if \"\
    aeiou\".contains(next) {\n                    let next = if next == 'u' { 'a'\
    \ } else { next.wrapping_add(2) };\n                    res.push(next.to_ascii_uppercase());\n\
    \                } else {\n                    res.push(next.to_ascii_uppercase());\n\
    \                }\n            } else {\n                let next = c.to_lowercase().next().unwrap();\n\
    \                if \"aeiou\".contains(next) {\n                    let next =\
    \ if next == 'u' { 'a' } else { next.wrapping_add(2) };\n                    res.push(next);\n\
    \                } else {\n                    res.push(next);\n             \
    \   }\n            }\n        } else {\n            res.push(c);\n        }\n\
    \    }\n    res", "    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let lowercase = c.to_lowercase().to_string();\n        if lowercase\
    \ == \"a\" {\n            result.push_str(\"c\");\n        } else if lowercase\
    \ == \"e\" {\n            result.push_str(\"g\");\n        } else if lowercase\
    \ == \"i\" {\n            result.push_str(\"k\");\n        } else if lowercase\
    \ == \"o\" {\n            result.push_str(\"q\");\n        } else if lowercase\
    \ == \"u\" {\n            result.push_str(\"s\");\n        } else if lowercase\
    \ == \"y\" {\n            result.push_str(\"a\");\n        } else {\n        \
    \    result.push_str(&c.to_uppercase().to_string());\n        }\n    }\n    result",
  "    let mut encoded = String::new();\n    for c in message.chars() {\n        let\
    \ mut c = match c {\n            'A' => 'C',\n            'E' => 'G',\n      \
    \      'I' => 'K',\n            'O' => 'Q',\n            'U' => 'S',\n       \
    \     'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n        \
    \    'o' => 'q',\n            'u' => 's',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        encoded.push(c);\n    }\n    encoded", "    let mut result\
    \ = String::new();\n    for c in message.chars() {\n        let mut char = c;\n\
    \        if c.is_alphabetic() {\n            char = c.to_ascii_uppercase();\n\
    \        }\n        match char {\n            'A' => result.push('C'),\n     \
    \       'E' => result.push('G'),\n            'I' => result.push('K'),\n     \
    \       'O' => result.push('Q'),\n            'U' => result.push('S'),\n     \
    \       _ => result.push(char),\n        }\n    }\n    result", "    let mut encoded\
    \ = String::new();\n    let mut chars = message.chars();\n    let shift = (('z'\
    \ as u8 - 'a' as u8) / 2) as u8;\n    while let Some(c) = chars.next() {\n   \
    \     if c.is_alphabetic() {\n            let upper = c.is_uppercase();\n    \
    \        let mut code = c.to_ascii_lowercase().to_string();\n            let first\
    \ = code.pop().unwrap();\n            if first == 'u' {\n                let next\
    \ = chars.next().unwrap();\n                encoded.push(next);\n            }\
    \ else {\n                let offset = ('a' as u8 + (first as u8 + shift)) as\
    \ char;\n                encoded.push(offset);\n            }\n            if\
    \ upper {\n                encoded.make_ascii_uppercase();\n            }\n  \
    \      } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    let mut encoded_message = String::new();\n    for letter in message.chars()\
    \ {\n        if letter.is_alphabetic() {\n            if let Some(next_letter)\
    \ = letter.to_lowercase().next() {\n                if is_vowel(next_letter) {\n\
    \                    if let Some(next_next_letter) = next_letter.to_lowercase().next()\
    \ {\n                        if is_vowel(next_next_letter) {\n               \
    \             encoded_message.push(next_next_letter.to_uppercase().next().unwrap());\n\
    \                        } else {\n                            encoded_message.push(next_next_letter.to_uppercase().next().unwrap());\n\
    \                        }\n                    }\n                } else {\n\
    \                    encoded_message.push(next_letter.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        } else {\n            encoded_message.push(letter);\n\
    \        }\n    }\n    encoded_message", "    let mut encrypted_message = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars()\
    \ {\n        match letter {\n            'a' => encrypted_message.push('c'),\n\
    \            'e' => encrypted_message.push('g'),\n            'i' => encrypted_message.push('k'),\n\
    \            'o' => encrypted_message.push('m'),\n            'u' => encrypted_message.push('q'),\n\
    \            'A' => encrypted_message.push('C'),\n            'E' => encrypted_message.push('G'),\n\
    \            'I' => encrypted_message.push('K'),\n            'O' => encrypted_message.push('M'),\n\
    \            'U' => encrypted_message.push('Q'),\n            _ => encrypted_message.push(letter),\n\
    \        }\n    }\n    encrypted_message", "    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        if is_vowel(character) {\n  \
    \          encoded_message.push(encode_vowel(character));\n        } else {\n\
    \            encoded_message.push(encode_consonant(character));\n        }\n \
    \   }\n    encoded_message", '    unimplemented!();', "    let mut encoded_str\
    \ = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for character\
    \ in message.chars() {\n        if character.is_alphabetic() {\n            if\
    \ character.is_uppercase() {\n                encoded_str.push(character.to_lowercase().to_string().parse::<char>().unwrap());\n\
    \            } else {\n                encoded_str.push(character.to_uppercase().to_string().parse::<char>().unwrap());\n\
    \            }\n        } else {\n            encoded_str.push(character);\n \
    \       }\n    }\n    let mut final_str = String::new();\n    for character in\
    \ encoded_str.chars() {\n        let mut push_character = character;\n       \
    \ if vowels.contains(&character) {\n            let mut next_index = character\
    \ as usize;\n            if character == 'u' {\n                next_index = 0;\n\
    \            } else {\n                next_index += 2;\n            }\n     \
    \       push_character = vowels[next_index];\n        }\n        final_str.push(push_character);\n\
    \    }\n    final_str", "    let result = message.chars().map(|c| {\n        match\
    \ c {\n            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n\
    \            'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n \
    \           'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n  \
    \          'U' => 'W',\n            _ => c.to_ascii_uppercase(),\n        }\n\
    \    }).collect::<String>();\n    result", "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            if c.is_lowercase() {\n\
    \                let encoded_letter = match c {\n                    'a' => 'c',\n\
    \                    'b' => 'd',\n                    'c' => 'e',\n          \
    \          'd' => 'f',\n                    'e' => 'g',\n                    'f'\
    \ => 'h',\n                    'g' => 'i',\n                    'h' => 'j',\n\
    \                    'i' => 'k',\n                    'j' => 'l',\n          \
    \          'k' => 'm',\n                    'l' => 'n',\n                    'm'\
    \ => 'o',\n                    'n' => 'p',\n                    'o' => 'q',\n\
    \                    'p' => 'r',\n                    'q' => 's',\n          \
    \          'r' => 't',\n                    's' => 'u',\n                    't'\
    \ => 'v',\n                    'u' => 'w',\n                    'v' => 'x',\n\
    \                    'w' => 'y',\n                    'x' => 'z',\n          \
    \          'y' => 'a',\n                    'z' => 'b',\n                    _\
    \ => c,\n                };\n                encoded_message.push(encoded_letter);\n\
    \            } else {\n                let encoded_letter = match c {\n      \
    \              'A' => 'C',\n                    'B' => 'D',\n                \
    \    'C' => 'E',\n                    'D' => 'F',\n                    'E' =>\
    \ 'G',\n                    'F' => 'H',\n                    'G' => 'I',\n   \
    \                 'H' => 'J',\n                    'I' => 'K',\n             \
    \       'J' => 'L',\n                    'K' => 'M',\n                    'L'\
    \ => 'N',\n                    'M' => 'O',\n                    'N' => 'P',\n\
    \                    'O' => 'Q',\n                    'P' => 'R',\n          \
    \          'Q' => 'S',\n                    'R' => 'T", "    // write your code\
    \ here\n    let mut encoded_msg = message.clone();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut iter = encoded_msg.chars();\n    let mut new_str\
    \ = String::new();\n    while let Some(curr_char) = iter.next() {\n        if\
    \ vowels.contains(&curr_char) {\n            let mut next_char = iter.next().unwrap();\n\
    \            if next_char == 'a' {\n                next_char = 'c';\n       \
    \     } else if next_char == 'e' {\n                next_char = 'i';\n       \
    \     } else if next_char == 'i' {\n                next_char = 'o';\n       \
    \     } else if next_char == 'o' {\n                next_char = 'u';\n       \
    \     } else if next_char == 'u' {\n                next_char = 'a';\n       \
    \     }\n            new_str.push(next_char);\n        } else {\n            if\
    \ curr_char.is_ascii_lowercase() {\n                new_str.push(curr_char.to_ascii_uppercase());\n\
    \            } else {\n                new_str.push(curr_char.to_ascii_lowercase());\n\
    \            }\n        }\n    }\n    new_str", '    unimplemented!()', "    let\
    \ mut new_message = String::new();\n    for ch in message.chars() {\n        if\
    \ ch.is_ascii_uppercase() {\n            new_message.push(ch.to_ascii_lowercase());\n\
    \        } else if ch.is_ascii_lowercase() {\n            new_message.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            new_message.push(ch);\n        }\n    }\n    new_message",
  '    unimplemented!()', "    let s: String = message.chars().map(|c| match c {\n\
    \        'a' | 'A' => \"c\",\n        'e' | 'E' => \"g\",\n        'i' | 'I' =>\
    \ \"k\",\n        'o' | 'O' => \"s\",\n        'u' | 'U' => \"y\",\n        '\
    \ ' => \" \",\n        _ => c.to_ascii_uppercase().to_string().as_str(),\n   \
    \ }).collect();\n    return s;", "    message.to_lowercase()\n        .chars()\n\
    \        .map(|x| {\n            match x {\n                'a' => 'c',\n    \
    \            'e' => 'g',\n                'i' => 'k',\n                'o' =>\
    \ 'q',\n                'u' => 'w',\n                'y' => 'a',\n           \
    \     _ => x,\n            }\n        })\n        .collect()", "    message.chars().map(|letter|\
    \ match letter {\n        'A' | 'a' => 'C',\n        'E' | 'e' => 'G',\n     \
    \   'I' | 'i' => 'K',\n        'O' | 'o' => 'Q',\n        'U' | 'u' => 'S',\n\
    \        ' ' => ' ',\n        _ => letter.to_ascii_uppercase(),\n    }).collect()",
  "    message.chars().map(|x| {\n        let mut ch = x.to_lowercase().to_string();\n\
    \        match x {\n            'a' => ch = \"c\".to_string(),\n            'e'\
    \ => ch = \"g\".to_string(),\n            'i' => ch = \"k\".to_string(),\n   \
    \         'o' => ch = \"s\".to_string(),\n            'u' => ch = \"y\".to_string(),\n\
    \            _ => (),\n        }\n        if x.is_uppercase() {\n            ch.to_uppercase().to_string()\n\
    \        } else {\n            ch\n        }\n    }).collect()", "  let mut encoded\
    \ = String::new();\n  for c in message.chars() {\n    if c.is_alphabetic() {\n\
    \      let ascii_value = c.to_ascii_lowercase() as u8;\n      let value = match\
    \ ascii_value {\n        b'a'...b'e' => ascii_value + 3,\n        b'f'...b'j'\
    \ => ascii_value - 5,\n        b'k'...b'o' => ascii_value + 2,\n        b'p'...b't'\
    \ => ascii_value - 6,\n        b'u'...b'y' => ascii_value + 1,\n        b'z' =>\
    \ b'c',\n        _ => unreachable!()\n      };\n      encoded.push(value as char);\n\
    \    } else {\n      encoded.push(c);\n    }\n  }\n  encoded", "    let v: Vec<char>\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        if v.contains(&character) {\n\
    \            let mut index = v.iter().position(|&r| r == character).unwrap();\n\
    \            index += 2;\n            if index > v.len() - 1 {\n             \
    \   index -= v.len();\n            }\n            encoded_message.push(v[index]);\n\
    \        } else if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message", '    unimplemented!()', "    let mut\
    \ res = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for\
    \ c in message.chars() {\n        let result = if vowels.contains(&c) {\n    \
    \        (b'a' + ((c as u8) - b'a' + 2) % 26) as char\n        } else {\n    \
    \        c.to_uppercase().next().unwrap()\n        };\n        res.push(result);\n\
    \    }\n    res", "    let mut encoded_message = String::new();\n    for c in\
    \ message.chars() {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                encoded_message.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \            } else {\n                encoded_message.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(c);\n     \
    \   }\n    }\n    encoded_message", "    let alphabet = String::from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    let vowels = String::from(\"AEIOU\");\n    let mut message = message.to_uppercase();\n\
    \    let mut encoded_message = String::new();\n    let mut found_vowel = false;\n\
    \    for ch in message.chars() {\n        if !found_vowel {\n            if vowels.contains(ch)\
    \ {\n                found_vowel = true;\n                for i in 0..alphabet.len()\
    \ {\n                    if alphabet.chars().nth(i).unwrap() == ch {\n       \
    \                 let new_index = i + 2;\n                        if new_index\
    \ > alphabet.len() - 1 {\n                            encoded_message.push(alphabet.chars().nth(new_index\
    \ - alphabet.len()).unwrap());\n                        } else {\n           \
    \                 encoded_message.push(alphabet.chars().nth(new_index).unwrap());\n\
    \                        }\n                    }\n                }\n       \
    \     } else {\n                encoded_message.push(ch);\n            }\n   \
    \     } else {\n            encoded_message.push(ch);\n        }\n    }\n    encoded_message",
  "    let mut result = String::new();\n    for c in message.chars() {\n        match\
    \ c {\n            'A' => result.push('C'),\n            'E' => result.push('G'),\n\
    \            'I' => result.push('K'),\n            'O' => result.push('Q'),\n\
    \            'U' => result.push('S'),\n            'a' => result.push('c'),\n\
    \            'e' => result.push('g'),\n            'i' => result.push('k'),\n\
    \            'o' => result.push('q'),\n            'u' => result.push('s'),\n\
    \            _ => result.push(c),\n        }\n    }\n    result", '    message.chars().map(char_map).collect()',
  "    let mut encoded = String::new();\n    for letter in message.chars() {\n   \
    \     let encoded_letter = match letter {\n            'a' | 'A' => 'C',\n   \
    \         'e' | 'E' => 'G',\n            'i' | 'I' => 'K',\n            'o' |\
    \ 'O' => 'Q',\n            'u' | 'U' => 'Y',\n            letter => {\n      \
    \          match letter.is_uppercase() {\n                    true => letter.to_lowercase().to_string(),\n\
    \                    false => letter.to_uppercase().to_string(),\n           \
    \     }\n            }\n        };\n        encoded.push_str(&encoded_letter);\n\
    \    }\n    encoded", "    let encode_table = vec!['y', 'u', 'i', 'o', 'a', 'e',\
    \ 'A', 'E', 'I', 'O', 'U', 'Y'];\n    let mut message_vec: Vec<char> = message.chars().collect();\n\
    \    for i in 0..message_vec.len() {\n        match message_vec[i] {\n       \
    \     'a' => message_vec[i] = encode_table[0],\n            'e' => message_vec[i]\
    \ = encode_table[1],\n            'i' => message_vec[i] = encode_table[2],\n \
    \           'o' => message_vec[i] = encode_table[3],\n            'u' => message_vec[i]\
    \ = encode_table[4],\n            'y' => message_vec[i] = encode_table[5],\n \
    \           'A' => message_vec[i] = encode_table[6],\n            'E' => message_vec[i]\
    \ = encode_table[7],\n            'I' => message_vec[i] = encode_table[8],\n \
    \           'O' => message_vec[i] = encode_table[9],\n            'U' => message_vec[i]\
    \ = encode_table[10],\n            'Y' => message_vec[i] = encode_table[11],\n\
    \            _ => message_vec[i] = message_vec[i].to_ascii_uppercase(),\n    \
    \    }\n    }\n    message_vec.into_iter().collect()", "    let mut encoded_message\
    \ = String::new();\n    let message_characters: Vec<char> = message.chars().collect();\n\
    \    for character in message_characters {\n        if is_vowel(character) {\n\
    \            encoded_message.push(get_next_vowel(character));\n        } else\
    \ {\n            encoded_message.push(get_swapped_case(character));\n        }\n\
    \    }\n    encoded_message", "    message.chars().map(|c| match c {\n       \
    \ 'a' | 'A' => 'C',\n        'e' | 'E' => 'G',\n        'i' | 'I' => 'K',\n  \
    \      'o' | 'O' => 'Q',\n        'u' | 'U' => 'S',\n        'y' | 'Y' => 'A',\n\
    \        _ => c.to_ascii_uppercase(),\n    }).collect()", "    const ENGLISH_ALPHABET:\
    \ &'static str = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut result = String::new();\n\
    \    let mut is_lowercase = false;\n    for c in message.chars() {\n        if\
    \ c.is_lowercase() {\n            is_lowercase = true;\n        } else {\n   \
    \         is_lowercase = false;\n        }\n        if let Some(index) = ENGLISH_ALPHABET.find(c.to_lowercase().next().unwrap())\
    \ {\n            let mut index = index;\n            let replacement = if is_lowercase\
    \ {\n                index += 2;\n                ENGLISH_ALPHABET.chars().nth(index\
    \ % 26).unwrap()\n            } else {\n                index += 2;\n        \
    \        ENGLISH_ALPHABET.chars().nth(index % 26).unwrap().to_uppercase().next().unwrap()\n\
    \            };\n            if VOWELS.find(c.to_lowercase().next().unwrap()).is_some()\
    \ {\n                result.push(replacement);\n            } else {\n       \
    \         result.push(c);\n            }\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result", "    let mut result = message.to_lowercase();\n\
    \    let chars = [\n        ('a', 'c'), ('e', 'g'), ('i', 'k'), ('o', 'q'), ('u',\
    \ 'w'),\n        ('b', 'd'), ('f', 'h'), ('j', 'l'), ('p', 'r'), ('v', 'x'),\n\
    \        ('c', 'e'), ('g', 'i'), ('k', 'm'), ('q', 's'), ('w', 'y'),\n       \
    \ ('d', 'f'), ('h', 'j'), ('l', 'n'), ('r', 't'), ('x', 'z'),\n    ];\n    for\
    \ (old, new) in chars.iter() {\n        result = result.replace(old, new);\n \
    \   }\n    result.to_uppercase()", "    let message_as_vec: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for c in message_as_vec {\n\
    \        match c {\n            'a' => encoded_message.push('c'),\n          \
    \  'A' => encoded_message.push('C'),\n            'e' => encoded_message.push('g'),\n\
    \            'E' => encoded_message.push('G'),\n            'i' => encoded_message.push('k'),\n\
    \            'I' => encoded_message.push('K'),\n            'o' => encoded_message.push('q'),\n\
    \            'O' => encoded_message.push('Q'),\n            'u' => encoded_message.push('s'),\n\
    \            'U' => encoded_message.push('S'),\n            'y' => encoded_message.push('a'),\n\
    \            'Y' => encoded_message.push('A'),\n            ' ' => encoded_message.push('\
    \ '),\n            _ => encoded_message.push(c.to_uppercase().to_string().chars().next().unwrap()),\n\
    \        }\n    }\n    encoded_message", "    message.chars().map(|c| {\n    \
    \    let new_c = match c {\n            'a' => 'c',\n            'A' => 'C',\n\
    \            'e' => 'g',\n            'E' => 'G',\n            'i' => 'k',\n \
    \           'I' => 'K',\n            'o' => 'q',\n            'O' => 'Q',\n  \
    \          'u' => 'w',\n            'U' => 'W',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        new_c\n    }).collect()", "    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if is_vowel(c) {\n            result.push(vowel_next(c));\n\
    \        } else {\n            result.push(char_swap(c));\n        }\n    }\n\
    \    result", "    let mut new_message = String::new();\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        let mut new_c\
    \ = c;\n        if c.is_ascii_uppercase() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if vowels.contains(&new_c) {\n            new_c = get_vowel(new_c);\n\
    \        }\n        new_message.push(new_c);\n    }\n    new_message", "    let\
    \ mut s: Vec<char> = message.chars().collect();\n    let mut result = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in s {\n        if vowels.contains(&c)\
    \ {\n            match c {\n                'a' => result.push('c'),\n       \
    \         'e' => result.push('g'),\n                'i' => result.push('k'),\n\
    \                'o' => result.push('m'),\n                'u' => result.push('q'),\n\
    \                _ => {}\n            }\n        } else {\n            match c\
    \ {\n                'a'..='z' => result.push((c as u8 + 2) as char),\n      \
    \          'A'..='Z' => result.push((c as u8 + 2) as char),\n                _\
    \ => result.push(c),\n            }\n        }\n    }\n    result", "    // Create\
    \ a slice from the message\n    let message_bytes = message.as_bytes();\n    //\
    \ Create an empty String\n    let mut encoded = String::new();\n    // Use match\
    \ to determine the output character\n    for &byte in message_bytes {\n      \
    \  encoded.push(match byte {\n            b'a' => 'c',\n            b'e' => 'g',\n\
    \            b'i' => 'k',\n            b'o' => 'q',\n            b'u' => 'w',\n\
    \            b'A' => 'C',\n            b'E' => 'G',\n            b'I' => 'K',\n\
    \            b'O' => 'Q',\n            b'U' => 'W',\n            b'y' => 'a',\n\
    \            b'Y' => 'A',\n            // If it's not a vowel, toggle the case\n\
    \            _ => match byte {\n                b'a'...b'z' => byte - 32,\n  \
    \              b'A'...b'Z' => byte + 32,\n                _ => byte,\n       \
    \     }\n        });\n    }\n    // Return the encoded message\n    encoded",
  '    unimplemented!()', '    String::from("TODO")', "    let vowels = \"AEIOU\"\
    ;\n    let mut chars = message.chars();\n    let mut encoded_message = String::new();\n\
    \    while let Some(char) = chars.next() {\n        let is_vowel = vowels.contains(char);\n\
    \        let mut code = char.to_ascii_uppercase();\n        if is_vowel {\n  \
    \          let mut next_vowel = code;\n            while next_vowel == code {\n\
    \                next_vowel = ((code as u8) + 2) as char;\n            }\n   \
    \         code = next_vowel;\n        }\n        encoded_message.push(code);\n\
    \    }\n    encoded_message", '    unimplemented!()', "    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if c.is_ascii_alphabetic() {\n      \
    \      if c.is_ascii_uppercase() {\n                result.push(c.to_ascii_lowercase());\n\
    \            } else {\n                result.push(c.to_ascii_uppercase());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    let mut result = String::new();\n    for c in message.chars() {\n   \
    \     match c {\n            'a' => result.push('c'),\n            'e' => result.push('g'),\n\
    \            'i' => result.push('k'),\n            'o' => result.push('q'),\n\
    \            'u' => result.push('y'),\n            'A' => result.push('C'),\n\
    \            'E' => result.push('G'),\n            'I' => result.push('K'),\n\
    \            'O' => result.push('Q'),\n            'U' => result.push('Y'),\n\
    \            _ => result.push(c),\n        }\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        if c.is_uppercase() {\n            c.to_lowercase().to_string()\n\
    \        } else if c.is_lowercase() {\n            c.to_uppercase().to_string()\n\
    \        } else {\n            c.to_string()\n        }\n    }).collect()", " \
    \   // return what you want\n    let mut encoded_message = message.clone();\n\
    \    encoded_message.make_ascii_uppercase();\n    //no characters in message,\
    \ so return empty string\n    if encoded_message.len() == 0 {\n        return\
    \ String::from(\"\");\n    }\n    let mut encoded_letter = 'A';\n    let mut prev_char\
    \ = 'A';\n    let mut encoded_message_iter = encoded_message.chars();\n    let\
    \ mut char_vec: Vec<char> = Vec::new();\n    let mut encoded_message_vec: Vec<char>\
    \ = Vec::new();\n    let mut y = -1;\n\n    for letter in encoded_message_iter\
    \ {\n        encoded_letter = letter;\n        y += 1;\n        if letter.is_ascii_uppercase()\
    \ {\n            encoded_letter = letter.to_ascii_lowercase();\n        }\n  \
    \      if prev_char.is_ascii_uppercase() {\n            prev_char = prev_char.to_ascii_lowercase();\n\
    \        }\n        if encoded_letter == 'a' {\n            encoded_letter = 'c';\n\
    \        } else if encoded_letter == 'e' {\n            encoded_letter = 'g';\n\
    \        } else if encoded_letter == 'i' {\n            encoded_letter = 'k';\n\
    \        } else if encoded_letter == 'o' {\n            encoded_letter = 'q';\n\
    \        } else if encoded_letter == 'u' {\n            encoded_letter = 'y';\n\
    \        } else if encoded_letter == 'y' {\n            encoded_letter = 'b';\n\
    \        }\n        if prev_char.is_ascii_uppercase() {\n            prev_char\
    \ = prev_char.to_ascii_lowercase();\n        }\n        if prev_char == 'a' {\n\
    \            prev_char = 'c';\n        } else if prev_char == 'e' {\n        \
    \    prev_char = 'g';\n        } else if prev_char == 'i' {\n            prev_char\
    \ = 'k';\n        } else if prev_char == 'o' {\n            prev_char = '", " \
    \   message.chars().map(|c| {\n        match c {\n            'a' => 'c',\n  \
    \          'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n   \
    \         'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n    \
    \        'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n     \
    \       _ => if c.is_uppercase() {\n                c.to_lowercase().to_string().chars().collect::<Vec<char>>()[0]\n\
    \            } else {\n                c.to_uppercase().to_string().chars().collect::<Vec<char>>()[0]\n\
    \            }\n        }\n    }).collect()", '    message.chars().map(char_encoder).collect()',
  "    // TODO - implement your code here\n    String::from(\"\")", "    // TODO:\
    \ Your answer here\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ result = String::new();\n    for i in message.chars() {\n        match i {\n\
    \            'a' => result.push('c'),\n            'e' => result.push('i'),\n\
    \            'i' => result.push('m'),\n            'o' => result.push('s'),\n\
    \            'u' => result.push('y'),\n            _ => result.push(i),\n    \
    \    }\n    }\n    result", '    return String::from("TODO: implement");', " \
    \   let vowels = \"aeiouAEIOU\";\n    let mut result = String::new();\n    for\
    \ c in message.chars() {\n        let mut letter = c;\n        if vowels.contains(c)\
    \ {\n            letter = match c {\n                'a' => 'c',\n           \
    \     'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 'y',\n                'A' => 'C',\n                'E'\
    \ => 'G',\n                'I' => 'K',\n                'O' => 'Q',\n        \
    \        'U' => 'Y',\n                _ => c,\n            }\n        }\n    \
    \    result.push(letter.to_uppercase().next().unwrap());\n    }\n    result",
  "    message.chars().map(|c| {\n        let new_char = match c {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'w',\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n \
    \           _ => c,\n        };\n        match new_char {\n            'c' | 'g'\
    \ | 'k' | 'q' | 'w' | 'C' | 'G' | 'K' | 'Q' | 'W' => new_char,\n            _\
    \ => match new_char.is_uppercase() {\n                true => new_char.to_lowercase().next().unwrap(),\n\
    \                false => new_char.to_uppercase().next().unwrap(),\n         \
    \   },\n        }\n    }).collect()", '    unimplemented!()', "    let mut encoded_message\
    \ = String::new();\n    let message_string = String::from(message);\n    let message_len\
    \ = message_string.len();\n    let vowels: Vec<char> = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut ctr = 0;\n    while ctr < message_len {\n        let ch =\
    \ message_string.chars().nth(ctr).unwrap();\n        if vowels.contains(&ch) {\n\
    \            encoded_message.push(vowels[((vowels.iter().position(|&x| x == ch).unwrap()\
    \ + 2) % 5)]);\n        } else {\n            encoded_message.push(ch);\n    \
    \    }\n        ctr += 1;\n    }\n    encoded_message", "    let vowels = \"aeiou\"\
    ;\n    let mut new_message = String::new();\n    for c in message.chars() {\n\
    \        if c.is_ascii_lowercase() {\n            let c_upper = c.to_ascii_uppercase();\n\
    \            if vowels.contains(c_upper) {\n                let index = vowels.find(c_upper).unwrap();\n\
    \                new_message.push(vowels.chars().nth(index + 2).unwrap());\n \
    \           } else {\n                new_message.push(c_upper);\n           \
    \ }\n        } else if c.is_ascii_uppercase() {\n            let c_lower = c.to_ascii_lowercase();\n\
    \            if vowels.contains(c_lower) {\n                let index = vowels.find(c_lower).unwrap();\n\
    \                new_message.push(vowels.chars().nth(index + 2).unwrap());\n \
    \           } else {\n                new_message.push(c_lower);\n           \
    \ }\n        } else {\n            new_message.push(c);\n        }\n    }\n  \
    \  new_message", "    let mut encoded = String::new();\n    let mut message_chars\
    \ = message.chars();\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_index = 0;\n    let mut next_vowel = vowels[vowels_index];\n\
    \    let mut char_iter = CharIterator::new(message_chars);\n    loop {\n     \
    \   let c = char_iter.next();\n        if c.is_none() {\n            break;\n\
    \        }\n        let c = c.unwrap();\n        let mut c = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        if vowels.contains(&c.to_string().as_str()) {\n            if c == next_vowel\
    \ {\n                c = vowels[(vowels_index + 2) % vowels.len()].chars().next().unwrap();\n\
    \                vowels_index = (vowels_index + 1) % vowels.len();\n         \
    \       next_vowel = vowels[vowels_index].chars().next().unwrap();\n         \
    \   }\n        }\n        if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded.push(c.to_ascii_uppercase());\n       \
    \ }\n    }\n    encoded", "  let alphabet = \n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n  let vowels = \"AEIOU\";\n  let mut result = String::new();\n  for c in message.chars()\
    \ {\n    if let Some(index) = alphabet.find(c) {\n      if vowels.contains(c)\
    \ {\n        result.push(alphabet.chars().nth(index + 2).unwrap());\n      } else\
    \ {\n        result.push(alphabet.chars().nth(index + 26).unwrap());\n      }\n\
    \    } else {\n      result.push(c);\n    }\n  }\n  result", "    // TODO: Implement\
    \ this function. \n    String::from(\"\")"]
stop_tokens:
- "\n}"
