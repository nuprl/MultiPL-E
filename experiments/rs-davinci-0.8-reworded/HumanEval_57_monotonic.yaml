name: HumanEval_57_monotonic
language: rs
prompt: "/// Return true is vector elements are monotonically increasing or decreasing.\n\
  /// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4,\
  \ 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l:\
  \ Vec<isize>) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1,\
  \ 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1,\
  \ 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n \
  \   assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]),\
  \ true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"
completions: ['    l.windows(2).all(|x| x[0] <= x[1]) || l.windows(2).all(|x| x[0]
    >= x[1])', "    let mut increasing = true;\n    let mut decreasing = true;\n \
    \   for (i, j) in l.iter().zip(l.iter().skip(1)) {\n        if i < j {\n     \
    \       decreasing = false;\n        } else if i > j {\n            increasing\
    \ = false;\n        }\n    }\n    increasing || decreasing", "    // todo\n  \
    \  let mut i = 1;\n    let mut sign = 0;\n    for i in 1..l.len() {\n        let\
    \ current_sign = (l[i] - l[i - 1]).signum();\n        if current_sign == 0 {\n\
    \            i += 1;\n            continue;\n        }\n        if sign == 0 {\n\
    \            sign = current_sign;\n        } else if sign * current_sign < 0 {\n\
    \            return false;\n        }\n    }\n    true", "    let mut is_decreasing\
    \ = false;\n    let mut is_increasing = false;\n    let mut last_value = l[0];\n\
    \    for i in 1..l.len() {\n        if l[i] < last_value {\n            is_decreasing\
    \ = true;\n        } else if l[i] > last_value {\n            is_increasing =\
    \ true;\n        }\n        last_value = l[i];\n    }\n    !(is_decreasing &&\
    \ is_increasing)", "    let mut ascending = true;\n    let mut descending = true;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while ascending || descending {\n\
    \        if ascending {\n            if i == l.len() - 1 {\n                break;\n\
    \            }\n            if l[i] > l[i + 1] {\n                ascending =\
    \ false;\n            }\n            i += 1;\n        }\n        if descending\
    \ {\n            if j == l.len() - 1 {\n                break;\n            }\n\
    \            if l[j] < l[j + 1] {\n                descending = false;\n     \
    \       }\n            j += 1;\n        }\n    }\n    ascending || descending",
  "    let mut vec = l.clone();\n    vec.sort();\n    vec == l || vec.iter().rev().collect::<Vec<_>>()\
    \ == l", "    let mut c = None;\n    for v in l {\n        match c {\n       \
    \     None => c = Some(v),\n            Some(b) => {\n                if v < b\
    \ {\n                    return false;\n                }\n                c =\
    \ Some(v);\n            }\n        }\n    }\n    true", "    let mut mono_increasing\
    \ = true;\n    let mut mono_decreasing = true;\n    for i in 1..l.len() {\n  \
    \      if l[i] < l[i - 1] {\n            mono_increasing = false;\n        }\n\
    \        if l[i] > l[i - 1] {\n            mono_decreasing = false;\n        }\n\
    \    }\n    mono_increasing || mono_decreasing", "    // TODO\n    if l.len()\
    \ <= 1 {\n        return true;\n    }\n    let mut list = l.to_vec();\n    let\
    \ mut first = list.remove(0);\n    let mut inc: bool = true;\n    let mut dec:\
    \ bool = true;\n    for i in list {\n        if i < first {\n            inc =\
    \ false;\n        }\n        if i > first {\n            dec = false;\n      \
    \  }\n        first = i;\n    }\n    if inc || dec {\n        return true;\n \
    \   }\n    false", "    let mut b = true;\n    let mut c = 0;\n    let mut d =\
    \ 0;\n    for i in 1..l.len() {\n        if l[i] - l[i - 1] > 0 {\n          \
    \  c += 1;\n        } else if l[i] - l[i - 1] < 0 {\n            d += 1;\n   \
    \     }\n    }\n    if d != 0 && c != 0 {\n        b = false;\n    }\n    b",
  "    let mut up = false;\n    let mut down = false;\n    let mut last = l[0];\n\
    \    for i in l {\n        if i > last {\n            if down {\n            \
    \    return false;\n            }\n            up = true;\n        } else if i\
    \ < last {\n            if up {\n                return false;\n            }\n\
    \            down = true;\n        }\n        last = i;\n    }\n    true", " \
    \   let mut result = true;\n    for i in 1..l.len() {\n        if l[i - 1] > l[i]\
    \ {\n            result = false;\n            break;\n        }\n    }\n    result",
  "    let mut incr = true;\n    let mut decr = true;\n    for i in 1..l.len() {\n\
    \        incr = incr && l[i] >= l[i - 1];\n        decr = decr && l[i] <= l[i\
    \ - 1];\n    }\n    incr || decr", "    let mut prev = None;\n    for current\
    \ in l {\n        if let Some(prev) = prev {\n            if current < prev {\n\
    \                return false;\n            }\n        }\n        prev = Some(current);\n\
    \    }\n    true", "    let mut cur = l[0];\n    let mut asc = true;\n    let\
    \ mut des = true;\n    for &i in l.iter().skip(1) {\n        if i > cur {\n  \
    \          des = false;\n        } else if i < cur {\n            asc = false;\n\
    \        }\n        cur = i;\n    }\n    asc || des", "    if l.len() <= 1 {\n\
    \        return true;\n    }\n    let mut increasing = l[0] < l[1];\n    for i\
    \ in 0..l.len() - 1 {\n        if l[i] == l[i + 1] {\n            return false;\n\
    \        }\n        if increasing {\n            if l[i] > l[i + 1] {\n      \
    \          return false;\n            }\n        } else {\n            if l[i]\
    \ < l[i + 1] {\n                return false;\n            }\n        }\n    }\n\
    \    true", "    for i in 1..l.len() {\n        if (l[i - 1] - l[i]).abs() < l[i\
    \ - 1].abs() {\n            return false;\n        }\n    }\n    true", "    let\
    \ mut i = 0;\n    let mut inc = false;\n    let mut dec = false;\n    for item\
    \ in l {\n        if item < l[i] {\n            inc = true;\n        } else if\
    \ item > l[i] {\n            dec = true;\n        }\n        i += 1;\n    }\n\
    \    inc && dec", "    let mut incr = false;\n    let mut decr = false;\n    for\
    \ i in 1..l.len() {\n        if l[i] > l[i - 1] {\n            incr = true;\n\
    \        } else if l[i] < l[i - 1] {\n            decr = true;\n        }\n  \
    \      if incr && decr {\n            return false;\n        }\n    }\n    true",
  "    match l.len() {\n        0 => false,\n        1 => true,\n        _ => {\n\
    \            let mut increasing = true;\n            let mut decreasing = true;\n\
    \            for i in 1..l.len() {\n                increasing = increasing &&\
    \ l[i] >= l[i - 1];\n                decreasing = decreasing && l[i] <= l[i -\
    \ 1];\n            }\n            increasing || decreasing\n        }\n    }",
  "    // (1)\n    // let mut previous = std::isize::MIN;\n    // let mut mono = true;\n\
    \    // for i in l {\n    //     if i >= previous {\n    //         previous =\
    \ i;\n    //     } else {\n    //         mono = false;\n    //         break;\n\
    \    //     }\n    // }\n    // return mono;\n\n    // (2)\n    // return l.windows(2).all(|w|\
    \ w[0] <= w[1]);\n\n    // (3)\n    // l.windows(2).all(|w| w[0] <= w[1])\n  \
    \  //     || l.windows(2).all(|w| w[0] >= w[1])\n\n    // (4)\n    l.windows(2).all(|w|\
    \ w[0] <= w[1])\n        || l.windows(2).all(|w| w[0] >= w[1])", "    let mut\
    \ increasing = true;\n    let mut decreasing = true;\n    for i in 1..l.len()\
    \ {\n        increasing = increasing && l[i] >= l[i - 1];\n        decreasing\
    \ = decreasing && l[i] <= l[i - 1];\n    }\n    increasing || decreasing", " \
    \   let mut inc = true;\n    let mut dec = true;\n    for n in 1..l.len() {\n\
    \        if l[n] < l[n - 1] {\n            inc = false;\n        }\n        if\
    \ l[n] > l[n - 1] {\n            dec = false;\n        }\n    }\n    inc || dec",
  "    for i in 1..l.len() {\n        if l[i] - l[i - 1] < 0 {\n            return\
    \ false;\n        }\n    }\n    true", "    // TODO\n    unimplemented!()", " \
    \   let mut l = l;\n    l.sort();\n    l == l.clone().into_iter().rev()", "  \
    \  if l.len() == 0 {\n        return true;\n    }\n    let mut prev = l[0];\n\
    \    let mut increasing = true;\n    for i in l {\n        if i == prev {\n  \
    \          continue;\n        }\n        if (i > prev) != increasing {\n     \
    \       return false;\n        }\n        increasing = i > prev;\n        prev\
    \ = i;\n    }\n    true", "    let mut length = l.len();\n    let mut i = 0;\n\
    \    while i < length - 1 {\n        if (l[i] - l[i + 1]).abs() > 0 {\n      \
    \      length = i + 1;\n            break;\n        }\n        i += 1;\n    }\n\
    \    length == 1", "    let mut increasing = true;\n    let mut decreasing = true;\n\
    \    for i in 1..l.len() {\n        increasing = increasing && l[i] >= l[i - 1];\n\
    \        decreasing = decreasing && l[i] <= l[i - 1];\n    }\n    increasing ||\
    \ decreasing", "    let mut inc = true;\n    let mut dec = true;\n    for i in\
    \ 1..l.len() {\n        if l[i - 1] > l[i] {\n            inc = false;\n     \
    \   }\n        if l[i - 1] < l[i] {\n            dec = false;\n        }\n   \
    \ }\n    return inc || dec;", "    if l.len() < 2 {\n        return true;\n  \
    \  }\n    let inc = l[0] < l[1];\n    l.windows(2).all(|w| inc == (w[0] < w[1]))",
  "    let mut m = 0;\n    let l = &l;\n    for i in 1..l.len() {\n        if l[i]\
    \ > l[i - 1] {\n            if m == -1 {\n                return false;\n    \
    \        }\n            m = 1;\n        } else if l[i] < l[i - 1] {\n        \
    \    if m == 1 {\n                return false;\n            }\n            m\
    \ = -1;\n        }\n    }\n    true", "    let m = l.len();\n    if m == 0 {\n\
    \        return true;\n    }\n    let mut i = 0;\n    let mut strictly_increasing\
    \ = false;\n    let mut strictly_decreasing = false;\n    while i < m - 1 {\n\
    \        if l[i] > l[i + 1] {\n            strictly_increasing = true;\n     \
    \   } else if l[i] < l[i + 1] {\n            strictly_decreasing = true;\n   \
    \     }\n        if strictly_increasing && strictly_decreasing {\n           \
    \ return false;\n        }\n        i += 1;\n    }\n    true", "    let mut inc\
    \ = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n        inc &=\
    \ l[i - 1] <= l[i];\n        dec &= l[i - 1] >= l[i];\n    }\n    inc || dec",
  "    let mut x = l[0];\n    let mut inc = true;\n    let mut dec = true;\n    for\
    \ y in l.iter().skip(1) {\n        if *y > x {\n            dec = false;\n   \
    \     } else if *y < x {\n            inc = false;\n        }\n        x = *y;\n\
    \    }\n    inc || dec", "    let mut direction = None;\n    for (a, b) in l.iter().tuple_windows()\
    \ {\n        let new_direction = if a < b {\n            Direction::Ascending\n\
    \        } else if a > b {\n            Direction::Descending\n        } else\
    \ {\n            Direction::Equal\n        };\n        match direction {\n   \
    \         None => direction = Some(new_direction),\n            Some(d) => {\n\
    \                if d != new_direction && new_direction != Direction::Equal {\n\
    \                    return false;\n                }\n            }\n       \
    \ }\n    }\n    true", "    for i in 1..l.len() {\n        let a = l[i - 1];\n\
    \        let b = l[i];\n        if a.signum() != b.signum() {\n            return\
    \ false;\n        }\n        if (a - b).abs() > 1 {\n            return false;\n\
    \        }\n    }\n    true", "    if l.len() < 2 {\n        return true;\n  \
    \  }\n    let mut acc = l[0];\n    let mut negative = false;\n    for (i, e) in\
    \ l.iter().enumerate() {\n        if i == 0 {\n            continue;\n       \
    \ }\n        if e < &acc {\n            if negative {\n                return\
    \ false;\n            }\n            negative = true;\n        } else if e > &acc\
    \ {\n            if !negative {\n                return false;\n            }\n\
    \            negative = false;\n        }\n        acc = *e;\n    }\n    true",
  "    let mut sorted = l.clone();\n    sorted.sort();\n    let mut reversed = l.clone();\n\
    \    reversed.sort_by(|a, b| b.cmp(a));\n    l == sorted || l == reversed", " \
    \   let mut increasing = true;\n    let mut decreasing = true;\n    for idx in\
    \ 1..l.len() {\n        if l[idx - 1] > l[idx] {\n            increasing = false;\n\
    \        }\n        if l[idx - 1] < l[idx] {\n            decreasing = false;\n\
    \        }\n    }\n    increasing || decreasing", "    let mut state = None;\n\
    \    for i in 1..l.len() {\n        let curr = l[i] - l[i - 1];\n        if curr\
    \ == 0 {\n            continue;\n        }\n        if state.is_none() {\n   \
    \         state = Some(curr > 0);\n        } else if curr > 0 != state.unwrap()\
    \ {\n            return false;\n        }\n    }\n    true", "    let mut asc\
    \ = true;\n    let mut desc = true;\n    let mut i = 0;\n    while i < l.len()\
    \ - 1 {\n        if l[i] > l[i + 1] {\n            asc = false;\n        }\n \
    \       if l[i] < l[i + 1] {\n            desc = false;\n        }\n        i\
    \ += 1;\n    }\n    asc || desc", "    let mut it = l.iter();\n    let mut m =\
    \ it.next().unwrap();\n    let mut ok = true;\n    for i in it {\n        ok =\
    \ ok && m <= i;\n        m = i;\n    }\n    ok", "    let mut prev = l[0];\n \
    \   let mut is_increasing = true;\n    for n in l {\n        if n != prev {\n\
    \            if n < prev {\n                is_increasing = false;\n         \
    \   }\n            prev = n;\n        }\n    }\n    true", "    let l = l.iter().collect::<Vec<_>>();\n\
    \    let mut a = *l[0];\n    let mut b = *l[1];\n    let mut x = false;\n    let\
    \ mut y = false;\n    if a < b {\n        x = true;\n    } else if a > b {\n \
    \       y = true;\n    }\n    for i in 2..l.len() {\n        if x && *l[i] < a\
    \ {\n            return false;\n        } else if y && *l[i] > a {\n         \
    \   return false;\n        }\n        a = b;\n        b = *l[i];\n    }\n    true",
  "    if l.len() <= 1 {\n        return true;\n    }\n    if l[0] == l[1] {\n   \
    \     return monotonic(l[1..].to_vec());\n    }\n    let mut dir = l[0] < l[1];\n\
    \    for i in 1..l.len() - 1 {\n        if dir && l[i] > l[i + 1] {\n        \
    \    return false;\n        }\n        if !dir && l[i] < l[i + 1] {\n        \
    \    return false;\n        }\n    }\n    true", "    match l.iter().fold((0,\
    \ 0), |acc, x| {\n        if acc.0 == 0 {\n            (x.signum(), x.signum())\n\
    \        } else if (acc.0 < 0 && acc.1 >= 0) || (acc.0 > 0 && acc.1 <= 0) {\n\
    \            return (2, 2);\n        } else {\n            (x.signum(), acc.0)\n\
    \        }\n    }) {\n        (0, _) => true,\n        (1, _) => true,\n     \
    \   (-1, _) => true,\n        _ => false,\n    }", "    let mut c = l[0];\n  \
    \  let mut d = true;\n    for x in l {\n        if x > c {\n            d = true;\n\
    \        } else if x < c {\n            d = false;\n        }\n        c = x;\n\
    \    }\n    d", "    if l.len() == 0 {\n        return true;\n    }\n    let mut\
    \ r = l[0];\n    let mut d = false;\n    for v in l {\n        if r == v {\n \
    \           continue;\n        }\n        if !d {\n            d = true;\n   \
    \     } else {\n            if v > r {\n                return false;\n      \
    \      }\n        }\n        r = v;\n    }\n    true", "    let mut i = 0;\n \
    \   let mut j = 1;\n    while j < l.len() {\n        if l[i] < l[j] {\n      \
    \      while j < l.len() && l[j - 1] < l[j] {\n                j += 1;\n     \
    \       }\n        } else if l[i] > l[j] {\n            while j < l.len() && l[j\
    \ - 1] > l[j] {\n                j += 1;\n            }\n        } else {\n  \
    \          return false;\n        }\n        i = j;\n        j += 1;\n    }\n\
    \    true", "    let mut l = l;\n    l.sort();\n    l.dedup();\n    return l.len()\
    \ == 1;", "    let mut l = l;\n    let mut ok = true;\n    while ok && l.len()\
    \ > 1 {\n        let first = l.remove(0);\n        let second = l.remove(0);\n\
    \        if first < second {\n            ok = !l.iter().any(|x| *x < second);\n\
    \        } else if first > second {\n            ok = !l.iter().any(|x| *x > second);\n\
    \        }\n    }\n    ok", "    let mut d = None;\n    for i in 1..l.len() {\n\
    \        let j = l[i] - l[i - 1];\n        match d {\n            None => d =\
    \ Some(j),\n            Some(k) => {\n                if (k < 0 && j > 0) || (k\
    \ > 0 && j < 0) {\n                    return false;\n                }\n    \
    \        }\n        }\n    }\n    true", "    let len = l.len();\n    if len <\
    \ 2 {\n        return true;\n    }\n    let mut increasing = l[0] < l[1];\n  \
    \  for i in 0..len - 1 {\n        if increasing {\n            if l[i] > l[i +\
    \ 1] {\n                return false;\n            }\n        } else {\n     \
    \       if l[i] < l[i + 1] {\n                return false;\n            }\n \
    \       }\n    }\n    true", "    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    let mut n = l.len();\n    if n == 0 {\n        return true;\n \
    \   }\n    let mut prev = l[0];\n    for i in 1..n {\n        let e = l[i];\n\
    \        if e < prev {\n            increasing = false;\n        }\n        if\
    \ e > prev {\n            decreasing = false;\n        }\n        prev = e;\n\
    \    }\n    return increasing || decreasing;", "    let (_, m) = l.iter().fold((0,\
    \ 0), |(acc, dir), &next| {\n        let new_dir = next - acc;\n        if dir\
    \ == 0 {\n            (next, new_dir)\n        } else if dir > 0 && new_dir <\
    \ 0 {\n            (next, new_dir)\n        } else if dir < 0 && new_dir > 0 {\n\
    \            (next, new_dir)\n        } else {\n            (next, dir)\n    \
    \    }\n    });\n    m == 0", "    let mut m = l[0];\n    let mut is_increasing\
    \ = false;\n    for i in l {\n        if i > m {\n            if is_increasing\
    \ {\n                return false;\n            }\n            is_increasing =\
    \ true;\n        } else if i < m {\n            if !is_increasing {\n        \
    \        return false;\n            }\n            is_increasing = false;\n  \
    \      }\n        m = i;\n    }\n    true", "    let mut upward = false;\n   \
    \ let mut downward = false;\n    let mut i = 0;\n    while i < l.len() - 1 {\n\
    \        if l[i] < l[i + 1] {\n            upward = true;\n        } else if l[i]\
    \ > l[i + 1] {\n            downward = true;\n        }\n        if upward &&\
    \ downward {\n            return false;\n        }\n        i += 1;\n    }\n \
    \   true", "    let mut dir = if l[0] < l[1] { 1 } else { -1 };\n    for i in\
    \ 1..l.len() - 1 {\n        let new_dir = if l[i] < l[i + 1] { 1 } else { -1 };\n\
    \        if new_dir != dir {\n            return false;\n        }\n    }\n  \
    \  true", "    let mut is_monotonic = true;\n    let mut dir: isize = 0;\n   \
    \ for i in 0..l.len() - 1 {\n        if dir == 0 {\n            if l[i] > l[i\
    \ + 1] {\n                dir = -1;\n            } else if l[i] < l[i + 1] {\n\
    \                dir = 1;\n            }\n        } else if (dir > 0 && l[i] >\
    \ l[i + 1]) || (dir < 0 && l[i] < l[i + 1]) {\n            is_monotonic = false;\n\
    \            break;\n        }\n    }\n    is_monotonic", "    let mut prev =\
    \ l[0];\n    let mut up = true;\n    let mut down = true;\n    for i in l {\n\
    \        if i < prev {\n            up = false;\n        }\n        if i > prev\
    \ {\n            down = false;\n        }\n        prev = i;\n    }\n    up ||\
    \ down", "    let mut v = l.clone();\n    v.sort();\n    v == l || v.iter().rev().collect::<Vec<_>>()\
    \ == l", "    match l.as_slice() {\n        [] => true,\n        [a] => true,\n\
    \        [a, b] => a != b,\n        [a, b, .., x, y] => a < b && monotonic(l[1..].to_vec())\
    \ || a > b && monotonic(l[1..].to_vec())\n    }", "    if l.len() < 2 {\n    \
    \    return true;\n    }\n    let mut i = 0;\n    let mut j = 1;\n    while j\
    \ < l.len() {\n        if l[i] > l[j] {\n            break;\n        }\n     \
    \   i += 1;\n        j += 1;\n    }\n    if j == l.len() {\n        return true;\n\
    \    }\n    while j < l.len() {\n        if l[i] < l[j] {\n            return\
    \ false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true", "   \
    \ let mut monotonic = true;\n    let mut prev = l[0];\n    for i in l {\n    \
    \    if i < prev {\n            monotonic = false;\n            break;\n     \
    \   }\n        prev = i;\n    }\n    monotonic", "    let mut is_monotonic = true;\n\
    \    let first = l[0];\n    let length = l.len();\n    for i in 1..length {\n\
    \        let second = l[i];\n        is_monotonic = if first < second {\n    \
    \        i == length - 1 || second >= l[i + 1]\n        } else {\n           \
    \ i == length - 1 || second <= l[i + 1]\n        };\n        if !is_monotonic\
    \ {\n            break;\n        }\n    }\n    is_monotonic", "    let mut (st,\
    \ base) = (0, l[0]);\n    for i in l.iter() {\n        if st == 0 {\n        \
    \    st = if i > &base { 1 } else if i < &base { -1 } else { 0 };\n          \
    \  base = *i;\n        } else if st == 1 {\n            if i < &base {\n     \
    \           return false;\n            }\n            base = *i;\n        } else\
    \ if st == -1 {\n            if i > &base {\n                return false;\n \
    \           }\n            base = *i;\n        }\n    }\n    true", "    let mut\
    \ i = 0;\n    let mut inc = true;\n    let mut dec = true;\n    while i < l.len()\
    \ - 1 {\n        if l[i] > l[i + 1] {\n            inc = false;\n        }\n \
    \       if l[i] < l[i + 1] {\n            dec = false;\n        }\n        i +=\
    \ 1;\n    }\n    inc || dec", "    if l.len() <= 1 {\n        return true;\n \
    \   }\n    if l[0] < l[1] {\n        for i in 0..l.len() - 1 {\n            if\
    \ l[i] > l[i + 1] {\n                return false;\n            }\n        }\n\
    \    } else {\n        for i in 0..l.len() - 1 {\n            if l[i] < l[i +\
    \ 1] {\n                return false;\n            }\n        }\n    }\n    true",
  "    let mut dir = None;\n    for i in 0..l.len() - 1 {\n        let diff = l[i\
    \ + 1] - l[i];\n        match dir {\n            None => dir = Some(diff),\n \
    \           Some(d) => {\n                if d * diff < 0 {\n                \
    \    return false;\n                }\n            }\n        }\n    }\n    true",
  "    let mut increasing = true;\n    let mut decreasing = true;\n    for i in 1..l.len()\
    \ {\n        if l[i] > l[i - 1] {\n            decreasing = false;\n        }\
    \ else if l[i] < l[i - 1] {\n            increasing = false;\n        }\n    }\n\
    \    increasing || decreasing", "    if l.len() < 2 {\n        return true;\n\
    \    }\n    let mut is_increasing = l[0] < l[1];\n    for i in 1..l.len() - 1\
    \ {\n        if l[i] < l[i + 1] != is_increasing {\n            return false;\n\
    \        }\n    }\n    true", "    let mut flag = None;\n    for i in 1..l.len()\
    \ {\n        let d = l[i] - l[i - 1];\n        if flag == None {\n           \
    \ flag = Some(d);\n        } else if flag != Some(d) {\n            return false;\n\
    \        }\n    }\n    true", "    let mut mono = true;\n    let mut prev = l[0];\n\
    \    for x in l {\n        if (x - prev).abs() == 1 {\n            prev = x;\n\
    \        } else {\n            mono = false;\n            break;\n        }\n\
    \    }\n    mono", "    let mut sign = None;\n    for (i, v) in l.into_iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        let s = if\
    \ l[i - 1] > v {\n            -1\n        } else if l[i - 1] < v {\n         \
    \   1\n        } else {\n            continue;\n        };\n        if sign.is_none()\
    \ {\n            sign = Some(s);\n        } else if sign.unwrap() != s {\n   \
    \         return false;\n        }\n    }\n    true", "    let mut m = true;\n\
    \    let mut s = false;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1]\
    \ {\n            if s {\n                return false;\n            }\n      \
    \      m = true;\n        } else if l[i] < l[i - 1] {\n            if m {\n  \
    \              return false;\n            }\n            s = true;\n        }\n\
    \    }\n    true", "    if l.len() < 2 {\n        return true;\n    }\n    let\
    \ (start, end) = l.split_at(2);\n    let mut direction = start[1] - start[0];\n\
    \    for e in end {\n        let diff = *e - start[start.len() - 1];\n       \
    \ if direction * diff < 0 {\n            return false;\n        }\n    }\n   \
    \ true", "    let mut curr = l[0];\n    let mut last = l[0];\n    let mut order\
    \ = 0;\n\n    for e in l.iter() {\n        if e < &curr {\n            curr =\
    \ *e;\n            order -= 1;\n        } else if e > &curr {\n            curr\
    \ = *e;\n            order += 1;\n        }\n    }\n\n    if order == 0 || (order\
    \ > 0 && last < l[l.len() - 1]) || (order < 0 && last > l[l.len() - 1]) {\n  \
    \      true\n    } else {\n        false\n    }", "    let mut incr = true;\n\
    \    let mut decr = true;\n    for i in 1..l.len() {\n        if l[i] < l[i -\
    \ 1] {\n            incr = false;\n        }\n        if l[i] > l[i - 1] {\n \
    \           decr = false;\n        }\n    }\n    incr || decr", "    if l.len()\
    \ <= 1 {\n        return true;\n    }\n    let mut inc = true;\n    let mut dec\
    \ = true;\n    for (x, y) in l.iter().zip(l.iter().skip(1)) {\n        if x <\
    \ y {\n            dec = false;\n        } else if x > y {\n            inc =\
    \ false;\n        }\n    }\n    inc || dec", "    if l.len() <= 1 {\n        return\
    \ true;\n    }\n    let mut result = true;\n    for i in 1..l.len() {\n      \
    \  if l[i] > l[i - 1] {\n            result = result && monotonic_increasing(l[i\
    \ - 1], l[i]);\n        } else if l[i] < l[i - 1] {\n            result = result\
    \ && monotonic_decreasing(l[i - 1], l[i]);\n        }\n    }\n    result", " \
    \   let mut prev: isize = 0;\n    let mut direction: isize = 0;\n    for item\
    \ in l {\n        if direction == 0 {\n            direction = item - prev;\n\
    \        } else if (item - prev) * direction < 0 {\n            return false;\n\
    \        }\n        prev = item;\n    }\n    true", "    let mut last = std::isize::MIN;\n\
    \    let mut is_increasing = true;\n    for e in l {\n        if e > last {\n\
    \            if !is_increasing {\n                return false;\n            }\n\
    \        } else if e < last {\n            if is_increasing {\n              \
    \  is_increasing = false;\n            }\n        }\n        last = e;\n    }\n\
    \    true", "    let mut count = 0;\n    for j in 1..l.len() {\n        if l[j]\
    \ > l[j - 1] {\n            count += 1;\n        } else if l[j] < l[j - 1] {\n\
    \            count -= 1;\n        }\n    }\n    count != -(l.len() as isize) &&\
    \ count != l.len() as isize", "    if l.len() <= 1 {\n        true\n    } else\
    \ {\n        let s = l[0] < l[1];\n        l.windows(2).all(|w| s == (w[0] < w[1]))\n\
    \    }", "    let mut decrease = false;\n    let mut increase = false;\n    let\
    \ mut prev = isize::MAX;\n    for i in l {\n        if i > prev {\n          \
    \  if decrease {\n                return false;\n            }\n            increase\
    \ = true;\n        } else if i < prev {\n            if increase {\n         \
    \       return false;\n            }\n            decrease = true;\n        }\n\
    \        prev = i;\n    }\n    true", "    for i in 1..l.len() {\n        if l[i]\
    \ - l[i - 1] > 0 {\n            for j in i + 1..l.len() {\n                if\
    \ l[j] - l[j - 1] < 0 {\n                    return false;\n                }\n\
    \            }\n        } else if l[i] - l[i - 1] < 0 {\n            for j in\
    \ i + 1..l.len() {\n                if l[j] - l[j - 1] > 0 {\n               \
    \     return false;\n                }\n            }\n        }\n    }\n    true",
  "    let mut is_increasing = false;\n    let mut is_decreasing = false;\n    for\
    \ i in 1..l.len() {\n        if l[i] > l[i - 1] {\n            is_increasing =\
    \ true;\n        } else if l[i] < l[i - 1] {\n            is_decreasing = true;\n\
    \        }\n        if is_increasing && is_decreasing {\n            return false;\n\
    \        }\n    }\n    true", "    let mut m = l[0];\n    let mut positive = None;\n\
    \    for i in l.iter() {\n        if positive.is_none() {\n            positive\
    \ = i.cmp(&m) == Ordering::Greater;\n        }\n        if positive.unwrap() &&\
    \ i.cmp(&m) == Ordering::Less {\n            return false;\n        }\n      \
    \  if !positive.unwrap() && i.cmp(&m) == Ordering::Greater {\n            return\
    \ false;\n        }\n        m = *i;\n    }\n    true", "    let mut trend = 0;\n\
    \n    for (i, v) in l.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n\n        if l[i - 1] == *v {\n            continue;\n        }\n\n\
    \        let new_trend = l[i - 1] - *v;\n\n        if trend == 0 {\n         \
    \   trend = new_trend;\n        } else if trend != new_trend {\n            return\
    \ false;\n        }\n    }\n\n    true", "    let mut m = l[0];\n    let mut a\
    \ = true;\n    for v in l {\n        if m < v {\n            m = v;\n        }\
    \ else if m > v {\n            m = v;\n            a = false;\n        }\n   \
    \ }\n    a", "    if l.len() < 2 {\n        return true;\n    }\n    let mut last\
    \ = l[0];\n    let mut increasing = true;\n    for x in l.iter().skip(1) {\n \
    \       if last > *x {\n            increasing = false;\n        }\n        if\
    \ (increasing && last > *x) || (!increasing && last < *x) {\n            return\
    \ false;\n        }\n        last = *x;\n    }\n    true", "    if l.len() <=\
    \ 1 {\n        return true;\n    }\n    let mut inc = true;\n    let mut dec =\
    \ true;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n           \
    \ dec = false;\n        }\n        if l[i] < l[i - 1] {\n            inc = false;\n\
    \        }\n    }\n    return inc || dec;", "    let mut a = l.iter();\n    let\
    \ mut v = a.next().unwrap();\n    let mut incr = true;\n    for i in a {\n   \
    \     if v > i {\n            incr = false;\n        }\n        if (incr && v\
    \ > i) || (!incr && v < i) {\n            return false;\n        }\n        v\
    \ = i;\n    }\n    true", "    if l.len() < 2 {\n        return true;\n    }\n\
    \    let diff = l[1] - l[0];\n    for i in 1..l.len() {\n        if (l[i] - l[i\
    \ - 1]) * diff < 0 {\n            return false;\n        }\n    }\n    true",
  "    // TODO\n    let mut m_t: bool = false;\n    let mut m_f: bool = false;\n \
    \   for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n            m_t = true;\n\
    \        } else if l[i] < l[i - 1] {\n            m_f = true;\n        }\n   \
    \ }\n    if m_t && m_f {\n        return false;\n    } else {\n        return\
    \ true;\n    }", "    let mut increasing = true;\n    let mut decreasing = true;\n\
    \    for i in 1..l.len() {\n        if l[i - 1] > l[i] {\n            increasing\
    \ = false;\n        }\n        if l[i - 1] < l[i] {\n            decreasing =\
    \ false;\n        }\n    }\n    return increasing || decreasing;", "    let (dir,\
    \ _) = l.iter().fold((0, l[0]), |(dir, prev), &curr| {\n        if prev < curr\
    \ {\n            (1, curr)\n        } else if prev > curr {\n            (-1,\
    \ curr)\n        } else {\n            (dir, curr)\n        }\n    });\n    dir\
    \ == 0 || dir == 1 || dir == -1", "    let mut iter = l.iter();\n    let first\
    \ = iter.next().unwrap_or(&0);\n    let inc = iter.fold(true, |acc, x| acc &&\
    \ x >= first);\n    let dec = iter.fold(true, |acc, x| acc && x <= first);\n \
    \   return inc || dec;", "    match l {\n        [] => true,\n        [x] => true,\n\
    \        [x, y] => x <= y,\n        [x, y, z, ..] => x <= y && y <= z,\n    }",
  "    let mut i = 0;\n    let mut increasing = true;\n    let mut decreasing = true;\n\
    \    for n in l {\n        increasing = increasing && i <= n;\n        decreasing\
    \ = decreasing && i >= n;\n        i = n;\n    }\n    increasing || decreasing",
  "    let mut z = l.clone();\n    z.sort();\n    l == z || l == z.iter().rev().cloned().collect()",
  "    let mut inc = true;\n    let mut dec = true;\n    let mut last = l[0];\n  \
    \  for &v in l.iter().skip(1) {\n        if v < last {\n            inc = false;\n\
    \        }\n        if v > last {\n            dec = false;\n        }\n     \
    \   last = v;\n    }\n    inc || dec", "    let mut i = 0;\n    loop {\n     \
    \   if i == l.len() - 1 {\n            return true;\n        } else if l[i] >\
    \ l[i + 1] {\n            break;\n        }\n        i += 1;\n    }\n    let mut\
    \ i = 0;\n    loop {\n        if i == l.len() - 1 {\n            return true;\n\
    \        } else if l[i] < l[i + 1] {\n            break;\n        }\n        i\
    \ += 1;\n    }\n    false", "    let mut l_iter = l.iter();\n    match l_iter.next()\
    \ {\n        None => true,\n        Some(f) => l_iter.fold((true, f), |(res, prev),\
    \ &curr| {\n            (res & prev.cmp(&curr) != std::cmp::Ordering::Greater,\
    \ curr)\n        }).0,\n    }", "    let mut s = l.iter().enumerate().skip(1);\n\
    \    let mut up = false;\n    let mut down = false;\n    for (i, e) in s {\n \
    \       if l[i - 1] > *e {\n            down = true;\n        } else if l[i -\
    \ 1] < *e {\n            up = true;\n        }\n        if up && down {\n    \
    \        return false;\n        }\n    }\n    true", "    let mut direction =\
    \ None;\n    for i in 1..l.len() {\n        if l[i - 1] < l[i] {\n           \
    \ if direction == Some(false) {\n                return false;\n            }\n\
    \            direction = Some(true);\n        } else if l[i - 1] > l[i] {\n  \
    \          if direction == Some(true) {\n                return false;\n     \
    \       }\n            direction = Some(false);\n        }\n    }\n    true",
  "    let mut inc = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n \
    \       if l[i] > l[i - 1] {\n            dec = false;\n        } else if l[i]\
    \ < l[i - 1] {\n            inc = false;\n        }\n    }\n    inc || dec", " \
    \   let mut inc = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n\
    \        if l[i - 1] > l[i] {\n            inc = false;\n        }\n        if\
    \ l[i - 1] < l[i] {\n            dec = false;\n        }\n    }\n    inc || dec",
  "    let mut inc = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n \
    \       if l[i] > l[i - 1] {\n            dec = false;\n        } else if l[i]\
    \ < l[i - 1] {\n            inc = false;\n        }\n    }\n    inc || dec", " \
    \   let mut s = l[0];\n    let mut p = s;\n    for n in l {\n        if p > n\
    \ {\n            if s > 0 {\n                return false;\n            }\n  \
    \          s = -1;\n        } else if p < n {\n            if s < 0 {\n      \
    \          return false;\n            }\n            s = 1;\n        }\n     \
    \   p = n;\n    }\n    true", "    l.windows(2).fold(\n        Ok(Incr(0)),\n\
    \        |acc, &[a, b]| match acc {\n            Ok(Incr(ref s)) if a < b => Ok(Incr(s\
    \ + 1)),\n            Ok(Decr(ref s)) if a > b => Ok(Decr(s + 1)),\n         \
    \   Ok(Incr(ref s)) if a > b => Ok(Decr(s)),\n            Ok(Decr(ref s)) if a\
    \ < b => Ok(Incr(s)),\n            Ok(Incr(ref s)) if a == b => Ok(Incr(s)),\n\
    \            Ok(Decr(ref s)) if a == b => Ok(Decr(s)),\n            Err(s) =>\
    \ Err(s),\n            _ => Err(l.len()),\n        },\n    )\n    .is_ok()", " \
    \   let mut m = l[0];\n    let mut sign = 0;\n    for n in l.iter() {\n      \
    \  if n > &m {\n            if sign == -1 {\n                return false;\n \
    \           }\n            sign = 1;\n        } else if n < &m {\n           \
    \ if sign == 1 {\n                return false;\n            }\n            sign\
    \ = -1;\n        }\n        m = *n;\n    }\n    true", "    // TODO: complete\
    \ this\n    true", "    let mut tmp = l[0];\n    let mut asc = true;\n    let\
    \ mut des = true;\n    for i in l {\n        if i >= tmp {\n            des =\
    \ false;\n        } else {\n            asc = false;\n        }\n        tmp =\
    \ i;\n    }\n    if asc || des {\n        return true;\n    }\n    false", " \
    \   if l.len() < 2 {\n        return true;\n    }\n    let f = l[0];\n    let\
    \ r = l[1];\n    let mut d = 0;\n    for x in l {\n        if d == 0 {\n     \
    \       if x == f {\n                continue;\n            }\n            if\
    \ x > f {\n                d = 1;\n            } else {\n                d = -1;\n\
    \            }\n        } else if d > 0 {\n            if x < f {\n          \
    \      return false;\n            }\n        } else {\n            if x > f {\n\
    \                return false;\n            }\n        }\n        f = x;\n   \
    \ }\n    true", "    let mut inc = 0;\n    let mut dec = 0;\n    for i in 0..l.len()\
    \ - 1 {\n        if l[i] < l[i + 1] {\n            inc += 1;\n        } else if\
    \ l[i] > l[i + 1] {\n            dec += 1;\n        }\n    }\n    if inc == l.len()\
    \ - 1 || dec == l.len() - 1 {\n        true\n    } else {\n        false\n   \
    \ }", "    let mut trend = 0;\n    for (i, n) in l.iter().enumerate() {\n    \
    \    if i == 0 {\n            continue;\n        }\n        let ntrend = n - &l[i\
    \ - 1];\n        if ntrend == 0 {\n            return false;\n        }\n    \
    \    if trend == 0 {\n            trend = ntrend;\n        } else if trend * ntrend\
    \ < 0 {\n            return false;\n        }\n    }\n    true", "    let mut\
    \ is_inc = true;\n    let mut is_dec = true;\n    for i in 1..l.len() {\n    \
    \    if l[i] < l[i - 1] {\n            is_inc = false;\n        }\n        if\
    \ l[i] > l[i - 1] {\n            is_dec = false;\n        }\n    }\n    is_inc\
    \ || is_dec", "    let mut inc = 0;\n    let mut dec = 0;\n    let mut last =\
    \ l[0];\n    for item in l {\n        if item > last {\n            inc += 1;\n\
    \        } else if item < last {\n            dec += 1;\n        }\n        last\
    \ = item;\n    }\n    (inc == 0 || dec == 0)", "    if l.len() <= 1 {\n      \
    \  return true;\n    }\n    let (first, second) = (l[0], l[1]);\n    let increasing\
    \ = first < second;\n    let decreasing = first > second;\n    l.iter().skip(1).all(|x|\
    \ increasing && x >= first || decreasing && x <= first)", "    let mut prev =\
    \ l[0];\n    let mut is_increasing = l[0] < l[1];\n    for e in l {\n        if\
    \ (e > prev) != is_increasing {\n            return false;\n        }\n      \
    \  prev = e;\n    }\n    true", "    let mut increasing = true;\n    let mut decreasing\
    \ = true;\n    for idx in 1..l.len() {\n        if l[idx] < l[idx - 1] {\n   \
    \         increasing = false;\n        }\n        if l[idx] > l[idx - 1] {\n \
    \           decreasing = false;\n        }\n    }\n    increasing || decreasing",
  "    let (mut inc, mut dec) = (true, true);\n    for i in 1..l.len() {\n       \
    \ if l[i] > l[i - 1] {\n            dec = false;\n        } else if l[i] < l[i\
    \ - 1] {\n            inc = false;\n        }\n    }\n    inc || dec", "    let\
    \ mut pos = false;\n    let mut neg = false;\n    for i in 1..l.len() {\n    \
    \    let diff = l[i] - l[i - 1];\n        if diff == 0 {\n            continue;\n\
    \        }\n        match diff.signum() {\n            1 => {\n              \
    \  if pos {\n                    continue;\n                }\n              \
    \  if neg {\n                    return false;\n                }\n          \
    \      pos = true;\n            }\n            -1 => {\n                if neg\
    \ {\n                    continue;\n                }\n                if pos\
    \ {\n                    return false;\n                }\n                neg\
    \ = true;\n            }\n            _ => (),\n        }\n    }\n    true", " \
    \   let mut l = l;\n    let mut decreasing = false;\n    let mut increasing =\
    \ false;\n    let mut check = true;\n    while check {\n        check = false;\n\
    \        if l.len() > 1 {\n            let x = l.pop().unwrap();\n           \
    \ let y = l.pop().unwrap();\n            if x < y {\n                decreasing\
    \ = true;\n            } else if x > y {\n                increasing = true;\n\
    \            }\n            l.push(y);\n            l.push(x);\n            check\
    \ = true;\n        }\n    }\n    return decreasing ^ increasing;", "    let mut\
    \ is_monotonic = true;\n    let mut is_increasing = true;\n    let mut is_decreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n         \
    \   is_decreasing = false;\n        } else if l[i] < l[i - 1] {\n            is_increasing\
    \ = false;\n        }\n    }\n    is_monotonic = is_increasing || is_decreasing;\n\
    \    is_monotonic", "    // TODO: change false to the correct answer\n    let\
    \ mut up = false;\n    let mut down = false;\n    for i in 0..l.len()-1 {\n  \
    \      if l[i] < l[i+1] {\n            up = true;\n        }\n        if l[i]\
    \ > l[i+1] {\n            down = true;\n        }\n    }\n    !(up && down)",
  "    // Your code goes here\n    let mut temp = l[0];\n    let mut is_incre = true;\n\
    \    for i in l {\n        if i != temp {\n            if i < temp {\n       \
    \         is_incre = false;\n            }\n            break;\n        }\n  \
    \  }\n    if is_incre {\n        for i in l {\n            if i < temp {\n   \
    \             return false;\n            }\n            temp = i;\n        }\n\
    \    } else {\n        for i in l {\n            if i > temp {\n             \
    \   return false;\n            }\n            temp = i;\n        }\n    }\n  \
    \  true", '    l.windows(2).all(|x| x[0] <= x[1]) || l.windows(2).all(|x| x[0]
    >= x[1])', "    let mut d = 0;\n    for i in 1..l.len() {\n        let delta =\
    \ l[i] - l[i - 1];\n        if delta * d < 0 {\n            return false;\n  \
    \      }\n        if delta != 0 {\n            d = delta;\n        }\n    }\n\
    \    true", "    let mut incr = true;\n    let mut decr = true;\n    for i in\
    \ 1..l.len() {\n        if l[i] > l[i - 1] {\n            decr = false;\n    \
    \    } else if l[i] < l[i - 1] {\n            incr = false;\n        }\n    }\n\
    \    incr || decr", "    let mut result = true;\n    let mut direction = 0;\n\
    \    for i in 1..l.len() {\n        let diff = l[i] - l[i - 1];\n        if direction\
    \ == 0 {\n            direction = diff;\n        } else if diff * direction <\
    \ 0 {\n            result = false;\n            break;\n        }\n    }\n   \
    \ result", "    let mut increasing = true;\n    let mut decreasing = true;\n \
    \   let mut i = 0;\n    while i < l.len() - 1 {\n        increasing = increasing\
    \ && l[i] <= l[i + 1];\n        decreasing = decreasing && l[i] >= l[i + 1];\n\
    \        i += 1;\n    }\n    increasing || decreasing", "    // let mut sorted_list\
    \ = l.clone();\n    // sorted_list.sort();\n    // sorted_list == l\n    let mut\
    \ direction = None;\n    let mut was_direction_set = false;\n    for (i, num)\
    \ in l.iter().enumerate() {\n        if i == 0 {\n            continue;\n    \
    \    }\n        let current_direction = num - &l[i - 1];\n        if was_direction_set\
    \ {\n            if current_direction * direction.unwrap() < 0 {\n           \
    \     return false;\n            }\n        } else {\n            direction =\
    \ Some(current_direction);\n            was_direction_set = true;\n        }\n\
    \    }\n    true", "    let mut last = l[0];\n    let mut increasing = true;\n\
    \    for &x in l.iter().skip(1) {\n        if x != last {\n            increasing\
    \ = x > last;\n            break;\n        }\n    }\n    for &x in l.iter().skip(1)\
    \ {\n        if x != last {\n            if increasing && x < last {\n       \
    \         return false;\n            }\n            if !increasing && x > last\
    \ {\n                return false;\n            }\n        }\n        last = x;\n\
    \    }\n    true", "    let mut inc = false;\n    let mut dec = false;\n    let\
    \ mut prev = 0;\n    for i in l {\n        if i < prev {\n            dec = true;\n\
    \        } else if i > prev {\n            inc = true;\n        }\n        prev\
    \ = i;\n    }\n    return !(inc && dec);", "    l.iter().rfold((true, None), |(is_increasing,\
    \ last), &el| {\n        (\n            is_increasing && last.map_or(true, |x|\
    \ x <= el),\n            Some(el),\n        )\n    })\n    .0", '    unimplemented!()',
  '    l.windows(2).all(|a| (a[0] - a[1]).abs() <= 1)', "    let mut i = 1;\n    let\
    \ mut dir = 0;\n    while i < l.len() {\n        if l[i - 1] == l[i] {\n     \
    \       return false;\n        }\n        if dir == 0 {\n            dir = l[i\
    \ - 1] - l[i];\n        } else if dir * (l[i - 1] - l[i]) < 0 {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true", "    let (first, rest)\
    \ = l.split_first().unwrap();\n    match rest.iter().fold((true, *first), |(mono,\
    \ prev), &curr| {\n        if (curr - prev) * (curr - *first) <= 0 {\n       \
    \     (mono, curr)\n        } else {\n            (false, curr)\n        }\n \
    \   }) {\n        (true, _) => true,\n        _ => false,\n    }", "    let mut\
    \ max = l[0];\n    let mut min = l[0];\n    let mut prev = l[0];\n    let mut\
    \ increasing = true;\n    let mut decreasing = true;\n    for x in l {\n     \
    \   max = max.max(x);\n        min = min.min(x);\n        increasing = increasing\
    \ && x >= prev;\n        decreasing = decreasing && x <= prev;\n        prev =\
    \ x;\n    }\n    return (max == l[l.len() - 1] && increasing) || (min == l[l.len()\
    \ - 1] && decreasing);", "    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    let mut count = 0;\n    let mut is_mono = true;\n    let mut mono_type\
    \ = false;\n    let mut is_asc = false;\n    let mut is_desc = false;\n    for\
    \ i in 1..l.len() {\n        if l[i] > l[i - 1] {\n            is_asc = true;\n\
    \        } else if l[i] < l[i - 1] {\n            is_desc = true;\n        }\n\
    \    }\n    if is_asc && is_desc {\n        return false;\n    }\n    if is_asc\
    \ {\n        mono_type = true;\n    }\n    if is_desc {\n        mono_type = false;\n\
    \    }\n    while i < l.len() {\n        count = 0;\n        while j < l.len()\
    \ {\n            while k < l.len() {\n                if i != j && j != k && i\
    \ != k {\n                    if mono_type {\n                        if l[i]\
    \ < l[j] && l[j] < l[k] {\n                            count += 1;\n         \
    \               }\n                    } else {\n                        if l[i]\
    \ > l[j] && l[j] > l[k] {\n                            count += 1;\n         \
    \               }\n                    }\n                }\n                k\
    \ += 1;\n            }\n            k = 0;\n            j += 1;\n        }\n \
    \       j = 0;\n        if count == 0 {\n            is_mono = false;\n      \
    \      break;\n        }\n        i += 1;\n    }\n    is_mono", "    let mut new_list\
    \ = l.clone();\n    new_list.sort();\n    new_list == l || new_list.into_iter().rev().collect::<Vec<isize>>()\
    \ == l", "    let direction = l.windows(2).fold(0, |acc, p| match (acc, p[0].cmp(&p[1]))\
    \ {\n        (0, Ordering::Equal) => 0,\n        (0, Ordering::Less) => 1,\n \
    \       (0, Ordering::Greater) => -1,\n        (1, Ordering::Less) => 1,\n   \
    \     (-1, Ordering::Greater) => -1,\n        _ => return false,\n    });\n  \
    \  true", "    let mut d = 0;\n    let mut dd = 0;\n    let mut is_decreasing\
    \ = false;\n    let mut is_increasing = false;\n    let len = l.len();\n    for\
    \ i in 0..len {\n        d = l[i] - l[i + 1];\n        dd = d - dd;\n        if\
    \ dd < 0 {\n            is_decreasing = true;\n        }\n        if dd > 0 {\n\
    \            is_increasing = true;\n        }\n    }\n    is_decreasing || is_increasing",
  "    let (first, rest) = l.split_first().unwrap();\n    rest.windows(2).all(|pair|\
    \ pair[0] < pair[1]) || rest.windows(2).all(|pair| pair[0] > pair[1])", "    let\
    \ mut m = 0;\n    let mut flag = true;\n    for i in 1..l.len() {\n        if\
    \ l[i] - l[i - 1] > 0 {\n            if m == -1 {\n                flag = false;\n\
    \                break;\n            }\n            m = 1;\n        } else if\
    \ l[i] - l[i - 1] < 0 {\n            if m == 1 {\n                flag = false;\n\
    \                break;\n            }\n            m = -1;\n        }\n    }\n\
    \    flag", "    if l.len() < 2 {\n        return true;\n    }\n    let dir =\
    \ l[1] - l[0];\n    if dir == 0 {\n        return monotonic(l[1..].to_vec());\n\
    \    }\n    let dirs = l[1..].iter().map(|x| x - l[0]).collect::<Vec<isize>>();\n\
    \    dirs.iter().all(|x| x == 0 || x == dir)", "    let mut up = true;\n    let\
    \ mut down = true;\n    for i in 1..l.len() {\n        if l[i] > l[i - 1] {\n\
    \            down = false;\n        }\n        if l[i] < l[i - 1] {\n        \
    \    up = false;\n        }\n    }\n    up || down", "    let mut asc = true;\n\
    \    let mut dsc = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1]\
    \ {\n            asc = false;\n        }\n        if l[i] > l[i - 1] {\n     \
    \       dsc = false;\n        }\n    }\n    asc || dsc", "    if l.len() < 2 {\n\
    \        return true;\n    }\n    let mut prev = l[0];\n    let mut increasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] > prev {\n            if\
    \ !increasing {\n                return false;\n            }\n        } else\
    \ if l[i] < prev {\n            increasing = false;\n        } else {\n      \
    \      return false;\n        }\n        prev = l[i];\n    }\n    true", '    unimplemented!()',
  "    let l = l.into_iter().enumerate().map(|(i, x)| x - i as isize).collect::<Vec<_>>();\n\
    \    l.windows(2).map(|window| window[0] - window[1]).all(|x| x == 0)", '    l.iter().zip(l.iter().skip(1)).all(|(x,
    y)| x < y || x > y)', "    let mut inc = true;\n    let mut dec = true;\n    for\
    \ i in 1..l.len() {\n        if l[i - 1] > l[i] {\n            inc = false;\n\
    \        }\n        if l[i - 1] < l[i] {\n            dec = false;\n        }\n\
    \    }\n    inc || dec", "    if l.len() == 0 {\n        return true;\n    }\n\
    \    let first = l[0];\n    let last = l[l.len() - 1];\n    if first > last {\n\
    \        for i in 1..l.len() {\n            if l[i] > l[i - 1] {\n           \
    \     return false;\n            }\n        }\n    } else {\n        for i in\
    \ 1..l.len() {\n            if l[i] < l[i - 1] {\n                return false;\n\
    \            }\n        }\n    }\n    true", "    for i in 1..l.len() {\n    \
    \    if l[i] - l[i - 1] < 0 {\n            return false;\n        }\n    }\n \
    \   true", "    if l.len() <= 1 {\n        return true;\n    }\n    let mut inc\
    \ = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n        if l[i\
    \ - 1] < l[i] {\n            dec = false;\n        }\n        if l[i - 1] > l[i]\
    \ {\n            inc = false;\n        }\n    }\n    return inc || dec;", "  \
    \  let mut flag = true;\n    let mut sign = 0;\n    for (i, j) in l.iter().enumerate()\
    \ {\n        if i == 0 {\n            sign = j;\n        } else {\n          \
    \  if j != &sign {\n                if flag {\n                    flag = false;\n\
    \                    if j > &sign {\n                        sign = 1;\n     \
    \               } else {\n                        sign = -1;\n               \
    \     }\n                } else {\n                    if j > &sign {\n      \
    \                  if sign != 1 {\n                            return false;\n\
    \                        }\n                    } else {\n                   \
    \     if sign != -1 {\n                            return false;\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n    }\n    true", "    let mut inc = true;\n    let mut dec = true;\n\
    \    for i in 1..l.len() {\n        inc &= l[i] >= l[i - 1];\n        dec &= l[i]\
    \ <= l[i - 1];\n    }\n    inc || dec", "    let mut iter = l.iter();\n    let\
    \ mut prev = iter.next();\n    let mut increasing = None;\n    for val in iter\
    \ {\n        if prev.is_none() {\n            return false;\n        }\n     \
    \   if increasing.is_none() {\n            increasing = Some(val > prev.unwrap());\n\
    \        } else if increasing.unwrap() && val < prev.unwrap() {\n            return\
    \ false;\n        } else if !increasing.unwrap() && val > prev.unwrap() {\n  \
    \          return false;\n        }\n        prev = Some(val);\n    }\n    true",
  "    if l.len() < 2 {\n        return true;\n    }\n    let mut sl = l.clone();\n\
    \    sl.sort();\n    if sl == l {\n        return true;\n    }\n    sl.reverse();\n\
    \    if sl == l {\n        return true;\n    }\n    false", "    let mut first\
    \ = l[0];\n    let mut monotonic = true;\n    for &v in l.iter().skip(1) {\n \
    \       if v > first {\n            first = v;\n        } else if v < first {\n\
    \            first = v;\n        } else {\n            monotonic = false;\n  \
    \          break;\n        }\n    }\n    monotonic", "    let mut l2 = l.clone();\n\
    \    l2.sort();\n    l == l2 || l.reverse() == l2", "    for i in 1..l.len() {\n\
    \        let s = l[i] - l[i - 1];\n        if s == 0 {\n            return false;\n\
    \        }\n        if i > 1 && s.signum() != (l[i - 1] - l[i - 2]).signum() {\n\
    \            return false;\n        }\n    }\n    true", "    if l.len() <= 1\
    \ {\n        return true;\n    }\n    let mut d = l[1] - l[0];\n    for i in 1..l.len()\
    \ {\n        if (l[i] - l[i - 1]) * d < 0 {\n            return false;\n     \
    \   }\n    }\n    true", "    let mut is_increasing = true;\n    let mut is_decreasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n         \
    \   is_increasing = false;\n        }\n        if l[i] > l[i - 1] {\n        \
    \    is_decreasing = false;\n        }\n    }\n    is_increasing || is_decreasing",
  "    let mut m = Monotonic::Unknown;\n    for i in 1..l.len() {\n        let a =\
    \ l[i - 1];\n        let b = l[i];\n        if b > a {\n            if m == Monotonic::Decreasing\
    \ {\n                return false;\n            }\n            m = Monotonic::Increasing;\n\
    \        } else if b < a {\n            if m == Monotonic::Increasing {\n    \
    \            return false;\n            }\n            m = Monotonic::Decreasing;\n\
    \        }\n    }\n    true", "    if l.len() == 0 {\n        return true;\n \
    \   }\n    let mut prev = l[0];\n    let mut increasing = true;\n    for x in\
    \ l {\n        if prev < x {\n            if !increasing {\n                return\
    \ false;\n            }\n        } else if prev > x {\n            if increasing\
    \ {\n                increasing = false;\n            }\n        }\n        prev\
    \ = x;\n    }\n    true", "    l.iter().zip(l.iter().skip(1)).all(|(x, y)| x <=\
    \ y) ||\n    l.iter().zip(l.iter().skip(1)).all(|(x, y)| x >= y)", "    if l.len()\
    \ <= 1 {\n        return true;\n    }\n    let mut i = 0;\n    while i < l.len()\
    \ - 1 {\n        if l[i] == l[i + 1] {\n            i += 1;\n            continue;\n\
    \        }\n        if (l[i] < l[i + 1] && i > 0 && l[i - 1] > l[i])\n       \
    \     || (l[i] > l[i + 1] && i > 0 && l[i - 1] < l[i])\n        {\n          \
    \  return false;\n        }\n        i += 1;\n    }\n    true", '    l.windows(2).all(|p|
    (p[0] - p[1]).abs() == 1)', "    let mut decreasing = true;\n    let mut increasing\
    \ = true;\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n         \
    \   increasing = false;\n        }\n        if l[i] > l[i - 1] {\n           \
    \ decreasing = false;\n        }\n    }\n    increasing || decreasing", "    let\
    \ mut decreasing = true;\n    let mut increasing = true;\n    for (i, &p) in l.iter().enumerate()\
    \ {\n        if i > 0 {\n            let &q = &l[i - 1];\n            if p < q\
    \ {\n                increasing = false;\n            } else if p > q {\n    \
    \            decreasing = false;\n            }\n        }\n    }\n    increasing\
    \ || decreasing", "    if l.len() < 2 {\n        return true;\n    }\n    for\
    \ i in 1..l.len() {\n        if l[i - 1] < l[i] {\n            continue;\n   \
    \     } else if l[i - 1] > l[i] {\n            break;\n        } else {\n    \
    \        return false;\n        }\n    }\n    return true;", "    match l {\n\
    \        [] => true,\n        [x] => true,\n        [a, b] => a <= b,\n      \
    \  _ => {\n            let mut m = l[0] <= l[1];\n            l.windows(2).all(|w|\
    \ {\n                let res = m && (w[0] <= w[1]);\n                m = res;\n\
    \                res\n            })\n        }\n    }", "    let mut inc = true;\n\
    \    let mut dec = true;\n    let mut previous = l[0];\n    for i in 1..l.len()\
    \ {\n        if l[i] < previous {\n            inc = false;\n        }\n     \
    \   if l[i] > previous {\n            dec = false;\n        }\n        previous\
    \ = l[i];\n    }\n    inc || dec", "    if l.len() < 2 {\n        return true;\n\
    \    }\n    let mut inc = None;\n    for i in 1..l.len() {\n        if l[i - 1]\
    \ < l[i] {\n            if inc.is_some() && inc.unwrap() {\n                continue;\n\
    \            }\n            inc = Some(true);\n        } else if l[i - 1] > l[i]\
    \ {\n            if inc.is_some() && !inc.unwrap() {\n                continue;\n\
    \            }\n            inc = Some(false);\n        } else {\n           \
    \ continue;\n        }\n        return false;\n    }\n    true", "    if l.len()\
    \ < 2 {\n        return true;\n    }\n    let mut prev = l[0];\n    let mut is_monotonic\
    \ = true;\n    for x in l {\n        if x != prev {\n            if (x - prev).abs()\
    \ > 1 {\n                is_monotonic = false;\n                break;\n     \
    \       }\n            prev = x;\n        }\n    }\n    is_monotonic", "    let\
    \ (mut increasing, mut decreasing) = (true, true);\n    let mut i = 0;\n    while\
    \ i < l.len() - 1 {\n        increasing &= l[i] <= l[i + 1];\n        decreasing\
    \ &= l[i] >= l[i + 1];\n        i += 1;\n    }\n    increasing || decreasing",
  "    for i in 1..l.len() {\n        if (l[i] > l[i - 1]) != (l[0] < l[1]) {\n  \
    \          return false;\n        }\n    }\n    true", "    let mut m = None;\n\
    \    for i in 1..l.len() {\n        if l[i] != l[i - 1] {\n            if m.is_none()\
    \ {\n                m = Some(l[i] > l[i - 1]);\n            } else if m.unwrap()\
    \ != (l[i] > l[i - 1]) {\n                return false;\n            }\n     \
    \   }\n    }\n    true", "    // your code here\n    let mut inc = true;\n   \
    \ let mut dec = true;\n    for i in 0..l.len()-1 {\n        if l[i] > l[i+1] {\n\
    \            inc = false;\n        }\n        if l[i] < l[i+1] {\n           \
    \ dec = false;\n        }\n    }\n    inc || dec", "    let mut is_increasing\
    \ = l[0] < l[1];\n    for i in 1..l.len() {\n        if l[i - 1] == l[i] {\n \
    \           continue;\n        }\n        if is_increasing != (l[i - 1] < l[i])\
    \ {\n            return false;\n        }\n    }\n    true", "    let mut increasing\
    \ = None;\n    let mut result = true;\n    for i in 1..l.len() {\n        let\
    \ inc = l[i] > l[i - 1];\n        if increasing.is_none() {\n            increasing\
    \ = Some(inc);\n        } else if increasing.unwrap() != inc {\n            result\
    \ = false;\n            break;\n        }\n    }\n    result", "    let mut inc\
    \ = true;\n    let mut dec = true;\n    for i in 1..l.len() {\n        if l[i]\
    \ > l[i - 1] {\n            dec = false;\n        } else if l[i] < l[i - 1] {\n\
    \            inc = false;\n        }\n    }\n    inc || dec", "    let mut result\
    \ = true;\n    let mut prev = *l.first().unwrap();\n    for &item in l.iter().skip(1)\
    \ {\n        if prev > item {\n            if result == true {\n             \
    \   result = false;\n            } else {\n                return false;\n   \
    \         }\n        } else if prev < item {\n            if result == false {\n\
    \                return false;\n            }\n        }\n        prev = item;\n\
    \    }\n    true", "    let mut state = 0;\n    for i in 1..l.len() {\n      \
    \  let new_state = l[i] - l[i - 1];\n        if state == 0 {\n            state\
    \ = new_state;\n        } else if state * new_state < 0 {\n            return\
    \ false;\n        }\n    }\n    true", "    let mut a = l.clone();\n    a.sort();\n\
    \    a == l || a.iter().rev().collect::<Vec<_>>() == l", "    let mut m = l[0];\n\
    \    let mut is_increasing = true;\n    for i in 1..l.len() {\n        if m ==\
    \ l[i] {\n            continue;\n        }\n        if (m < l[i]) == is_increasing\
    \ {\n            m = l[i];\n            continue;\n        }\n        m = l[i];\n\
    \        is_increasing = !is_increasing;\n    }\n    true", "    let mut inc =\
    \ l[0] < l[1];\n    for i in 0..l.len() - 1 {\n        if inc != l[i] < l[i +\
    \ 1] {\n            return false;\n        }\n    }\n    true", "    match l.len()\
    \ {\n        0 => true,\n        1 => true,\n        2 => l[0] <= l[1],\n    \
    \    _ => {\n            let mut v = l.to_vec();\n            v.sort();\n    \
    \        v == l || v.iter().rev().collect::<Vec<_>>() == l\n        }\n    }",
  "    if l.len() <= 1 {\n        return true;\n    }\n    let mut direction = None;\n\
    \    for i in 1..l.len() {\n        let d = l[i] - l[i - 1];\n        if d ==\
    \ 0 {\n            continue;\n        }\n        if direction.is_none() {\n  \
    \          direction = Some(d);\n        } else if d * direction.unwrap() < 0\
    \ {\n            return false;\n        }\n    }\n    true", "    if l.len() <\
    \ 2 {\n        return true;\n    }\n    let mut base = l[0];\n    let mut increasing\
    \ = true;\n    for i in 1..l.len() {\n        if base < l[i] {\n            if\
    \ !increasing {\n                return false;\n            }\n        } else\
    \ if base > l[i] {\n            if increasing {\n                increasing =\
    \ false;\n            }\n        } else {\n            return false;\n       \
    \ }\n        base = l[i];\n    }\n    true", "    let mut last = l[0];\n    let\
    \ mut cnt = 1;\n    for &n in l.iter().skip(1) {\n        if last != n {\n   \
    \         cnt += 1;\n            last = n;\n        }\n    }\n    cnt == 1", " \
    \   // monotonic_increasing(l) || monotonic_decreasing(l)\n    l == l.into_iter().sorted()\
    \ || l == l.into_iter().sorted().rev()", "    let mut is_monotonic = true;\n \
    \   let mut prev = None;\n    for x in l {\n        if let Some(p) = prev {\n\
    \            if (p > x && is_monotonic) || (p < x && !is_monotonic) {\n      \
    \          return false;\n            }\n        }\n        prev = Some(x);\n\
    \        is_monotonic = !is_monotonic;\n    }\n    true", "    if l.len() == 0\
    \ {\n        true\n    } else {\n        let mut increasing = None;\n        for\
    \ (x, y) in l.iter().zip(l.iter().skip(1)) {\n            let diff = *y - *x;\n\
    \            if increasing.is_none() {\n                increasing = Some(diff\
    \ > 0);\n            } else if diff > 0 != increasing.unwrap() {\n           \
    \     return false;\n            }\n        }\n        true\n    }"]
stop_tokens:
- "\n}"
