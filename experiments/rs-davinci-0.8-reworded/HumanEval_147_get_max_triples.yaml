name: HumanEval_147_get_max_triples
language: rs
prompt: "/// You are given a positive integer n. You have to create an integer vector\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>>\
  \ get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The\
  \ only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n\
    \        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", "    let\
    \ mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    let mut res = 0;\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n                }\n\
    \            }\n        }\n    }\n    res", "\tlet mut a: Vec<isize> = vec![0;\
    \ n as usize];\n\tlet mut n_triples = 0;\n\tfor i in 0..n {\n\t\ta[i as usize]\
    \ = i * i - i + 1;\n\t}\n\tfor i in 0..n {\n\t\tfor j in i+1..n {\n\t\t\tfor k\
    \ in j+1..n {\n\t\t\t\tif (a[i as usize] + a[j as usize] + a[k as usize]) % 3\
    \ == 0 {\n\t\t\t\t\tn_triples += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tn_triples",
  "    let a = (1..n + 1).map(|x| x * x - x + 1).collect::<Vec<isize>>();\n    let\
    \ mut count = 0;\n    for i in 0..a.len() {\n        for j in i + 1..a.len() {\n\
    \            for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut triples:\
    \ Vec<(isize, isize, isize)> = Vec::new();\n    for i in 0..a.len() - 2 {\n  \
    \      for j in i + 1..a.len() - 1 {\n            for k in j + 1..a.len() {\n\
    \                if a[i] + a[j] + a[k] % 3 == 0 {\n                    triples.push((a[i],\
    \ a[j], a[k]));\n                }\n            }\n        }\n    }\n    triples.len()\
    \ as isize", "    let mut res = 0;\n    for i in 1..n-1 {\n        let j = i +\
    \ 1;\n        let k = j + 1;\n        if (i * i - i + 1 + j * j - j + 1 + k *\
    \ k - k + 1) % 3 == 0 {\n            res += 1;\n        }\n    }\n    res", " \
    \   let mut max_triples = 0;\n    let mut a = Vec::new();\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    max_triples += 1;\n         \
    \       }\n            }\n        }\n    }\n    max_triples", "    let mut res\
    \ = 0;\n    let mut a = vec![0; n as usize];\n    for i in 0..n {\n        a[i\
    \ as usize] = i * i - i + 1;\n    }\n    for i in 0..n {\n        for j in i +\
    \ 1..n {\n            for k in j + 1..n {\n                if (a[i as usize] +\
    \ a[j as usize] + a[k as usize]) % 3 == 0 {\n                    res += 1;\n \
    \               }\n            }\n        }\n    }\n    res", "    let mut sum\
    \ = 0;\n    for i in 1..n-1 {\n        for j in i+1..n {\n            if (i*i-i+1\
    \ + j*j-j+1) % 3 == 0 {\n                sum += n - j;\n                break;\n\
    \            }\n        }\n    }\n    sum", "    let mut arr = vec![0; n as usize];\n\
    \    for i in 0..n {\n        arr[i as usize] = i * i - i + 1;\n    }\n    let\
    \ mut count = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n \
    \           for k in j + 1..n {\n                if (arr[i as usize] + arr[j as\
    \ usize] + arr[k as usize]) % 3 == 0 {\n                    count += 1;\n    \
    \            }\n            }\n        }\n    }\n    count", "    let mut arr\
    \ = Vec::new();\n    for i in 1..=n {\n        arr.push(i * i - i + 1);\n    }\n\
    \    // println!(\"{:?}\", arr);\n    let mut total = 0;\n    for i in 0..n -\
    \ 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n    \
    \            if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n                    total\
    \ += 1;\n                }\n            }\n        }\n    }\n    total", "   \
    \ let mut a: Vec<isize> = vec![0; n as usize];\n    let mut count = 0;\n    for\
    \ i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut sum = 0;\n    for j in 1..n {\n        for k in j+1..n+1\
    \ {\n            sum += 1;\n        }\n    }\n    sum", "    let mut triples =\
    \ 0;\n    for i in 1..n - 1 {\n        for j in i + 1..n {\n            for k\
    \ in j + 1..n + 1 {\n                if (i * i - i + 1 + j * j - j + 1 + k * k\
    \ - k + 1) % 3 == 0 {\n                    triples += 1;\n                }\n\
    \            }\n        }\n    }\n    triples", '    (1..n).map(|i| (i * i - i
    + 1) % 3).filter(|&x| x == 0).count() as isize', "    let mut res = 0;\n    let\
    \ vals = (1..=n).map(|x| x * x - x + 1).collect::<Vec<isize>>();\n    for i in\
    \ 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n\
    \                if (vals[i] + vals[j] + vals[k]) % 3 == 0 {\n               \
    \     res += 1;\n                }\n            }\n        }\n    }\n    res",
  "    if n < 3 {\n        return 0;\n    }\n    let mut v: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        v.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (v[i] + v[j] + v[k]) % 3 == 0 {\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut x = 1;\n    let mut a = vec![];\n    for _ in\
    \ 0..n {\n        a.push(x);\n        x += 2;\n    }\n    let mut count = 0;\n\
    \    for i in 0..a.len() - 2 {\n        for j in i + 1..a.len() - 1 {\n      \
    \      for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3\
    \ == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n    for\
    \ i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut count = 0;\n\
    \    for i in 0..a.len() {\n        for j in i+1..a.len() {\n            for k\
    \ in j+1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n    \
    \                count += 1;\n                }\n            }\n        }\n  \
    \  }\n    count", "    if n < 3 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    for i in 1..n - 1 {\n        for j in i + 1..n {\n            let\
    \ r = (i * i - i + 1) + (j * j - j + 1);\n            if r % 3 == 0 {\n      \
    \          count += 1;\n            }\n        }\n    }\n    count"]
stop_tokens:
- "\n}"
