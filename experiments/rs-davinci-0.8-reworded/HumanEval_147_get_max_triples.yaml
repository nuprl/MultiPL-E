name: HumanEval_147_get_max_triples
language: rs
prompt: "/// You are given a positive integer n. You have to create an integer vector\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>>\
  \ get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The\
  \ only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n\
    \        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", "    let\
    \ mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    let mut res = 0;\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n                }\n\
    \            }\n        }\n    }\n    res", "\tlet mut a: Vec<isize> = vec![0;\
    \ n as usize];\n\tlet mut n_triples = 0;\n\tfor i in 0..n {\n\t\ta[i as usize]\
    \ = i * i - i + 1;\n\t}\n\tfor i in 0..n {\n\t\tfor j in i+1..n {\n\t\t\tfor k\
    \ in j+1..n {\n\t\t\t\tif (a[i as usize] + a[j as usize] + a[k as usize]) % 3\
    \ == 0 {\n\t\t\t\t\tn_triples += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tn_triples",
  "    let a = (1..n + 1).map(|x| x * x - x + 1).collect::<Vec<isize>>();\n    let\
    \ mut count = 0;\n    for i in 0..a.len() {\n        for j in i + 1..a.len() {\n\
    \            for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut triples:\
    \ Vec<(isize, isize, isize)> = Vec::new();\n    for i in 0..a.len() - 2 {\n  \
    \      for j in i + 1..a.len() - 1 {\n            for k in j + 1..a.len() {\n\
    \                if a[i] + a[j] + a[k] % 3 == 0 {\n                    triples.push((a[i],\
    \ a[j], a[k]));\n                }\n            }\n        }\n    }\n    triples.len()\
    \ as isize", "    let mut res = 0;\n    for i in 1..n-1 {\n        let j = i +\
    \ 1;\n        let k = j + 1;\n        if (i * i - i + 1 + j * j - j + 1 + k *\
    \ k - k + 1) % 3 == 0 {\n            res += 1;\n        }\n    }\n    res", " \
    \   let mut max_triples = 0;\n    let mut a = Vec::new();\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    max_triples += 1;\n         \
    \       }\n            }\n        }\n    }\n    max_triples", "    let mut res\
    \ = 0;\n    let mut a = vec![0; n as usize];\n    for i in 0..n {\n        a[i\
    \ as usize] = i * i - i + 1;\n    }\n    for i in 0..n {\n        for j in i +\
    \ 1..n {\n            for k in j + 1..n {\n                if (a[i as usize] +\
    \ a[j as usize] + a[k as usize]) % 3 == 0 {\n                    res += 1;\n \
    \               }\n            }\n        }\n    }\n    res", "    let mut sum\
    \ = 0;\n    for i in 1..n-1 {\n        for j in i+1..n {\n            if (i*i-i+1\
    \ + j*j-j+1) % 3 == 0 {\n                sum += n - j;\n                break;\n\
    \            }\n        }\n    }\n    sum", "    let mut arr = vec![0; n as usize];\n\
    \    for i in 0..n {\n        arr[i as usize] = i * i - i + 1;\n    }\n    let\
    \ mut count = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n \
    \           for k in j + 1..n {\n                if (arr[i as usize] + arr[j as\
    \ usize] + arr[k as usize]) % 3 == 0 {\n                    count += 1;\n    \
    \            }\n            }\n        }\n    }\n    count", "    let mut arr\
    \ = Vec::new();\n    for i in 1..=n {\n        arr.push(i * i - i + 1);\n    }\n\
    \    // println!(\"{:?}\", arr);\n    let mut total = 0;\n    for i in 0..n -\
    \ 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n    \
    \            if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n                    total\
    \ += 1;\n                }\n            }\n        }\n    }\n    total", "   \
    \ let mut a: Vec<isize> = vec![0; n as usize];\n    let mut count = 0;\n    for\
    \ i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut sum = 0;\n    for j in 1..n {\n        for k in j+1..n+1\
    \ {\n            sum += 1;\n        }\n    }\n    sum", "    let mut triples =\
    \ 0;\n    for i in 1..n - 1 {\n        for j in i + 1..n {\n            for k\
    \ in j + 1..n + 1 {\n                if (i * i - i + 1 + j * j - j + 1 + k * k\
    \ - k + 1) % 3 == 0 {\n                    triples += 1;\n                }\n\
    \            }\n        }\n    }\n    triples", '    (1..n).map(|i| (i * i - i
    + 1) % 3).filter(|&x| x == 0).count() as isize', "    let mut res = 0;\n    let\
    \ vals = (1..=n).map(|x| x * x - x + 1).collect::<Vec<isize>>();\n    for i in\
    \ 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n\
    \                if (vals[i] + vals[j] + vals[k]) % 3 == 0 {\n               \
    \     res += 1;\n                }\n            }\n        }\n    }\n    res",
  "    if n < 3 {\n        return 0;\n    }\n    let mut v: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        v.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (v[i] + v[j] + v[k]) % 3 == 0 {\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut x = 1;\n    let mut a = vec![];\n    for _ in\
    \ 0..n {\n        a.push(x);\n        x += 2;\n    }\n    let mut count = 0;\n\
    \    for i in 0..a.len() - 2 {\n        for j in i + 1..a.len() - 1 {\n      \
    \      for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3\
    \ == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n    for\
    \ i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut count = 0;\n\
    \    for i in 0..a.len() {\n        for j in i+1..a.len() {\n            for k\
    \ in j+1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n    \
    \                count += 1;\n                }\n            }\n        }\n  \
    \  }\n    count", "    if n < 3 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    for i in 1..n - 1 {\n        for j in i + 1..n {\n            let\
    \ r = (i * i - i + 1) + (j * j - j + 1);\n            if r % 3 == 0 {\n      \
    \          count += 1;\n            }\n        }\n    }\n    count", "    (1..n\
    \ - 1).fold(0, |sum, i| {\n        let k = n - 1 - i;\n        let j = k - i;\n\
    \        if 2 * i + j < n && (2 * i + j) % 3 == 0 {\n            sum + 1\n   \
    \     } else {\n            sum\n        }\n    })", "    // The values of a[i]\
    \ = i * i - i + 1 is divisible by 3 if i is divisible by 3.\n    // So the values\
    \ of a[i] for which a[i] is divisible by 3 is i = 3, 6, 9, 12...\n    // For example,\
    \ when n = 10, a = [1, 3, 7, 13, 21, 31, 43, 57, 73, 91]. \n    // For this a\
    \ vector, the only valid triple is (7, 31, 43).\n    // So, the number of triples\
    \ is n / 3 - 2.\n    n / 3 - 2", "    let arr: Vec<isize> = (1..n + 1).map(|i|\
    \ i * i - i + 1).collect();\n    println!(\"{:?}\", arr);\n    let mut count =\
    \ 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for\
    \ k in j + 1..n {\n                if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut arr = Vec::with_capacity(n as usize);\n    for\
    \ i in 1..=n {\n        arr.push(i * i - i + 1);\n    }\n    let res = arr.iter().enumerate().map(|(i,\
    \ ai)| {\n        arr.iter().enumerate().filter(|(j, _)| i < *j).map(|(j, aj)|\
    \ {\n            arr.iter().enumerate().filter(|(k, _)| j < *k)\n            \
    \    .filter(|(_, ak)| (ai + aj + ak) % 3 == 0)\n                .count()\n  \
    \      }).sum::<usize>()\n    }).sum::<usize>();\n    res as isize", "    let\
    \ mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    let mut a: Vec<isize> =\
    \ Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n \
    \   let mut count = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1\
    \ {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    if n < 3 {\n        return 0;\n    }\n\
    \    let mut a = vec![0; n as usize];\n    let mut counter = 0;\n    for i in\
    \ 1..n {\n        a[i as usize] = i * i - i + 1;\n        for j in 0..i-1 {\n\
    \            for k in j+1..i {\n                if (a[j as usize] + a[k as usize]\
    \ + a[i as usize]) % 3 == 0 {\n                    counter += 1;\n           \
    \     }\n            }\n        }\n    }\n    counter", "    let mut count = 0;\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j\
    \ + 1) - (j + 1) + 1 + (k + 1) * (k + 1) - (k + 1) + 1 % 3 == 0 {\n          \
    \          count += 1;\n                }\n            }\n        }\n    }\n \
    \   count", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n \
    \       a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", "    let\
    \ mut a: Vec<isize> = Vec::new();\n    let mut res: isize = 0;\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n                }\n\
    \            }\n        }\n    }\n    res", "    let mut triple_count = 0;\n \
    \   let mut curr = 1;\n    let mut a = vec![0; n as usize];\n    let mut j = 0;\n\
    \    let mut k = 0;\n    for i in 0..n {\n        a[i as usize] = curr;\n    \
    \    curr += 2;\n        j = i + 1;\n        while j < n {\n            k = j\
    \ + 1;\n            while k < n {\n                if (a[i as usize] + a[j as\
    \ usize] + a[k as usize]) % 3 == 0 {\n                    triple_count += 1;\n\
    \                }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n    }\n    triple_count", "    let arr = (1..=n).map(|i| i * i - i\
    \ + 1).collect::<Vec<isize>>();\n    let mut sum = 0;\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n          \
    \      if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n                    sum += 1;\n\
    \                }\n            }\n        }\n    }\n    sum", "    let mut count\
    \ = 0;\n    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    let mut triples: isize = 0;\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         triples += 1;\n                }\n            }\n        }\n    }\n\
    \    triples", "    (1..n - 1).fold(0, |acc, i| {\n        let mut curr_sum =\
    \ a(i);\n        let mut j = i + 1;\n        while curr_sum < n {\n          \
    \  curr_sum += a(j);\n            j += 1;\n        }\n        if curr_sum % 3\
    \ == 0 {\n            acc + 1\n        } else {\n            acc\n        }\n\
    \    })", "    if n < 3 {\n        return 0;\n    }\n    let mut total = 0;\n\
    \    for i in 1..n - 1 {\n        for j in i + 1..n {\n            for k in j\
    \ + 1..n + 1 {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0 {\n                    total += 1;\n                }\n      \
    \      }\n        }\n    }\n    total", "    if n < 3 {\n        return 0;\n \
    \   }\n    let mut a = Vec::new();\n    for i in 1..n+1 {\n        a.push(i *\
    \ i - i + 1);\n    }\n    let mut sum = 0;\n    for i in 0..n-2 {\n        for\
    \ j in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    sum += 1;\n                }\n     \
    \       }\n        }\n    }\n    sum", "    let mut cnt = 0;\n    for i in 0..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n                 \
    \   cnt += 1;\n                }\n            }\n        }\n    }\n    cnt", " \
    \   let mut c = 0;\n    let a = (1..=n).map(|e| e * e - e + 1).collect::<Vec<isize>>();\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         c += 1;\n                }\n            }\n        }\n    }\n    c",
  "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n    \
    \    for j in i + 1..n - 1 {\n            for k in j + 1..n {\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    let mut a: Vec<isize>\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        a[i as usize] = i * i -\
    \ i + 1;\n    }\n    let mut cnt = 0;\n    for i in 0..n {\n        for j in i\
    \ + 1..n {\n            for k in j + 1..n {\n                if (a[i as usize]\
    \ + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    cnt += 1;\n\
    \                }\n            }\n        }\n    }\n    cnt", "    if n < 3 {\n\
    \        return 0;\n    }\n    let mut a = Vec::with_capacity(n as usize);\n \
    \   for i in 1..n+1 {\n        a.push(i * i - i + 1);\n    }\n    let mut ans\
    \ = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k\
    \ in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n                    ans += 1;\n                }\n            }\n\
    \        }\n    }\n    ans", "    let mut triples = 0;\n    let mut a = [0; 32];\n\
    \    for i in 1..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut\
    \ i = 0;\n    while i < n - 2 {\n        let mut j = i + 1;\n        while j <\
    \ n - 1 {\n            let mut k = j + 1;\n            while k < n {\n       \
    \         if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n    \
    \                triples += 1;\n                }\n                k += 1;\n \
    \           }\n            j += 1;\n        }\n        i += 1;\n    }\n    triples",
  "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    let mut result = 0;\n    for i in 0..n-2 {\n        for\
    \ j in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    result += 1;\n                }\n  \
    \          }\n        }\n    }\n    result", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut sum\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n  \
    \                  sum += 1;\n                }\n            }\n        }\n  \
    \  }\n    sum", "    let mut count = 0;\n    let v: Vec<isize> = (1..=n).map(|i|\
    \ i * i - i + 1).collect();\n    let mut i = 0;\n    while i < v.len() - 2 {\n\
    \        let mut j = i + 1;\n        while j < v.len() - 1 {\n            let\
    \ mut k = j + 1;\n            while k < v.len() {\n                if (v[i] +\
    \ v[j] + v[k]) % 3 == 0 {\n                    count += 1;\n                }\n\
    \                k += 1;\n            }\n            j += 1;\n        }\n    \
    \    i += 1;\n    }\n    count", "    let mut a: Vec<isize> = vec![];\n    for\
    \ i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut count =\
    \ 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for\
    \ k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n      \
    \              count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n+1 {\n\
    \        a.push(i*i - i + 1);\n    }\n    let mut cnt = 0;\n    for i in 0..a.len()\
    \ {\n        for j in i+1..a.len() {\n            for k in j+1..a.len() {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    cnt +=\
    \ 1;\n                }\n            }\n        }\n    }\n    cnt", "    let mut\
    \ count = 0;\n    for i in 1..n {\n        for j in i+1..n {\n            for\
    \ k in j+1..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0 {\n                    count += 1;\n                }\n      \
    \      }\n        }\n    }\n    count", "    let mut sum = 0;\n    let mut triple_count\
    \ = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                sum = i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1;\n                if sum % 3 == 0 {\n                    triple_count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    triple_count", " \
    \   (n * (n - 1) * (n - 2) / 6)\n        .wrapping_add(n * (n - 1) / 2)\n    \
    \    .wrapping_add(n * (n - 1) * (n - 2) * (n - 3) / 24)", "    let mut triples:\
    \ isize = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for\
    \ k in j+1..n {\n                if (i*i-i+1+j*j-j+1+k*k-k+1) % 3 == 0 {\n   \
    \                 triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", '    unimplemented!();', "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut result\
    \ = 0;\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n - 1) {\n     \
    \       for k in (j + 1)..n {\n                if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 {\n                    result += 1;\n                }\n            }\n  \
    \      }\n    }\n    result", "    let s: isize = n * (n + 1) / 2;\n    if s %\
    \ 3 == 0 {\n        let a: isize = s / 3;\n        let b: isize = 2 * a;\n   \
    \     (n - b) * (n - b - 1) / 2\n    } else {\n        0\n    }", "\tlet mut a:\
    \ Vec<isize> = Vec::new();\n\tfor i in 1..n+1 {\n\t\ta.push(i*i - i + 1);\n\t\
    }\n\tlet mut cnt = 0;\n\tfor i in 0..n-2 {\n\t\tfor j in i+1..n-1 {\n\t\t\tfor\
    \ k in j+1..n {\n\t\t\t\tif (a[i] + a[j] + a[k]) % 3 == 0 {\n\t\t\t\t\tcnt +=\
    \ 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcnt", "    let a = (1..n + 1).map(|x|\
    \ x * x - x + 1).collect::<Vec<isize>>();\n    let mut s = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    s += 1;\n\
    \                }\n            }\n        }\n    }\n    s", "    let mut sum\
    \ = 0;\n    let mut multiples = 0;\n    for i in 0..n {\n        let x = i * i\
    \ - i + 1;\n        sum += x;\n        if sum % 3 == 0 {\n            multiples\
    \ += 1;\n        }\n    }\n    multiples", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut n_triples\
    \ = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k\
    \ in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n          \
    \          n_triples += 1;\n                }\n            }\n        }\n    }\n\
    \    n_triples", "    if n < 3 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    for i in 1..n - 1 {\n        for j in i + 1..n {\n            for\
    \ k in j + 1..n + 1 {\n                if (i * i - i + 1 + j * j - j + 1 + k *\
    \ k - k + 1) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    let mut arr = vec![];\n   \
    \ let mut max_triples = 0;\n    for i in 1..=n {\n        arr.push(i * i - i +\
    \ 1);\n    }\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n     \
    \       for k in j + 1..n {\n                if (arr[i] + arr[j] + arr[k]) % 3\
    \ == 0 {\n                    max_triples += 1;\n                }\n         \
    \   }\n        }\n    }\n    max_triples", "    let mut a: Vec<isize> = vec![];\n\
    \    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    println!(\"\
    {:?}\", a);\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j\
    \ in i + 1..a.len() {\n            for k in j + 1..a.len() {\n               \
    \ if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n      \
    \          }\n            }\n        }\n    }\n    return count;", "    let mut\
    \ cnt = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n            let\
    \ s = i * i - i + 1 + j * j - j + 1;\n            for k in (j + 1)..n {\n    \
    \            if s + k * k - k + 1 % 3 == 0 {\n                    cnt += 1;\n\
    \                }\n            }\n        }\n    }\n    cnt", "    let mut a:\
    \ Vec<isize> = vec![0; n as usize];\n    for i in 0..n {\n        a[i as usize]\
    \ = i * i - i + 1;\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n \
    \       for j in i + 1..n - 1 {\n            for k in j + 1..n {\n           \
    \     if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n          \
    \          count += 1;\n                }\n            }\n        }\n    }\n \
    \   count", "    let mut a: Vec<isize> = vec![];\n    let mut count = 0;\n   \
    \ for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n\
    \ {\n        for j in i + 1..n {\n            for k in j + 1..n {\n          \
    \      if a[i] + a[j] + a[k] % 3 == 0 {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n    count", "    let mut res\
    \ = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n            let val\
    \ = i * i - i + 1 + j * j - j + 1;\n            for k in j + 1..n {\n        \
    \        if (k * k - k + 1 + val) % 3 == 0 {\n                    res += 1;\n\
    \                }\n            }\n        }\n    }\n    res", "    let a = get_a(n);\n\
    \    let mut count = 0;\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n\
    \ - 1) {\n            for k in (j + 1)..n {\n                if (a[i as usize]\
    \ + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ count = 0;\n    let mut arr = vec![0; n as usize];\n    for i in 0..n {\n  \
    \      arr[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n - 2 {\n    \
    \    for j in i + 1..n - 1 {\n            for k in j + 1..n {\n              \
    \  if arr[i as usize] + arr[j as usize] + arr[k as usize] % 3 == 0 {\n       \
    \             count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut res = 0;\n    for i in 0..n - 2 {\n        for j in\
    \ i + 1..n - 1 {\n            if (i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j\
    \ + 1) - (j + 1) + 1\n                >= (n - 1) * (n - 1) - (n - 1) + 1\n   \
    \         {\n                break;\n            }\n            for k in j + 1..n\
    \ {\n                if (i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j + 1) -\
    \ (j + 1) + 1\n                    + (k + 1) * (k + 1) - (k + 1) + 1\n       \
    \             % 3\n                    == 0\n                {\n             \
    \       res += 1;\n                }\n            }\n        }\n    }\n    res",
  "    if n < 3 {\n        return 0;\n    }\n    let mut a = Vec::with_capacity(n\
    \ as usize);\n    let mut rv = 0;\n    for i in 1..n {\n        a.push(i * i -\
    \ i + 1);\n    }\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n       \
    \     for k in j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k\
    \ as usize]) % 3 == 0 {\n                    rv += 1;\n                }\n   \
    \         }\n        }\n    }\n    rv", "    let mut a: Vec<isize> = Vec::new();\n\
    \    let mut res: isize = 0;\n    for i in 1..=n {\n        a.push(i * i - i +\
    \ 1);\n    }\n    for j in 0..n - 2 {\n        for k in j + 1..n - 1 {\n     \
    \       if (a[j] + a[k]) % 3 == 0 {\n                for l in k + 1..n {\n   \
    \                 if (a[j] + a[k] + a[l]) % 3 == 0 {\n                       \
    \ res += 1;\n                    }\n                }\n            }\n       \
    \ }\n    }\n    res", "    let mut max_triples = 0;\n    let mut my_vec = vec![];\n\
    \    for i in 1..n+1 {\n        my_vec.push(i*i - i + 1);\n    }\n    for x in\
    \ 0..my_vec.len() {\n        for y in (x+1)..my_vec.len() {\n            for z\
    \ in (y+1)..my_vec.len() {\n                if my_vec[x] + my_vec[y] + my_vec[z]\
    \ % 3 == 0 {\n                    max_triples += 1;\n                }\n     \
    \       }\n        }\n    }\n    max_triples", "    let mut _a: Vec<isize> = Vec::new();\n\
    \    for _i in 1..n + 1 {\n        _a.push(_i * _i - _i + 1);\n    }\n    let\
    \ mut _res: isize = 0;\n    for _i in 0.._a.len() {\n        for _j in (_i + 1).._a.len()\
    \ {\n            for _k in (_j + 1).._a.len() {\n                if (_a[_i] +\
    \ _a[_j] + _a[_k]) % 3 == 0 {\n                    _res += 1;\n              \
    \  }\n            }\n        }\n    }\n    _res", "    if n < 3 {\n        return\
    \ 0;\n    }\n    let mut count = 0;\n    for i in 1..n {\n        for j in (i\
    \ + 1)..n {\n            for k in (j + 1)..n {\n                if (i * i - i\
    \ + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", '    unimplemented!()',
  "    let mut a: Vec<isize> = vec![];\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n-2 {\n        for\
    \ j in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    count += 1;\n                }\n   \
    \         }\n        }\n    }\n    count", "    let mut res = 0;\n    let mut\
    \ a = vec![];\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         res += 1;\n                }\n            }\n        }\n    }\n    res",
  "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    println!(\"a = {:?}\", a);\n    let mut cnt = 0;\n   \
    \ for i in 0..a.len() {\n        for j in i+1..a.len() {\n            for k in\
    \ j+1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n       \
    \             cnt += 1;\n                }\n            }\n        }\n    }\n\
    \    cnt", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n  \
    \      a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", '    (1..n
    - 1).filter(|&i| (i + i + 1) % 3 == 0).count() as isize', "    let mut v: Vec<isize>\
    \ = Vec::new();\n    let mut cnt = 0;\n    for i in 1..=n {\n        v.push(i\
    \ * i - i + 1);\n    }\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1\
    \ {\n            for k in j + 1..n {\n                if (v[i] + v[j] + v[k])\
    \ % 3 == 0 {\n                    cnt += 1;\n                }\n            }\n\
    \        }\n    }\n    cnt", "    let mut a: Vec<isize> = Vec::new();\n    for\
    \ i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut cnt = 0;\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         cnt += 1;\n                }\n            }\n        }\n    }\n    cnt",
  "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    let mut sum = 0;\n    for i in 0..n-2 {\n        for j\
    \ in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    sum += 1;\n                }\n     \
    \       }\n        }\n    }\n    sum", "    let mut count = 0;\n    let mut i\
    \ = 1;\n    let mut j = 2;\n    let mut k = 3;\n    while i < n && j < n && k\
    \ < n {\n        if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n\
    \            count += 1;\n            k += 1;\n        } else if j < k {\n   \
    \         j += 1;\n        } else {\n            i += 1;\n            j = i +\
    \ 1;\n            k = j + 1;\n        }\n    }\n    count", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j in (i +\
    \ 1)..a.len() {\n            for k in (j + 1)..a.len() {\n                if a[i]\
    \ + a[j] + a[k] % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    if n < 3 {\n        return\
    \ 0;\n    }\n    let mut a = vec![];\n    for i in 1..n + 1 {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut result = 0;\n    for i in 0..n - 2 {\n   \
    \     for j in i + 1..n - 1 {\n            for k in j + 1..n {\n             \
    \   if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    result += 1;\n   \
    \             }\n            }\n        }\n    }\n    result", "    let a = (1..n\
    \ + 1).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    let mut count = 0;\n\
    \    for i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let arr = (1..n + 1).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    let\
    \ res = arr.iter().enumerate().map(|(i, _)| {\n        arr.iter().enumerate().filter(|(j,\
    \ _)| i < *j).filter(|(j, _)| (arr[i] + arr[*j]) % 3 == 0).map(|(j, _)| {\n  \
    \          arr.iter().enumerate().filter(|(k, _)| j < *k).filter(|(k, _)| (arr[i]\
    \ + arr[*j] + arr[*k]) % 3 == 0).count() as isize\n        }).sum::<isize>()\n\
    \    }).sum::<isize>();\n    res", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut counter\
    \ = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k\
    \ in j+1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n          \
    \          counter += 1;\n                }\n            }\n        }\n    }\n\
    \    counter", "    let mut a: Vec<isize> = vec![];\n    for i in 1..n+1 {\n \
    \       a.push(i*i - i + 1);\n    }\n    let mut triple_count = 0;\n    for i\
    \ in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    triple_count\
    \ += 1;\n                }\n            }\n        }\n    }\n    triple_count",
  "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut sum: isize = 0;\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n          \
    \      if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    sum += 1;\n   \
    \             }\n            }\n        }\n    }\n    sum", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut count = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n\
    \ - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    if n < 3 {return 0;}\n    let mut a =\
    \ vec![0; n as usize];\n    for i in 0..n {\n        a[i as usize] = i * i - i\
    \ + 1;\n    }\n    let mut ans = 0;\n    for i in 0..n - 2 {\n        for j in\
    \ i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i as\
    \ usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    ans\
    \ += 1;\n                }\n            }\n        }\n    }\n    ans", '    unimplemented!();',
  "    let mut a: Vec<isize> = vec![];\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n {\n        for j\
    \ in i+1..n {\n            for k in j+1..n {\n                if a[i] + a[j] +\
    \ a[k] % 3 == 0 {\n                    count += 1;\n                }\n      \
    \      }\n        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n\
    \    let mut count = 0;\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    if n <= 2 {\n        return 0;\n    }\n    let mut answer\
    \ = 0;\n    let n = n as usize;\n    let mut a = vec![0; n];\n    for i in 0..n\
    \ {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    answer\
    \ += 1;\n                }\n            }\n        }\n    }\n    answer", "  \
    \  // Write your code here\n    let mut triples = 0;\n    let mut i = 0;\n   \
    \ while i < n - 2 {\n        let mut j = i + 1;\n        while j < n - 1 {\n \
    \           let mut k = j + 1;\n            while k < n {\n                if\
    \ (i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j + 1) - (j + 1) + 1 + (k + 1)\
    \ * (k + 1) - (k + 1) + 1 % 3 == 0 {\n                    triples += 1;\n    \
    \            }\n                k += 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    triples", "    let mut count = 0;\n  \
    \  let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut a: Vec<isize> = Vec::new();\n    let mut i: isize = 1;\n\
    \    while i <= n {\n        a.push(i * i - i + 1);\n        i += 1;\n    }\n\
    \    let mut c: isize = 0;\n    let mut i: isize = 0;\n    while i < n - 2 {\n\
    \        let mut j: isize = i + 1;\n        while j < n - 1 {\n            let\
    \ mut k: isize = j + 1;\n            while k < n {\n                if (a[i as\
    \ usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    c +=\
    \ 1;\n                }\n                k += 1;\n            }\n            j\
    \ += 1;\n        }\n        i += 1;\n    }\n    c", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n\
    \    let mut triples: isize = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1\
    \ {\n            for k in j+1..n {\n                if (a[i] + a[j] + a[k]) %\
    \ 3 == 0 {\n                    triples += 1;\n                }\n           \
    \ }\n        }\n    }\n    triples", "    let mut result = 0;\n    let mut a =\
    \ Vec::with_capacity(n as usize);\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n -\
    \ 1) {\n            for k in (j + 1)..n {\n                if (a[i as usize] +\
    \ a[j as usize] + a[k as usize]) % 3 == 0 {\n                    result += 1;\n\
    \                }\n            }\n        }\n    }\n    result", "    let mut\
    \ res = 0;\n    for i in 1..n {\n        for j in i+1..n {\n            for k\
    \ in j+1..n {\n                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) %\
    \ 3 == 0 {\n                    res += 1;\n                }\n            }\n\
    \        }\n    }\n    res", "    if n <= 2 {\n        return 0;\n    }\n    let\
    \ mut count = 0;\n    for i in 1..(n - 1) {\n        let ai = i * i - i + 1;\n\
    \        for j in (i + 1)..(n - 1) {\n            let aj = j * j - j + 1;\n  \
    \          if (ai + aj) % 3 != 0 {\n                continue;\n            }\n\
    \            for k in (j + 1)..n {\n                let ak = k * k - k + 1;\n\
    \                if (ai + aj + ak) % 3 == 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ a: Vec<isize> = vec![];\n    let mut count = 0;\n    for i in 1..=n {\n    \
    \    a.push(i * i - i + 1);\n    }\n    for i in 0..n-2 {\n        for j in i+1..n-1\
    \ {\n            for k in j+1..n {\n                if a[i] + a[j] + a[k] % 3\
    \ == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut triple_count = 0;\n    let mut prev_sum\
    \ = None;\n    for i in 1..=n {\n        let cur_sum = i * i - i + 1;\n      \
    \  if let Some(sum) = prev_sum {\n            if (sum + cur_sum) % 3 == 0 {\n\
    \                triple_count += 1;\n            }\n        }\n        prev_sum\
    \ = Some(cur_sum);\n    }\n    triple_count", "    let mut a: Vec<isize> = Vec::new();\n\
    \    let mut sum = 0;\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \        if i >= 3 {\n            for j in 0..i - 2 {\n                for k in\
    \ j + 1..i - 1 {\n                    sum += (a[j] + a[k] + a[i - 1]) % 3 == 0;\n\
    \                }\n            }\n        }\n    }\n    return sum;", '    0',
  "    let a = (1..n+1).map(|i| i*i - i + 1).collect::<Vec<isize>>();\n    a.iter().combinations(3).filter(|v|\
    \ (v[0] + v[1] + v[2]) % 3 == 0).count() as isize", '    unimplemented!()', " \
    \   // create our vector of numbers\n    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    // now we need\
    \ to find the number of sublists that sum to a multiple of 3\n    // there are\
    \ 5 sublists\n    // [0, 1, 2, 3, 4]\n    // [0, 1, 2, 3]\n    // [0, 1, 2]\n\
    \    // [0, 1]\n    // [0]\n    // the number of sublists of length n is n * (n\
    \ + 1) / 2\n    // so, for n = 5, there are 15 sublists of length 2, 10 sublists\
    \ of length 3, etc.\n    // which is exactly (n * (n + 1) / 2)\n    // so we have\
    \ to add n, n - 1, n - 2, n - 3, n - 4, n - 5\n    // our loop will be i = n,\
    \ n - 1, n - 2, ... , 6, 5, 4, 3, 2, 1\n    // our loop will be i = n, n - 1,\
    \ n - 2, ... , 6, 5, 4, 3, 2, 1\n    // our loop will be i = n, n - 1, n - 2,\
    \ ... , 6, 5, 4, 3, 2, 1\n    // our loop will be i = n, n - 1, n - 2, ... , 6,\
    \ 5, 4, 3, 2, 1\n    // our loop will be i = n, n - 1, n - 2, ... , 6, 5, 4, 3,\
    \ 2, 1\n    // our loop will be i = n, n - 1, n - 2, ... , 6, 5, 4, 3, 2, 1\n\
    \    // our loop will be i = n, n - 1, n - 2, ... , 6, 5, 4, 3, 2, 1\n    // our\
    \ loop will be i = n, n - 1, n - 2, ... , 6, 5, 4, 3, 2, 1\n    // our loop will\
    \ be i = n, n - 1, n - 2, ... , 6, 5, 4, 3, 2, 1", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    let mut res: isize = 0;\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n\
    \ - 1) {\n            for k in (j + 1)..n {\n                if (a[i] + a[j] +\
    \ a[k]) % 3 == 0 {\n                    res += 1;\n                }\n       \
    \     }\n        }\n    }\n    res", "    let mut sum: isize = 0;\n    for i in\
    \ 1..n {\n        let mut a: isize = (i - 1) * (i - 1) - (i - 1) + 1;\n      \
    \  for j in i+1..n {\n            let mut b: isize = (j - 1) * (j - 1) - (j -\
    \ 1) + 1;\n            for k in j+1..n {\n                let mut c: isize = (k\
    \ - 1) * (k - 1) - (k - 1) + 1;\n                if (a + b + c) % 3 == 0 {\n \
    \                   sum += 1;\n                }\n            }\n        }\n \
    \   }\n    sum", "    let mut count = 0;\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                  \
    \  count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let mut counter = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n\
    \            for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1) % 3 == 0 {\n                    counter += 1;\n   \
    \             }\n            }\n        }\n    }\n    counter", "    let mut sum\
    \ = 0;\n    let mut x = 1;\n    for i in 0..n {\n        for j in i + 1..n {\n\
    \            for k in j + 1..n {\n                if (x + 3 * j + 9 * k) % 3 ==\
    \ 0 {\n                    sum += 1;\n                }\n            }\n     \
    \   }\n        x += 2;\n    }\n    sum", "    let a = (1..n + 1).map(|x| x * x\
    \ - x + 1).collect::<Vec<isize>>();\n    let mut res = 0;\n    for i in 0..n -\
    \ 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n    \
    \            if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n\
    \                }\n            }\n        }\n    }\n    res", "    let mut a:\
    \ Vec<isize> = vec![];\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n\
    \    }\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j in i\
    \ + 1..a.len() {\n            for k in j + 1..a.len() {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    let a = (1..n+1).map(|x|\
    \ x*x - x + 1).collect::<Vec<isize>>();\n    let mut count = 0;\n    for i in\
    \ 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n     \
    \           if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", '    (1..n).filter(|i|
    (2 * i - 1) % 3 == 0).count() as isize', "    let mut a: Vec<isize> = vec![];\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut counter\
    \ = 0;\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n - 1) {\n     \
    \       for k in (j + 1)..n {\n                if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 {\n                    counter += 1;\n                }\n            }\n \
    \       }\n    }\n    counter", "    let mut triples = 0;\n    let mut sum = 0;\n\
    \    let mut a = Vec::with_capacity(n as usize);\n    for i in 1..=n {\n     \
    \   let x = i * i - i + 1;\n        a.push(x);\n        for j in 0..(i - 2) {\n\
    \            for k in (j + 1)..(i - 1) {\n                sum = a[j as usize]\
    \ + a[k as usize] + a[i as usize - 1];\n                if sum % 3 == 0 {\n  \
    \                  triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", "    let mut a: Vec<isize> = vec![];\n    for i in 1..n\
    \ + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for\
    \ i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut count = 0;\n    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n\
    \ + 1 {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n    \
    \    for j in i + 1..n - 1 {\n            for k in j + 1..n {\n              \
    \  if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j in i + 1..a.len()\
    \ {\n            for k in j + 1..a.len() {\n                if (a[i] + a[j] +\
    \ a[k]) % 3 == 0 {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    count", "    let mut max_triples = 0;\n    let\
    \ mut array = Vec::new();\n    for i in 1..n+1 {\n        array.push(i*i - i +\
    \ 1);\n    }\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n           \
    \ for k in j+1..n {\n                if (array[i] + array[j] + array[k]) % 3 ==\
    \ 0 {\n                    max_triples += 1;\n                }\n            }\n\
    \        }\n    }\n    max_triples", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut counter\
    \ = 0;\n    for i in 0..a.len() - 2 {\n        for j in i + 1..a.len() - 1 {\n\
    \            for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    counter += 1;\n                }\n         \
    \   }\n        }\n    }\n    counter", "    if n < 3 {\n        return 0;\n  \
    \  }\n    let mut a = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i *\
    \ i - i + 1);\n    }\n    let mut n_max_triples = 0;\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n          \
    \      if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    n_max_triples +=\
    \ 1;\n                }\n            }\n        }\n    }\n    n_max_triples",
  "    let mut triples = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n  \
    \          for k in j + 1..n {\n                if (i * i - i + 1 + j * j - j\
    \ + 1 + k * k - k + 1) % 3 == 0 {\n                    triples += 1;\n       \
    \         }\n            }\n        }\n    }\n    triples", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n\
    \    let mut result = 0;\n    for i in 0..a.len() {\n        for j in i + 1..a.len()\
    \ {\n            for k in j + 1..a.len() {\n                if (a[i] + a[j] +\
    \ a[k]) % 3 == 0 {\n                    result += 1;\n                }\n    \
    \        }\n        }\n    }\n    result", "    let mut triple_counter = 0;\n\
    \    for i in 1..n-1 {\n        for j in i+1..n {\n            for k in j+1..n+1\
    \ {\n                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n\
    \                    triple_counter += 1;\n                }\n            }\n\
    \        }\n    }\n    triple_counter", "    let mut count = 0;\n    for i in\
    \ 1..n - 1 {\n        for j in i + 1..n {\n            for k in j + 1..n + 1 {\n\
    \                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n\
    \ + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for\
    \ i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ // Write your code here\n    0", "    // Fill the vector with entries of the\
    \ form i*i - i + 1\n    let mut a: Vec<isize> = (1..=n).map(|x| x*x - x + 1).collect();\n\
    \    let mut total = 0;\n    // Brute force every single triple of numbers in\
    \ a\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0\
    \ {\n                    total += 1;\n                }\n            }\n     \
    \   }\n    }\n    total", "    let mut a: Vec<isize> = vec![0; n as usize];\n\
    \    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut\
    \ ans = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n       \
    \     if (a[i as usize] + a[j as usize]) % 3 != 0 {\n                continue;\n\
    \            }\n            for k in j + 1..n {\n                if (a[i as usize]\
    \ + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    ans += 1;\n\
    \                }\n            }\n        }\n    }\n    ans", "    (1..n - 1).fold(0,\
    \ |acc, x| {\n        (x + 1..n).fold(acc, |acc, y| {\n            if (x * x -\
    \ x + 1 + y * y - y + 1) % 3 == 0 {\n                acc + 1\n            } else\
    \ {\n                acc\n            }\n        })\n    })", "    let mut a:\
    \ Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n        for j in i +\
    \ 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    count += 1;\n                }\n   \
    \         }\n        }\n    }\n    count", "    let mut res = 0;\n    let mut\
    \ a = Vec::with_capacity(n as usize);\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    for i in 0..a.len() - 2 {\n        for j in i + 1..a.len()\
    \ - 1 {\n            for k in j + 1..a.len() {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    res += 1;\n                }\n     \
    \       }\n        }\n    }\n    res", "    if n <= 2 {\n        return 0;\n \
    \   }\n    let mut a = vec![];\n    for i in 1..=n {\n        a.push(i * i - i\
    \ + 1);\n    }\n    let mut count = 0;\n    for i in 0..n-2 {\n        for j in\
    \ i+1..n-1 {\n            if (a[i] + a[j]) % 3 == 0 {\n                let mut\
    \ k = j + 1;\n                while k < n && a[i] + a[j] + a[k] < 3 * a[k] {\n\
    \                    k += 1;\n                }\n                count += k -\
    \ j - 1;\n            }\n        }\n    }\n    count", "    // The formula for\
    \ (a[i], a[j], a[k]) is\n    // a[i] + a[j] + a[k] = 3 * m\n    // where m is\
    \ the number of valid pairs (a[i], a[j])\n    // So, the task reduces to finding\
    \ the number of triples\n    // (i, j, k) where i < j < k, and a[i] + a[j] is\
    \ a multiple of 3.\n    // For each i, we can compute a[i] % 3.\n    // Then,\
    \ for each pair (i, j) where i < j, we can find a[i] + a[j] % 3.\n    // Since\
    \ a[i] + a[j] % 3 = (a[i] % 3 + a[j] % 3) % 3, \n    // we can compute this in\
    \ advance, and store in a table.\n    // Then, for each (i, j) where i < j, we\
    \ can find the number of \n    // valid triples where a[i] + a[j] is a multiple\
    \ of 3.\n    // Finally, we sum over all such pairs.\n    let mut n_triples =\
    \ 0;\n    let mut a = vec![0; n as usize];\n    let mut remainder_cnt = vec![0;\
    \ 3];\n    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n        let\
    \ rem = a[i as usize] % 3;\n        remainder_cnt[rem as usize] += 1;\n    }\n\
    \    // The number of valid pairs (a[i], a[j]) where i < j\n    // and a[i] +\
    \ a[j] is a multiple of 3 is\n    // pairs[0] = n - 1 + remainder_cnt[1] * remainder_cnt[2]\n\
    \    // pairs[1] = remainder_cnt[0] * remainder_cnt[2]\n    // pairs[2] = remainder_cnt[0]\
    \ * remainder_cnt[1]\n    // The number of valid triples (a[i], a[j], a[k]) where\
    \ i < j < k", "\tlet mut ans = 0;\n\tlet mut a = Vec::new();\n\tfor i in 1..=n\
    \ {\n\t\ta.push(i * i - i + 1);\n\t}\n\tfor i in 0..a.len() {\n\t\tfor j in i\
    \ + 1..a.len() {\n\t\t\tfor k in j + 1..a.len() {\n\t\t\t\tif (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n\t\t\t\t\tans += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans", " \
    \   let mut a: Vec<isize> = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..a.len()-2 {\n    \
    \    for j in i+1..a.len()-1 {\n            for k in j+1..a.len() {\n        \
    \        if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ counter = 0;\n    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n\
    \        a.push(i * i - i + 1);\n    }\n    for i in 0..n {\n        for j in\
    \ i+1..n {\n            for k in j+1..n {\n                if a[i] + a[j] + a[k]\
    \ % 3 == 0 {\n                    counter += 1;\n                }\n         \
    \   }\n        }\n    }\n    counter", "    let v = (1..n + 1).map(|i| i * i -\
    \ i + 1).collect::<Vec<isize>>();\n    let mut count = 0;\n    for i in 0..v.len()\
    \ {\n        for j in i + 1..v.len() {\n            for k in j + 1..v.len() {\n\
    \                if (v[i] + v[j] + v[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut a: Vec<isize> = vec![];\n    let mut count = 0;\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..n-2 {\n        for\
    \ j in i+1..n-1 {\n            for k in j+1..n {\n                if a[i] + a[j]\
    \ + a[k] % 3 == 0 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n    }\n    count", "    let a = (1..n + 1).map(|x| x *\
    \ x - x + 1).collect::<Vec<isize>>();\n    let mut cnt = 0;\n    for i in 0..a.len()\
    \ {\n        for j in i..a.len() {\n            for k in j..a.len() {\n      \
    \          if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    cnt += 1;\n\
    \                }\n            }\n        }\n    }\n    cnt", "    let mut i\
    \ = 1;\n    let mut a = Vec::new();\n    while i <= n {\n        a.push(i * i\
    \ - i + 1);\n        i += 1;\n    }\n    let mut counter = 0;\n    for (i, ai)\
    \ in a.iter().enumerate() {\n        for (j, aj) in a.iter().enumerate() {\n \
    \           if i < j {\n                for (k, ak) in a.iter().enumerate() {\n\
    \                    if j < k {\n                        if (ai + aj + ak) % 3\
    \ == 0 {\n                            counter += 1;\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   counter", "    let mut a: Vec<isize> = vec![0; n as usize];\n    for i in\
    \ 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut sum = 0;\n\
    \    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n\
    \                    sum += 1;\n                }\n            }\n        }\n\
    \    }\n    sum", "    let mut a: Vec<isize> = vec![0; n as usize];\n    for i\
    \ in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (a[i as usize] + a[j as usize] + a[k\
    \ as usize]) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    let mut c = 0;\n    for a in\
    \ 1..n - 1 {\n        let a1 = (a + 1) * (a + 1) - (a + 1) + 1;\n        for b\
    \ in a + 1..n {\n            let b1 = (b + 1) * (b + 1) - (b + 1) + 1;\n     \
    \       for c in b + 1..n + 1 {\n                let c1 = (c + 1) * (c + 1) -\
    \ (c + 1) + 1;\n                if (a1 + b1 + c1) % 3 == 0 {\n               \
    \     c += 1;\n                }\n            }\n        }\n    }\n    c", " \
    \   // get an array [1, 3, 7, 13, 21, ...]\n    let mut a: Vec<isize> = (1..n\
    \ + 1).map(|x| x * x - x + 1).collect();\n    let mut max_triples = 0;\n    for\
    \ j in 1..n {\n        for k in (j + 1)..n {\n            let sum = a[j as usize]\
    \ + a[k as usize];\n            if sum % 3 == 0 {\n                max_triples\
    \ += 1;\n            }\n        }\n    }\n    max_triples", "    let mut a: Vec<isize>\
    \ = vec![0; n as usize];\n    let mut res = 0;\n    for i in 0..n {\n        a[i\
    \ as usize] = i * i - i + 1;\n        for j in i+1..n {\n            for k in\
    \ j+1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n                    res += 1;\n                }\n            }\n\
    \        }\n    }\n    res", "    let mut n_triples = 0;\n    for i in 1..n {\n\
    \        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n          \
    \      if (i*i-i+1) + (j*j-j+1) + (k*k-k+1) % 3 == 0 {\n                    n_triples\
    \ += 1;\n                }\n            }\n        }\n    }\n    n_triples", " \
    \   let mut sum: isize = 0;\n    for i in 1..n {\n        for j in (i + 1)..n\
    \ {\n            for k in (j + 1)..n {\n                if (i * i - i + 1 + j\
    \ * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    sum += 1;\n   \
    \             }\n            }\n        }\n    }\n    sum", "    assert!(n > 0);\n\
    \    let mut a = vec![0; n as usize];\n    let mut result = 0;\n    let mut sum\
    \ = 0;\n    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n        if\
    \ i >= 2 {\n            sum += a[i as usize - 2];\n            if sum % 3 == 0\
    \ {\n                result += 1;\n            }\n        }\n    }\n    result",
  "    let mut triple_count = 0;\n    for i in 1..n {\n        for j in i+1..n {\n\
    \            for k in j+1..n {\n                if ((i*i - i + 1) + (j*j - j +\
    \ 1) + (k*k - k + 1)) % 3 == 0 {\n                    triple_count += 1;\n   \
    \             }\n            }\n        }\n    }\n    triple_count", "    let\
    \ mut a: Vec<isize> = vec![];\n    for i in 1..n + 1 {\n        a.push(i * i -\
    \ i + 1);\n    }\n    let mut ans = 0;\n    for i in 0..n - 2 {\n        for j\
    \ in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    ans += 1;\n                }\n\
    \            }\n        }\n    }\n    ans", "    let mut s = 0;\n    for i in\
    \ 1..n-1 {\n        for j in i+1..n {\n            let ai = i * i - i + 1;\n \
    \           let aj = j * j - j + 1;\n            let ak = (j+1) * (j+1) - (j+1)\
    \ + 1;\n            if (ai + aj + ak) % 3 == 0 {\n                s += 1;\n  \
    \          }\n        }\n    }\n    s", "    let mut a: Vec<_> = (1..=n).map(|i|\
    \ i * i - i + 1).collect();\n    a.sort();\n    let mut cnt = 0;\n    for i in\
    \ 0..n - 2 {\n        for j in i + 1..n - 1 {\n            let k = a[j] + a[i];\n\
    \            if k % 3 == 0 {\n                let pos = a.binary_search(&k).unwrap();\n\
    \                let st = pos + 1;\n                let ed = n;\n            \
    \    cnt += ed - st;\n            }\n        }\n    }\n    cnt", "    let mut\
    \ count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for\
    \ k in j+1..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k\
    \ + 1) % 3 == 0 {\n                    count += 1;\n                }\n      \
    \      }\n        }\n    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    println!(\"\
    {:?}\", a);\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j\
    \ in i+1..a.len() {\n            for k in j+1..a.len() {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    let mut a: Vec<isize> =\
    \ Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n\
    \    let mut result = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n \
    \           for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 {\n                    result += 1;\n                }\n            }\n  \
    \      }\n    }\n    result", "    let mut res = 0;\n    let mut triple: Vec<isize>\
    \ = Vec::new();\n    for i in 1..=n {\n        triple.push(i * i - i + 1);\n \
    \   }\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if (triple[i] + triple[j] + triple[k]) % 3 == 0\
    \ {\n                    res += 1;\n                }\n            }\n       \
    \ }\n    }\n    res", "    let mut a: Vec<isize> = Vec::new();\n    let mut result\
    \ = 0;\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    for i\
    \ in 0..a.len() {\n        for j in i+1..a.len() {\n            for k in j+1..a.len()\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    result\
    \ += 1;\n                }\n            }\n        }\n    }\n    result", "  \
    \  let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    let mut res = 0;\n    for i in 0..n - 2 {\n      \
    \  for j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if\
    \ (a[i] + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n           \
    \     }\n            }\n        }\n    }\n    res", "    let a = get_nums(n);\n\
    \    let mut count = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n\
    \            for k in (j + 1)..n {\n                if (a[i as usize] + a[j as\
    \ usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n      \
    \          }\n            }\n        }\n    }\n    count", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut count = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n\
    \            for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3\
    \ == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    if n < 3 {\n        return 0;\n    }\n   \
    \ let mut count = 0;\n    for a in 1..n - 1 {\n        for b in a + 1..n {\n \
    \           let c = (a * a - a + 1) + (b * b - b + 1);\n            if c % 3 ==\
    \ 0 {\n                count += 1;\n            }\n        }\n    }\n    count",
  "    if n < 3 {\n        return 0;\n    }\n    let mut a = vec![0; n as usize];\n\
    \    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut\
    \ count = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n     \
    \       if (a[i as usize] + a[j as usize]) % 3 != 0 {\n                continue;\n\
    \            }\n            for k in j + 1..n {\n                if (a[i as usize]\
    \ + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    count", "    let mut\
    \ result = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n            for\
    \ k in j + 1..n {\n                if (i*i-i+1 + j*j-j+1 + k*k-k+1) % 3 == 0 {\n\
    \                    result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    let mut sum = 0;\n    let mut v: Vec<isize> = vec![0;\
    \ n as usize];\n    for i in 0..n {\n        v[i as usize] = i * i - i + 1;\n\
    \    }\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (v[i as usize] + v[j as usize] + v[k as usize]) % 3 ==\
    \ 0 {\n                    sum += 1;\n                }\n            }\n     \
    \   }\n    }\n    sum", "    if n < 2 {\n        return 0;\n    }\n    let mut\
    \ tmp_arr = Vec::new();\n    for i in 1..=n {\n        tmp_arr.push(i * i - i\
    \ + 1);\n    }\n    let mut count = 0;\n    for i in 0..tmp_arr.len() - 2 {\n\
    \        for j in i + 1..tmp_arr.len() - 1 {\n            for k in j + 1..tmp_arr.len()\
    \ {\n                if (tmp_arr[i] + tmp_arr[j] + tmp_arr[k]) % 3 == 0 {\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n\
    \ {\n        a.push(i * i - i + 1);\n    }\n    let mut k = 0;\n    for i in 0..n\
    \ - 2 {\n        for j in i + 1..n - 1 {\n            for m in j + 1..n {\n  \
    \              if (a[i] + a[j] + a[m]) % 3 == 0 {\n                    k += 1;\n\
    \                }\n            }\n        }\n    }\n    k", "    // Your code\
    \ here\n    let mut triples = 0;\n    let mut a = vec![0; n as usize];\n    for\
    \ i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n\
    \ {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n      \
    \          if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n   \
    \                 triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", "    let mut result = 0;\n    for i in 1..n - 1 {\n    \
    \    for j in i + 1..n {\n            let a_i = i * i - i + 1;\n            let\
    \ a_j = j * j - j + 1;\n            let a_k = (j + 1) * (j + 1) - (j + 1) + 1;\n\
    \            if (a_i + a_j + a_k) % 3 == 0 {\n                result += 1;\n \
    \           }\n        }\n    }\n    result", "    let mut a: Vec<isize> = Vec::new();\n\
    \    let mut num_triples = 0;\n    for i in 1..=n {\n        a.push(i * i - i\
    \ + 1);\n    }\n    for (i, _) in a.iter().enumerate() {\n        for (j, _) in\
    \ a.iter().enumerate() {\n            if j > i {\n                for (k, _) in\
    \ a.iter().enumerate() {\n                    if k > j {\n                   \
    \     if (a[i] + a[j] + a[k]) % 3 == 0 {\n                            num_triples\
    \ += 1;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    num_triples", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n\
    \    let mut max = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1\
    \ {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    max += 1;\n                }\n            }\n\
    \        }\n    }\n    max", "    let mut count = 0;\n    let mut a = vec![];\n\
    \    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    for i in 0..n-2\
    \ {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n            \
    \    if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n    count", "    let mut v =\
    \ vec![];\n    let mut res = 0;\n    for i in 1..=n {\n        v.push(i * i -\
    \ i + 1);\n    }\n    for i in 0..v.len() {\n        for j in i + 1..v.len() {\n\
    \            for k in j + 1..v.len() {\n                if (v[i] + v[j] + v[k])\
    \ % 3 == 0 {\n                    res += 1;\n                }\n            }\n\
    \        }\n    }\n    res", "\t(1..n).map(|i| (i*i - i + 1) % 3).collect::<Vec<_>>().windows(3).filter(|w|\
    \ w.iter().sum::<isize>() % 3 == 0).count() as isize", "    let mut sum = 0;\n\
    \    for a in 1..n {\n        for b in (a + 1)..n {\n            for c in (b +\
    \ 1)..n {\n                if (a + b + c) % 3 == 0 {\n                    sum\
    \ += 1;\n                }\n            }\n        }\n    }\n    sum", "    //\
    \ Your code here\n    unimplemented!();", "    let mut results = vec![0; n as\
    \ usize];\n    let mut a = vec![0; n as usize];\n    for i in 0..n {\n       \
    \ a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n {\n        for j in\
    \ i + 1..n {\n            for k in j + 1..n {\n                if a[i as usize]\
    \ + a[j as usize] + a[k as usize] % 3 == 0 {\n                    results[(i +\
    \ j + k) as usize] += 1;\n                }\n            }\n        }\n    }\n\
    \    *results.iter().max().unwrap()", "\tif n < 3 { return 0; }\n\tlet mut a =\
    \ vec![0; n as usize];\n\tlet mut s = 0;\n\tfor i in 1..n {\n\t\ta[i as usize]\
    \ = i * i - i + 1;\n\t\tif a[i as usize] % 3 == 0 { s += 1; }\n\t}\n\tlet mut\
    \ i = 0;\n\tlet mut j = 0;\n\tlet mut k = 0;\n\tlet mut c = 0;\n\twhile i < n\
    \ {\n\t\twhile j < n {\n\t\t\twhile k < n {\n\t\t\t\tif i < j && j < k && (a[i\
    \ as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n\t\t\t\t\tc += 1;\n\t\
    \t\t\t}\n\t\t\t\tk += 1;\n\t\t\t}\n\t\t\tj += 1;\n\t\t}\n\t\ti += 1;\n\t}\n\t\
    return c;", "    let mut a: Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n\
    \        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n\
    \ {\n        for j in i + 1..n {\n            for k in j + 1..n {\n          \
    \      if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n \
    \               }\n            }\n        }\n    }\n    count", "    let mut a:\
    \ Vec<isize> = vec![0; n as usize];\n    let mut res = 0;\n    for i in 0..n {\n\
    \        a[i as usize] = i * i - i + 1;\n        if i > 1 {\n            for j\
    \ in 1..i {\n                if (a[i as usize] + a[j as usize]) % 3 == 0 {\n \
    \                   for k in 0..j {\n                        if (a[i as usize]\
    \ + a[j as usize] + a[k as usize]) % 3 == 0 {\n                            res\
    \ += 1;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    res", "    let mut triples = 0;\n    for\
    \ i in 1..n-1 {\n        for j in i+1..n {\n            for k in j+1..n+1 {\n\
    \                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n   \
    \                 triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", "    if n < 3 {\n        return 0;\n    }\n    let mut result\
    \ = 0;\n    let mut cnt_array = vec![0; 3];\n    for i in 0..3 {\n        cnt_array[i]\
    \ = (n - i) / 3;\n    }\n    for i in 3..n {\n        cnt_array[i % 3] += (n -\
    \ i) / 3;\n    }\n    for i in 0..3 {\n        let mut cnt = 0;\n        for j\
    \ in 0..3 {\n            cnt += cnt_array[(i + j) % 3];\n        }\n        result\
    \ += cnt * cnt_array[i];\n    }\n    result", "    let n = n as usize;\n    let\
    \ mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = i * i - i + 1;\n  \
    \  }\n    let mut cnt = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n\
    \ - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    cnt += 1;\n                }\n            }\n\
    \        }\n    }\n    cnt", "    let mut count = 0;\n    for i in 0..n {\n  \
    \      for j in i + 1..n {\n            for k in j + 1..n {\n                if\
    \ ((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 == 0 {\n         \
    \           count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut cnt = 0;\n    let mut v = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        v[i as usize] = i * i - i + 1;\n    }\n    for i in\
    \ 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n         \
    \       if (v[i as usize] + v[j as usize] + v[k as usize]) % 3 == 0 {\n      \
    \              cnt += 1;\n                }\n            }\n        }\n    }\n\
    \    cnt", "    let mut result = 0;\n    let mut a = vec![];\n    for i in 1..n+1\
    \ {\n        a.push(i*i - i + 1);\n    }\n    for i in 0..n-2 {\n        for j\
    \ in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    result += 1;\n                }\n  \
    \          }\n        }\n    }\n    result", "    if n < 3 {\n        return 0;\n\
    \    }\n    let mut triple_count = 0;\n    let mut i = 1;\n    while i < n - 1\
    \ {\n        let ai = i * i - i + 1;\n        if ai % 3 == 0 {\n            triple_count\
    \ += n - i - 1;\n        }\n        i += 1;\n    }\n    triple_count", "    let\
    \ mut a: Vec<isize> = vec![];\n    let mut cnt = 0;\n    for i in 1..=n {\n  \
    \      a.push(i * i - i + 1);\n    }\n    for i in 0..n - 2 {\n        for j in\
    \ i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i] +\
    \ a[j] + a[k]) % 3 == 0 {\n                    cnt += 1;\n                }\n\
    \            }\n        }\n    }\n    cnt", "    let mut count = 0;\n    for i\
    \ in 0..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n\
    \                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    // TODO - add code here\n    0", "    let mut a: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n   \
    \ }\n    let mut count = 0;\n    for i in 0..a.len() {\n        for j in i + 1..a.len()\
    \ {\n            for k in j + 1..a.len() {\n                if (a[i] + a[j] +\
    \ a[k]) % 3 == 0 {\n                    count += 1;\n                }\n     \
    \       }\n        }\n    }\n    count", "    let mut a: Vec<isize> = vec![0;\
    \ n as usize];\n    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n\
    \    }\n    let mut res = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n\
    \            for k in j + 1..n {\n                if (a[i as usize] + a[j as usize]\
    \ + a[k as usize]) % 3 == 0 {\n                    res += 1;\n               \
    \ }\n            }\n        }\n    }\n    res", "    let mut a: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n  \
    \                  count += 1;\n                }\n            }\n        }\n\
    \    }\n    count"]
stop_tokens:
- "\n}"
