language: rs
name: HumanEval_93_encode
results:
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n      \
    \  if vowels.contains(&letter) {\n            let encoded_letter = match letter\
    \ {\n                'a' => 'c',\n                'e' => 'g',\n              \
    \  'i' => 'k',\n                'o' => 'q',\n                'u' => 's',\n   \
    \             _ => letter,\n            };\n            encoded_message.push(encoded_letter);\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    }\n\
    \    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpp1dneb1w.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| \n        match c {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           _ => c,\n        }\n    ).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp514qsphr.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let num = c as u8;\n        let encoded_num = if num >= 65 && num\
    \ <= 90 {\n            num + 33\n        } else if num >= 97 && num <= 122 {\n\
    \            num - 31\n        } else {\n            num\n        };\n       \
    \ encoded_message.push(encoded_num as char);\n    }\n    encoded_message\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uftu\"`,\n right: `\"tgst\"`', /tmp/tmp89zoe5jv.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x|\n        match x {\n            x if\
    \ x.is_ascii_uppercase() => x.to_ascii_lowercase(),\n            x if x.is_ascii_lowercase()\
    \ => x.to_ascii_uppercase(),\n            x if (x == 'a' || x == 'e' || x == 'i'\
    \ || x == 'o' || x == 'u') => 'c',\n            _ => x\n        }\n    ).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpea5kt98h.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: implement\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpbuyf1xz2.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        let mut ch = ch.to_ascii_lowercase();\n        if ch == 'a' {\n \
    \           ch = 'c';\n        } else if ch == 'e' {\n            ch = 'g';\n\
    \        } else if ch == 'i' {\n            ch = 'k';\n        } else if ch ==\
    \ 'o' {\n            ch = 'q';\n        } else if ch == 'u' {\n            ch\
    \ = 'y';\n        }\n        result.push(ch);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mydcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmph63fqujj.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            let mut ch = c.to_ascii_lowercase();\n\
    \            if ch == 'z' {\n                ch = 'b';\n            } else if\
    \ ch == 'y' {\n                ch = 'a';\n            } else {\n             \
    \   match ch {\n                    'a' | 'b' | 'c' => ch = 'd',\n           \
    \         'd' | 'e' | 'f' => ch = 'g',\n                    'g' | 'h' | 'i' =>\
    \ ch = 'j',\n                    'j' | 'k' | 'l' => ch = 'm',\n              \
    \      'm' | 'n' | 'o' => ch = 'p',\n                    'p' | 'q' | 'r' => ch\
    \ = 's',\n                    's' | 't' | 'u' => ch = 'v',\n                 \
    \   'v' | 'w' | 'x' => ch = 'y',\n                    'y' | 'z' => unreachable!(),\n\
    \                    _ => unreachable!(),\n                }\n            }\n\
    \            result.push(ch);\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vgvv\"`,\n right: `\"tgst\"`', /tmp/tmpea7581mp.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| match c {\n        'a'...'e' => c.to_uppercase().next().unwrap_or(c),\n\
    \        'f'...'j' => c.to_lowercase().next().unwrap_or(c),\n        'k'...'o'\
    \ => c.to_uppercase().next().unwrap_or(c),\n        'p'...'t' => c.to_lowercase().next().unwrap_or(c),\n\
    \        'u'...'y' => c.to_uppercase().next().unwrap_or(c),\n        'z' => 'a',\n\
    \        'Z' => 'A',\n        _ => c,\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp2lpwen0v.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'A'\
    \ | 'a' => 'C',\n            'E' | 'e' => 'G',\n            'I' | 'i' => 'K',\n\
    \            'O' | 'o' => 'M',\n            'U' | 'u' => 'Q',\n            'Y'\
    \ | 'y' => 'U',\n            _ => c.to_ascii_uppercase(),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpiwsp0ijc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = [String::from(\"A\"), String::from(\"E\"), String::from(\"\
    I\"), String::from(\"O\"), String::from(\"U\")];\n    let mut output = String::new();\n\
    \    for c in message.chars() {\n        let mut is_vowel = false;\n        for\
    \ i in 0..vowels.len() {\n            if vowels[i] == c.to_string().to_uppercase()\
    \ {\n                is_vowel = true;\n                output.push_str(&vowels[(i\
    \ + 2) % vowels.len()].to_lowercase());\n            }\n        }\n        if\
    \ !is_vowel {\n            output.push(c);\n        }\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ToST\"`,\n right: `\"tgst\"`', /tmp/tmppi6mkcq_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::new();\n    for character in message.chars() {\n        if character.is_ascii_uppercase()\
    \ {\n            encoded_message.push(character.to_ascii_lowercase());\n     \
    \   } else if character.is_ascii_lowercase() {\n            if vowels.contains(&character)\
    \ {\n                encoded_message.push(get_next_vowel(character));\n      \
    \      } else {\n                encoded_message.push(character.to_ascii_uppercase());\n\
    \            }\n        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_next_vowel` in this scope\n  -->\
    \ /tmp/tmpw4kwomnh.rs:19:38\n   |\n19 |                 encoded_message.push(get_next_vowel(character));\n\
    \   |                                      ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::new();\n    for character in message.chars() {\n        let new_character\
    \ = match character {\n            'A'...'Z' => match character.to_lowercase().next().unwrap()\
    \ {\n                'a' => 'c',\n                'e' => 'g',\n              \
    \  'i' => 'k',\n                'o' => 'q',\n                'u' => 's',\n   \
    \             _ => character.to_lowercase().next().unwrap(),\n            },\n\
    \            'a'...'z' => match character {\n                'a' => 'c',\n   \
    \             'e' => 'g',\n                'i' => 'k',\n                'o' =>\
    \ 'q',\n                'u' => 's',\n                _ => character,\n       \
    \     },\n            _ => character,\n        };\n        encoded_message.push(new_character);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"msdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp32l0a38o.rs:42:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let is_upper = c.is_uppercase();\n        let c = c.to_lowercase().next().unwrap();\n\
    \        let encode_ch = match c {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n\
    \            _ => c,\n        };\n        result.push(if is_upper {\n        \
    \    encode_ch.to_uppercase().next().unwrap()\n        } else {\n            encode_ch\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmptjr1why1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // convert to uppercase\n    let mut result = message.to_uppercase();\n\
    \    // convert to lowercase\n    result = result.to_lowercase();\n    // replace\
    \ vowels with the letter that appears 2 places ahead\n    result = result.replace(\"\
    a\", \"c\");\n    result = result.replace(\"e\", \"g\");\n    result = result.replace(\"\
    i\", \"k\");\n    result = result.replace(\"o\", \"q\");\n    result = result.replace(\"\
    u\", \"s\");\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"msdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpqjpxqk0j.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| encode_char(c)).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmppfvksqe6.rs:12:29\n\
    \   |\n12 |     message.chars().map(|c| encode_char(c)).collect()\n   |      \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            if c != 'u' {\n                encoded_message.push((c as u8\
    \ + 2) as char);\n            } else {\n                encoded_message.push('a');\n\
    \            }\n        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(c.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpt3nip4v7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut message_list:\
    \ Vec<char> = message.chars().collect();\n    let mut out_string = String::new();\n\
    \    for i in 0..message_list.len() {\n        let c = message_list[i];\n    \
    \    if c.is_uppercase() {\n            if c.is_ascii_lowercase() {\n        \
    \        out_string.push(c.to_ascii_uppercase());\n            } else {\n    \
    \            out_string.push(c);\n            }\n        } else {\n          \
    \  if c.is_ascii_uppercase() {\n                out_string.push(c.to_ascii_lowercase());\n\
    \            } else {\n                out_string.push(c);\n            }\n  \
    \      }\n        if vowels.contains(&message_list[i]) {\n            let mut\
    \ index = vowels.iter().position(|&r| r == message_list[i]).unwrap();\n      \
    \      index += 2;\n            index %= vowels.len();\n            out_string.push(vowels[index]);\n\
    \        }\n    }\n    out_string\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpl02vsxu3.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // first map all letters to lowercase to get rid of case issues\n\
    \    let message = message.to_lowercase();\n    // create a bool vector, mapping\
    \ whether the char at the same index\n    // is a vowel or not\n    let message:\
    \ Vec<char> = message.chars().collect();\n    let is_vowel: Vec<bool> = message.iter().map(|&x|\
    \ x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u').collect();\n    //\
    \ create an iterator, which maps each char to the char two positions\n    // up\
    \ in the alphabet, or is a vowel that does the same, but if the index\n    //\
    \ of the char is at the end of the alphabet, it moves back to the beginning\n\
    \    let message: Vec<char> = message.iter().enumerate().map(|(i, &x)| {\n   \
    \     let is_vowel = is_vowel[i];\n        let x = if x == 'z' {\n           \
    \ 'a'\n        } else if x == 'z' {\n            'a'\n        } else {\n     \
    \       ((x as u8 + 2) as char)\n        };\n        if is_vowel {\n         \
    \   x\n        } else {\n            x.to_uppercase().next().unwrap()\n      \
    \  }\n    }).collect();\n    // put everything together, and return\n    message.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VgUV\"`,\n right: `\"tgst\"`', /tmp/tmpd4hqldsu.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let encoded_char = if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        };\n        encoded_message.push(encoded_char);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpa0xypg42.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let vowel = match c {\n\
    \            'a' | 'e' | 'i' | 'o' | 'u' => true,\n            _ => false,\n \
    \       };\n        if vowel {\n            let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n            alphabet.find(c).map(|i| {\n                let i = i + 2;\n  \
    \              if i >= alphabet.len() {\n                    alphabet.chars().nth(i\
    \ - alphabet.len()).unwrap()\n                } else {\n                    alphabet.chars().nth(i).unwrap()\n\
    \                }\n            }).unwrap()\n        } else {\n            c.to_uppercase().next().unwrap()\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmph5hu2e33.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message.to_lowercase();\n    for (i, c) in\
    \ message.chars().enumerate() {\n        if c == 'a' {\n            message.replace_range(i..i+1,\
    \ \"c\");\n        } else if c == 'e' {\n            message.replace_range(i..i+1,\
    \ \"g\");\n        } else if c == 'i' {\n            message.replace_range(i..i+1,\
    \ \"k\");\n        } else if c == 'o' {\n            message.replace_range(i..i+1,\
    \ \"m\");\n        } else if c == 'u' {\n            message.replace_range(i..i+1,\
    \ \"o\");\n        } else if c == 'y' {\n            message.replace_range(i..i+1,\
    \ \"a\");\n        }\n    }\n    let mut encoded_message = String::new();\n  \
    \  for c in message.chars() {\n        if c.is_alphabetic() {\n            let\
    \ alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n        \
    \    let index = alphabet.iter().position(|&r| r == c).unwrap();\n           \
    \ encoded_message.push(alphabet[(index + 2) % 26]);\n        } else {\n      \
    \      encoded_message.push(c);\n        }\n    }\n    encoded_message\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `message` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpshrfk653.rs:15:13\n   |\n13 |     for (i, c) in\
    \ message.chars().enumerate() {\n   |                   ---------------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n14 |         if c ==\
    \ 'a' {\n15 |             message.replace_range(i..i+1, \"c\");\n   |        \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `message` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpshrfk653.rs:17:13\n   |\n13 |     for (i, c) in message.chars().enumerate()\
    \ {\n   |                   ---------------------------\n   |                \
    \   |\n   |                   immutable borrow occurs here\n   |             \
    \      immutable borrow later used here\n...\n17 |             message.replace_range(i..i+1,\
    \ \"g\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror[E0502]: cannot borrow `message` as mutable because it is\
    \ also borrowed as immutable\n  --> /tmp/tmpshrfk653.rs:19:13\n   |\n13 |    \
    \ for (i, c) in message.chars().enumerate() {\n   |                   ---------------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n...\n19 |          \
    \   message.replace_range(i..i+1, \"k\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `message` as mutable\
    \ because it is also borrowed as immutable\n  --> /tmp/tmpshrfk653.rs:21:13\n\
    \   |\n13 |     for (i, c) in message.chars().enumerate() {\n   |            \
    \       ---------------------------\n   |                   |\n   |          \
    \         immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n...\n21 |             message.replace_range(i..i+1, \"m\");\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\
    \nerror[E0502]: cannot "
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO implement this function\n    String::from(\"TODO\"\
    )\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TODO\"`,\n right: `\"tgst\"`', /tmp/tmpwq9hrz4v.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let alphabet =\
    \ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut result\
    \ = String::new();\n    for char in message.chars() {\n        if char.is_alphabetic()\
    \ {\n            if char.is_uppercase() {\n                let index = alphabet.iter().position(|&r|\
    \ r == char.to_lowercase().next().unwrap()).unwrap();\n                if vowels.contains(&alphabet[index])\
    \ {\n                    result.push(alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap());\n\
    \                } else {\n                    result.push(alphabet[index].to_uppercase().next().unwrap());\n\
    \                }\n            } else {\n                let index = alphabet.iter().position(|&r|\
    \ r == char).unwrap();\n                if vowels.contains(&alphabet[index]) {\n\
    \                    result.push(alphabet[(index + 2) % alphabet.len()]);\n  \
    \              } else {\n                    result.push(alphabet[index]);\n \
    \               }\n            }\n        } else {\n            result.push(char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp4_0w83k6.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = String::from(\"aeiou\");\n    let mut m = message.chars().collect::<Vec<char>>();\n\
    \    for (i, v) in m.iter_mut().enumerate() {\n        let vowels = vowels.chars().collect::<Vec<char>>();\n\
    \        if vowels.contains(v) {\n            let index = vowels.iter().position(|&r|\
    \ r == *v).unwrap();\n            let index = match index+2 {\n              \
    \  _ if index == 4 => 0,\n                _ if index == 5 => 1,\n            \
    \    n => n,\n            };\n            *v = vowels[index];\n        }\n   \
    \     *v = match *v {\n            'a' ... 'z' => (*v as u8 - 32) as char,\n \
    \           'A' ... 'Z' => (*v as u8 + 32) as char,\n            _ => *v,\n  \
    \      };\n    }\n    m.iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpk4f7c2ul.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        encoded_message.push(match c {\n            'A' => 'C',\n       \
    \     'a' => 'c',\n            'E' => 'G',\n            'e' => 'g',\n        \
    \    'I' => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n         \
    \   'o' => 'q',\n            'U' => 'Y',\n            'u' => 'y',\n          \
    \  'a'...'z' => ((c as u8) - 32) as char,\n            'A'...'Z' => ((c as u8)\
    \ + 32) as char,\n            _ => c,\n        });\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmponenmtel.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let mut vowels\
    \ = Vec::new();\n    vowels.push('a');\n    vowels.push('e');\n    vowels.push('i');\n\
    \    vowels.push('o');\n    vowels.push('u');\n    vowels.push('A');\n    vowels.push('E');\n\
    \    vowels.push('I');\n    vowels.push('O');\n    vowels.push('U');\n    for\
    \ c in message.chars() {\n        match c {\n            'a' => encoded_message.push('c'),\n\
    \            'e' => encoded_message.push('g'),\n            'i' => encoded_message.push('k'),\n\
    \            'o' => encoded_message.push('m'),\n            'u' => encoded_message.push('q'),\n\
    \            'A' => encoded_message.push('C'),\n            'E' => encoded_message.push('G'),\n\
    \            'I' => encoded_message.push('K'),\n            'O' => encoded_message.push('M'),\n\
    \            'U' => encoded_message.push('Q'),\n            _ => encoded_message.push(c.to_ascii_uppercase()),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpq54ho_x8.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let c = if c.is_uppercase() {\n\
    \                c.to_lowercase().to_string()\n            } else {\n        \
    \        c.to_uppercase().to_string()\n            };\n            result.push_str(&match\
    \ c.as_str() {\n                \"a\" => \"c\",\n                \"e\" => \"g\"\
    ,\n                \"i\" => \"k\",\n                \"o\" => \"q\",\n        \
    \        \"u\" => \"w\",\n                _ => &c,\n            });\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpan0dyf0p.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::from(\"\");\n    for c in\
    \ message.chars() {\n        if c == ' ' {\n            encoded_message.push('\
    \ ');\n        } else {\n            let mut letter_number = c as u8;\n      \
    \      // If lowercase letter\n            if letter_number < 91 {\n         \
    \       letter_number += 32;\n            }\n            // If vowel\n       \
    \     if letter_number == 97 || letter_number == 101 || letter_number == 105 ||\
    \ letter_number == 111 || letter_number == 117 {\n                letter_number\
    \ += 2;\n            }\n            // If uppercase\n            if letter_number\
    \ > 109 {\n                letter_number -= 26;\n            }\n            encoded_message.push(letter_number\
    \ as char);\n        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ZgYZ\"`,\n right: `\"tgst\"`', /tmp/tmpg9w3zaqo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let new_char = match c {\n            'a' | 'A' => 'c',\n       \
    \     'e' | 'E' => 'g',\n            'i' | 'I' => 'k',\n            'o' | 'O'\
    \ => 'q',\n            'u' | 'U' => 'y',\n            'b' | 'B' => 'd',\n    \
    \        'c' | 'C' => 'e',\n            'd' | 'D' => 'f',\n            'f' | 'F'\
    \ => 'h',\n            'g' | 'G' => 'i',\n            'h' | 'H' => 'j',\n    \
    \        'j' | 'J' => 'l',\n            'k' | 'K' => 'm',\n            'l' | 'L'\
    \ => 'n',\n            'm' | 'M' => 'o',\n            'n' | 'N' => 'p',\n    \
    \        'p' | 'P' => 'r',\n            'q' | 'Q' => 's',\n            'r' | 'R'\
    \ => 't',\n            's' | 'S' => 'u',\n            't' | 'T' => 'v',\n    \
    \        'v' | 'V' => 'x',\n            'w' | 'W' => 'z',\n            'x' | 'X'\
    \ => 'a',\n            'y' | 'Y' => 'b',\n            'z' | 'Z' => 'c',\n    \
    \        ' ' => ' ',\n            _ => c,\n        };\n        encoded_message.push(new_char);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vguv\"`,\n right: `\"tgst\"`', /tmp/tmpnvdvq5_w.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_alphabetic() {\n            encoded_message.push(match ch\
    \ {\n                'a' => 'c',\n                'A' => 'C',\n              \
    \  'e' => 'g',\n                'E' => 'G',\n                'i' => 'k',\n   \
    \             'I' => 'K',\n                'o' => 'q',\n                'O' =>\
    \ 'Q',\n                'u' => 'y',\n                'U' => 'Y',\n           \
    \     _ => ch.to_ascii_uppercase(),\n            });\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmppmxs4qk7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let letters = message.to_lowercase();\n    let mut encoded\
    \ = String::from(\"\");\n    for c in letters.chars() {\n        let idx = (c\
    \ as u8 - 'a' as u8) as usize;\n        match c {\n            'a' | 'e' | 'i'\
    \ | 'o' | 'u' => {\n                encoded.push(ALPHABET[(idx + 2) % 26] as char);\n\
    \            },\n            _ => {\n                encoded.push(ALPHABET[idx]\
    \ as char);\n            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpjq6ibhud.rs:18:30\n\
    \   |\n18 |                 encoded.push(ALPHABET[(idx + 2) % 26] as char);\n\
    \   |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpjq6ibhud.rs:21:30\n\
    \   |\n21 |                 encoded.push(ALPHABET[idx] as char);\n   |       \
    \                       ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'A'\
    \ => 'C',\n            'E' => 'G',\n            'I' => 'K',\n            'O' =>\
    \ 'Q',\n            'U' => 'S',\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 's',\n \
    \           _ => c.to_ascii_uppercase(),\n        }\n    }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpu0w4twh2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(swap_case).map(encode_char).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `swap_case` in this scope\n  --> /tmp/tmpfq4m2ax3.rs:12:25\n\
    \   |\n12 |     message.chars().map(swap_case).map(encode_char).collect()\n  \
    \ |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `encode_char` in this scope\n  --> /tmp/tmpfq4m2ax3.rs:12:40\n\
    \   |\n12 |     message.chars().map(swap_case).map(encode_char).collect()\n  \
    \ |                                        ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let start = if c.is_uppercase()\
    \ { 'A' } else { 'a' };\n        match c {\n            'A'|'E'|'I'|'O'|'U' =>\
    \ ((c as u8 + 2 - start as u8) % 26 + start as u8) as char,\n            'a'|'e'|'i'|'o'|'u'\
    \ => ((c as u8 + 2 - start as u8) % 26 + start as u8) as char,\n            _\
    \ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpdzdc8ibw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| match x {\n        'a'...'z' => (((x\
    \ as u8) - ('a' as u8) + 2) % 26 + ('a' as u8)) as char,\n        'A'...'Z' =>\
    \ (((x as u8) - ('A' as u8) + 2) % 26 + ('A' as u8)) as char,\n        _ => x,\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpkql6ml_2.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'w',\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'W',\n            _ => c,\n     \
    \   };\n        encoded.push(new_char);\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpbs5i44h4.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| match c {\n        'a' => 'c',\n  \
    \      'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' => 'w',\n\
    \        'y' => 'a',\n        'A' => 'C',\n        'E' => 'G',\n        'I' =>\
    \ 'K',\n        'O' => 'Q',\n        'U' => 'W',\n        'Y' => 'A',\n      \
    \  _ => c,\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp42_hxoqo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let mut characters\
    \ = message.chars();\n    while let Some(character) = characters.next() {\n  \
    \      if character.is_alphabetic() {\n            let mut character = character.to_ascii_lowercase();\n\
    \            let offset = match character {\n                'a' | 'e' | 'i' |\
    \ 'o' | 'u' => 2,\n                _ => 0,\n            };\n            character\
    \ = (character as u8 + offset) as char;\n            if character > 'z' {\n  \
    \              character = (character as u8 - 26) as char;\n            }\n  \
    \          encoded_message.push(character);\n        } else {\n            encoded_message.push(character);\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mwdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpqx5szv05.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let mut c = c.to_ascii_lowercase();\n        let c_num = c as u8;\n\
    \        if c_num >= 97 && c_num <= 122 {\n            if c_num < 101 {\n    \
    \            c = (c_num + 26) as char;\n            }\n            c = (c_num\
    \ - 2) as char;\n        }\n        result.push(c);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"rcqr\"`,\n right: `\"tgst\"`', /tmp/tmprmbavy1t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut encoded_c = c;\n        if c.is_alphabetic() {\n        \
    \    encoded_c = if c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n\
    \            } else {\n                c.to_lowercase().next().unwrap()\n    \
    \        };\n            if \"aeiou\".contains(encoded_c) {\n                encoded_c\
    \ = ((encoded_c as u8) + 2) as char;\n            }\n        }\n        encoded.push(encoded_c);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmp8dht8n0k.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded\
    \ = String::new();\n    for ch in message.chars() {\n        if ch.is_lowercase()\
    \ {\n            encoded.push(ch.to_uppercase().next().unwrap());\n        } else\
    \ if ch.is_uppercase() {\n            encoded.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded.push(ch);\n        }\n    }\n    for ch\
    \ in encoded.chars() {\n        if vowels.contains(&ch) {\n            let index\
    \ = vowels.iter().position(|&v| v == ch).unwrap();\n            encoded.push(vowels[(index\
    \ + 2) % vowels.len()]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `encoded` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpbgbqt9zq.rs:26:13\n   |\n23 |     for ch in encoded.chars()\
    \ {\n   |               ---------------\n   |               |\n   |          \
    \     immutable borrow occurs here\n   |               immutable borrow later\
    \ used here\n...\n26 |             encoded.push(vowels[(index + 2) % vowels.len()]);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let vowels = String::from(\"\
    aeiou\");\n    for character in message.chars() {\n        if character.is_alphabetic()\
    \ {\n            encoded.push(match character.is_uppercase() {\n             \
    \   true => match character.to_lowercase().next().unwrap() {\n               \
    \     'z' => 'b',\n                    'a'..='y' => (character as u8 + 2) as char,\n\
    \                    _ => character\n                },\n                false\
    \ => match character {\n                    'z' => 'B',\n                    'a'..='y'\
    \ => (character as u8 + 2) as char,\n                    _ => character\n    \
    \            }\n            });\n        } else {\n            encoded.push(character);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpq745krrh.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  let mut result = String::new();\n  let mut c = message.chars();\n\
    \  while let Some(ch) = c.next() {\n    let mut ch = ch;\n    if ch.is_lowercase()\
    \ {\n      ch = ch.to_uppercase().next().unwrap();\n    }\n    if ch.is_uppercase()\
    \ {\n      ch = ch.to_lowercase().next().unwrap();\n    }\n    if ch == 'A' {\n\
    \      ch = 'C';\n    } else if ch == 'E' {\n      ch = 'G';\n    } else if ch\
    \ == 'I' {\n      ch = 'K';\n    } else if ch == 'O' {\n      ch = 'Q';\n    }\
    \ else if ch == 'U' {\n      ch = 'S';\n    } else if ch == 'Y' {\n      ch =\
    \ 'A';\n    }\n    result.push(ch);\n  }\n  result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpdvl4vywi.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut out = String::from(\"\");\n    for ch in message.chars()\
    \ {\n        let mut uc = ch.to_uppercase().next().unwrap();\n        if \"AEIOU\"\
    .contains(uc) {\n            uc = match uc {\n                'A' => 'C',\n  \
    \              'E' => 'I',\n                'I' => 'O',\n                'O' =>\
    \ 'U',\n                'U' => 'A',\n                _ => uc,\n            }\n\
    \        } else {\n            uc = match uc {\n                'B' => 'D',\n\
    \                'C' => 'E',\n                'D' => 'F',\n                'F'\
    \ => 'H',\n                'G' => 'J',\n                'H' => 'K',\n        \
    \        'J' => 'L',\n                'K' => 'M',\n                'L' => 'N',\n\
    \                'M' => 'P',\n                'N' => 'Q',\n                'P'\
    \ => 'R',\n                'Q' => 'S',\n                'R' => 'T',\n        \
    \        'S' => 'V',\n                'T' => 'W',\n                'V' => 'X',\n\
    \                'W' => 'Y',\n                'X' => 'Z',\n                'Y'\
    \ => 'B',\n                'Z' => 'C',\n                _ => uc,\n           \
    \ }\n        }\n        if ch.is_uppercase() {\n            out.push(uc);\n  \
    \      } else {\n            out.push(uc.to_lowercase().next().unwrap());\n  \
    \      }\n    }\n    out\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"WIVW\"`,\n right: `\"tgst\"`', /tmp/tmpo1zgr6x7.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_string = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            encoded_string.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded_string.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_string.push(c);\n        }\n    }\n   \
    \ encoded_string\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpss6jo7pw.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    for ch in message.chars()\
    \ {\n        let ch = match ch {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n\
    \            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n \
    \           'O' => 'Q',\n            'U' => 'Y',\n            ' ' => ' ',\n  \
    \          _ => if ch.is_lowercase() { ch.to_uppercase().to_string() } else {\
    \ ch.to_lowercase().to_string() }\n        };\n        res.push_str(&ch);\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpn4tc5x1d.rs:26:18\n\
    \   |\n14 |           let ch = match ch {\n   |  __________________-\n15 | | \
    \            'a' => 'c',\n16 | |             'e' => 'g',\n17 | |             'i'\
    \ => 'k',\n...  |\n25 | |             ' ' => ' ',\n   | |                    ---\
    \ this and all prior arms are found to be of type `char`\n26 | |             _\
    \ => if ch.is_lowercase() { ch.to_uppercase().to_string() } else { ch.to_lowercase().to_string()\
    \ }\n   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n27 | |         };\n   | |_________-\
    \ `match` arms have incompatible types\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        let encoded_char =\
    \ if c.is_ascii_uppercase() {\n            (c as u8 + 2) as char\n        } else\
    \ if c.is_ascii_lowercase() {\n            (c as u8 + 2) as char\n        } else\
    \ {\n            c\n        };\n        if vowels.contains(&encoded_char) {\n\
    \            encoded_char.to_lowercase().collect::<String>()\n        } else {\n\
    \            encoded_char.to_string()\n        }\n    }\n    encoded\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7acl2vjb.rs:23:13\n   |\n\
    22 | /         if vowels.contains(&encoded_char) {\n23 | |             encoded_char.to_lowercase().collect::<String>()\n\
    \   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`,\
    \ found struct `String`\n24 | |         } else {\n25 | |             encoded_char.to_string()\n\
    26 | |         }\n   | |_________- expected this to be `()`\n   |\nhelp: consider\
    \ using a semicolon here\n   |\n23 |             encoded_char.to_lowercase().collect::<String>();\n\
    \   |                                                            +\nhelp: consider\
    \ using a semicolon here\n   |\n26 |         };\n   |          +\nhelp: you might\
    \ have meant to return this value\n   |\n23 |             return encoded_char.to_lowercase().collect::<String>();\n\
    \   |             ++++++                                                +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7acl2vjb.rs:25:13\n   |\n22 | /\
    \         if vowels.contains(&encoded_char) {\n23 | |             encoded_char.to_lowercase().collect::<String>()\n\
    24 | |         } else {\n25 | |             encoded_char.to_string()\n   | | \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n26\
    \ | |         }\n   | |_________- expected this to be `()`\n   |\nhelp: consider\
    \ using a semicolon here\n   |\n25 |             encoded_char.to_string();\n \
    \  |                                     +\nhelp: consider using a semicolon here\n\
    \   |\n26 |         };\n   |          +\nhelp: you might have meant to return\
    \ this value\n   |\n25 |             return encoded_char.to_string();\n   |  \
    \           ++++++                         +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if let Some(code) = code_char(c) {\n            encoded.push(code);\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `code_char` in this scope\n  --> /tmp/tmpv3f_2ppl.rs:14:29\n\
    \   |\n14 |         if let Some(code) = code_char(c) {\n   |                 \
    \            ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let mut c = c.to_ascii_lowercase();\n\
    \        match c {\n            'a' => 'c',\n            'e' => 'g',\n       \
    \     'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n        \
    \    _ => c\n        }\n    }).map(|c| {\n        if c.is_ascii_lowercase() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp3wigfora.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let v = message.into_bytes();\n    let mut res = vec![];\n\
    \    for c in v {\n        let is_upper = c >= 65 && c <= 90;\n        let is_lower\
    \ = c >= 97 && c <= 122;\n        let is_vowel = c == 97 || c == 101 || c == 105\
    \ || c == 111 || c == 117;\n        if is_upper || is_lower {\n            if\
    \ is_upper {\n                res.push(c.to_ascii_lowercase());\n            }\
    \ else {\n                res.push(c);\n            }\n            if is_vowel\
    \ {\n                res.push(\n                    (c as i8 + 2) as u8\n    \
    \            );\n            }\n        }\n    }\n    String::from_utf8(res).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpdn2xzwg_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for character in message.chars()\
    \ {\n        let character = character.to_ascii_lowercase();\n        match character\
    \ {\n            'a' => encoded.push('c'),\n            'e' => encoded.push('g'),\n\
    \            'i' => encoded.push('k'),\n            'o' => encoded.push('q'),\n\
    \            'u' => encoded.push('s'),\n            'y' => encoded.push('a'),\n\
    \            _ => encoded.push(\n                character.to_ascii_uppercase()\n\
    \            )\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpds6_47_4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let alphabet_upper\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut encoded = String::new();\n  \
    \  for c in message.chars() {\n        let mut found = false;\n        for (i,\
    \ letter) in alphabet.chars().enumerate() {\n            if letter == c {\n  \
    \              let next_letter = alphabet.chars().nth(i + 2).unwrap();\n     \
    \           encoded.push(next_letter);\n                found = true;\n      \
    \          break;\n            }\n        }\n        if !found {\n           \
    \ for (i, letter) in alphabet_upper.chars().enumerate() {\n                if\
    \ letter == c {\n                    let next_letter = alphabet_upper.chars().nth(i\
    \ + 2).unwrap();\n                    encoded.push(next_letter);\n           \
    \         break;\n                }\n            }\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpm1t1ha6p.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut skip = false;\n\
    \    for c in message.chars() {\n        if skip {\n            skip = false;\n\
    \            continue;\n        }\n        let mut i = c.to_string();\n      \
    \  match c {\n            'A' | 'a' => {\n                i = \"C\".to_string();\n\
    \                skip = true;\n            }\n            'E' | 'e' => {\n   \
    \             i = \"G\".to_string();\n                skip = true;\n         \
    \   }\n            'I' | 'i' => {\n                i = \"K\".to_string();\n  \
    \              skip = true;\n            }\n            'O' | 'o' => {\n     \
    \           i = \"M\".to_string();\n                skip = true;\n           \
    \ }\n            'U' | 'u' => {\n                i = \"Q\".to_string();\n    \
    \            skip = true;\n            }\n            'a' => i = \"c\".to_string(),\n\
    \            'b' => i = \"d\".to_string(),\n            'c' => i = \"e\".to_string(),\n\
    \            'd' => i = \"f\".to_string(),\n            'e' => i = \"g\".to_string(),\n\
    \            'f' => i = \"h\".to_string(),\n            'g' => i = \"i\".to_string(),\n\
    \            'h' => i = \"j\".to_string(),\n            'i' => i = \"k\".to_string(),\n\
    \            'j' => i = \"l\".to_string(),\n            'k' => i = \"m\".to_string(),\n\
    \            'l' => i = \"n\".to_string(),\n            'm' => i = \"o\".to_string(),\n\
    \            'n' => i = \"p\".to_string(),\n            'o' => i = \"q\".to_string(),\n\
    \            'p' => i = \"r\".to_string(),\n            'q' => i = \"s\".to_string(),\n\
    \            'r' => i = \"t\".to_string(),\n            's' => i = \"u\".to_string(),\n\
    \            't' => i =\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpd_gowzky.rs:70:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for c in message.chars()\
    \ {\n   |                              - unclosed delimiter\n...\n20 |       \
    \  match c {\n   |                 - this delimiter might not be properly closed...\n\
    ...\n61 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    70 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpd_gowzky.rs:61:1\n\
    \   |\n60 |             't' => i =\n   |                 -- while parsing the\
    \ `match` arm starting here\n61 | }\n   | ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_gowzky.rs:14:5\n   |\n11 |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n14 | /     for c in message.chars() {\n15 | | \
    \        if skip {\n16 | |             skip = false;\n17 | |             continue;\n\
    ...  |\n69 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n70 | | }\n   | |__^ expected\
    \ struct `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  let mut encoded = String::new();\n  let alphabet = vec!['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n  let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n  for ch in message.chars() {\n    let ch_string = ch.to_string();\n\
    \    let ch_lower = ch_string.to_lowercase();\n    if vowels.contains(&ch_lower.chars().nth(0).unwrap())\
    \ {\n      let mut index = alphabet.iter().position(|&x| x == ch_lower.chars().nth(0).unwrap()).unwrap();\n\
    \      index += 2;\n      if index > alphabet.len() - 1 {\n        index -= alphabet.len();\n\
    \      }\n      encoded.push(alphabet[index]);\n    } else {\n      encoded.push(ch);\n\
    \    }\n  }\n  encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpd2660hk1.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let alphabet = vec!['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    for letter in message.chars() {\n        let mut index\
    \ = alphabet.iter().position(|&r| r == letter).unwrap();\n        if vowels.contains(&letter)\
    \ {\n            if index + 2 >= alphabet.len() {\n                index = 0 +\
    \ (index + 2 - alphabet.len());\n            } else {\n                index +=\
    \ 2;\n            }\n        }\n        if letter.is_lowercase() {\n         \
    \   result.push(alphabet[index].to_ascii_uppercase());\n        } else {\n   \
    \         result.push(alphabet[index]);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpqlz7xmte.rs:16:68

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let vowels =\
    \ \"aeiou\";\n    for c in message.chars() {\n        if c.is_lowercase() {\n\
    \            encoded_message.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  for (i, c) in encoded_message.chars().enumerate() {\n        if vowels.contains(c)\
    \ {\n            let vowel_idx = vowels.find(c).unwrap();\n            let encoded_vowel_idx\
    \ = (vowel_idx + 2) % 5;\n            let encoded_vowel = vowels.chars().nth(encoded_vowel_idx).unwrap();\n\
    \            encoded_message.replace_range(i..=i, &encoded_vowel.to_string());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `encoded_message` as mutable because it is\
    \ also borrowed as immutable\n  --> /tmp/tmp4pnlyh6n.rs:28:13\n   |\n23 |    \
    \ for (i, c) in encoded_message.chars().enumerate() {\n   |                  \
    \ -----------------------------------\n   |                   |\n   |        \
    \           immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n...\n28 |             encoded_message.replace_range(i..=i,\
    \ &encoded_vowel.to_string());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"\");\n    let mut vowel_index\
    \ = 0;\n    for character in message.chars() {\n        match character {\n  \
    \          'a' => {\n                encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n\
    \                vowel_index += 1;\n            },\n            'e' => {\n   \
    \             encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n      \
    \          vowel_index += 1;\n            },\n            'i' => {\n         \
    \       encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n            \
    \    vowel_index += 1;\n            },\n            'o' => {\n               \
    \ encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n                vowel_index\
    \ += 1;\n            },\n            'u' => {\n                encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n                vowel_index += 1;\n            },\n\
    \            character => {\n                if character.is_uppercase() {\n \
    \                   encoded.push(character.to_lowercase().next().unwrap());\n\
    \                } else {\n                    encoded.push(character.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmpn7wficnj.rs:17:30\n\
    \   |\n17 |                 encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n\
    \   |                              ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `VOWELS` in this scope\n  --> /tmp/tmpn7wficnj.rs:17:57\n\
    \   |\n17 |                 encoded.push(VOWELS[(vowel_index + 2) % VOWELS.len()]);\n\
    \   |                                                         ^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `VOWELS` in this scope\n  -->\
    \ /tmp/tmpn7wficnj.rs:21:30\n   |\n21 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                              ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `VOWELS` in this scope\n  -->\
    \ /tmp/tmpn7wficnj.rs:21:57\n   |\n21 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                                               \
    \          ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VOWELS`\
    \ in this scope\n  --> /tmp/tmpn7wficnj.rs:25:30\n   |\n25 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                              ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `VOWELS` in this scope\n  -->\
    \ /tmp/tmpn7wficnj.rs:25:57\n   |\n25 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                                               \
    \          ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VOWELS`\
    \ in this scope\n  --> /tmp/tmpn7wficnj.rs:29:30\n   |\n29 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                              ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `VOWELS` in this scope\n  -->\
    \ /tmp/tmpn7wficnj.rs:29:57\n   |\n29 |                 encoded.push(VOWELS[(vowel_index\
    \ + 2) % VOWELS.len()]);\n   |                                               \
    \          ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VOWELS`\
    \ in this scope\n  -->"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut encoded_message = String::new();\n    for ch in message.chars() {\n    \
    \    match ch {\n            'a' => encoded_message.push_str(\"c\"),\n       \
    \     'e' => encoded_message.push_str(\"i\"),\n            'i' => encoded_message.push_str(\"\
    m\"),\n            'o' => encoded_message.push_str(\"s\"),\n            'u' =>\
    \ encoded_message.push_str(\"y\"),\n            'A' => encoded_message.push_str(\"\
    C\"),\n            'E' => encoded_message.push_str(\"I\"),\n            'I' =>\
    \ encoded_message.push_str(\"M\"),\n            'O' => encoded_message.push_str(\"\
    S\"),\n            'U' => encoded_message.push_str(\"Y\"),\n            _ => encoded_message.push(ch),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TIST\"`,\n right: `\"tgst\"`', /tmp/tmpy7ac3hqj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let mut chars = message.chars();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_ascii_lowercase() {\n\
    \            output.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            output.push(c.to_ascii_lowercase());\n        } else {\n    \
    \        output.push(c);\n        }\n    }\n    output\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp24w3igxv.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encode_message\
    \ = String::new();\n    for letter in message.chars() {\n        if letter.is_alphabetic()\
    \ {\n            if letter.is_lowercase() {\n                if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == letter) {\n                    let pos =\
    \ (vowel + 2) % vowels.len();\n                    encode_message.push(vowels[pos]);\n\
    \                } else {\n                    encode_message.push(letter.to_uppercase().next().unwrap());\n\
    \                }\n            } else {\n                if let Some(vowel) =\
    \ vowels.iter().position(|&x| x == letter.to_lowercase().next().unwrap()) {\n\
    \                    let pos = (vowel + 2) % vowels.len();\n                 \
    \   encode_message.push(vowels[pos].to_uppercase().next().unwrap());\n       \
    \         } else {\n                    encode_message.push(letter.to_lowercase().next().unwrap());\n\
    \                }\n            }\n        } else {\n            encode_message.push(letter);\n\
    \        }\n    }\n    encode_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tOst\"`,\n right: `\"tgst\"`', /tmp/tmpcgkt2z25.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    let vowels = String::from(\"\
    aeiou\");\n    for c in message.chars() {\n        if c.is_ascii_uppercase() {\n\
    \            result.push(c.to_ascii_lowercase());\n        } else if c.is_ascii_lowercase()\
    \ {\n            if vowels.contains(c) {\n                let index = c as u8\
    \ - 'a' as u8;\n                result.push((index + 2) as char);\n          \
    \  } else {\n                result.push(c);\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpn4r5qcb2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        match c {\n       \
    \     x if is_vowel(x, &vowels) => output.push(encode_vowel(x)),\n           \
    \ x if x.is_lowercase() => output.push(x.to_uppercase().next().unwrap()),\n  \
    \          x if x.is_uppercase() => output.push(x.to_lowercase().next().unwrap()),\n\
    \            _ => output.push(c),\n        }\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8au4sac6.rs:16:18\n\
    \   |\n16 |             x if is_vowel(x, &vowels) => output.push(encode_vowel(x)),\n\
    \   |                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `encode_vowel` in this scope\n  --> /tmp/tmp8au4sac6.rs:16:54\n\
    \   |\n16 |             x if is_vowel(x, &vowels) => output.push(encode_vowel(x)),\n\
    \   |                                                      ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for c in message_chars {\n\
    \        let mut swap_lower = false;\n        let mut swap_upper = false;\n  \
    \      if c.is_lowercase() {\n            swap_lower = true;\n        } else if\
    \ c.is_uppercase() {\n            swap_upper = true;\n        }\n        let mut\
    \ result = c as u8;\n        if c == 'a' || c == 'A' {\n            result = result\
    \ + 2;\n        } else if c == 'e' || c == 'E' {\n            result = result\
    \ + 2;\n        } else if c == 'i' || c == 'I' {\n            result = result\
    \ + 2;\n        } else if c == 'o' || c == 'O' {\n            result = result\
    \ + 2;\n        } else if c == 'u' || c == 'U' {\n            result = result\
    \ + 2;\n        } else if c == 'y' || c == 'Y' {\n            result = result\
    \ + 2;\n        } else {\n            result = result + 1;\n        }\n      \
    \  let mut result_char = result as char;\n        if swap_lower {\n          \
    \  result_char = result_char.to_lowercase().collect::<Vec<char>>()[0];\n     \
    \   } else if swap_upper {\n            result_char = result_char.to_uppercase().collect::<Vec<char>>()[0];\n\
    \        }\n        encoded_message.push(result_char);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"UGTU\"`,\n right: `\"tgst\"`', /tmp/tmph36rjyx1.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| swap_case(vowel_shift(c))).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap_case` in this scope\n  --> /tmp/tmp2dpolqel.rs:12:29\n\
    \   |\n12 |     message.chars().map(|c| swap_case(vowel_shift(c))).collect()\n\
    \   |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `vowel_shift` in this scope\n  --> /tmp/tmp2dpolqel.rs:12:39\n\
    \   |\n12 |     message.chars().map(|c| swap_case(vowel_shift(c))).collect()\n\
    \   |                                       ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppeex87rs.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.chars().map(|c| match c {\n      \
    \  'a' | 'A' => 'C',\n        'e' | 'E' => 'G',\n        'i' | 'I' => 'K',\n \
    \       'o' | 'O' => 'M',\n        'u' | 'U' => 'Q',\n        'y' | 'Y' => 'U',\n\
    \        _ => c,\n    }).collect::<String>();\n    let mut index = 0;\n    for\
    \ c in result.chars() {\n        let case = c.is_uppercase();\n        result.remove(index);\n\
    \        let c_uppercase = if case {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        };\n\
    \        result.insert(index, c_uppercase);\n        index += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpiv47qh0k.rs:24:9\n   |\n22 |     for c in result.chars()\
    \ {\n   |              --------------\n   |              |\n   |             \
    \ immutable borrow occurs here\n   |              immutable borrow later used\
    \ here\n23 |         let case = c.is_uppercase();\n24 |         result.remove(index);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `result` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpiv47qh0k.rs:30:9\n   |\n22 |     for c in result.chars() {\n  \
    \ |              --------------\n   |              |\n   |              immutable\
    \ borrow occurs here\n   |              immutable borrow later used here\n...\n\
    30 |         result.insert(index, c_uppercase);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message.chars().map(|c| encode_char(c)).collect::<String>();\n\
    \    return encoded_message;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmpyjyfpxdb.rs:12:55\n\
    \   |\n12 |     let mut encoded_message = message.chars().map(|c| encode_char(c)).collect::<String>();\n\
    \   |                                                       ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"\");\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    return\
    \ encoded;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpq4ffzl6h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n                    result.push(\n                        c.to_lowercase()\n\
    \                            .to_string()\n                            .chars()\n\
    \                            .nth(1)\n                            .unwrap()\n\
    \                            .to_uppercase()\n                            .next()\n\
    \                            .unwrap(),\n                    );\n            \
    \    } else {\n                    result.push(c.to_lowercase().next().unwrap());\n\
    \                }\n            } else {\n                if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n                    result.push(\n                        c.to_lowercase()\n\
    \                            .to_string()\n                            .chars()\n\
    \                            .nth(1)\n                            .unwrap()\n\
    \                            .next()\n                            .unwrap(),\n\
    \                    );\n                } else {\n                    result.push(c.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3w8hw34v.rs:39:30\n   |\n39 | ...                   .next()\n\
    \   |                        ^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.to_uppercase()\n        .chars()\n        .map(|c|\
    \ {\n            if !c.is_alphabetic() {\n                c\n            } else\
    \ {\n                let mut c = c as i8;\n                if c > 'Z' as i8 {\n\
    \                    c -= 32;\n                }\n                c += 2;\n  \
    \              c = (c - 'A' as i8) % 26 + 'A' as i8;\n                c as u8\
    \ as char\n            }\n        })\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp0w9j2fus.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    //todo!()\n    message.chars().map(|c| encode_char(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_char` in this scope\n  --> /tmp/tmpqye8pfis.rs:13:29\n\
    \   |\n13 |     message.chars().map(|c| encode_char(c)).collect()\n   |      \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for letter in\
    \ message.chars() {\n        encoded_message.push(if letter.is_ascii_lowercase()\
    \ {\n            let letter_idx = letter.to_ascii_lowercase() as u8 - b'a';\n\
    \            let encoded_letter_idx = match letter_idx {\n                0...8\
    \ => (letter_idx + 2) % 26,\n                9...15 => letter_idx + 2,\n     \
    \           16...25 => (letter_idx + 2) % 26,\n                _ => panic!(\"\
    letter index out of range 0...25 ({})\", letter_idx),\n            };\n      \
    \      (encoded_letter_idx + b'a') as char\n        } else {\n            let\
    \ letter_idx = letter.to_ascii_uppercase() as u8 - b'A';\n            let encoded_letter_idx\
    \ = match letter_idx {\n                0...8 => (letter_idx + 2) % 26,\n    \
    \            9...15 => letter_idx + 2,\n                16...25 => (letter_idx\
    \ + 2) % 26,\n                _ => panic!(\"letter index out of range 0...25 ({})\"\
    , letter_idx),\n            };\n            (encoded_letter_idx + b'A') as char\n\
    \        });\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp94munuqc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c == ' ' {\n        \
    \    ' '\n        } else {\n            let c = c.to_ascii_lowercase();\n    \
    \        let c = match c {\n                'a' => 'c',\n                'e' =>\
    \ 'g',\n                'i' => 'k',\n                'o' => 'q',\n           \
    \     'u' => 'y',\n                'y' => 'a',\n                _ => (c as u8\
    \ + 2) as char,\n            };\n            c.to_ascii_uppercase()\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpd09wxdzl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut chars = message.chars();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_ascii_alphabetic() {\n\
    \            if let Some(vowel) = encode_vowel(c) {\n                encoded.push(vowel);\n\
    \            } else {\n                encoded.push(c.to_ascii_uppercase());\n\
    \            }\n        } else {\n            encoded.push(c);\n        }\n  \
    \  }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_vowel` in this scope\n  -->\
    \ /tmp/tmppgpwryxk.rs:16:34\n   |\n16 |             if let Some(vowel) = encode_vowel(c)\
    \ {\n   |                                  ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c == ' ' {\n        \
    \    ' '\n        } else {\n            let idx = match c.is_uppercase() {\n \
    \               true => ALPHABET.to_uppercase().find(c).unwrap(),\n          \
    \      false => ALPHABET.to_lowercase().find(c).unwrap(),\n            };\n  \
    \          let idx = idx + 2;\n            if idx < 26 {\n                ALPHABET[idx..].chars().next().unwrap()\n\
    \            } else {\n                ALPHABET[idx - 26..].chars().next().unwrap()\n\
    \            }\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmplisb26a3.rs:17:25\n\
    \   |\n17 |                 true => ALPHABET.to_uppercase().find(c).unwrap(),\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ALPHABET` in this scope\n  --> /tmp/tmplisb26a3.rs:18:26\n\
    \   |\n18 |                 false => ALPHABET.to_lowercase().find(c).unwrap(),\n\
    \   |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ALPHABET` in this scope\n  --> /tmp/tmplisb26a3.rs:22:17\n\
    \   |\n22 |                 ALPHABET[idx..].chars().next().unwrap()\n   |    \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ALPHABET` in this scope\n  --> /tmp/tmplisb26a3.rs:24:17\n   |\n24 |      \
    \           ALPHABET[idx - 26..].chars().next().unwrap()\n   |               \
    \  ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // your code here\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_f5bwltb.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppeex87rs.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.to_ascii_uppercase();\n    let chars\
    \ = \"AEIOU\".chars();\n    for c in chars {\n        result = result.replace(c,\
    \ &((c as u8 + 2) as char).to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpm8xhrpik.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = [\n        \"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"A\", \"E\", \"I\", \"O\", \"U\"\n    ];\n    let mut encoded_message = String::new();\n\
    \    for ch in message.chars() {\n        let mut encoded_ch = match ch {\n  \
    \          'a'...'z' => (ch as u8 + 2) as char,\n            'A'...'Z' => (ch\
    \ as u8 + 2) as char,\n            _ => ch\n        };\n        if encoded_ch\
    \ > 'z' {\n            encoded_ch = (encoded_ch as u8 - 26) as char;\n       \
    \ }\n        if encoded_ch > 'Z' && encoded_ch < 'a' {\n            encoded_ch\
    \ = (encoded_ch as u8 - 26) as char;\n        }\n        if vowels.contains(&encoded_ch.to_string().as_str())\
    \ {\n            encoded_ch = match encoded_ch {\n                'a'...'z' =>\
    \ (encoded_ch as u8 + 2) as char,\n                'A'...'Z' => (encoded_ch as\
    \ u8 + 2) as char,\n                _ => encoded_ch\n            };\n        \
    \    if encoded_ch > 'z' {\n                encoded_ch = (encoded_ch as u8 - 26)\
    \ as char;\n            }\n            if encoded_ch > 'Z' && encoded_ch < 'a'\
    \ {\n                encoded_ch = (encoded_ch as u8 - 26) as char;\n         \
    \   }\n        }\n        encoded_message.push(encoded_ch);\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGWV\"`,\n right: `\"tgst\"`', /tmp/tmpilnk9rfg.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut chars = message.chars();\n    let mut encoded = String::new();\n\
    \    while let Some(c) = chars.next() {\n        let mut char_to_add = encode_character(c);\n\
    \        encoded.push(char_to_add);\n    }\n    encoded\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_character` in this scope\n \
    \ --> /tmp/tmpt7prz473.rs:15:31\n   |\n15 |         let mut char_to_add = encode_character(c);\n\
    \   |                               ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let alphabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let uppercase_alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ uppercase_vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut message_chars:\
    \ Vec<char> = message.chars().collect();\n    let mut alphabet_index = 0;\n  \
    \  let mut is_uppercase: bool = false;\n    let mut encoded_message = String::new();\n\
    \n    for ch in message_chars.iter() {\n        is_uppercase = false;\n      \
    \  if uppercase_alphabet.contains(ch) {\n            alphabet_index = match uppercase_alphabet.iter().position(|&x|\
    \ x == *ch) {\n                Some(number) => number,\n                None =>\
    \ 0,\n            };\n            is_uppercase = true;\n        } else {\n   \
    \         alphabet_index = match alphabet.iter().position(|&x| x == *ch) {\n \
    \               Some(number) => number,\n                None => 0,\n        \
    \    };\n        }\n\n        if is_uppercase {\n            if uppercase_vowels.contains(ch)\
    \ {\n                encoded_message.push(uppercase_alphabet[(alphabet_index +\
    \ 3) % 26]);\n            } else {\n                encoded_message.push(uppercase_alphabet[alphabet_index]);\n\
    \            }\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk9wcbtu0.rs:52:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n21 |     for ch in message_chars.iter()\
    \ {\n   |                                    - unclosed delimiter\n...\n36 | \
    \        if is_uppercase {\n   |                         - this delimiter might\
    \ not be properly closed...\n...\n43 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n52 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk9wcbtu0.rs:21:5\n   |\n11 |   fn encode(message: String)\
    \ -> String {\n   |                                 ------ expected `String` because\
    \ of return type\n...\n21 | /     for ch in message_chars.iter() {\n22 | |   \
    \      is_uppercase = false;\n23 | |         if uppercase_alphabet.contains(ch)\
    \ {\n24 | |             alphabet_index = match uppercase_alphabet.iter().position(|&x|\
    \ x == *ch) {\n...  |\n51 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw\
    \ WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n52 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  let mut result = message.chars().collect::<Vec<char>>();\n  for\
    \ i in 0..result.len() {\n    if result[i].is_ascii_alphabetic() {\n      result[i]\
    \ = result[i].to_ascii_uppercase();\n      result[i] = match result[i] {\n   \
    \     'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n        'O' => 'Q',\n\
    \        'U' => 'Y',\n        _ => (result[i] as u8 + 2) as char,\n      };\n\
    \    }\n  }\n  result.iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpx01xqcd2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::from(\"\");\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let next_c = \n                match c {\n                  \
    \  'a' => 'c',\n                    'e' => 'g',\n                    'i' => 'k',\n\
    \                    'o' => 'q',\n                    'u' => 'y',\n          \
    \          _ => panic!(\"Unexpected vowel\"),\n                };\n          \
    \  output.push(next_c);\n        } else {\n            output.push(c);\n     \
    \   }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpmpdfdwkk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO\n    String::from(\"Not yet implemented\")\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Not yet implemented\"`,\n right: `\"tgst\"`', /tmp/tmp9d2v2nnv.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(encode_char).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `encode_char` in this scope\n  --> /tmp/tmptyee8xgp.rs:12:25\n\
    \   |\n12 |     message.chars().map(encode_char).collect()\n   |             \
    \            ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message.to_uppercase();\n    let\
    \ vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    for i in 0..encoded_message.len()\
    \ {\n        if vowels.contains(&encoded_message.chars().nth(i).unwrap()) {\n\
    \            encoded_message.replace_range(i..i+1, &alphabet()[alphabet().iter().position(|&x|\
    \ x == encoded_message.chars().nth(i).unwrap()).unwrap() + 2].to_string());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `alphabet` in this scope\n  --> /tmp/tmppp7xvb4o.rs:16:52\n\
    \   |\n16 | ...   encoded_message.replace_range(i..i+1, &alphabet()[alphabet().iter().position(|&x|\
    \ x == encoded_message.chars().nth(i).unwrap()).unw...\n   |                 \
    \                             ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `alphabet` in this scope\n  --> /tmp/tmppp7xvb4o.rs:16:63\n\
    \   |\n16 | ...   encoded_message.replace_range(i..i+1, &alphabet()[alphabet().iter().position(|&x|\
    \ x == encoded_message.chars().nth(i).unwrap()).unw...\n   |                 \
    \                                        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: implement the function here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmplu_zjq4z.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // first, change case of letters\n    let mut case_message\
    \ = message.to_lowercase();\n    for c in case_message.chars_mut() {\n       \
    \ if c.is_ascii_lowercase() {\n            *c = c.to_ascii_uppercase();\n    \
    \    }\n    }\n    // next, replace vowels with the letter that is 2 places ahead\
    \ of the vowel\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut new_message = String::new();\n    for c in case_message.chars() {\n    \
    \    if !c.is_ascii_alphabetic() {\n            new_message.push(c);\n       \
    \ } else {\n            let alphabets = \"abcdefghijklmnopqrstuvwxyz\";\n    \
    \        let alphabets_char = alphabets.chars();\n            let mut alphabet_iter\
    \ = alphabets_char.into_iter();\n            // skip letters in alphabet_iter\
    \ and push letters ahead of vowels\n            let c_lower = c.to_ascii_lowercase();\n\
    \            if vowels.contains(&c_lower.to_string().as_str()) {\n           \
    \     for _ in 0..4 {\n                    alphabet_iter.next();\n           \
    \     }\n                new_message.push(*alphabet_iter.next().unwrap());\n \
    \           } else {\n                for _ in 0..2 {\n                    alphabet_iter.next();\n\
    \                }\n                new_message.push(*alphabet_iter.next().unwrap());\n\
    \            }\n        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars_mut` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpm4526i8l.rs:14:27\n   |\n14 |     for c in\
    \ case_message.chars_mut() {\n   |                           ^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `chars`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpm4526i8l.rs:35:34\n   |\n35 | \
    \                new_message.push(*alphabet_iter.next().unwrap());\n   |     \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpm4526i8l.rs:40:34\n   |\n\
    40 |                 new_message.push(*alphabet_iter.next().unwrap());\n   | \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.to_lowercase()\n        .chars()\n        .map(encode_char)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `encode_char` in this scope\n  --> /tmp/tmpkzyv23kp.rs:14:14\n\
    \   |\n14 |         .map(encode_char)\n   |              ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if !c.is_alphabetic() {\n            encoded.push(c);\n         \
    \   continue;\n        }\n        let c_upper = c.to_uppercase().next().unwrap();\n\
    \        if c_upper == 'A' || c_upper == 'E' || c_upper == 'I' || c_upper == 'O'\
    \ || c_upper == 'U' {\n            if c_upper == 'U' {\n                encoded.push('B');\n\
    \            } else {\n                encoded.push((c_upper as u8 + 2) as char);\n\
    \            }\n        } else {\n            encoded.push(c_upper);\n       \
    \ }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpnsxrjek1.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    for (i, ch) in message.chars().enumerate() {\n\
    \        if vowels.contains(&ch.to_lowercase().to_string().as_str()) {\n     \
    \       let position = ch.to_lowercase().to_string().as_str().to_string().as_bytes()[0]\
    \ - 97;\n            result.push(((position + 2) % 26 + 97) as char);\n      \
    \  } else {\n            result.push(ch);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpi5ebkllj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    String::from(\"Function not implemented yet!\")\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Function not implemented yet!\"`,\n right: `\"tgst\"`', /tmp/tmpdo9t2fx6.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpss8gdixn.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let (character, lower_case) = match c {\n            'a' => ('c',\
    \ false),\n            'A' => ('C', true),\n            'e' => ('g', false),\n\
    \            'E' => ('G', true),\n            'i' => ('k', false),\n         \
    \   'I' => ('K', true),\n            'o' => ('q', false),\n            'O' =>\
    \ ('Q', true),\n            'u' => ('s', false),\n            'U' => ('S', true),\n\
    \            _ => {\n                let lower_case = (c as u8) > 96;\n      \
    \          (c, lower_case)\n            }\n        };\n        let character =\
    \ if lower_case { character.to_ascii_lowercase() } else { character.to_ascii_uppercase()\
    \ };\n        encoded_message.push(character);\n    }\n    encoded_message\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmpuggp6bat.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let vowels = String::from(\"\
    AEIOUaeiou\");\n    let alphabet = String::from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    );\n    for x in message.chars() {\n        if !vowels.contains(x) {\n       \
    \     let mut new_char = x.to_ascii_uppercase();\n            let alphabet_pos\
    \ = alphabet.find(new_char).unwrap();\n            let new_pos = (alphabet_pos\
    \ + 2) % 52;\n            let new_char = alphabet.chars().nth(new_pos).unwrap();\n\
    \            output.push(new_char);\n        } else {\n            let alphabet_pos\
    \ = alphabet.find(x).unwrap();\n            let new_pos = (alphabet_pos + 2) %\
    \ 52;\n            let new_char = alphabet.chars().nth(new_pos).unwrap();\n  \
    \          output.push(new_char);\n        }\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpsx93ds9j.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut\
    \ result = String::new();\n    for ch in message.chars() {\n        if ch.is_ascii_alphabetic()\
    \ {\n            let mut new_char: char = match ch.is_ascii_lowercase() {\n  \
    \              true => alphabet[if alphabet.find(ch).unwrap() + 2 > 25 {\n   \
    \                 alphabet.find(ch).unwrap() + 2 - 26\n                } else\
    \ {\n                    alphabet.find(ch).unwrap() + 2\n                }],\n\
    \                false => alphabet[if alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2 > 25 {\n                    alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2 - 26\n                } else {\n                    alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2\n                }].to_ascii_uppercase(),\n            };\n            for\
    \ vowel in \"aeiou\".chars() {\n                if vowel == new_char {\n     \
    \               match new_char {\n                        'a' => new_char = 'c',\n\
    \                        'e' => new_char = 'g',\n                        'i' =>\
    \ new_char = 'k',\n                        'o' => new_char = 'm',\n          \
    \              'u' => new_char = 'w',\n                        _ => new_char =\
    \ new_char,\n                    }\n                }\n            }\n       \
    \     result.push(new_char);\n        } else {\n            result.push(ch);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp5ou_ujqo.rs:17:25\n\
    \   |\n17 |                   true => alphabet[if alphabet.find(ch).unwrap() +\
    \ 2 > 25 {\n   |  _________________________^\n18 | |                     alphabet.find(ch).unwrap()\
    \ + 2 - 26\n19 | |                 } else {\n20 | |                     alphabet.find(ch).unwrap()\
    \ + 2\n21 | |                 }],\n   | |__________________^ string indices are\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmp5ou_ujqo.rs:22:26\n   |\n22 |                   false => alphabet[if\
    \ alphabet.find(ch.to_ascii_lowercase()).unwrap() + 2 > 25 {\n   |  __________________________^\n\
    23 | |                     alphabet.find(ch.to_ascii_lowercase()).unwrap() + 2\
    \ - 26\n24 | |                 } else {\n25 | |                     alphabet.find(ch.to_ascii_lowercase()).unwrap()\
    \ + 2\n26 | |                 }].to_ascii_uppercase(),\n   | |__________________^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            match c {\n                'A' => 'C',\n                'B' =>\
    \ 'D',\n                'C' => 'E',\n                'D' => 'F',\n           \
    \     'E' => 'G',\n                'F' => 'H',\n                'G' => 'I',\n\
    \                'H' => 'J',\n                'I' => 'K',\n                'J'\
    \ => 'L',\n                'K' => 'M',\n                'L' => 'N',\n        \
    \        'M' => 'O',\n                'N' => 'P',\n                'O' => 'Q',\n\
    \                'P' => 'R',\n                'Q' => 'S',\n                'R'\
    \ => 'T',\n                'S' => 'U',\n                'T' => 'V',\n        \
    \        'U' => 'W',\n                'V' => 'X',\n                'W' => 'Y',\n\
    \                'X' => 'Z',\n                'Y' => 'A',\n                'Z'\
    \ => 'B',\n                _ => c,\n            }\n        } else {\n        \
    \    match c {\n                'a' => 'c',\n                'b' => 'd',\n   \
    \             'c' => 'e',\n                'd' => 'f',\n                'e' =>\
    \ 'g',\n                'f' => 'h',\n                'g' => 'i',\n           \
    \     'h' => 'j',\n                'i' => 'k',\n                'j' => 'l',\n\
    \                'k' => 'm',\n                'l' => 'n',\n                'm'\
    \ => 'o',\n                'n' => 'p',\n                'o' => 'q',\n        \
    \        'p' => 'r',\n                'q' => 's',\n                'r' => 't',\n\
    \                's' => 'u',\n                't' => 'v',\n                'u'\
    \ => 'w',\n                'v' => 'x',\n                'w' => 'y',\n        \
    \        'x' => 'z',\n                'y' => 'a',\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp81yweemm.rs:79:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     message.chars().map(|c| {\n \
    \  |                        -    - unclosed delimiter\n   |                  \
    \      |\n   |                        unclosed delimiter\n...\n43 |         }\
    \ else {\n   |                - unclosed delimiter\n44 |             match c {\n\
    \   |                     - this delimiter might not be properly closed...\n...\n\
    70 | }\n   | - ...as it matches this but it has different indentation\n...\n79\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp81yweemm.rs:44:13\n\
    \   |\n44 | /             match c {\n45 | |                 'a' => 'c',\n46 |\
    \ |                 'b' => 'd',\n47 | |                 'c' => 'e',\n...  |\n\
    69 | |                 'y' => 'a',\n70 | | }\n   | | ^- help: consider using a\
    \ semicolon here\n   | |_|\n   |   expected `()`, found `char`\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmp81yweemm.rs:72:1\n  \
    \ |\n13 |   /         if c.is_ascii_uppercase() {\n14 |   |             match\
    \ c {\n   |  _|_____________-\n15 | | |                 'A' => 'C',\n16 | | |\
    \                 'B' => 'D',\n17 | | |                 'C' => 'E',\n...  | |\n\
    41 | | |                 _ => c,\n42 | | |             }\n   | |_|_____________-\
    \ expected because of this\n...    |\n72 | / | fn main() {\n73 | | |     let candidate\
    \ = encode;\n74 | | |     assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n75 | | |     assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n...  | |\n78 | | |     assert_eq!(candidate(String::from(\"I DoNt\
    \ KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n79 |\
    \ | | }\n   | | |_^- `if` and `else` have incompatible types\n   | |___|\n   |\
    \     expected `char`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp81yweemm.rs:12:5\n\
    \   |\n11 |   fn encode(message: String) -> String {\n   |                   \
    \              ------ expected `String` because of return t"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for ch in message.chars()\
    \ {\n        let next_ch = match ch {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'w',\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'W',\n            _ => ch,\n    \
    \    };\n        encoded.push(next_ch);\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpksrbrdv0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  message.chars().map(|c| match c {\n    'a' => 'c',\n    'A' =>\
    \ 'C',\n    'e' => 'g',\n    'E' => 'G',\n    'i' => 'k',\n    'I' => 'K',\n \
    \   'o' => 'q',\n    'O' => 'Q',\n    'u' => 'y',\n    'U' => 'Y',\n    'y' =>\
    \ 'a',\n    'Y' => 'A',\n    a => a.to_ascii_uppercase(),\n  }).collect()\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpumk8x6ds.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.to_lowercase();\n    for (i, c) in\
    \ result.chars().enumerate() {\n        if c == 'a' {\n            result.replace_range(i..i+1,\
    \ \"c\");\n        } else if c == 'e' {\n            result.replace_range(i..i+1,\
    \ \"g\");\n        } else if c == 'i' {\n            result.replace_range(i..i+1,\
    \ \"k\");\n        } else if c == 'o' {\n            result.replace_range(i..i+1,\
    \ \"m\");\n        } else if c == 'u' {\n            result.replace_range(i..i+1,\
    \ \"o\");\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpash303fw.rs:15:13\n   |\n13 |     for (i, c) in\
    \ result.chars().enumerate() {\n   |                   --------------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n14 |         if c ==\
    \ 'a' {\n15 |             result.replace_range(i..i+1, \"c\");\n   |         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `result` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpash303fw.rs:17:13\n   |\n13 |     for (i, c) in result.chars().enumerate()\
    \ {\n   |                   --------------------------\n   |                 \
    \  |\n   |                   immutable borrow occurs here\n   |              \
    \     immutable borrow later used here\n...\n17 |             result.replace_range(i..i+1,\
    \ \"g\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs\
    \ here\n\nerror[E0502]: cannot borrow `result` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpash303fw.rs:19:13\n   |\n13 |     for (i, c) in\
    \ result.chars().enumerate() {\n   |                   --------------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n...\n19 |          \
    \   result.replace_range(i..i+1, \"k\");\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `result` as mutable\
    \ because it is also borrowed as immutable\n  --> /tmp/tmpash303fw.rs:21:13\n\
    \   |\n13 |     for (i, c) in result.chars().enumerate() {\n   |             \
    \      --------------------------\n   |                   |\n   |            \
    \       immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n...\n21 |             result.replace_range(i..i+1, \"m\");\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\
    \nerror[E0502]: cannot borrow `result` as m"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.to_lowercase()\n        .chars()\n        .map(|x|\
    \ {\n            match x {\n                'a' => 'c',\n                'e' =>\
    \ 'g',\n                'i' => 'k',\n                'o' => 'q',\n           \
    \     'u' => 'w',\n                x => x,\n            }\n        })\n      \
    \  .map(|x| {\n            match x {\n                'b' => 'a',\n          \
    \      'c' => 'b',\n                'd' => 'c',\n                'f' => 'e',\n\
    \                'g' => 'f',\n                'h' => 'g',\n                'j'\
    \ => 'i',\n                'k' => 'j',\n                'l' => 'k',\n        \
    \        'm' => 'l',\n                'n' => 'm',\n                'p' => 'o',\n\
    \                'q' => 'p',\n                'r' => 'q',\n                's'\
    \ => 'r',\n                't' => 's',\n                'v' => 'u',\n        \
    \        'w' => 'v',\n                'x' => 'w',\n                'y' => 'x',\n\
    \                'z' => 'y',\n                x => x,\n            }\n       \
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"sfrs\"`,\n right: `\"tgst\"`', /tmp/tmpubgkg2xs.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let mut encoded = String::new();\n\
    \    for c in message.chars() {\n        if vowels.contains(c) {\n           \
    \ encoded.push(get_next_vowel(c));\n        } else {\n            encoded.push(get_opposite_case(c));\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_next_vowel` in this scope\n  -->\
    \ /tmp/tmpxxbaywyj.rs:16:26\n   |\n16 |             encoded.push(get_next_vowel(c));\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_opposite_case` in this scope\n  --> /tmp/tmpxxbaywyj.rs:18:26\n\
    \   |\n18 |             encoded.push(get_opposite_case(c));\n   |            \
    \              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    const LOWERCASE_VOWELS: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n\
    \    const UPPERCASE_VOWELS: [char; 5] = ['A', 'E', 'I', 'O', 'U'];\n    const\
    \ ALPHABET: [char; 26] = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z',\n    ];\n\n    let mut encoded = String::new();\n    for c in\
    \ message.chars() {\n        let mut ch = c;\n        if ch.is_lowercase() {\n\
    \            for vowel in LOWERCASE_VOWELS.iter() {\n                if ch ==\
    \ *vowel {\n                    let idx = ALPHABET.iter().position(|&x| x == *vowel).unwrap();\n\
    \                    ch = ALPHABET[(idx + 2) % 26];\n                    break;\n\
    \                }\n            }\n        } else if ch.is_uppercase() {\n   \
    \         for vowel in UPPERCASE_VOWELS.iter() {\n                if ch == *vowel\
    \ {\n                    let idx = ALPHABET.iter().position(|&x| x == *vowel).unwrap();\n\
    \                    ch = ALPHABET[(idx + 2) % 26].to_uppercase().to_string().chars().next().unwrap();\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     encoded.push(ch);\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpkg407jqc.rs:33:74

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // define a function to handle each letter\n    fn encode_letter(ch:\
    \ char) -> char {\n        // define a list of vowels\n        const VOWELS: [char;\
    \ 5] = ['a', 'e', 'i', 'o', 'u'];\n        // check for lowercase\n        if\
    \ ch.is_lowercase() {\n            // check for vowel\n            if VOWELS.contains(&ch)\
    \ {\n                // get the next two letters in the alphabet\n           \
    \     let next_letter = (ch as u8 + 2) as char;\n                let next_letter_2\
    \ = (next_letter as u8 + 1) as char;\n                // check for z\n       \
    \         if next_letter == 'z' {\n                    return 'b';\n         \
    \       }\n                // check for zz\n                if next_letter_2 ==\
    \ 'z' {\n                    return 'c';\n                }\n                //\
    \ return\n                return next_letter_2;\n            }\n            //\
    \ return the letter\n            return ch.to_uppercase().next().unwrap();\n \
    \       }\n        // check for uppercase\n        if ch.is_uppercase() {\n  \
    \          // check for vowel\n            if VOWELS.contains(&ch.to_lowercase().next().unwrap())\
    \ {\n                // get the next two letters in the alphabet\n           \
    \     let next_letter = (ch as u8 + 2) as char;\n                let next_letter_2\
    \ = (next_letter as u8 + 1) as char;\n                // check for z\n       \
    \         if next_letter == 'Z' {\n                    return 'B';\n         \
    \       }\n                // check for zz\n                if next_letter_2 ==\
    \ 'Z' {\n                    return 'C';\n                }\n                //\
    \ return\n                return next_letter_2;\n            }\n            //\
    \ return the letter\n            return ch.to_lowercase().next().unwrap();\n \
    \       }\n        // return the letter\n        return ch;\n    }\n    // iterate\
    \ through letters\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        result.push(encode_letter(ch));\n    }\n    // return result\n  \
    \  return result;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tHst\"`,\n right: `\"tgst\"`', /tmp/tmp42jd2a3a.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let replace =\
    \ ['c', 'f', 'j', 'n', 'r'];\n    let mut new_message = String::new();\n    for\
    \ c in message.chars() {\n        if vowels.contains(&c) {\n            let mut\
    \ i = 0;\n            while i < 5 {\n                if c == vowels[i] {\n   \
    \                 new_message.push(replace[i]);\n                    break;\n\
    \                }\n                i += 1;\n            }\n        } else if\
    \ c.is_uppercase() {\n            new_message.push(c.to_lowercase().to_string());\n\
    \        } else {\n            new_message.push(c.to_uppercase().to_string());\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvj6aw0va.rs:26:30\n   |\n\
    26 |             new_message.push(c.to_lowercase().to_string());\n   |       \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvj6aw0va.rs:28:30\n\
    \   |\n28 |             new_message.push(c.to_uppercase().to_string());\n   |\
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n        let mut c_char = c.to_ascii_lowercase();\n        if\
    \ vowels.contains(&c_char) {\n            let index = vowels.iter().position(|&r|\
    \ r == c_char).unwrap();\n            c_char = match index {\n               \
    \ 0 => 'c',\n                1 => 'f',\n                2 => 'i',\n          \
    \      3 => 'l',\n                4 => 'o',\n                _ => panic!(\"failed\
    \ to find vowel\")\n            };\n        }\n        if c.is_lowercase() {\n\
    \            c_char.to_ascii_uppercase()\n        } else {\n            c_char\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tfst\"`,\n right: `\"tgst\"`', /tmp/tmpdb3tngeo.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           let c_uppercase = c.to_ascii_uppercase();\n                let index\
    \ = c_uppercase as usize - 65;\n                result.push(((index + 2) % 26\
    \ + 65) as u8 as char);\n            } else {\n                let c_lowercase\
    \ = c.to_ascii_lowercase();\n                let index = c_lowercase as usize\
    \ - 97;\n                result.push(((index + 2) % 26 + 97) as u8 as char);\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp4fvt9wp2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|char| {\n        let original_char = char.to_lowercase().next().unwrap();\n\
    \        let ascii_code = original_char as u8;\n        if ascii_code == b'z'\
    \ {\n            (b'a' + 1) as char\n        } else if ascii_code == b'y' {\n\
    \            (b'a' + 0) as char\n        } else if ascii_code == b'x' {\n    \
    \        (b'a' - 1) as char\n        } else if ascii_code >= b'a' && ascii_code\
    \ <= b'z' {\n            (ascii_code + 2) as char\n        } else {\n        \
    \    char\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vguv\"`,\n right: `\"tgst\"`', /tmp/tmpnfmrz8a6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    fn is_vowel(ch: char) -> bool {\n        vec!['a', 'e', 'i',\
    \ 'o', 'u'].contains(&ch)\n    }\n\n    let letters: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    let mut output = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_uppercase() {\n            let index = letters.iter().position(|x|\
    \ x == &ch.to_lowercase().next().unwrap()).unwrap();\n            let ch2 = letters[(index\
    \ + 2) % letters.len()];\n            output.push(ch2.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_lowercase() {\n            let index = letters.iter().position(|x|\
    \ x == &ch).unwrap();\n            let ch2 = letters[(index + 2) % letters.len()];\n\
    \            output.push(ch2);\n        } else {\n            output.push(ch);\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp013d4160.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let next = if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        match next {\n            'a' => 'c',\n          \
    \  'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n           \
    \ 'u' => 'y',\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmp14e6a37g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|ch| {\n        if ch.is_uppercase() {\n\
    \            let shift = ((ch as u8) - 65 + 2) % 26;\n            (shift + 65)\
    \ as char\n        } else if ch.is_lowercase() {\n            let shift = ((ch\
    \ as u8) - 97 + 2) % 26;\n            (shift + 97) as char\n        } else {\n\
    \            ch\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp1f8vbbqt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n \
    \           'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n  \
    \          'O' => 'Q',\n            'U' => 'Y',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        encoded.push(c);\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp85zb_v9q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009061
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'a'\
    \ => 'c',\n            'A' => 'C',\n            'e' => 'g',\n            'E' =>\
    \ 'G',\n            'i' => 'k',\n            'I' => 'K',\n            'o' => 'q',\n\
    \            'O' => 'Q',\n            'u' => 'y',\n            'U' => 'Y',\n \
    \           _ => c.to_uppercase().next().unwrap()\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpi6gkx6dw.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result\
    \ = String::new();\n    for c in message.chars() {\n        if c.is_lowercase()\
    \ {\n            if vowels.contains(&c) {\n                let idx = find_idx(c,\
    \ vowels);\n                let new_char = vowels[(idx + 2) % vowels.len()];\n\
    \                result.push(new_char);\n            } else {\n              \
    \  result.push(c.to_uppercase().next().unwrap());\n            }\n        } else\
    \ {\n            if vowels.contains(&c.to_lowercase().next().unwrap()) {\n   \
    \             let idx = find_idx(c.to_lowercase().next().unwrap(), vowels);\n\
    \                let new_char = vowels[(idx + 2) % vowels.len()];\n          \
    \      result.push(new_char);\n            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_idx` in this scope\n  --> /tmp/tmp5h1k30ro.rs:17:27\n\
    \   |\n17 |                 let idx = find_idx(c, vowels);\n   |             \
    \              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `find_idx` in this scope\n  --> /tmp/tmp5h1k30ro.rs:25:27\n   |\n25 |      \
    \           let idx = find_idx(c.to_lowercase().next().unwrap(), vowels);\n  \
    \ |                           ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let letter = match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'w',\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'W',\n            _ => c,\n     \
    \   };\n        encoded_message.push(letter);\n    }\n    encoded_message\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpf46r5u5z.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::from(\"\
    \");\n    for c in message.chars() {\n        let mut current_char = String::from(\"\
    \");\n        if vowels.contains(c) {\n            current_char.push(next_vowel(c));\n\
    \        } else {\n            current_char.push(c);\n        }\n        if current_char.as_str().is_lowercase()\
    \ {\n            current_char = current_char.to_uppercase();\n        } else {\n\
    \            current_char = current_char.to_lowercase();\n        }\n        result.push_str(current_char.as_str());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_vowel` in this scope\n  --> /tmp/tmpbqxvap0b.rs:17:31\n\
    \   |\n17 |             current_char.push(next_vowel(c));\n   |              \
    \                 ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_lowercase` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpbqxvap0b.rs:21:34\n   |\n21 |         if current_char.as_str().is_lowercase()\
    \ {\n   |                                  ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let encoded = message.chars().map(|c| match c {\n        'a'\
    \ => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n   \
    \     'u' => 'y',\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n\
    \        'O' => 'Q',\n        'U' => 'Y',\n        _ => if c.is_lowercase() {\
    \ c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap() }\n\
    \    }).collect();\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp4gobbes9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut chars = message.chars();\n    let mut result = String::new();\n\
    \    while let Some(c) = chars.next() {\n        if c.is_ascii_alphabetic() {\n\
    \            if c.is_ascii_uppercase() {\n                if c == 'Z' {\n    \
    \                result.push('B');\n                } else if c == 'Y' {\n   \
    \                 result.push('A');\n                } else {\n              \
    \      let num = c as u8;\n                    let num = num + 2;\n          \
    \          let c = num as char;\n                    result.push(c);\n       \
    \         }\n            } else {\n                if c == 'z' {\n           \
    \         result.push('b');\n                } else if c == 'y' {\n          \
    \          result.push('a');\n                } else {\n                    let\
    \ num = c as u8;\n                    let num = num + 2;\n                   \
    \ let c = num as char;\n                    result.push(c);\n                }\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpeab28jxl.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut case = c.is_uppercase();\n        let mut c = c.to_lowercase().to_string();\n\
    \        if c == \"a\" {\n            c = \"c\".to_string();\n        } else if\
    \ c == \"e\" {\n            c = \"g\".to_string();\n        } else if c == \"\
    i\" {\n            c = \"k\".to_string();\n        } else if c == \"o\" {\n  \
    \          c = \"q\".to_string();\n        } else if c == \"u\" {\n          \
    \  c = \"s\".to_string();\n        } else if c == \"y\" {\n            c = \"\
    a\".to_string();\n        }\n        if case {\n            encoded.push_str(&c.to_uppercase());\n\
    \        } else {\n            encoded.push_str(&c);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpu9580i9e.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut chars = message.chars();\n    let mut encoded = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    while let Some(c) = chars.next()\
    \ {\n        if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n        if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            if let Some(c) = chars.next() {\n                encoded.push(c);\n\
    \            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"teSt\"`,\n right: `\"tgst\"`', /tmp/tmpnpt8smdj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let c = (b'a' + (c as u8 + 2\
    \ - b'a') % 26) as char;\n            encoded.push(c);\n        } else {\n   \
    \         encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfpel0dc7.rs:15:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    for character in message.chars() {\n        let result_character:\
    \ char;\n        if character.is_uppercase() {\n            result_character =\
    \ character.to_lowercase().next().unwrap();\n        } else {\n            result_character\
    \ = character.to_uppercase().next().unwrap();\n        }\n        if vowels.contains(&result_character)\
    \ {\n            let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n            let\
    \ mut index = alphabet.find(result_character).unwrap();\n            index +=\
    \ 2;\n            if index > 25 {\n                index -= 26;\n            }\n\
    \            result.push(alphabet.chars().nth(index).unwrap());\n        } else\
    \ {\n            result.push(result_character);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mUDASIR\"`,\n right: `\"mWDCSKR\"`', /tmp/tmps1bjj6mt.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // break the message into a vector of chars\n    let message:\
    \ Vec<char> = message.chars().collect();\n    // iterate the message, swapping\
    \ case and replacing each char\n    let encoded_message: String = message.iter().map(|c|\
    \ {\n        // println!(\"c: {}\", c);\n        let c = if c.is_lowercase() {\n\
    \            c.to_uppercase().collect::<Vec<char>>()[0]\n        } else {\n  \
    \          c.to_lowercase().collect::<Vec<char>>()[0]\n        };\n        //\
    \ println!(\"swapped case: {}\", c);\n        // encode each vowel\n        if\
    \ VOWELS.contains(&c) {\n            let mut encode_char = c as u8 + 2;\n    \
    \        // println!(\"{} is a vowel, encoding it\", c);\n            // if we're\
    \ past Z, wrap around to the beginning\n            if encode_char > 90 {\n  \
    \              encode_char = 65 + (encode_char - 90);\n            }\n       \
    \     // return the resulting char\n            (encode_char as char).to_string()\n\
    \        } else {\n            // not a vowel, return original char\n        \
    \    c.to_string()\n        }\n    }).collect();\n    encoded_message\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmpwjoqcfg8.rs:24:12\n\
    \   |\n24 |         if VOWELS.contains(&c) {\n   |            ^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let alphabet\
    \ = (b'a'..=b'z').collect::<Vec<u8>>();\n    let mut result = message.chars().map(|c|\
    \ {\n        if c.is_ascii_uppercase() {\n            (c as u8 + 32) as char\n\
    \        } else {\n            c\n        }\n    }).collect::<String>();\n   \
    \ for vowel in vowels {\n        if let Some(idx) = alphabet.iter().position(|c|\
    \ *c == vowel as u8) {\n            let idx = if idx == alphabet.len() - 1 {\n\
    \                0\n            } else if idx == alphabet.len() - 2 {\n      \
    \          1\n            } else {\n                idx + 2\n            };\n\
    \            result = result.replace(vowel, alphabet[idx] as char);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzpo6wgr.rs:30:44\n   |\n\
    30 |             result = result.replace(vowel, alphabet[idx] as char);\n   |\
    \                                            ^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n    let uppercase\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut encoded = String::new();\n  \
    \  for (i, c) in message.chars().enumerate() {\n        if lowercase.contains(c)\
    \ {\n            encoded.push(match c {\n                'a' => 'c',\n       \
    \         'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 'w',\n                _ => lowercase.chars().nth((lowercase.find(c).unwrap()\
    \ + 2) % 26).unwrap(),\n            });\n        } else if uppercase.contains(c)\
    \ {\n            encoded.push(match c {\n                'A' => 'C',\n       \
    \         'E' => 'G',\n                'I' => 'K',\n                'O' => 'Q',\n\
    \                'U' => 'W',\n                _ => uppercase.chars().nth((uppercase.find(c).unwrap()\
    \ + 2) % 26).unwrap(),\n            });\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmprwnskbad.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    return String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpfdzk6ddp.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let is_upper = c.is_uppercase();\n\
    \        let char_pos = encode_character(c);\n        let char_pos = (char_pos\
    \ + 2) % 26;\n        let c = letter_from_char_pos(char_pos);\n        if is_upper\
    \ { c.to_uppercase().next().unwrap() } else { c }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_character` in this scope\n \
    \ --> /tmp/tmpj9s2v91h.rs:14:24\n   |\n14 |         let char_pos = encode_character(c);\n\
    \   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `letter_from_char_pos` in this scope\n  --> /tmp/tmpj9s2v91h.rs:16:17\n\
    \   |\n16 |         let c = letter_from_char_pos(char_pos);\n   |            \
    \     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'a'...'y'\
    \ => char::from(((c as u8 - b'a' + 2) % 26) + b'a'),\n            'A'...'Y' =>\
    \ char::from(((c as u8 - b'A' + 2) % 26) + b'A'),\n            _ => c,\n     \
    \   }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmp0iqxt95v.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"\");\n    for c in message.chars()\
    \ {\n        if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpyokk_zyn.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut encoded_message\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.push(((c as u8 + 2) as char));\n        } else\
    \ {\n            encoded_message.push(c);\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmplee_ljct.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        if (c.is_ascii_lowercase() && c != 'y') || (c.is_ascii_uppercase()\
    \ && c != 'Y') {\n            encoded.push(c.to_ascii_uppercase());\n        }\
    \ else if c == 'y' || c == 'Y' {\n            encoded.push('B');\n        } else\
    \ if c == 'z' || c == 'Z' {\n            encoded.push('C');\n        } else {\n\
    \            encoded.push(c);\n        }\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp9p55los4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = [false, false, true, false, true, false, false,\
    \ true, false, false, false, true, false, true, false, false, true, false, false,\
    \ false, true, false, true, false, false, true, false, false];\n    let mut message_bytes\
    \ = message.into_bytes();\n    let vowels_count = message_bytes.iter().filter(|&&b|\
    \ vowels[(b - 97) as usize]).count();\n    message_bytes.reserve(vowels_count\
    \ * 2);\n    let mut last_index = message_bytes.len() - 1;\n    for _ in 0..vowels_count\
    \ {\n        message_bytes.push(0);\n    }\n    for i in (0..last_index).rev()\
    \ {\n        let item = message_bytes[i];\n        let new_item = if vowels[(item\
    \ - 97) as usize] {\n            item + 2\n        } else {\n            item\n\
    \        };\n        message_bytes[last_index] = new_item;\n        last_index\
    \ -= 1;\n    }\n    if vowels[(message_bytes[0] - 97) as usize] {\n        message_bytes[last_index]\
    \ = message_bytes[0] + 2;\n    } else {\n        message_bytes[last_index] = message_bytes[0];\n\
    \    }\n    for b in &mut message_bytes {\n        if *b < 97 {\n            *b\
    \ += 26;\n        } else if *b > 122 {\n            *b -= 26;\n        }\n   \
    \     if *b > 90 && *b < 97 {\n            *b -= 26;\n        }\n    }\n    unsafe\
    \ {\n        String::from_utf8_unchecked(message_bytes)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwp_dehup.rs:14:65

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_str = String::new();\n    let mut swap = true;\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            swap\
    \ = !swap;\n            if swap {\n                encoded_str.push(c.to_ascii_uppercase());\n\
    \            } else {\n                encoded_str.push(c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            encoded_str.push(c);\n        }\n\
    \    }\n    encoded_str\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tEsT\"`,\n right: `\"tgst\"`', /tmp/tmpgkhht3uo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let alphabet = vec!['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut alphabet_index =\
    \ 0;\n    let mut count_index = 0;\n    let message_chars: Vec<char> = message.chars().collect();\n\
    \    for i in message_chars {\n        for x in alphabet.iter() {\n          \
    \  count_index += 1;\n            if i == *x {\n                alphabet_index\
    \ = count_index;\n            }\n        }\n        count_index = 0;\n       \
    \ if alphabet_index > 0 {\n            let encoded_letter = match i {\n      \
    \          'a' => 'c',\n                'b' => 'd',\n                'c' => 'e',\n\
    \                'd' => 'f',\n                'e' => 'g',\n                'f'\
    \ => 'h',\n                'g' => 'i',\n                'h' => 'j',\n        \
    \        'i' => 'k',\n                'j' => 'l',\n                'k' => 'm',\n\
    \                'l' => 'n',\n                'm' => 'o',\n                'n'\
    \ => 'p',\n                'o' => 'q',\n                'p' => 'r',\n        \
    \        'q' => 's',\n                'r' => 't',\n                's' => 'u',\n\
    \                't' => 'v',\n                'u' => 'w',\n                'v'\
    \ => 'x',\n                'w' => 'y',\n                'x' => 'z',\n        \
    \        'y' => 'a',\n                'z' => 'b',\n                _ => '0',\n\
    \            };\n            encoded.push(encoded_letter);\n        } else {\n\
    \            encoded.push(i);\n        }\n        alphabet_index = 0;\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpziu_fxt1.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           let next = c.to_lowercase().next().unwrap();\n                if \"\
    aeiou\".contains(next) {\n                    let next = if next == 'u' { 'a'\
    \ } else { next.wrapping_add(2) };\n                    res.push(next.to_ascii_uppercase());\n\
    \                } else {\n                    res.push(next.to_ascii_uppercase());\n\
    \                }\n            } else {\n                let next = c.to_lowercase().next().unwrap();\n\
    \                if \"aeiou\".contains(next) {\n                    let next =\
    \ if next == 'u' { 'a' } else { next.wrapping_add(2) };\n                    res.push(next);\n\
    \                } else {\n                    res.push(next);\n             \
    \   }\n            }\n        } else {\n            res.push(c);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9kp094zf.rs:18:67\n   |\n18 |                 \
    \    let next = if next == 'u' { 'a' } else { next.wrapping_add(2) };\n   |  \
    \                                                                 ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `wrapping_add` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp9kp094zf.rs:26:67\n   |\n\
    26 |                     let next = if next == 'u' { 'a' } else { next.wrapping_add(2)\
    \ };\n   |                                                                   ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let lowercase = c.to_lowercase().to_string();\n        if lowercase\
    \ == \"a\" {\n            result.push_str(\"c\");\n        } else if lowercase\
    \ == \"e\" {\n            result.push_str(\"g\");\n        } else if lowercase\
    \ == \"i\" {\n            result.push_str(\"k\");\n        } else if lowercase\
    \ == \"o\" {\n            result.push_str(\"q\");\n        } else if lowercase\
    \ == \"u\" {\n            result.push_str(\"s\");\n        } else if lowercase\
    \ == \"y\" {\n            result.push_str(\"a\");\n        } else {\n        \
    \    result.push_str(&c.to_uppercase().to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TgST\"`,\n right: `\"tgst\"`', /tmp/tmp_vsyt1ku.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let mut c = match c {\n            'A' => 'C',\n            'E' =>\
    \ 'G',\n            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'S',\n\
    \            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n \
    \           'o' => 'q',\n            'u' => 's',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        encoded.push(c);\n    }\n    encoded\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpakhsegp0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        let mut char = c;\n        if c.is_alphabetic() {\n            char\
    \ = c.to_ascii_uppercase();\n        }\n        match char {\n            'A'\
    \ => result.push('C'),\n            'E' => result.push('G'),\n            'I'\
    \ => result.push('K'),\n            'O' => result.push('Q'),\n            'U'\
    \ => result.push('S'),\n            _ => result.push(char),\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpp90docyr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut chars = message.chars();\n\
    \    let shift = (('z' as u8 - 'a' as u8) / 2) as u8;\n    while let Some(c) =\
    \ chars.next() {\n        if c.is_alphabetic() {\n            let upper = c.is_uppercase();\n\
    \            let mut code = c.to_ascii_lowercase().to_string();\n            let\
    \ first = code.pop().unwrap();\n            if first == 'u' {\n              \
    \  let next = chars.next().unwrap();\n                encoded.push(next);\n  \
    \          } else {\n                let offset = ('a' as u8 + (first as u8 +\
    \ shift)) as char;\n                encoded.push(offset);\n            }\n   \
    \         if upper {\n                encoded.make_ascii_uppercase();\n      \
    \      }\n        } else {\n            encoded.push(c);\n        }\n    }\n \
    \   encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xE1\xD2\xE0\xE1\"`,\n right: `\"tgst\"`', /tmp/tmp5jtperhi.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for letter in\
    \ message.chars() {\n        if letter.is_alphabetic() {\n            if let Some(next_letter)\
    \ = letter.to_lowercase().next() {\n                if is_vowel(next_letter) {\n\
    \                    if let Some(next_next_letter) = next_letter.to_lowercase().next()\
    \ {\n                        if is_vowel(next_next_letter) {\n               \
    \             encoded_message.push(next_next_letter.to_uppercase().next().unwrap());\n\
    \                        } else {\n                            encoded_message.push(next_next_letter.to_uppercase().next().unwrap());\n\
    \                        }\n                    }\n                } else {\n\
    \                    encoded_message.push(next_letter.to_uppercase().next().unwrap());\n\
    \                }\n            }\n        } else {\n            encoded_message.push(letter);\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp9oydbnp_.rs:16:20\n\
    \   |\n16 |                 if is_vowel(next_letter) {\n   |                 \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel`\
    \ in this scope\n  --> /tmp/tmp9oydbnp_.rs:18:28\n   |\n18 |                 \
    \        if is_vowel(next_next_letter) {\n   |                            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encrypted_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n        match\
    \ letter {\n            'a' => encrypted_message.push('c'),\n            'e' =>\
    \ encrypted_message.push('g'),\n            'i' => encrypted_message.push('k'),\n\
    \            'o' => encrypted_message.push('m'),\n            'u' => encrypted_message.push('q'),\n\
    \            'A' => encrypted_message.push('C'),\n            'E' => encrypted_message.push('G'),\n\
    \            'I' => encrypted_message.push('K'),\n            'O' => encrypted_message.push('M'),\n\
    \            'U' => encrypted_message.push('Q'),\n            _ => encrypted_message.push(letter),\n\
    \        }\n    }\n    encrypted_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp2538806x.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for character\
    \ in message.chars() {\n        if is_vowel(character) {\n            encoded_message.push(encode_vowel(character));\n\
    \        } else {\n            encoded_message.push(encode_consonant(character));\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpuxcoodv4.rs:14:12\n\
    \   |\n14 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `encode_vowel` in this scope\n\
    \  --> /tmp/tmpuxcoodv4.rs:15:34\n   |\n15 |             encoded_message.push(encode_vowel(character));\n\
    \   |                                  ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `encode_consonant` in this scope\n  --> /tmp/tmpuxcoodv4.rs:17:34\n\
    \   |\n17 |             encoded_message.push(encode_consonant(character));\n \
    \  |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmppeex87rs.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_str = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for character in message.chars() {\n        if character.is_alphabetic()\
    \ {\n            if character.is_uppercase() {\n                encoded_str.push(character.to_lowercase().to_string().parse::<char>().unwrap());\n\
    \            } else {\n                encoded_str.push(character.to_uppercase().to_string().parse::<char>().unwrap());\n\
    \            }\n        } else {\n            encoded_str.push(character);\n \
    \       }\n    }\n    let mut final_str = String::new();\n    for character in\
    \ encoded_str.chars() {\n        let mut push_character = character;\n       \
    \ if vowels.contains(&character) {\n            let mut next_index = character\
    \ as usize;\n            if character == 'u' {\n                next_index = 0;\n\
    \            } else {\n                next_index += 2;\n            }\n     \
    \       push_character = vowels[next_index];\n        }\n        final_str.push(push_character);\n\
    \    }\n    final_str\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 103'', /tmp/tmphl5tymoy.rs:35:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let result = message.chars().map(|c| {\n        match c {\n\
    \            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n \
    \           'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n  \
    \          'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n   \
    \         'U' => 'W',\n            _ => c.to_ascii_uppercase(),\n        }\n \
    \   }).collect::<String>();\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpebqrib2y.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut\
    \ encoded_message = String::new();\n    for c in message.chars() {\n        if\
    \ c.is_ascii_alphabetic() {\n            if c.is_lowercase() {\n             \
    \   let encoded_letter = match c {\n                    'a' => 'c',\n        \
    \            'b' => 'd',\n                    'c' => 'e',\n                  \
    \  'd' => 'f',\n                    'e' => 'g',\n                    'f' => 'h',\n\
    \                    'g' => 'i',\n                    'h' => 'j',\n          \
    \          'i' => 'k',\n                    'j' => 'l',\n                    'k'\
    \ => 'm',\n                    'l' => 'n',\n                    'm' => 'o',\n\
    \                    'n' => 'p',\n                    'o' => 'q',\n          \
    \          'p' => 'r',\n                    'q' => 's',\n                    'r'\
    \ => 't',\n                    's' => 'u',\n                    't' => 'v',\n\
    \                    'u' => 'w',\n                    'v' => 'x',\n          \
    \          'w' => 'y',\n                    'x' => 'z',\n                    'y'\
    \ => 'a',\n                    'z' => 'b',\n                    _ => c,\n    \
    \            };\n                encoded_message.push(encoded_letter);\n     \
    \       } else {\n                let encoded_letter = match c {\n           \
    \         'A' => 'C',\n                    'B' => 'D',\n                    'C'\
    \ => 'E',\n                    'D' => 'F',\n                    'E' => 'G',\n\
    \                    'F' => 'H',\n                    'G' => 'I',\n          \
    \          'H' => 'J',\n                    'I' => 'K',\n                    'J'\
    \ => 'L',\n                    'K' => 'M',\n                    'L' => 'N',\n\
    \                    'M' => 'O',\n                    'N' => 'P',\n          \
    \          'O' => 'Q',\n                    'P' => 'R',\n                    'Q'\
    \ => 'S',\n                    'R' => 'T\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp82fdze33.rs:76:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for c in message.chars()\
    \ {\n   |                              - unclosed delimiter\n15 |         if c.is_ascii_alphabetic()\
    \ {\n   |                                    - unclosed delimiter\n...\n47 | \
    \            } else {\n   |                    - unclosed delimiter\n48 |    \
    \             let encoded_letter = match c {\n   |                           \
    \                   - this delimiter might not be properly closed...\n...\n67\
    \ | }\n   | - ...as it matches this but it has different indentation\n...\n76\
    \ | }\n   |   ^\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n\
    \  --> /tmp/tmp82fdze33.rs:67:1\n   |\n67 | }\n   | ^ expected `while`, `for`,\
    \ `loop` or `{` after a label\n\nerror: expected expression, found `}`\n  -->\
    \ /tmp/tmp82fdze33.rs:67:1\n   |\n66 |                     'R' => 'T\n   |   \
    \                      -- while parsing the `match` arm starting here\n67 | }\n\
    \   | ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `else`, or\
    \ an operator, found keyword `fn`\n  --> /tmp/tmp82fdze33.rs:69:1\n   |\n67 |\
    \ }\n   |  - expected one of `.`, `;`, `?`, `else`, or an operator\n68 | \n69\
    \ | fn main() {\n   | ^^ unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp82fdze33.rs:14:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n14 | /     for c in message.chars() {\n15 | |         if c.is_ascii_alphabetic()\
    \ {\n16 | |             if c.is_lowercase() {\n17 | |                 let encoded_letter\
    \ = match c {\n...  |\n75 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw\
    \ WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n76 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // write your code here\n    let mut encoded_msg = message.clone();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut iter = encoded_msg.chars();\n\
    \    let mut new_str = String::new();\n    while let Some(curr_char) = iter.next()\
    \ {\n        if vowels.contains(&curr_char) {\n            let mut next_char =\
    \ iter.next().unwrap();\n            if next_char == 'a' {\n                next_char\
    \ = 'c';\n            } else if next_char == 'e' {\n                next_char\
    \ = 'i';\n            } else if next_char == 'i' {\n                next_char\
    \ = 'o';\n            } else if next_char == 'o' {\n                next_char\
    \ = 'u';\n            } else if next_char == 'u' {\n                next_char\
    \ = 'a';\n            }\n            new_str.push(next_char);\n        } else\
    \ {\n            if curr_char.is_ascii_lowercase() {\n                new_str.push(curr_char.to_ascii_uppercase());\n\
    \            } else {\n                new_str.push(curr_char.to_ascii_lowercase());\n\
    \            }\n        }\n    }\n    new_str\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpkbgs6zt_.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = String::new();\n    for ch in message.chars()\
    \ {\n        if ch.is_ascii_uppercase() {\n            new_message.push(ch.to_ascii_lowercase());\n\
    \        } else if ch.is_ascii_lowercase() {\n            new_message.push(ch.to_ascii_uppercase());\n\
    \        } else {\n            new_message.push(ch);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmp_6dkuzir.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let s: String = message.chars().map(|c| match c {\n       \
    \ 'a' | 'A' => \"c\",\n        'e' | 'E' => \"g\",\n        'i' | 'I' => \"k\"\
    ,\n        'o' | 'O' => \"s\",\n        'u' | 'U' => \"y\",\n        ' ' => \"\
    \ \",\n        _ => c.to_ascii_uppercase().to_string().as_str(),\n    }).collect();\n\
    \    return s;\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0515]: cannot return reference to temporary value\n  --> /tmp/tmp70203mqb.rs:19:14\n\
    \   |\n19 |         _ => c.to_ascii_uppercase().to_string().as_str(),\n   |  \
    \            ----------------------------------^^^^^^^^^\n   |              |\n\
    \   |              returns a reference to data owned by the current function\n\
    \   |              temporary value created here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0515`.\n"
  stdout: ''
  timestamp: 1660009101
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.to_lowercase()\n        .chars()\n        .map(|x|\
    \ {\n            match x {\n                'a' => 'c',\n                'e' =>\
    \ 'g',\n                'i' => 'k',\n                'o' => 'q',\n           \
    \     'u' => 'w',\n                'y' => 'a',\n                _ => x,\n    \
    \        }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"mwdcskr\"`,\n right: `\"mWDCSKR\"`', /tmp/tmpkclr22lf.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|letter| match letter {\n        'A' |\
    \ 'a' => 'C',\n        'E' | 'e' => 'G',\n        'I' | 'i' => 'K',\n        'O'\
    \ | 'o' => 'Q',\n        'U' | 'u' => 'S',\n        ' ' => ' ',\n        _ =>\
    \ letter.to_ascii_uppercase(),\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpw6rj131i.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|x| {\n        let mut ch = x.to_lowercase().to_string();\n\
    \        match x {\n            'a' => ch = \"c\".to_string(),\n            'e'\
    \ => ch = \"g\".to_string(),\n            'i' => ch = \"k\".to_string(),\n   \
    \         'o' => ch = \"s\".to_string(),\n            'u' => ch = \"y\".to_string(),\n\
    \            _ => (),\n        }\n        if x.is_uppercase() {\n            ch.to_uppercase().to_string()\n\
    \        } else {\n            ch\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmprxnpyl2q.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  let mut encoded = String::new();\n  for c in message.chars()\
    \ {\n    if c.is_alphabetic() {\n      let ascii_value = c.to_ascii_lowercase()\
    \ as u8;\n      let value = match ascii_value {\n        b'a'...b'e' => ascii_value\
    \ + 3,\n        b'f'...b'j' => ascii_value - 5,\n        b'k'...b'o' => ascii_value\
    \ + 2,\n        b'p'...b't' => ascii_value - 6,\n        b'u'...b'y' => ascii_value\
    \ + 1,\n        b'z' => b'c',\n        _ => unreachable!()\n      };\n      encoded.push(value\
    \ as char);\n    } else {\n      encoded.push(c);\n    }\n  }\n  encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"nhmn\"`,\n right: `\"tgst\"`', /tmp/tmp7dvs11bw.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let v: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut encoded_message = String::new();\n    for character in message.chars() {\n\
    \        if v.contains(&character) {\n            let mut index = v.iter().position(|&r|\
    \ r == character).unwrap();\n            index += 2;\n            if index > v.len()\
    \ - 1 {\n                index -= v.len();\n            }\n            encoded_message.push(v[index]);\n\
    \        } else if character.is_uppercase() {\n            encoded_message.push(character.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(character.to_uppercase().next().unwrap());\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpwote6q2a.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        let result = if vowels.contains(&c)\
    \ {\n            (b'a' + ((c as u8) - b'a' + 2) % 26) as char\n        } else\
    \ {\n            c.to_uppercase().next().unwrap()\n        };\n        res.push(result);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp9smnobjq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           encoded_message.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \            } else {\n                encoded_message.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \            }\n        } else {\n            encoded_message.push(c);\n     \
    \   }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpq9d9ss1j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let alphabet = String::from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    let vowels = String::from(\"AEIOU\");\n    let mut message = message.to_uppercase();\n\
    \    let mut encoded_message = String::new();\n    let mut found_vowel = false;\n\
    \    for ch in message.chars() {\n        if !found_vowel {\n            if vowels.contains(ch)\
    \ {\n                found_vowel = true;\n                for i in 0..alphabet.len()\
    \ {\n                    if alphabet.chars().nth(i).unwrap() == ch {\n       \
    \                 let new_index = i + 2;\n                        if new_index\
    \ > alphabet.len() - 1 {\n                            encoded_message.push(alphabet.chars().nth(new_index\
    \ - alphabet.len()).unwrap());\n                        } else {\n           \
    \                 encoded_message.push(alphabet.chars().nth(new_index).unwrap());\n\
    \                        }\n                    }\n                }\n       \
    \     } else {\n                encoded_message.push(ch);\n            }\n   \
    \     } else {\n            encoded_message.push(ch);\n        }\n    }\n    encoded_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpgfepw3e8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'A' => result.push('C'),\n            'E'\
    \ => result.push('G'),\n            'I' => result.push('K'),\n            'O'\
    \ => result.push('Q'),\n            'U' => result.push('S'),\n            'a'\
    \ => result.push('c'),\n            'e' => result.push('g'),\n            'i'\
    \ => result.push('k'),\n            'o' => result.push('q'),\n            'u'\
    \ => result.push('s'),\n            _ => result.push(c),\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpjws00vku.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(char_map).collect()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `char_map` in this scope\n  --> /tmp/tmphfxr7amh.rs:12:25\n\
    \   |\n12 |     message.chars().map(char_map).collect()\n   |                \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message.chars()\
    \ {\n        let encoded_letter = match letter {\n            'a' | 'A' => 'C',\n\
    \            'e' | 'E' => 'G',\n            'i' | 'I' => 'K',\n            'o'\
    \ | 'O' => 'Q',\n            'u' | 'U' => 'Y',\n            letter => {\n    \
    \            match letter.is_uppercase() {\n                    true => letter.to_lowercase().to_string(),\n\
    \                    false => letter.to_uppercase().to_string(),\n           \
    \     }\n            }\n        };\n        encoded.push_str(&encoded_letter);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmp0imtblso.rs:21:17\n\
    \   |\n14 |           let encoded_letter = match letter {\n   |              \
    \                  ------------ `match` arms have incompatible types\n...\n19\
    \ |               'u' | 'U' => 'Y',\n   |                            --- this\
    \ and all prior arms are found to be of type `char`\n20 |               letter\
    \ => {\n21 | /                 match letter.is_uppercase() {\n22 | |         \
    \            true => letter.to_lowercase().to_string(),\n23 | |              \
    \       false => letter.to_uppercase().to_string(),\n24 | |                 }\n\
    \   | |_________________^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let encode_table = vec!['y', 'u', 'i', 'o', 'a', 'e', 'A',\
    \ 'E', 'I', 'O', 'U', 'Y'];\n    let mut message_vec: Vec<char> = message.chars().collect();\n\
    \    for i in 0..message_vec.len() {\n        match message_vec[i] {\n       \
    \     'a' => message_vec[i] = encode_table[0],\n            'e' => message_vec[i]\
    \ = encode_table[1],\n            'i' => message_vec[i] = encode_table[2],\n \
    \           'o' => message_vec[i] = encode_table[3],\n            'u' => message_vec[i]\
    \ = encode_table[4],\n            'y' => message_vec[i] = encode_table[5],\n \
    \           'A' => message_vec[i] = encode_table[6],\n            'E' => message_vec[i]\
    \ = encode_table[7],\n            'I' => message_vec[i] = encode_table[8],\n \
    \           'O' => message_vec[i] = encode_table[9],\n            'U' => message_vec[i]\
    \ = encode_table[10],\n            'Y' => message_vec[i] = encode_table[11],\n\
    \            _ => message_vec[i] = message_vec[i].to_ascii_uppercase(),\n    \
    \    }\n    }\n    message_vec.into_iter().collect()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpk4ekcxd8.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let message_characters:\
    \ Vec<char> = message.chars().collect();\n    for character in message_characters\
    \ {\n        if is_vowel(character) {\n            encoded_message.push(get_next_vowel(character));\n\
    \        } else {\n            encoded_message.push(get_swapped_case(character));\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp0for3ztj.rs:15:12\n\
    \   |\n15 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `get_next_vowel` in this\
    \ scope\n  --> /tmp/tmp0for3ztj.rs:16:34\n   |\n16 |             encoded_message.push(get_next_vowel(character));\n\
    \   |                                  ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `get_swapped_case` in this scope\n  --> /tmp/tmp0for3ztj.rs:18:34\n\
    \   |\n18 |             encoded_message.push(get_swapped_case(character));\n \
    \  |                                  ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| match c {\n        'a' | 'A' => 'C',\n\
    \        'e' | 'E' => 'G',\n        'i' | 'I' => 'K',\n        'o' | 'O' => 'Q',\n\
    \        'u' | 'U' => 'S',\n        'y' | 'Y' => 'A',\n        _ => c.to_ascii_uppercase(),\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmptuhakglo.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    const ENGLISH_ALPHABET: &'static str = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut result = String::new();\n    let mut is_lowercase = false;\n  \
    \  for c in message.chars() {\n        if c.is_lowercase() {\n            is_lowercase\
    \ = true;\n        } else {\n            is_lowercase = false;\n        }\n  \
    \      if let Some(index) = ENGLISH_ALPHABET.find(c.to_lowercase().next().unwrap())\
    \ {\n            let mut index = index;\n            let replacement = if is_lowercase\
    \ {\n                index += 2;\n                ENGLISH_ALPHABET.chars().nth(index\
    \ % 26).unwrap()\n            } else {\n                index += 2;\n        \
    \        ENGLISH_ALPHABET.chars().nth(index % 26).unwrap().to_uppercase().next().unwrap()\n\
    \            };\n            if VOWELS.find(c.to_lowercase().next().unwrap()).is_some()\
    \ {\n                result.push(replacement);\n            } else {\n       \
    \         result.push(c);\n            }\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmphnu1d6z8.rs:30:16\n\
    \   |\n30 |             if VOWELS.find(c.to_lowercase().next().unwrap()).is_some()\
    \ {\n   |                ^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.to_lowercase();\n    let chars = [\n\
    \        ('a', 'c'), ('e', 'g'), ('i', 'k'), ('o', 'q'), ('u', 'w'),\n       \
    \ ('b', 'd'), ('f', 'h'), ('j', 'l'), ('p', 'r'), ('v', 'x'),\n        ('c', 'e'),\
    \ ('g', 'i'), ('k', 'm'), ('q', 's'), ('w', 'y'),\n        ('d', 'f'), ('h', 'j'),\
    \ ('l', 'n'), ('r', 't'), ('x', 'z'),\n    ];\n    for (old, new) in chars.iter()\
    \ {\n        result = result.replace(old, new);\n    }\n    result.to_uppercase()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnwc5et1u.rs:20:38\n   |\n\
    20 |         result = result.replace(old, new);\n   |                        \
    \              ^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n   --> /tmp/tmpnwc5et1u.rs:20:33\n    |\n20  |      \
    \   result = result.replace(old, new);\n    |                         -------\
    \ ^^^ expected an `Fn<(char,)>` closure, found `char`\n    |                 \
    \        |\n    |                         required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n    = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    help: consider dereferencing here\n    |\n20  |         result = result.replace(*old,\
    \ new);\n    |                                 +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let message_as_vec: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = String::new();\n    for c in message_as_vec {\n\
    \        match c {\n            'a' => encoded_message.push('c'),\n          \
    \  'A' => encoded_message.push('C'),\n            'e' => encoded_message.push('g'),\n\
    \            'E' => encoded_message.push('G'),\n            'i' => encoded_message.push('k'),\n\
    \            'I' => encoded_message.push('K'),\n            'o' => encoded_message.push('q'),\n\
    \            'O' => encoded_message.push('Q'),\n            'u' => encoded_message.push('s'),\n\
    \            'U' => encoded_message.push('S'),\n            'y' => encoded_message.push('a'),\n\
    \            'Y' => encoded_message.push('A'),\n            ' ' => encoded_message.push('\
    \ '),\n            _ => encoded_message.push(c.to_uppercase().to_string().chars().next().unwrap()),\n\
    \        }\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpt8p6t6es.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let new_c = match c {\n\
    \            'a' => 'c',\n            'A' => 'C',\n            'e' => 'g',\n \
    \           'E' => 'G',\n            'i' => 'k',\n            'I' => 'K',\n  \
    \          'o' => 'q',\n            'O' => 'Q',\n            'u' => 'w',\n   \
    \         'U' => 'W',\n            _ => c.to_ascii_uppercase(),\n        };\n\
    \        new_c\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp7_8oyxm8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if is_vowel(c) {\n            result.push(vowel_next(c));\n     \
    \   } else {\n            result.push(char_swap(c));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp0vge_e3s.rs:14:12\n\
    \   |\n14 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `vowel_next` in this scope\n  -->\
    \ /tmp/tmp0vge_e3s.rs:15:25\n   |\n15 |             result.push(vowel_next(c));\n\
    \   |                         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `char_swap` in this scope\n  --> /tmp/tmp0vge_e3s.rs:17:25\n\
    \   |\n17 |             result.push(char_swap(c));\n   |                     \
    \    ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = String::new();\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        let mut new_c\
    \ = c;\n        if c.is_ascii_uppercase() {\n            new_c = c.to_ascii_lowercase();\n\
    \        }\n        if vowels.contains(&new_c) {\n            new_c = get_vowel(new_c);\n\
    \        }\n        new_message.push(new_c);\n    }\n    new_message\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_vowel` in this scope\n  --> /tmp/tmpd8y4pc4g.rs:20:21\n\
    \   |\n20 |             new_c = get_vowel(new_c);\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s: Vec<char> = message.chars().collect();\n    let\
    \ mut result = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n \
    \   for c in s {\n        if vowels.contains(&c) {\n            match c {\n  \
    \              'a' => result.push('c'),\n                'e' => result.push('g'),\n\
    \                'i' => result.push('k'),\n                'o' => result.push('m'),\n\
    \                'u' => result.push('q'),\n                _ => {}\n         \
    \   }\n        } else {\n            match c {\n                'a'..='z' => result.push((c\
    \ as u8 + 2) as char),\n                'A'..='Z' => result.push((c as u8 + 2)\
    \ as char),\n                _ => result.push(c),\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"VGUV\"`,\n right: `\"tgst\"`', /tmp/tmpvrt5a6r2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // Create a slice from the message\n    let message_bytes =\
    \ message.as_bytes();\n    // Create an empty String\n    let mut encoded = String::new();\n\
    \    // Use match to determine the output character\n    for &byte in message_bytes\
    \ {\n        encoded.push(match byte {\n            b'a' => 'c',\n           \
    \ b'e' => 'g',\n            b'i' => 'k',\n            b'o' => 'q',\n         \
    \   b'u' => 'w',\n            b'A' => 'C',\n            b'E' => 'G',\n       \
    \     b'I' => 'K',\n            b'O' => 'Q',\n            b'U' => 'W',\n     \
    \       b'y' => 'a',\n            b'Y' => 'A',\n            // If it's not a vowel,\
    \ toggle the case\n            _ => match byte {\n                b'a'...b'z'\
    \ => byte - 32,\n                b'A'...b'Z' => byte + 32,\n                _\
    \ => byte,\n            }\n        });\n    }\n    // Return the encoded message\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpmlemmx4f.rs:33:21\n\
    \   |\n33 |                 b'a'...b'z' => byte - 32,\n   |                  \
    \   ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpmlemmx4f.rs:34:21\n\
    \   |\n34 |                 b'A'...b'Z' => byte + 32,\n   |                  \
    \   ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmlemmx4f.rs:33:32\n   |\n33 |\
    \                 b'a'...b'z' => byte - 32,\n   |                            \
    \    ^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting due to previous\
    \ error; 2 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    String::from(\"TODO\")\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TODO\"`,\n right: `\"tgst\"`', /tmp/tmp3ppztblv.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"AEIOU\";\n    let mut chars = message.chars();\n\
    \    let mut encoded_message = String::new();\n    while let Some(char) = chars.next()\
    \ {\n        let is_vowel = vowels.contains(char);\n        let mut code = char.to_ascii_uppercase();\n\
    \        if is_vowel {\n            let mut next_vowel = code;\n            while\
    \ next_vowel == code {\n                next_vowel = ((code as u8) + 2) as char;\n\
    \            }\n            code = next_vowel;\n        }\n        encoded_message.push(code);\n\
    \    }\n    encoded_message\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp7ehcbxoz.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            if c.is_ascii_uppercase()\
    \ {\n                result.push(c.to_ascii_lowercase());\n            } else\
    \ {\n                result.push(c.to_ascii_uppercase());\n            }\n   \
    \     } else {\n            result.push(c);\n        }\n    }\n    let mut result\
    \ = String::new();\n    for c in message.chars() {\n        match c {\n      \
    \      'a' => result.push('c'),\n            'e' => result.push('g'),\n      \
    \      'i' => result.push('k'),\n            'o' => result.push('q'),\n      \
    \      'u' => result.push('y'),\n            'A' => result.push('C'),\n      \
    \      'E' => result.push('G'),\n            'I' => result.push('K'),\n      \
    \      'O' => result.push('Q'),\n            'U' => result.push('Y'),\n      \
    \      _ => result.push(c),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpg9hy0u5l.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if c.is_uppercase() {\n\
    \            c.to_lowercase().to_string()\n        } else if c.is_lowercase()\
    \ {\n            c.to_uppercase().to_string()\n        } else {\n            c.to_string()\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpdvq_yjlh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // return what you want\n    let mut encoded_message = message.clone();\n\
    \    encoded_message.make_ascii_uppercase();\n    //no characters in message,\
    \ so return empty string\n    if encoded_message.len() == 0 {\n        return\
    \ String::from(\"\");\n    }\n    let mut encoded_letter = 'A';\n    let mut prev_char\
    \ = 'A';\n    let mut encoded_message_iter = encoded_message.chars();\n    let\
    \ mut char_vec: Vec<char> = Vec::new();\n    let mut encoded_message_vec: Vec<char>\
    \ = Vec::new();\n    let mut y = -1;\n\n    for letter in encoded_message_iter\
    \ {\n        encoded_letter = letter;\n        y += 1;\n        if letter.is_ascii_uppercase()\
    \ {\n            encoded_letter = letter.to_ascii_lowercase();\n        }\n  \
    \      if prev_char.is_ascii_uppercase() {\n            prev_char = prev_char.to_ascii_lowercase();\n\
    \        }\n        if encoded_letter == 'a' {\n            encoded_letter = 'c';\n\
    \        } else if encoded_letter == 'e' {\n            encoded_letter = 'g';\n\
    \        } else if encoded_letter == 'i' {\n            encoded_letter = 'k';\n\
    \        } else if encoded_letter == 'o' {\n            encoded_letter = 'q';\n\
    \        } else if encoded_letter == 'u' {\n            encoded_letter = 'y';\n\
    \        } else if encoded_letter == 'y' {\n            encoded_letter = 'b';\n\
    \        }\n        if prev_char.is_ascii_uppercase() {\n            prev_char\
    \ = prev_char.to_ascii_lowercase();\n        }\n        if prev_char == 'a' {\n\
    \            prev_char = 'c';\n        } else if prev_char == 'e' {\n        \
    \    prev_char = 'g';\n        } else if prev_char == 'i' {\n            prev_char\
    \ = 'k';\n        } else if prev_char == 'o' {\n            prev_char = '\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp6riphb52.rs:58:25\n\
    \   |\n58 |             prev_char = '\n   |                         ^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        match c {\n            'a'\
    \ => 'c',\n            'e' => 'g',\n            'i' => 'k',\n            'o' =>\
    \ 'q',\n            'u' => 'y',\n            'A' => 'C',\n            'E' => 'G',\n\
    \            'I' => 'K',\n            'O' => 'Q',\n            'U' => 'Y',\n \
    \           _ => if c.is_uppercase() {\n                c.to_lowercase().to_string().chars().collect::<Vec<char>>()[0]\n\
    \            } else {\n                c.to_uppercase().to_string().chars().collect::<Vec<char>>()[0]\n\
    \            }\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmp15nd9iur.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(char_encoder).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `char_encoder` in this scope\n  --> /tmp/tmp4ndmrzep.rs:12:25\n\
    \   |\n12 |     message.chars().map(char_encoder).collect()\n   |            \
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO - implement your code here\n    String::from(\"\")\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpey9jorbw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: Your answer here\n    let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    let mut result = String::new();\n    for i in message.chars()\
    \ {\n        match i {\n            'a' => result.push('c'),\n            'e'\
    \ => result.push('i'),\n            'i' => result.push('m'),\n            'o'\
    \ => result.push('s'),\n            'u' => result.push('y'),\n            _ =>\
    \ result.push(i),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpd0cb06hw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    return String::from(\"TODO: implement\");\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TODO: implement\"`,\n right: `\"tgst\"`', /tmp/tmp1pbvpikg.rs:17:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut result = String::new();\n\
    \    for c in message.chars() {\n        let mut letter = c;\n        if vowels.contains(c)\
    \ {\n            letter = match c {\n                'a' => 'c',\n           \
    \     'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n\
    \                'u' => 'y',\n                'A' => 'C',\n                'E'\
    \ => 'G',\n                'I' => 'K',\n                'O' => 'Q',\n        \
    \        'U' => 'Y',\n                _ => c,\n            }\n        }\n    \
    \    result.push(letter.to_uppercase().next().unwrap());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmp53c3oelb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let new_char = match c {\n\
    \            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n \
    \           'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n  \
    \          'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n   \
    \         'U' => 'W',\n            _ => c,\n        };\n        match new_char\
    \ {\n            'c' | 'g' | 'k' | 'q' | 'w' | 'C' | 'G' | 'K' | 'Q' | 'W' =>\
    \ new_char,\n            _ => match new_char.is_uppercase() {\n              \
    \  true => new_char.to_lowercase().next().unwrap(),\n                false =>\
    \ new_char.to_uppercase().next().unwrap(),\n            },\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tGst\"`,\n right: `\"tgst\"`', /tmp/tmpqn9vh35r.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpnz6tgu53.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009100
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    let message_string\
    \ = String::from(message);\n    let message_len = message_string.len();\n    let\
    \ vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut ctr = 0;\n \
    \   while ctr < message_len {\n        let ch = message_string.chars().nth(ctr).unwrap();\n\
    \        if vowels.contains(&ch) {\n            encoded_message.push(vowels[((vowels.iter().position(|&x|\
    \ x == ch).unwrap() + 2) % 5)]);\n        } else {\n            encoded_message.push(ch);\n\
    \        }\n        ctr += 1;\n    }\n    encoded_message\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmp1vn4a1tb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let vowels = \"aeiou\";\n    let mut new_message = String::new();\n\
    \    for c in message.chars() {\n        if c.is_ascii_lowercase() {\n       \
    \     let c_upper = c.to_ascii_uppercase();\n            if vowels.contains(c_upper)\
    \ {\n                let index = vowels.find(c_upper).unwrap();\n            \
    \    new_message.push(vowels.chars().nth(index + 2).unwrap());\n            }\
    \ else {\n                new_message.push(c_upper);\n            }\n        }\
    \ else if c.is_ascii_uppercase() {\n            let c_lower = c.to_ascii_lowercase();\n\
    \            if vowels.contains(c_lower) {\n                let index = vowels.find(c_lower).unwrap();\n\
    \                new_message.push(vowels.chars().nth(index + 2).unwrap());\n \
    \           } else {\n                new_message.push(c_lower);\n           \
    \ }\n        } else {\n            new_message.push(c);\n        }\n    }\n  \
    \  new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"tost\"`,\n right: `\"tgst\"`', /tmp/tmpm0sab0w2.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut message_chars\
    \ = message.chars();\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut vowels_index = 0;\n    let mut next_vowel = vowels[vowels_index];\n\
    \    let mut char_iter = CharIterator::new(message_chars);\n    loop {\n     \
    \   let c = char_iter.next();\n        if c.is_none() {\n            break;\n\
    \        }\n        let c = c.unwrap();\n        let mut c = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        if vowels.contains(&c.to_string().as_str()) {\n            if c == next_vowel\
    \ {\n                c = vowels[(vowels_index + 2) % vowels.len()].chars().next().unwrap();\n\
    \                vowels_index = (vowels_index + 1) % vowels.len();\n         \
    \       next_vowel = vowels[vowels_index].chars().next().unwrap();\n         \
    \   }\n        }\n        if c.is_ascii_uppercase() {\n            encoded.push(c.to_ascii_lowercase());\n\
    \        } else {\n            encoded.push(c.to_ascii_uppercase());\n       \
    \ }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `CharIterator`\n\
    \  --> /tmp/tmp8liyzqsq.rs:17:25\n   |\n17 |     let mut char_iter = CharIterator::new(message_chars);\n\
    \   |                         ^^^^^^^^^^^^ use of undeclared type `CharIterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8liyzqsq.rs:29:30\n   |\n16 |\
    \     let mut next_vowel = vowels[vowels_index];\n   |                       \
    \   -------------------- expected due to this value\n...\n29 |               \
    \  next_vowel = vowels[vowels_index].chars().next().unwrap();\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n  let alphabet = \n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n  let vowels = \"AEIOU\";\n  let mut result = String::new();\n  for c in message.chars()\
    \ {\n    if let Some(index) = alphabet.find(c) {\n      if vowels.contains(c)\
    \ {\n        result.push(alphabet.chars().nth(index + 2).unwrap());\n      } else\
    \ {\n        result.push(alphabet.chars().nth(index + 26).unwrap());\n      }\n\
    \    } else {\n      result.push(c);\n    }\n  }\n  result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TGST\"`,\n right: `\"tgst\"`', /tmp/tmpd96ha0ga.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: Implement this function. \n    String::from(\"\")\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"tgst\"`', /tmp/tmpw1athalq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009102
