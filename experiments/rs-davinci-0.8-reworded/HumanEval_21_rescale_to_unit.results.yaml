language: rs
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let\
    \ n = numbers.len();\n    if min == max {\n        return vec![0.0; n];\n    }\n\
    \    numbers.iter().map(|number| (*number - min) / (max - min)).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| n / max).collect()\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpjsr3bux4.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpjsr3bux4.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n\
    \    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let scaled_numbers\
    \ = numbers.iter().map(|x| (x - min) / (max - min)).collect();\n    scaled_numbers\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() >= 2);\n    let mut smallest = numbers[0];\n\
    \    let mut largest = numbers[0];\n    for &number in numbers.iter() {\n    \
    \    if number < smallest {\n            smallest = number;\n        }\n     \
    \   if number > largest {\n            largest = number;\n        }\n    }\n \
    \   let scale = 1.0 / (largest - smallest);\n    numbers.iter().map(|number| (number\
    \ - smallest) * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut numbers = numbers;\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let normalized_numbers = numbers.iter().map(|n| (n - min) / (max - min)).collect();\n\
    \    normalized_numbers\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // Find the maximum and minimum\n    let (min, max) = numbers.iter().fold((f64::MAX,\
    \ f64::MIN), |(min, max), &n| {\n        if n < min {\n            (n, max)\n\
    \        } else if n > max {\n            (min, n)\n        } else {\n       \
    \     (min, max)\n        }\n    });\n\n    // If the max and min are the same,\
    \ then all the numbers are the same.\n    // Just return the same array.\n   \
    \ if min == max {\n        return numbers;\n    }\n\n    // return the rescaled\
    \ numbers\n    let factor = 1.0 / (max - min);\n    numbers.iter().map(|n| (n\
    \ - min) * factor).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000278690500778027,\
    \ -0.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpf_3g2x4c.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822481
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]),\
    \ |(min, max), x| {\n        (min.min(*x), max.max(*x))\n    });\n    let max_dif\
    \ = max - min;\n    numbers.iter().map(|x| (*x - min) / max_dif).collect()\n}\n\
    \nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let max = *numbers.iter().max().unwrap();\n    let min =\
    \ *numbers.iter().min().unwrap();\n    numbers.iter().map(|n| (*n - min) / (max\
    \ - min)).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp06fa7be5.rs:6:31\n\
    \  |\n6 |     let max = *numbers.iter().max().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp06fa7be5.rs:7:31\n\
    \  |\n7 |     let min = *numbers.iter().min().unwrap();\n  |                 \
    \              ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if *min == *max {\n        return numbers;\n    }\n    let scale = 1.0 /\
    \ (max - min);\n    let shift = -min;\n    numbers.iter().map(|x| (x + shift)\
    \ * scale).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2ypjldir.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp2ypjldir.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let mut ret_val = Vec::new();\n    for i in numbers {\n        ret_val.push((i\
    \ - min) / (max - min));\n    }\n    ret_val\n}\n\nfn main() {\n    let candidate\
    \ = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n\
    \    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    // Ensure that we have at least two elements, or else we\
    \ can't do anything\n    if numbers.len() < 2 {\n        panic!(\"rescale_to_unit\
    \ requires a vector of at least two elements!\");\n    }\n\n    // Find smallest\
    \ and largest elements\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n\n    // Compute range\n    let range\
    \ = max - min;\n\n    // Do the rescaling\n    let mut result = vec![];\n    for\
    \ &number in numbers.iter() {\n        let rescaled = (number - min) / range;\n\
    \        result.push(rescaled);\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0,\
    \ 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n  --> /tmp/tmpw6m1b4fg.rs:12:30\n\
    \   |\n12 |     let min = numbers.iter().min().unwrap();\n   |               \
    \               ^^^ the trait `Ord` is not implemented for `f64`\n   |\n   = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n  --> /tmp/tmpw6m1b4fg.rs:13:30\n\
    \   |\n13 |     let max = numbers.iter().max().unwrap();\n   |               \
    \               ^^^ the trait `Ord` is not implemented for `f64`\n   |\n   = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| {\n        (x - min) /\
    \ range\n    }).collect()\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmprem9j1o3.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmprem9j1o3.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1u7mjzjy.rs:6:30\n\
    \  |\n6 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp1u7mjzjy.rs:7:30\n\
    \  |\n7 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    if numbers.len() == 0 {\n        return vec![];\n    }\n\n\
    \    let smallest = numbers.iter().fold(numbers[0], |memo, &x| cmp::min(memo,\
    \ x));\n    let range = numbers.iter().fold(numbers[0], |memo, &x| cmp::max(memo,\
    \ x)) - smallest;\n\n    if range == 0.0 {\n        return vec![];\n    }\n\n\
    \    numbers.iter().map(|x| (x - smallest) / range).collect()\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpo8vv1dcp.rs:10:63\n   |\n10 |     let smallest = numbers.iter().fold(numbers[0],\
    \ |memo, &x| cmp::min(memo, x));\n   |                                       \
    \                        ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpo8vv1dcp.rs:11:60\n\
    \   |\n11 |     let range = numbers.iter().fold(numbers[0], |memo, &x| cmp::max(memo,\
    \ x)) - smallest;\n   |                                                      \
    \      ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    assert!(numbers.len() >= 2);\n    let n = numbers.len();\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    (0..n).map(|i| (numbers[i] - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp43cf6dj7.rs:8:30\n\
    \  |\n8 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmp43cf6dj7.rs:9:30\n\
    \  |\n9 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut result = numbers.clone();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    for x in result.iter_mut()\
    \ {\n        *x = (*x - min) / (max - min);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplim049gj.rs:7:30\n\
    \  |\n7 |     let min = numbers.iter().min().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror[E0277]:\
    \ the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmplim049gj.rs:8:30\n\
    \  |\n8 |     let max = numbers.iter().max().unwrap();\n  |                  \
    \            ^^^ the trait `Ord` is not implemented for `f64`\n  |\n  = note:\
    \ required because of the requirements on the impl of `Ord` for `&f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 101
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let\
    \ range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0.0, 1.0]`,\n right: `[1.0, 0.0]`', /tmp/tmpruipx6ge.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822481
- exit_code: 1
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min_number = numbers.iter().min().unwrap();\n    let\
    \ max_number = numbers.iter().max().unwrap();\n    let mut result = vec![];\n\
    \    for number in numbers {\n        result.push((number - min_number) / (max_number\
    \ - min_number));\n    }\n    result\n}\n\nfn main() {\n    let candidate = rescale_to_unit;\n\
    \    assert_eq!(candidate(vec![2.0, 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0,\
    \ 49.9]), vec![1.0, 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0]), vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0,\
    \ 1.0, 5.0, 3.0, 4.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0,\
    \ 11.0, 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpuolk26xl.rs:6:37\n\
    \  |\n6 |     let min_number = numbers.iter().min().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror[E0277]: the trait bound `f64: Ord` is not satisfied\n --> /tmp/tmpuolk26xl.rs:7:37\n\
    \  |\n7 |     let max_number = numbers.iter().max().unwrap();\n  |           \
    \                          ^^^ the trait `Ord` is not implemented for `f64`\n\
    \  |\n  = note: required because of the requirements on the impl of `Ord` for\
    \ `&f64`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822480
- exit_code: 0
  program: "/// Given vector of numbers (of at least two elements), apply a linear\
    \ transform to that vector,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>)\
    \ -> Vec<f64> {\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let delta = max - min;\n    numbers.iter().map(|n| (n - min) / delta).collect()\n\
    }\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
    \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
    \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
    \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]),\
    \ vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0,\
    \ 15.0, 13.0, 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822481
