name: HumanEval_84_solve
language: rs
prompt: "/// Given a positive integer N, return the total sum of its digits in binary.\n\
  /// Example\n/// >>> solve(1000)\n/// String::from(\"1\")\n/// >>> solve(150)\n\
  /// String::from(\"110\")\n/// >>> solve(147)\n/// String::from(\"1100\")\n/// Variables:\n\
  /// @N integer\n/// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string\
  \ of binary number\nfn solve(N: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(1000),\
  \ String::from(\"1\"));\n    assert_eq!(candidate(150), String::from(\"110\"));\n\
  \    assert_eq!(candidate(147), String::from(\"1100\"));\n    assert_eq!(candidate(333),\
  \ String::from(\"1001\"));\n    assert_eq!(candidate(963), String::from(\"10010\"\
  ));\n}\n"
completions: ["    let mut n = N;\n    let mut result = String::new();\n    while\
    \ n > 0 {\n        result.push_str(&format!(\"{}\", n % 2));\n        n /= 2;\n\
    \    }\n    result.chars().rev().collect()", "    let binary_string = format!(\"\
    {:b}\", N);\n    let mut sum = 0;\n    for character in binary_string.chars()\
    \ {\n        sum += character.to_digit(10).unwrap();\n    }\n    sum.to_string()",
  "    // Your code goes here\n    format!(\"{:b}\", N).chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>().to_string()",
  "    let mut N = N;\n    let mut res = String::new();\n    while N > 0 {\n     \
    \   res = String::from(if N % 2 == 0 { \"0\" } else { \"1\" }) + &res;\n     \
    \   N /= 2;\n    }\n    res", '    format!("{:b}", N).replace("0", "").len().to_string()',
  '    format!("{:b}", N).chars().map(|d| d.to_digit(10).unwrap()).sum::<u32>().to_string()',
  "    format!(\"{:b}\", N).chars().map(|x| x.to_string()).collect::<Vec<String>>().iter().fold(String::from(\"\
    \"), |acc, x| {\n        acc + x\n    }).to_string()", '    format!("{:b}", N).chars().map(|c|
    c.to_digit(10).unwrap()).sum::<u32>().to_string()', '    format!("{:b}", N).chars().map(|c|
    c.to_digit(10).unwrap()).sum::<u32>().to_string()', "    format!(\"{:b}\", N).chars().fold(0,\
    \ |sum, i| sum + i.to_digit(10).unwrap())\n        .to_string()", '    format!("{:b}",
    N).chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>().to_string()', "    let\
    \ mut n = N;\n    let mut s = String::new();\n    let mut d = 0;\n    while n\
    \ > 0 {\n        d = n % 2;\n        n = n / 2;\n        s.push_str(&d.to_string());\n\
    \    }\n    s.chars().rev().collect()", "    let mut res = String::new();\n  \
    \  let mut n = N;\n    while n > 0 {\n        res.push_str(&format!(\"{}\", n\
    \ % 2));\n        n /= 2;\n    }\n    res.chars().rev().collect()", "    let mut\
    \ num = N;\n    let mut bin = String::new();\n    while num > 0 {\n        bin.push_str(&format!(\"\
    {}\", num % 2));\n        num /= 2;\n    }\n    bin.chars().rev().collect()",
  "    // Your solution here\n    String::from(\"\")", "    let mut res = String::new();\n\
    \    let mut tmp = N;\n    while tmp > 0 {\n        let c = tmp % 2;\n       \
    \ res.push_str(&c.to_string());\n        tmp /= 2;\n    }\n    res.chars().rev().collect()",
  "    // convert N to binary\n    format!(\"{:b}\", N)\n        // convert to string\n\
    \        .to_string()\n        // get bytes\n        .as_bytes()\n        // sum\
    \ bytes\n        .iter()\n        .fold(0, |sum, item| sum + (*item - 48))\n \
    \       // convert to string\n        .to_string()", '    format!("{:b}", N).chars().map(|x|
    x.to_string()).collect::<Vec<String>>().concat()', "    if N == 0 {\n        String::from(\"\
    0\")\n    } else {\n        format!(\"{:b}\", N)\n    }", '    format!("{:b}",
    N).chars().map(|x| x.to_string()).collect::<Vec<String>>().join("")']
stop_tokens:
- "\n}"
