name: HumanEval_100_make_a_pile
language: rs
prompt: "/// Given a positive integer n, you have to make a pile of n levels of stones.\n\
  /// The first level has n stones.\n/// The number of stones in the next level is:\n\
  /// - the next odd number if n is odd.\n/// - the next even number if n is even.\n\
  /// Return the number of stones in each level in a vector, where element at index\n\
  /// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>>\
  \ make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
  \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
  \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
  \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
completions: ["    let mut stones = vec![n];\n    let mut last = n;\n    let mut i\
    \ = 2;\n    loop {\n        let n = if last % 2 == 0 {\n            last / 2\n\
    \        } else {\n            last * 2 - 1\n        };\n        if n <= 0 {\n\
    \            break;\n        }\n        stones.push(n);\n        last = n;\n \
    \       i += 1;\n    }\n    stones", '    unimplemented!("Return a vector of stone
    levels, starting with n stones at level 1");', "    let mut stones = vec![n];\n\
    \    let mut m = n;\n    while m > 1 {\n        m = if m % 2 == 0 { m / 2 } else\
    \ { (m - 1) / 2 };\n        stones.push(m);\n    }\n    stones", "    let mut\
    \ v = vec![n];\n    let mut i = n + 2;\n    let mut j = n + 1;\n    while i <=\
    \ n * 2 {\n        if i <= n * 2 {\n            v.push(i);\n            i += 2;\n\
    \        }\n        if j <= n * 2 {\n            v.push(j);\n            j +=\
    \ 2;\n        }\n    }\n    v", "    let mut res = vec![n];\n    let mut odd =\
    \ n % 2 != 0;\n    while n > 0 {\n        n -= 1;\n        let next = if odd {\
    \ n - 1 } else { n - 2 };\n        if next < 0 {\n            break;\n       \
    \ }\n        res.push(next);\n        odd = !odd;\n    }\n    res", '    (1..=n).map(|level|
    n + 2*(level-1)).collect()', "    (1..n + 1)\n        .map(|i| if i % 2 == 0 {\
    \ n + i } else { n + i - 1 })\n        .collect()", "    if n == 1 {\n       \
    \ return vec![1];\n    }\n    let mut res = vec![n];\n    let mut last = n;\n\
    \    loop {\n        if last % 2 == 0 {\n            last += 1;\n        } else\
    \ {\n            last += 2;\n        }\n        res.push(last);\n        if last\
    \ == 2 * n {\n            break;\n        }\n    }\n    res", '    unimplemented!("Number
    of stones in pile level {}, i.e. {:?}", n, vec![])', "    if n <= 0 {\n      \
    \  return vec![];\n    }\n    let mut pile = vec![n];\n    while pile.last().unwrap()\
    \ > &1 {\n        pile.push(if pile.last().unwrap() % 2 == 0 {\n            pile.last().unwrap()\
    \ + 1\n        } else {\n            pile.last().unwrap() - 1\n        });\n \
    \   }\n    pile", '    vec![n, n + 2, n + 4]', "    let mut i = 1;\n    let mut\
    \ result = vec![n];\n    while i < n {\n        if n % 2 == 0 {\n            result.push(result[i\
    \ as usize - 1] + 2);\n        } else {\n            result.push(result[i as usize\
    \ - 1] + 1);\n        }\n        i += 1;\n    }\n    result", "    let mut pile\
    \ = vec![n];\n    let mut level = n;\n    loop {\n        if level == 1 {\n  \
    \          break;\n        }\n        level = level + 2 - level % 2;\n       \
    \ pile.push(level);\n    }\n    pile", "    if n == 1 {\n        return vec![1];\n\
    \    }\n    let mut result = vec![n];\n    let mut last = n;\n    while last >\
    \ 1 {\n        last = last / 2;\n        if last % 2 == 0 {\n            last\
    \ -= 1;\n        }\n        result.push(last);\n    }\n    result", "    // Your\
    \ code here!\n    unimplemented!()", "    let mut ans = vec![n];\n    let mut\
    \ cur = n;\n    while cur > 1 {\n        cur = if cur % 2 == 0 { cur / 2 } else\
    \ { (cur + 1) / 2 };\n        ans.push(cur);\n    }\n    ans", "    let mut stones\
    \ = vec![n];\n    let mut prev = n;\n    while prev > 1 {\n        let next =\
    \ if prev % 2 == 0 {\n            prev / 2\n        } else {\n            (prev\
    \ + 1) / 2\n        };\n        stones.push(next);\n        prev = next;\n   \
    \ }\n    stones", "    let mut pile = vec![n];\n    loop {\n        let next =\
    \ match pile.last().unwrap() % 2 {\n            0 => pile.last().unwrap() + 1,\n\
    \            _ => pile.last().unwrap() + 2,\n        };\n        if next > n {\n\
    \            break;\n        }\n        pile.push(next);\n    }\n    pile", " \
    \   let mut res = vec![n];\n    let mut count = n;\n    loop {\n        let next\
    \ = next_odd_even(count);\n        if next == 0 {\n            break;\n      \
    \  }\n        res.push(next);\n        count = next;\n    }\n    res", "    let\
    \ mut stones = vec![n];\n    let mut level = n;\n    loop {\n        if level\
    \ == 1 {\n            break;\n        }\n        level = if level % 2 == 0 {\n\
    \            level + 1\n        } else {\n            level + 2\n        };\n\
    \        stones.push(level);\n    }\n    stones"]
stop_tokens:
- "\n}"
