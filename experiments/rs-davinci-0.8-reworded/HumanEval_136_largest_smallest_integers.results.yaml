language: rs
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negative_numbers:\
    \ Vec<isize> = vec![];\n    let mut positive_numbers: Vec<isize> = vec![];\n \
    \   let mut negative_max: Option<isize> = None;\n    let mut positive_min: Option<isize>\
    \ = None;\n\n    for num in lst {\n        if num < 0 {\n            negative_numbers.push(num);\n\
    \        }\n        if num > 0 {\n            positive_numbers.push(num);\n  \
    \      }\n    }\n\n    for num in negative_numbers {\n        if negative_max\
    \ == None {\n            negative_max = Some(num);\n        }\n        if negative_max\
    \ != None && num > negative_max.unwrap() {\n            negative_max = Some(num);\n\
    \        }\n    }\n\n    for num in positive_numbers {\n        if positive_min\
    \ == None {\n            positive_min = Some(num);\n        }\n        if positive_min\
    \ != None && num < positive_min.unwrap() {\n            positive_min = Some(num);\n\
    \        }\n    }\n\n    (negative_max, positive_min)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut largest_neg = None;\n    let\
    \ mut smallest_pos = None;\n    for item in lst {\n        if item < 0 {\n   \
    \         match largest_neg {\n                None => largest_neg = Some(item),\n\
    \                Some(x) => if item > x { largest_neg = Some(item) }\n       \
    \     }\n        } else if item > 0 {\n            match smallest_pos {\n    \
    \            None => smallest_pos = Some(item),\n                Some(x) => if\
    \ item < x { smallest_pos = Some(item) }\n            }\n        }\n    }\n  \
    \  (largest_neg, smallest_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpypw2y13z.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut large = None;\n\
    \    let mut small = None;\n    for i in lst {\n        if i > 0 {\n         \
    \   if small == None {\n                small = Some(i);\n            } else if\
    \ i < small.unwrap() {\n                small = Some(i);\n            }\n    \
    \    } else if i < 0 {\n            if large == None {\n                large\
    \ = Some(i);\n            } else if i > large.unwrap() {\n                large\
    \ = Some(i);\n            }\n        }\n    }\n    (large, small)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxsxz_o6w.rs:13:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut lst_neg = vec![];\n\
    \    let mut lst_pos = vec![];\n    for &i in &lst {\n        if i >= 0 {\n  \
    \          lst_pos.push(i);\n        } else {\n            lst_neg.push(i);\n\
    \        }\n    }\n    if lst_neg.len() > 0 {\n        lst_neg.sort();\n     \
    \   lst_neg.reverse();\n    }\n    if lst_pos.len() > 0 {\n        lst_pos.sort();\n\
    \    }\n    let mut res = (None, None);\n    if lst_neg.len() > 0 {\n        res.0\
    \ = Some(lst_neg[0]);\n    }\n    if lst_pos.len() > 0 {\n        res.1 = Some(lst_pos[0]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmprifd8jb4.rs:42:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for e in lst {\n        if e > 0 {\n            min\
    \ = match min {\n                None => Some(e),\n                Some(m) =>\
    \ Some(cmp::min(m, e)),\n            };\n        } else if e < 0 {\n         \
    \   max = match max {\n                None => Some(e),\n                Some(m)\
    \ => Some(cmp::max(m, e)),\n            };\n        }\n    }\n    (max, min)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpr42ii_jw.rs:19:33\n   |\n19 |                 Some(m) => Some(cmp::min(m,\
    \ e)),\n   |                                 ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpr42ii_jw.rs:24:33\n   |\n24 |                 Some(m) =>\
    \ Some(cmp::max(m, e)),\n   |                                 ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for x in lst {\n        if x > 0 {\n            if\
    \ min.is_none() || x < min.unwrap() {\n                min = Some(x);\n      \
    \      }\n        } else if x < 0 {\n            if max.is_none() || x > max.unwrap()\
    \ {\n                max = Some(x);\n            }\n        }\n    }\n    (max,\
    \ min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut smallest = None;\n    let mut\
    \ largest = None;\n    for num in lst {\n        if num > 0 {\n            match\
    \ smallest {\n                None => smallest = Some(num),\n                Some(x)\
    \ => {\n                    if num < x {\n                        smallest = Some(num);\n\
    \                    }\n                }\n            }\n        } else if num\
    \ < 0 {\n            match largest {\n                None => largest = Some(num),\n\
    \                Some(x) => {\n                    if num > x {\n            \
    \            largest = Some(num);\n                    }\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // Your code here!\n  \
    \  let mut largest = None;\n    let mut smallest = None;\n    for i in lst.iter()\
    \ {\n        if i > &0 {\n            match smallest {\n                None =>\
    \ smallest = Some(*i),\n                Some(x) => if x > *i { smallest = Some(*i)\
    \ },\n            }\n        } else if i < &0 {\n            match largest {\n\
    \                None => largest = Some(*i),\n                Some(x) => if x\
    \ < *i { largest = Some(*i) },\n            }\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for el in lst {\n        if el > 0 {\n            match smallest_positive\
    \ {\n                None => smallest_positive = Some(el),\n                Some(x)\
    \ => {\n                    if el < x {\n                        smallest_positive\
    \ = Some(el);\n                    }\n                }\n            }\n     \
    \   } else if el < 0 {\n            match largest_negative {\n               \
    \ None => largest_negative = Some(el),\n                Some(x) => {\n       \
    \             if el > x {\n                        largest_negative = Some(el);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   (largest_negative, smallest_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpqwtjbi7_.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0fk6ll52.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpp548l3jy.rs:13:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let x = lst.iter().filter(|&x|\
    \ x < &0).max();\n    let y = lst.iter().filter(|&x| x > &0).min();\n    (x.map(|a|\
    \ *a), y.map(|a| *a))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for i in lst {\n      \
    \  match i.signum() {\n            -1 => {\n                match neg {\n    \
    \                Some(x) => {\n                        if i > x {\n          \
    \                  neg = Some(i);\n                        }\n               \
    \     }\n                    None => neg = Some(i),\n                }\n     \
    \       }\n            1 => {\n                match pos {\n                 \
    \   Some(x) => {\n                        if i < x {\n                       \
    \     pos = Some(i);\n                        }\n                    }\n     \
    \               None => pos = Some(i),\n                }\n            }\n   \
    \         _ => continue,\n        }\n    }\n    (neg, pos)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut a: Option<isize>\
    \ = None;\n    let mut b: Option<isize> = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if let Some(a_val) = a {\n                if i > a_val\
    \ {\n                    a = Some(i);\n                }\n            } else {\n\
    \                a = Some(i);\n            }\n        } else if i > 0 {\n    \
    \        if let Some(b_val) = b {\n                if i < b_val {\n          \
    \          b = Some(i);\n                }\n            } else {\n           \
    \     b = Some(i);\n            }\n        }\n    }\n    (a, b)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for i in lst {\n        if i < 0 {\n            if\
    \ max.is_none() || i > max.unwrap() {\n                max = Some(i);\n      \
    \      }\n        } else if i > 0 {\n            if min.is_none() || i < min.unwrap()\
    \ {\n                min = Some(i);\n            }\n        }\n    }\n    (max,\
    \ min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut v = lst.clone();\n\
    \    v.sort();\n    if v.len() == 0 {\n        return (None, None);\n    }\n \
    \   let mut neg = None;\n    let mut pos = None;\n    for i in v {\n        if\
    \ i < 0 {\n            neg = Some(i);\n        } else if i > 0 {\n           \
    \ pos = Some(i);\n            break;\n        }\n    }\n    (neg, pos)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // TODO\n    (None, None)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmp8mxigo8k.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut max_negative: Option<isize> =\
    \ None;\n    let mut min_positive: Option<isize> = None;\n    for n in lst {\n\
    \        if n < 0 {\n            if max_negative.is_none() || n > max_negative.unwrap()\
    \ {\n                max_negative = Some(n);\n            }\n        } else if\
    \ n > 0 {\n            if min_positive.is_none() || n < min_positive.unwrap()\
    \ {\n                min_positive = Some(n);\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_value: Option<isize>\
    \ = None;\n    let mut max_value: Option<isize> = None;\n    for i in lst {\n\
    \        min_value = match min_value {\n            None => Some(i),\n       \
    \     Some(m) => {\n                if i < m && i > 0 {\n                    Some(i)\n\
    \                } else {\n                    Some(m)\n                }\n  \
    \          }\n        };\n        max_value = match max_value {\n            None\
    \ => Some(i),\n            Some(m) => {\n                if i > m && i < 0 {\n\
    \                    Some(i)\n                } else {\n                    Some(m)\n\
    \                }\n            }\n        };\n    }\n    (max_value, min_value)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(2), Some(1))`,\n right: `(None, Some(1))`', /tmp/tmpkda4qacp.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest_pos: Option<isize>\
    \ = None;\n    let mut largest_neg: Option<isize> = None;\n    for x in lst {\n\
    \        if x > 0 {\n            match smallest_pos {\n                None =>\
    \ smallest_pos = Some(x),\n                Some(num) => {\n                  \
    \  if x < num {\n                        smallest_pos = Some(x);\n           \
    \         }\n                }\n            }\n        } else if x < 0 {\n   \
    \         match largest_neg {\n                None => largest_neg = Some(x),\n\
    \                Some(num) => {\n                    if x > num {\n          \
    \              largest_neg = Some(x);\n                    }\n               \
    \ }\n            }\n        }\n    }\n    (largest_neg, smallest_pos)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_neg = None;\n\
    \    let mut smallest_pos = None;\n    for i in lst {\n        match i {\n   \
    \         i if i < 0 => {\n                match largest_neg {\n             \
    \       None => largest_neg = Some(i),\n                    Some(j) if i > j =>\
    \ largest_neg = Some(i),\n                    _ => (),\n                }\n  \
    \          }\n            i if i > 0 => {\n                match smallest_pos\
    \ {\n                    None => smallest_pos = Some(i),\n                   \
    \ Some(j) if i < j => smallest_pos = Some(i),\n                    _ => (),\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  (largest_neg, smallest_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest_positive\
    \ = None;\n    let mut largest_negative = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if largest_negative.is_none() || i > largest_negative.unwrap()\
    \ {\n                largest_negative = Some(i);\n            }\n        } else\
    \ if i > 0 {\n            if smallest_positive.is_none() || i < smallest_positive.unwrap()\
    \ {\n                smallest_positive = Some(i);\n            }\n        }\n\
    \    }\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut large = None;\n\
    \    let mut small = None;\n    for v in lst {\n        if large.is_none() &&\
    \ v < 0 {\n            large = Some(v);\n        } else if small.is_none() &&\
    \ v > 0 {\n            small = Some(v);\n        } else if large.is_some() &&\
    \ v < large.unwrap() {\n            large = Some(v);\n        } else if small.is_some()\
    \ && v > small.unwrap() {\n            small = Some(v);\n        }\n    }\n  \
    \  (large, small)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpw9f0hqgg.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut small = None;\n\
    \    let mut large = None;\n    for i in lst {\n        if i < 0 {\n         \
    \   if small == None {\n                small = Some(i);\n            } else if\
    \ small.unwrap() < i {\n                small = Some(i);\n            }\n    \
    \    } else if i > 0 {\n            if large == None {\n                large\
    \ = Some(i);\n            } else if large.unwrap() > i {\n                large\
    \ = Some(i);\n            }\n        }\n    }\n    (small, large)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for num in lst {\n    \
    \    match num {\n            0 => (),\n            x if x < 0 => {\n        \
    \        match neg {\n                    None => neg = Some(x),\n           \
    \         Some(y) if x > y => neg = Some(x),\n                    _ => (),\n \
    \               }\n            }\n            x if x > 0 => {\n              \
    \  match pos {\n                    None => pos = Some(x),\n                 \
    \   Some(y) if x < y => pos = Some(x),\n                    _ => (),\n       \
    \         }\n            }\n            _ => unreachable!(),\n        }\n    }\n\
    \    (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg = None;\n \
    \   let mut pos = None;\n    for i in lst {\n        if i < 0 {\n            neg\
    \ = if let Some(n) = neg {\n                Some(cmp::max(n, i))\n           \
    \ } else {\n                Some(i)\n            }\n        } else if i > 0 {\n\
    \            pos = if let Some(p) = pos {\n                Some(cmp::min(p, i))\n\
    \            } else {\n                Some(i)\n            }\n        }\n   \
    \ }\n    (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpj3oq7tb3.rs:18:22\n   |\n18 |                 Some(cmp::max(n,\
    \ i))\n   |                      ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpj3oq7tb3.rs:24:22\n   |\n24 |                 Some(cmp::min(p, i))\n\
    \   |                      ^^^ use of undeclared crate or module `cmp`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut lst = lst;\n  \
    \  lst.sort();\n    let l = lst.len();\n    if l == 0 {\n        return (None,\
    \ None);\n    }\n    let mut b = None;\n    let mut a = None;\n    for i in lst\
    \ {\n        if i < 0 {\n            a = Some(i);\n        } else if i > 0 {\n\
    \            b = Some(i);\n            break;\n        }\n    }\n    (a, b)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut res = (None, None);\n\
    \    for x in lst {\n        if x > 0 {\n            if res.1.is_none() || res.1.unwrap()\
    \ > x {\n                res.1 = Some(x);\n            }\n        } else if x\
    \ < 0 {\n            if res.0.is_none() || res.0.unwrap() < x {\n            \
    \    res.0 = Some(x);\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxsxz_o6w.rs:13:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for i in lst {\n        if min.is_none() && i > 0\
    \ {\n            min = Some(i);\n        }\n        if max.is_none() && i < 0\
    \ {\n            max = Some(i);\n        }\n        if let Some(n) = min {\n \
    \           if i > 0 && i < n {\n                min = Some(i);\n            }\n\
    \        }\n        if let Some(n) = max {\n            if i < 0 && i > n {\n\
    \                max = Some(i);\n            }\n        }\n    }\n    (max, min)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i > 0 {\n      \
    \      if smallest == None || i < smallest.unwrap() {\n                smallest\
    \ = Some(i);\n            }\n        } else if i < 0 {\n            if largest\
    \ == None || i > largest.unwrap() {\n                largest = Some(i);\n    \
    \        }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let (mut max, mut min)\
    \ = (None, None);\n    for v in lst {\n        if max.is_none() && v < 0 {\n \
    \           max = Some(v);\n        } else if v < 0 && v > max.unwrap() {\n  \
    \          max = Some(v);\n        }\n\n        if min.is_none() && v > 0 {\n\
    \            min = Some(v);\n        } else if v > 0 && v < min.unwrap() {\n \
    \           min = Some(v);\n        }\n    }\n    (max, min)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut min_num = Some(isize::MAX);\n\
    \    let mut max_num = Some(isize::MIN);\n    for x in lst {\n        if x > 0\
    \ {\n            if x < min_num.unwrap() {\n                min_num = Some(x);\n\
    \            }\n        } else if x < 0 {\n            if x > max_num.unwrap()\
    \ {\n                max_num = Some(x);\n            }\n        }\n    }\n   \
    \ if min_num.unwrap() == isize::MAX {\n        min_num = None;\n    }\n    if\
    \ max_num.unwrap() == isize::MIN {\n        max_num = None;\n    }\n    (max_num,\
    \ min_num)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let v: Vec<isize> = lst.iter().filter(|&x|\
    \ *x < 0).cloned().collect();\n    let w: Vec<isize> = lst.iter().filter(|&x|\
    \ *x > 0).cloned().collect();\n    (v.iter().max().cloned(), w.iter().min().cloned())\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for i in lst {\n        if i > 0 {\n            if\
    \ let Some(x) = min {\n                if i < x {\n                    min = Some(i);\n\
    \                }\n            } else {\n                min = Some(i);\n   \
    \         }\n        } else if i < 0 {\n            if let Some(x) = max {\n \
    \               if i > x {\n                    max = Some(i);\n             \
    \   }\n            } else {\n                max = Some(i);\n            }\n \
    \       }\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for i in lst {\n        if i < 0 {\n            max\
    \ = Some(match max {\n                Some(x) => cmp::max(x, i),\n           \
    \     None => i,\n            });\n        } else if i > 0 {\n            min\
    \ = Some(match min {\n                Some(x) => cmp::min(x, i),\n           \
    \     None => i,\n            });\n        }\n    }\n    (max, min)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpmlqvtegy.rs:18:28\n   |\n18 |                 Some(x) => cmp::max(x,\
    \ i),\n   |                            ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpmlqvtegy.rs:23:28\n   |\n23 |                 Some(x) => cmp::min(x,\
    \ i),\n   |                            ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for i in lst {\n        if i < 0 {\n            max\
    \ = Some(i.max(max.unwrap_or(i)));\n        } else if i > 0 {\n            min\
    \ = Some(i.min(min.unwrap_or(i)));\n        }\n    }\n    (max, min)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negatives = Vec::new();\n\
    \    let mut positives = Vec::new();\n    for num in lst {\n        if num < 0\
    \ {\n            negatives.push(num);\n        } else if num > 0 {\n         \
    \   positives.push(num);\n        }\n    }\n    negatives.sort();\n    positives.sort();\n\
    \    negatives.reverse();\n    return (negatives.pop(), positives.pop());\n}\n\
    \nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp_c1l0kwb.rs:30:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let max_pos = lst.iter().cloned().filter(|&x|\
    \ x > 0).max();\n    let min_neg = lst.iter().cloned().filter(|&x| x < 0).min();\n\
    \    (min_neg, max_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmprqi9mtav.rs:20:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        match i {\n       \
    \     x if x > 0 => {\n                match smallest {\n                    None\
    \ => smallest = Some(x),\n                    Some(y) => if x < y { smallest =\
    \ Some(x) }\n                }\n            },\n            x if x < 0 => {\n\
    \                match largest {\n                    None => largest = Some(x),\n\
    \                    Some(y) => if x > y { largest = Some(x) }\n             \
    \   }\n            },\n            _ => {}\n        }\n    }\n    (largest, smallest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut lst_pos = Vec::new();\n\
    \    let mut lst_neg = Vec::new();\n    for i in lst {\n        if i > 0 {\n \
    \           lst_pos.push(i);\n        } else if i < 0 {\n            lst_neg.push(i);\n\
    \        }\n    }\n    lst_pos.sort();\n    lst_neg.sort();\n    if lst_pos.len()\
    \ == 0 && lst_neg.len() == 0 {\n        (None, None)\n    } else if lst_pos.len()\
    \ == 0 {\n        (Some(lst_neg[0]), None)\n    } else if lst_neg.len() == 0 {\n\
    \        (None, Some(lst_pos[0]))\n    } else {\n        (Some(lst_neg[0]), Some(lst_pos[0]))\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(-6), None)`,\n right: `(Some(-1), None)`', /tmp/tmpeywb_onh.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut pos = None;\n \
    \   let mut neg = None;\n    for num in lst {\n        if num > 0 {\n        \
    \    if pos.is_none() || num < pos.unwrap() {\n                pos = Some(num);\n\
    \            }\n        } else if num < 0 {\n            if neg.is_none() || num\
    \ > neg.unwrap() {\n                neg = Some(num);\n            }\n        }\n\
    \    }\n    (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // Write your code here\n\
    \    if lst.len() == 0 {\n        return (None, None);\n    }\n    let mut a =\
    \ None;\n    let mut b = None;\n    for i in lst {\n        if i < 0 {\n     \
    \       if let Some(x) = a {\n                if i > x {\n                   \
    \ a = Some(i);\n                }\n            } else {\n                a = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if let Some(x) = b {\n\
    \                if i < x {\n                    b = Some(i);\n              \
    \  }\n            } else {\n                b = Some(i);\n            }\n    \
    \    }\n    }\n    (a, b)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for el in lst {\n        match (max, min) {\n   \
    \         (None, None) => {\n                if el > 0 {\n                   \
    \ min = Some(el);\n                } else if el < 0 {\n                    max\
    \ = Some(el);\n                }\n            }\n            (None, Some(min))\
    \ => {\n                if el > 0 && el < min {\n                    min = el;\n\
    \                } else if el < 0 {\n                    max = Some(el);\n   \
    \             }\n            }\n            (Some(max), None) => {\n         \
    \       if el > 0 {\n                    min = Some(el);\n                } else\
    \ if el < 0 && el > max {\n                    max = el;\n                }\n\
    \            }\n            (Some(max), Some(min)) => {\n                if el\
    \ > 0 && el < min {\n                    min = el;\n                } else if\
    \ el < 0 && el > max {\n                    max = el;\n                }\n   \
    \         }\n        }\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `min` is never read\n  --> /tmp/tmpkldxmj3k.rs:26:21\n\
    \   |\n26 |                     min = el;\n   |                     ^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max` is never\
    \ read\n  --> /tmp/tmpkldxmj3k.rs:35:21\n   |\n35 |                     max =\
    \ el;\n   |                     ^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `min` is never read\n  -->\
    \ /tmp/tmpkldxmj3k.rs:40:21\n   |\n40 |                     min = el;\n   |  \
    \                   ^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nwarning: value assigned to `max` is never read\n  --> /tmp/tmpkldxmj3k.rs:42:21\n\
    \   |\n42 |                     max = el;\n   |                     ^^^\n   |\n\
    \   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot\
    \ assign twice to immutable variable `min`\n  --> /tmp/tmpkldxmj3k.rs:26:21\n\
    \   |\n24 |             (None, Some(min)) => {\n   |                         ---\n\
    \   |                         |\n   |                         first assignment\
    \ to `min`\n   |                         help: consider making this binding mutable:\
    \ `mut min`\n25 |                 if el > 0 && el < min {\n26 |              \
    \       min = el;\n   |                     ^^^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n\
    \  --> /tmp/tmpkldxmj3k.rs:35:21\n   |\n31 |             (Some(max), None) =>\
    \ {\n   |                   ---\n   |                   |\n   |              \
    \     first assignment to `max`\n   |                   help: consider making\
    \ this binding mutable: `mut max`\n...\n35 |                     max = el;\n \
    \  |                     ^^^^^^^^ cannot assign twice to immutable variable\n\n\
    error[E0384]: cannot assign twice to immutable variable `min`\n  --> /tmp/tmpkldxmj3k.rs:40:21\n\
    \   |\n38 |             (Some(max), Some(min)) => {\n   |                    \
    \          ---\n   |                              |\n   |        "
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = None;\n\
    \    let mut largest = None;\n    for x in lst {\n        if x > 0 {\n       \
    \     if smallest == None || smallest.unwrap() > x {\n                smallest\
    \ = Some(x);\n            }\n        } else if x < 0 {\n            if largest\
    \ == None || largest.unwrap() < x {\n                largest = Some(x);\n    \
    \        }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for num in lst {\n        if num > 0 {\n            if smallest_positive.is_none()\
    \ || num < smallest_positive.unwrap() {\n                smallest_positive = Some(num);\n\
    \            }\n        } else if num < 0 {\n            if largest_negative.is_none()\
    \ || num > largest_negative.unwrap() {\n                largest_negative = Some(num);\n\
    \            }\n        }\n    }\n    (largest_negative, smallest_positive)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for &item in &lst {\n        if item < 0 {\n    \
    \        max = match max {\n                None => Some(item),\n            \
    \    Some(x) => Some(max(x, item)),\n            };\n        } else if item >\
    \ 0 {\n            min = match min {\n                None => Some(item),\n  \
    \              Some(x) => Some(min(x, item)),\n            };\n        }\n   \
    \ }\n    (max, min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found enum variant `max`\n  --> /tmp/tmpto_356wb.rs:19:33\n\
    \   |\n14 |     let mut max = None;\n   |         ------- `max` defined here\n\
    ...\n19 |                 Some(x) => Some(max(x, item)),\n   |               \
    \                  ^^^---------\n   |                                 |\n   |\
    \                                 call expression requires function\n   |\nhelp:\
    \ `max` is a unit variant, you need to write it without the parentheses\n   |\n\
    19 -                 Some(x) => Some(max(x, item)),\n19 +                 Some(x)\
    \ => Some(max),\n   | \n\nerror[E0618]: expected function, found enum variant\
    \ `min`\n  --> /tmp/tmpto_356wb.rs:24:33\n   |\n13 |     let mut min = None;\n\
    \   |         ------- `min` defined here\n...\n24 |                 Some(x) =>\
    \ Some(min(x, item)),\n   |                                 ^^^---------\n   |\
    \                                 |\n   |                                 call\
    \ expression requires function\n   |\nhelp: `min` is a unit variant, you need\
    \ to write it without the parentheses\n   |\n24 -                 Some(x) => Some(min(x,\
    \ item)),\n24 +                 Some(x) => Some(min),\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0618`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_smallest_tuple\
    \ = (None, None);\n    for i in lst {\n        if largest_smallest_tuple.0 ==\
    \ None {\n            if i < 0 {\n                largest_smallest_tuple.0 = Some(i);\n\
    \            }\n        } else if largest_smallest_tuple.0.unwrap() < i {\n  \
    \          largest_smallest_tuple.0 = Some(i);\n        }\n        if largest_smallest_tuple.1\
    \ == None {\n            if i > 0 {\n                largest_smallest_tuple.1\
    \ = Some(i);\n            }\n        } else if largest_smallest_tuple.1.unwrap()\
    \ > i {\n            largest_smallest_tuple.1 = Some(i);\n        }\n    }\n \
    \   largest_smallest_tuple\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpawmm5k2b.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for i in lst {\n        match i.cmp(&0) {\n            Ordering::Less =>\
    \ {\n                if largest_negative.is_none() || i > largest_negative.unwrap()\
    \ {\n                    largest_negative = Some(i);\n                }\n    \
    \        }\n            Ordering::Greater => {\n                if smallest_positive.is_none()\
    \ || i < smallest_positive.unwrap() {\n                    smallest_positive =\
    \ Some(i);\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    (largest_negative, smallest_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmprm8lg5nt.rs:17:13\n   |\n17 |             Ordering::Less => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmprm8lg5nt.rs:22:13\n\
    \   |\n22 |             Ordering::Greater => {\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut least_positive:\
    \ Option<isize> = None;\n    let mut greatest_negative: Option<isize> = None;\n\
    \    for &num in lst.iter() {\n        if num > 0 {\n            if least_positive.is_none()\
    \ || num < least_positive.unwrap() {\n                least_positive = Some(num);\n\
    \            }\n        } else if num < 0 {\n            if greatest_negative.is_none()\
    \ || num > greatest_negative.unwrap() {\n                greatest_negative = Some(num);\n\
    \            }\n        }\n    }\n    (greatest_negative, least_positive)\n}\n\
    \nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negative_max: Option<isize>\
    \ = None;\n    let mut positive_min: Option<isize> = None;\n    for x in lst {\n\
    \        if x < 0 {\n            match negative_max {\n                None =>\
    \ negative_max = Some(x),\n                Some(y) => {\n                    if\
    \ x > y {\n                        negative_max = Some(x);\n                 \
    \   }\n                }\n            }\n        } else if x > 0 {\n         \
    \   match positive_min {\n                None => positive_min = Some(x),\n  \
    \              Some(y) => {\n                    if x < y {\n                \
    \        positive_min = Some(x);\n                    }\n                }\n \
    \           }\n        }\n    }\n    (negative_max, positive_min)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negatives = None;\n\
    \    let mut positives = None;\n    for i in lst {\n        if i < 0 {\n     \
    \       negatives = match negatives {\n                None => Some(i),\n    \
    \            Some(x) => Some(std::cmp::max(x, i)),\n            };\n        }\
    \ else if i > 0 {\n            positives = match positives {\n               \
    \ None => Some(i),\n                Some(x) => Some(std::cmp::min(x, i)),\n  \
    \          };\n        }\n    }\n    (negatives, positives)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // let mut it = lst.iter();\n\
    \    let mut largest = None;\n    let mut smallest = None;\n    for item in lst\
    \ {\n        if item < 0 {\n            largest = match largest {\n          \
    \      None => Some(item),\n                Some(a) => Some(item.max(a)),\n  \
    \          };\n        } else if item > 0 {\n            smallest = match smallest\
    \ {\n                None => Some(item),\n                Some(a) => Some(item.min(a)),\n\
    \            };\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let sorted_lst = lst.clone();\n\
    \    sorted_lst.sort();\n    let largest = sorted_lst.iter().fold(None, |acc,\
    \ &x| {\n        match acc {\n            None => Some(x),\n            Some(n)\
    \ => if x < 0 && x > n { Some(x) } else { Some(n) },\n        }\n    });\n   \
    \ let smallest = sorted_lst.iter().fold(None, |acc, &x| {\n        match acc {\n\
    \            None => Some(x),\n            Some(n) => if x > 0 && x < n { Some(x)\
    \ } else { Some(n) },\n        }\n    });\n    (largest, smallest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `sorted_lst` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpidte9uc_.rs:14:5\n   |\n13 |     let sorted_lst =\
    \ lst.clone();\n   |         ---------- help: consider changing this to be mutable:\
    \ `mut sorted_lst`\n14 |     sorted_lst.sort();\n   |     ^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    lst.iter().fold((None,\
    \ None), |acc, &num| match (acc.0, acc.1) {\n        (None, None) => (None, None),\n\
    \        (Some(x), None) => if num < 0 {\n            (Some(cmp::max(x, num)),\
    \ None)\n        } else {\n            (Some(x), Some(num))\n        },\n    \
    \    (None, Some(y)) => if num < 0 {\n            (Some(num), Some(y))\n     \
    \   } else {\n            (None, Some(cmp::min(y, num)))\n        },\n       \
    \ (Some(x), Some(y)) => if num < 0 {\n            (Some(cmp::max(x, num)), Some(y))\n\
    \        } else {\n            (Some(x), Some(cmp::min(y, num)))\n        },\n\
    \    })\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n  \
    \  assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp96r294w2.rs:16:19\n   |\n16 |             (Some(cmp::max(x, num)),\
    \ None)\n   |                   ^^^ use of undeclared crate or module `cmp`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n  -->\
    \ /tmp/tmp96r294w2.rs:23:25\n   |\n23 |             (None, Some(cmp::min(y, num)))\n\
    \   |                         ^^^ use of undeclared crate or module `cmp`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n  -->\
    \ /tmp/tmp96r294w2.rs:26:19\n   |\n26 |             (Some(cmp::max(x, num)), Some(y))\n\
    \   |                   ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmp96r294w2.rs:28:28\n\
    \   |\n28 |             (Some(x), Some(cmp::min(y, num)))\n   |              \
    \              ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for i in lst {\n        match i {\n            i\
    \ if i > 0 => {\n                if min.is_none() || i < min.unwrap() {\n    \
    \                min = Some(i);\n                }\n            }\n          \
    \  i if i < 0 => {\n                if max.is_none() || i > max.unwrap() {\n \
    \                   max = Some(i);\n                }\n            }\n       \
    \     _ => (),\n        }\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut l = None;\n   \
    \ let mut s = None;\n    for num in lst {\n        if num < 0 {\n            if\
    \ l.is_none() || l.unwrap() < num {\n                l = Some(num);\n        \
    \    }\n        } else if num > 0 {\n            if s.is_none() || s.unwrap()\
    \ > num {\n                s = Some(num);\n            }\n        }\n    }\n \
    \   (l, s)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut a = None;\n   \
    \ let mut b = None;\n    for n in lst {\n        if n < 0 {\n            if a.is_none()\
    \ || n > a.unwrap() {\n                a = Some(n);\n            }\n        }\
    \ else if n > 0 {\n            if b.is_none() || n < b.unwrap() {\n          \
    \      b = Some(n);\n            }\n        }\n    }\n    (a, b)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n\
    \    let mut min_pos = None;\n    for x in lst {\n        if x < 0 {\n       \
    \     if max_neg.is_none() || max_neg.unwrap() < x {\n                max_neg\
    \ = Some(x);\n            }\n        } else if x > 0 {\n            if min_pos.is_none()\
    \ || min_pos.unwrap() > x {\n                min_pos = Some(x);\n            }\n\
    \        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative\
    \ = None;\n    let mut smallest_positive = None;\n    for item in lst {\n    \
    \    if item < 0 {\n            if let Some(temp) = largest_negative {\n     \
    \           if item > temp {\n                    largest_negative = Some(item);\n\
    \                }\n            } else {\n                largest_negative = Some(item);\n\
    \            }\n        } else if item > 0 {\n            if let Some(temp) =\
    \ smallest_positive {\n                if item < temp {\n                    smallest_positive\
    \ = Some(item);\n                }\n            } else {\n                smallest_positive\
    \ = Some(item);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // TODO\n    (None, None)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmp8mxigo8k.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_pos = None;\n\
    \    let mut max_neg = None;\n    for num in lst {\n        if num > 0 {\n   \
    \         min_pos = match min_pos {\n                None => Some(num),\n    \
    \            Some(x) => Some(cmp::min(x, num)),\n            };\n        } else\
    \ if num < 0 {\n            max_neg = match max_neg {\n                None =>\
    \ Some(num),\n                Some(x) => Some(cmp::max(x, num)),\n           \
    \ };\n        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpi59k2mvl.rs:19:33\n   |\n19 |                 Some(x) => Some(cmp::min(x,\
    \ num)),\n   |                                 ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `cmp`\n  --> /tmp/tmpi59k2mvl.rs:24:33\n   |\n24 |                 Some(x)\
    \ => Some(cmp::max(x, num)),\n   |                                 ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut a = None;\n   \
    \ let mut b = None;\n    for x in lst {\n        if x < 0 {\n            a = match\
    \ a {\n                None => Some(x),\n                Some(y) => Some(max(x,\
    \ y)),\n            }\n        } else if x > 0 {\n            b = match b {\n\
    \                None => Some(x),\n                Some(y) => Some(min(x, y)),\n\
    \            }\n        }\n    }\n    (a, b)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp08axsdfs.rs:19:33\n\
    \   |\n19 |                 Some(y) => Some(max(x, y)),\n   |                \
    \                 ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ function `min` in this scope\n  --> /tmp/tmp08axsdfs.rs:24:33\n   |\n24 |  \
    \               Some(y) => Some(min(x, y)),\n   |                            \
    \     ^^^\n...\n31 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n24 |\
    \                 Some(y) => Some(main(x, y)),\n   |                         \
    \        ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg: Option<isize>\
    \ = None;\n    let mut min_pos: Option<isize> = None;\n    for x in lst {\n  \
    \      match x < 0 {\n            true => {\n                if let Some(y) =\
    \ max_neg {\n                    if x > y {\n                        max_neg =\
    \ Some(x);\n                    }\n                } else {\n                \
    \    max_neg = Some(x);\n                }\n            }\n            false =>\
    \ {\n                if let Some(y) = min_pos {\n                    if x < y\
    \ {\n                        min_pos = Some(x);\n                    }\n     \
    \           } else {\n                    min_pos = Some(x);\n               \
    \ }\n            }\n        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp_rmf_ce7.rs:43:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg_max = None;\n\
    \    let mut pos_min = None;\n    for x in lst {\n        if x >= 0 {\n      \
    \      if pos_min.is_none() || x < pos_min.unwrap() {\n                pos_min\
    \ = Some(x);\n            }\n        } else {\n            if neg_max.is_none()\
    \ || x > neg_max.unwrap() {\n                neg_max = Some(x);\n            }\n\
    \        }\n    }\n    (neg_max, pos_min)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmprepwf3fv.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // put your code here\n\
    \    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmp634e44mh.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // TODO\n    let mut min\
    \ = None;\n    let mut max = None;\n    for i in lst {\n        min = min.map_or(Some(i),\
    \ |x| Some(x.min(i)));\n        max = max.map_or(Some(i), |x| Some(x.max(i)));\n\
    \    }\n    (max, min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmphqfn12j8.rs:17:36\n\
    \   |\n17 |         min = min.map_or(Some(i), |x| Some(x.min(i)));\n   |     \
    \                               ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // Your code here.\n  \
    \  let mut least = None;\n    let mut most = None;\n    for i in lst {\n     \
    \   match i.cmp(&0) {\n            Ordering::Less => {\n                if let\
    \ Some(i) = least {\n                    if i < i {\n                        least\
    \ = Some(i);\n                    }\n                } else {\n              \
    \      least = Some(i);\n                }\n            }\n            Ordering::Greater\
    \ => {\n                if let Some(i) = most {\n                    if i > i\
    \ {\n                        most = Some(i);\n                    }\n        \
    \        } else {\n                    most = Some(i);\n                }\n  \
    \          }\n            _ => {}\n        }\n    }\n    (least, most)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmplbsaewgk.rs:18:13\n   |\n18 |             Ordering::Less => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmplbsaewgk.rs:27:13\n\
    \   |\n27 |             Ordering::Greater => {\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for x in lst {\n        if x < 0 {\n            if\
    \ max.is_none() || max.unwrap() < x {\n                max = Some(x);\n      \
    \      }\n        } else if x > 0 {\n            if min.is_none() || min.unwrap()\
    \ > x {\n                min = Some(x);\n            }\n        }\n    }\n   \
    \ (max, min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut largest_neg = None;\n    let\
    \ mut smallest_pos = None;\n    for item in lst {\n        if item < 0 {\n   \
    \         if largest_neg.is_none() || item > largest_neg.unwrap() {\n        \
    \        largest_neg = Some(item);\n            }\n        } else if item > 0\
    \ {\n            if smallest_pos.is_none() || item < smallest_pos.unwrap() {\n\
    \                smallest_pos = Some(item);\n            }\n        }\n    }\n\
    \    (largest_neg, smallest_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut small_pos: Option<isize>\
    \ = None;\n    let mut large_neg: Option<isize> = None;\n    for n in lst {\n\
    \        if n > 0 {\n            match small_pos {\n                None => small_pos\
    \ = Some(n),\n                Some(m) => if n < m {\n                    small_pos\
    \ = Some(n);\n                }\n            }\n        } else if n < 0 {\n  \
    \          match large_neg {\n                None => large_neg = Some(n),\n \
    \               Some(m) => if n > m {\n                    large_neg = Some(n);\n\
    \                }\n            }\n        }\n    }\n    (large_neg, small_pos)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut large = None;\n\
    \    let mut small = None;\n    for i in lst {\n        if i >= 0 {\n        \
    \    if small == None {\n                small = Some(i);\n            } else\
    \ if i < small.unwrap() {\n                small = Some(i);\n            }\n \
    \       } else {\n            if large == None {\n                large = Some(i);\n\
    \            } else if i > large.unwrap() {\n                large = Some(i);\n\
    \            }\n        }\n    }\n    (large, small)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmp9mkbtt9_.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i > 0 {\n      \
    \      if smallest == None || i < smallest.unwrap() {\n                smallest\
    \ = Some(i);\n            }\n        } else if i < 0 {\n            if largest\
    \ == None || i > largest.unwrap() {\n                largest = Some(i);\n    \
    \        }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010650
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let (pos, neg) = lst.iter().fold((None,\
    \ None), |acc, x| {\n        let (x, y) = acc;\n        if *x == None && *x >\
    \ Some(*x) {\n            (*x, y)\n        } else if *y == None && *y < Some(*y)\
    \ {\n            (x, *y)\n        } else {\n            (*x, *y)\n        }\n\
    \    });\n    (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:15:12\n\
    \   |\n15 |         if *x == None && *x > Some(*x) {\n   |            ^^\n\nerror[E0614]:\
    \ type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:15:26\n \
    \  |\n15 |         if *x == None && *x > Some(*x) {\n   |                    \
    \      ^^\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:15:36\n\
    \   |\n15 |         if *x == None && *x > Some(*x) {\n   |                   \
    \                 ^^\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n\
    \  --> /tmp/tmpqdl298xb.rs:16:14\n   |\n16 |             (*x, y)\n   |       \
    \       ^^\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:17:19\n\
    \   |\n17 |         } else if *y == None && *y < Some(*y) {\n   |            \
    \       ^^\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:17:33\n\
    \   |\n17 |         } else if *y == None && *y < Some(*y) {\n   |            \
    \                     ^^\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n\
    \  --> /tmp/tmpqdl298xb.rs:17:43\n   |\n17 |         } else if *y == None && *y\
    \ < Some(*y) {\n   |                                           ^^\n\nerror[E0614]:\
    \ type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:18:17\n \
    \  |\n18 |             (x, *y)\n   |                 ^^\n\nerror[E0614]: type\
    \ `Option<_>` cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:20:14\n   |\n\
    20 |             (*x, *y)\n   |              ^^\n\nerror[E0614]: type `Option<_>`\
    \ cannot be dereferenced\n  --> /tmp/tmpqdl298xb.rs:20:18\n   |\n20 |        \
    \     (*x, *y)\n   |                  ^^\n\nerror: aborting due to 10 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut small: Option<isize>\
    \ = None;\n    let mut large: Option<isize> = None;\n    for i in lst {\n    \
    \    if i > 0 {\n            if let Some(s) = small {\n                if i <\
    \ s {\n                    small = Some(i);\n                }\n            }\
    \ else {\n                small = Some(i);\n            }\n        } else if i\
    \ < 0 {\n            if let Some(l) = large {\n                if i > l {\n  \
    \                  large = Some(i);\n                }\n            } else {\n\
    \                large = Some(i);\n            }\n        }\n    }\n    (large,\
    \ small)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n \
    \   assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for x in lst {\n        if x > 0 {\n            if\
    \ max.is_none() || x > max.unwrap() {\n                max = Some(x);\n      \
    \      }\n        } else if x < 0 {\n            if min.is_none() || x < min.unwrap()\
    \ {\n                min = Some(x);\n            }\n        }\n    }\n    (min,\
    \ max)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpm0vquwfk.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // This function returns\
    \ a tuple containing the largest of negative integers,\n    // and the smallest\
    \ of positive integers in the given array.\n    let v: Vec<_> = lst.iter().filter(|x|\
    \ x < &&0).collect();\n    let u: Vec<_> = lst.iter().filter(|x| x > &&0).collect();\n\
    \    if !v.is_empty() {\n        (Some(*v.iter().max().unwrap()), Some(*u.iter().min().unwrap()))\n\
    \    } else {\n        (None, None)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxqlz1uix.rs:18:15\n   |\n\
    18 |         (Some(*v.iter().max().unwrap()), Some(*u.iter().min().unwrap()))\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n18 |         (Some(**v.iter().max().unwrap()),\
    \ Some(*u.iter().min().unwrap()))\n   |               +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxqlz1uix.rs:18:47\n   |\n18 |         (Some(*v.iter().max().unwrap()),\
    \ Some(*u.iter().min().unwrap()))\n   |                                      \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n18 |         (Some(*v.iter().max().unwrap()),\
    \ Some(**u.iter().min().unwrap()))\n   |                                     \
    \          +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut pos_min = None;\n\
    \    let mut neg_max = None;\n    for elem in lst {\n        if elem > 0 {\n \
    \           pos_min = Some(match pos_min {\n                None => elem,\n  \
    \              Some(min) => if elem < min { elem } else { min },\n           \
    \ });\n        } else if elem < 0 {\n            neg_max = Some(match neg_max\
    \ {\n                None => elem,\n                Some(max) => if elem > max\
    \ { elem } else { max },\n            });\n        }\n    }\n    (neg_max, pos_min)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i < 0 {\n      \
    \      largest = Some(cmp::max(largest.unwrap_or(i), i));\n        } else if i\
    \ > 0 {\n            smallest = Some(cmp::min(smallest.unwrap_or(i), i));\n  \
    \      }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpa9iplu5z.rs:17:28\n   |\n17 |             largest = Some(cmp::max(largest.unwrap_or(i),\
    \ i));\n   |                            ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpa9iplu5z.rs:19:29\n   |\n19 |             smallest = Some(cmp::min(smallest.unwrap_or(i),\
    \ i));\n   |                             ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_neg = None;\n\
    \    let mut smallest_pos = None;\n    for i in lst {\n        if i < 0 {\n  \
    \          largest_neg = match largest_neg {\n                None => Some(i),\n\
    \                Some(a) => Some(std::cmp::max(a, i)),\n            };\n     \
    \   } else if i > 0 {\n            smallest_pos = match smallest_pos {\n     \
    \           None => Some(i),\n                Some(a) => Some(std::cmp::min(a,\
    \ i)),\n            };\n        }\n    }\n    (largest_neg, smallest_pos)\n}\n\
    \nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min: Option<isize>\
    \ = None;\n    let mut max: Option<isize> = None;\n    for i in lst {\n      \
    \  if i > 0 {\n            if min.is_none() || i < min.unwrap() {\n          \
    \      min = Some(i);\n            }\n        } else if i < 0 {\n            if\
    \ max.is_none() || i > max.unwrap() {\n                max = Some(i);\n      \
    \      }\n        }\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut min_pos = None;\n    let mut\
    \ max_neg = None;\n    for i in lst {\n        if i < 0 {\n            if let\
    \ Some(x) = max_neg {\n                if i > x {\n                    max_neg\
    \ = Some(i);\n                }\n            } else {\n                max_neg\
    \ = Some(i);\n            }\n        } else if i > 0 {\n            if let Some(x)\
    \ = min_pos {\n                if i < x {\n                    min_pos = Some(i);\n\
    \                }\n            } else {\n                min_pos = Some(i);\n\
    \            }\n        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n \
    \   let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  //return a tuple\n  //(largest\
    \ negative, smallest positive)\n  let mut largest_negative: Option<isize> = None;\n\
    \  let mut smallest_positive: Option<isize> = None;\n  for i in lst {\n    if\
    \ i >= 0 {\n      if smallest_positive == None {\n        smallest_positive =\
    \ Some(i);\n      } else if i < smallest_positive.unwrap() {\n        smallest_positive\
    \ = Some(i);\n      }\n    } else {\n      if largest_negative == None {\n   \
    \     largest_negative = Some(i);\n      } else if i > largest_negative.unwrap()\
    \ {\n        largest_negative = Some(i);\n      }\n    }\n  }\n  (largest_negative,\
    \ smallest_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmphjh220yd.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // initialize the result\n\
    \    let mut result = (None, None);\n    for i in lst {\n        if i > 0 {\n\
    \            if let Some(j) = result.1 {\n                if i < j {\n       \
    \             result.1 = Some(i);\n                }\n            } else {\n \
    \               result.1 = Some(i);\n            }\n        } else if i < 0 {\n\
    \            if let Some(j) = result.0 {\n                if i > j {\n       \
    \             result.0 = Some(i);\n                }\n            } else {\n \
    \               result.0 = Some(i);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut pos = None;\n \
    \   let mut neg = None;\n    for &i in &lst {\n        if i < 0 {\n          \
    \  if let Some(n) = neg {\n                if i > n {\n                    neg\
    \ = Some(i);\n                }\n            } else {\n                neg = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if let Some(p) = pos {\n\
    \                if i < p {\n                    pos = Some(i);\n            \
    \    }\n            } else {\n                pos = Some(i);\n            }\n\
    \        }\n    }\n    (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n\
    \    let mut min_pos = None;\n    for x in lst {\n        if x < 0 {\n       \
    \     if let Some(max) = max_neg {\n                if x > max {\n           \
    \         max_neg = Some(x);\n                }\n            } else {\n      \
    \          max_neg = Some(x);\n            }\n        } else if x > 0 {\n    \
    \        if let Some(min) = min_pos {\n                if x < min {\n        \
    \            min_pos = Some(x);\n                }\n            } else {\n   \
    \             min_pos = Some(x);\n            }\n        }\n    }\n    (max_neg,\
    \ min_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = None;\n\
    \    let mut largest = None;\n    for n in lst {\n        if n > 0 {\n       \
    \     smallest = match smallest {\n                None => Some(n),\n        \
    \        Some(n2) => Some(std::cmp::min(n, n2)),\n            };\n        } else\
    \ if n < 0 {\n            largest = match largest {\n                None => Some(n),\n\
    \                Some(n2) => Some(std::cmp::max(n, n2)),\n            };\n   \
    \     }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate =\
    \ largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // Your code here\n   \
    \ let mut smallest = None;\n    let mut largest = None;\n    for i in lst {\n\
    \        if i < 0 {\n            match largest {\n                None => largest\
    \ = Some(i),\n                Some(x) => {\n                    if i > x {\n \
    \                       largest = Some(i);\n                    }\n          \
    \      }\n            }\n        } else if i > 0 {\n            match smallest\
    \ {\n                None => smallest = Some(i),\n                Some(x) => {\n\
    \                    if i < x {\n                        smallest = Some(i);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min: Option<isize>\
    \ = None;\n    let mut max: Option<isize> = None;\n    for i in lst {\n      \
    \  if i < 0 {\n            match max {\n                Some(n) => {\n       \
    \             if i > n {\n                        max = Some(i);\n           \
    \         }\n                }\n                None => max = Some(i),\n     \
    \       }\n        } else if i > 0 {\n            match min {\n              \
    \  Some(n) => {\n                    if i < n {\n                        min =\
    \ Some(i);\n                    }\n                }\n                None =>\
    \ min = Some(i),\n            }\n        }\n    }\n    (max, min)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negatives = vec![];\n\
    \    let mut positives = vec![];\n    for i in lst {\n        if i < 0 {\n   \
    \         negatives.push(i);\n        } else if i > 0 {\n            positives.push(i);\n\
    \        }\n    }\n    negatives.sort();\n    positives.sort();\n    (negatives.last().map(|x|\
    \ *x), positives.first().map(|x| *x))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  (largest_integer(lst.clone()),\
    \ smallest_integer(lst))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `largest_integer` in this scope\n  -->\
    \ /tmp/tmpqzjs4vr_.rs:13:4\n   |\n13 |   (largest_integer(lst.clone()), smallest_integer(lst))\n\
    \   |    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `smallest_integer` in this scope\n  --> /tmp/tmpqzjs4vr_.rs:13:34\n\
    \   |\n13 |   (largest_integer(lst.clone()), smallest_integer(lst))\n   |    \
    \                              ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010650
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n\
    \    let mut min_pos = None;\n    for n in lst {\n        if n < 0 {\n       \
    \     if max_neg.is_none() || n > max_neg.unwrap() {\n                max_neg\
    \ = Some(n);\n            }\n        } else if n > 0 {\n            if min_pos.is_none()\
    \ || n < min_pos.unwrap() {\n                min_pos = Some(n);\n            }\n\
    \        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest_positive\
    \ = None;\n    let mut largest_negative = None;\n    for x in lst {\n        if\
    \ x > 0 {\n            smallest_positive = Some(match smallest_positive {\n  \
    \              None => x,\n                Some(y) => cmp::min(x, y),\n      \
    \      });\n        } else if x < 0 {\n            largest_negative = Some(match\
    \ largest_negative {\n                None => x,\n                Some(y) => cmp::max(x,\
    \ y),\n            });\n        }\n    }\n    (largest_negative, smallest_positive)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpr9fnp6dx.rs:19:28\n   |\n19 |                 Some(y) => cmp::min(x,\
    \ y),\n   |                            ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpr9fnp6dx.rs:24:28\n   |\n24 |                 Some(y) => cmp::max(x,\
    \ y),\n   |                            ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_pos: Option<isize>\
    \ = None;\n    let mut max_neg: Option<isize> = None;\n    for i in lst {\n  \
    \      match i > 0 {\n            true => {\n                if let Some(x) =\
    \ min_pos {\n                    if i < x {\n                        min_pos =\
    \ Some(i);\n                    }\n                } else {\n                \
    \    min_pos = Some(i);\n                }\n            }\n            false =>\
    \ {\n                if let Some(x) = max_neg {\n                    if i > x\
    \ {\n                        max_neg = Some(i);\n                    }\n     \
    \           } else {\n                    max_neg = Some(i);\n               \
    \ }\n            }\n        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(1))`,\n right: `(None, Some(1))`', /tmp/tmpoc6n78zq.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg_cnt = 0;\n\
    \    let mut pos_cnt = 0;\n    let mut largest_neg = std::isize::MIN;\n    let\
    \ mut smallest_pos = std::isize::MAX;\n    for item in lst {\n        if item\
    \ < 0 {\n            neg_cnt += 1;\n            if item > largest_neg {\n    \
    \            largest_neg = item;\n            }\n        } else if item > 0 {\n\
    \            pos_cnt += 1;\n            if item < smallest_pos {\n           \
    \     smallest_pos = item;\n            }\n        }\n    }\n    let largest_neg\
    \ = if neg_cnt == 0 {\n        None\n    } else {\n        Some(largest_neg)\n\
    \    };\n    let smallest_pos = if pos_cnt == 0 {\n        None\n    } else {\n\
    \        Some(smallest_pos)\n    };\n    (largest_neg, smallest_pos)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    lst.iter().fold((None,\
    \ None), |(a, b), x| match x {\n        x if x < &0 => (Some(x.max(a.unwrap_or(0))),\
    \ b),\n        x if x > &0 => (a, Some(x.min(b.unwrap_or(0)))),\n        _ =>\
    \ (a, b),\n    })\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5tsdx9a7.rs:14:36\n   |\n\
    14 |         x if x < &0 => (Some(x.max(a.unwrap_or(0))), b),\n   |          \
    \                          ^^^^^^^^^^^^^^\n   |                              \
    \      |\n   |                                    expected `&isize`, found `isize`\n\
    \   |                                    help: consider borrowing here: `&a.unwrap_or(0)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5tsdx9a7.rs:14:30\n   |\n14 |\
    \         x if x < &0 => (Some(x.max(a.unwrap_or(0))), b),\n   |             \
    \                 ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n14 |         x if x < &0 => (Some(*x.max(a.unwrap_or(0))),\
    \ b),\n   |                              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5tsdx9a7.rs:15:39\n   |\n15 |         x if x > &0 => (a, Some(x.min(b.unwrap_or(0)))),\n\
    \   |                                       ^^^^^^^^^^^^^^\n   |             \
    \                          |\n   |                                       expected\
    \ `&isize`, found `isize`\n   |                                       help: consider\
    \ borrowing here: `&b.unwrap_or(0)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5tsdx9a7.rs:15:33\n\
    \   |\n15 |         x if x > &0 => (a, Some(x.min(b.unwrap_or(0)))),\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n15 |         x if x > &0\
    \ => (a, Some(*x.min(b.unwrap_or(0)))),\n   |                                \
    \ +\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut max = isize::min_value();\n \
    \   let mut min = isize::max_value();\n    for item in lst {\n        if item\
    \ > 0 {\n            if item < min {\n                min = item;\n          \
    \  }\n        } else if item < 0 {\n            if item > max {\n            \
    \    max = item;\n            }\n        }\n    }\n    if max == isize::min_value()\
    \ {\n        max = None;\n    } else {\n        max = Some(max);\n    }\n    if\
    \ min == isize::max_value() {\n        min = None;\n    } else {\n        min\
    \ = Some(min);\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqr7ttefy.rs:30:15\n   |\n\
    16 |     let mut max = isize::min_value();\n   |                   ------------------\
    \ expected due to this value\n...\n30 |         max = None;\n   |            \
    \   ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqr7ttefy.rs:32:15\n   |\n16 |     let mut max = isize::min_value();\n\
    \   |                   ------------------ expected due to this value\n...\n32\
    \ |         max = Some(max);\n   |               ^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqr7ttefy.rs:35:15\n\
    \   |\n17 |     let mut min = isize::max_value();\n   |                   ------------------\
    \ expected due to this value\n...\n35 |         min = None;\n   |            \
    \   ^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqr7ttefy.rs:37:15\n   |\n17 |     let mut min = isize::max_value();\n\
    \   |                   ------------------ expected due to this value\n...\n37\
    \ |         min = Some(min);\n   |               ^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqr7ttefy.rs:39:6\n\
    \   |\n39 |     (max, min)\n   |      ^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n39 |     (Some(max), min)\n\
    \   |      +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqr7ttefy.rs:39:11\n\
    \   |\n39 |     (max, min)\n   |           ^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n39 |     (max, Some(min))\n\
    \   |           ++++"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg: Option<isize>\
    \ = None;\n    let mut min_pos: Option<isize> = None;\n    for n in lst {\n  \
    \      if n > 0 {\n            if min_pos.is_none() || n < min_pos.unwrap() {\n\
    \                min_pos = Some(n);\n            }\n        } else if n < 0 {\n\
    \            if max_neg.is_none() || n > max_neg.unwrap() {\n                max_neg\
    \ = Some(n);\n            }\n        }\n    }\n    (max_neg, min_pos)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for item in lst {\n        if item > 0 {\n\
    \            if let Some(ref current) = smallest {\n                if item <\
    \ *current {\n                    smallest = Some(item);\n                }\n\
    \            } else {\n                smallest = Some(item);\n            }\n\
    \        } else if item < 0 {\n            if let Some(ref current) = largest\
    \ {\n                if item > *current {\n                    largest = Some(item);\n\
    \                }\n            } else {\n                largest = Some(item);\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut a = None;\n   \
    \ let mut b = None;\n    for i in lst {\n        if i < 0 {\n            if a.is_none()\
    \ || a.unwrap() < i {\n                a = Some(i);\n            }\n        }\
    \ else if i > 0 {\n            if b.is_none() || b.unwrap() > i {\n          \
    \      b = Some(i);\n            }\n        }\n    }\n    (a, b)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_neg: Option<isize>\
    \ = None;\n    let mut smallest_pos: Option<isize> = None;\n    for i in lst {\n\
    \        if i < 0 {\n            if largest_neg.is_none() || i > largest_neg.unwrap()\
    \ {\n                largest_neg = Some(i);\n            }\n        } else if\
    \ i > 0 {\n            if smallest_pos.is_none() || i < smallest_pos.unwrap()\
    \ {\n                smallest_pos = Some(i);\n            }\n        }\n    }\n\
    \    (largest_neg, smallest_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for x in lst {\n        if x < 0 {\n            if let Some(y) = largest_negative\
    \ {\n                if x > y {\n                    largest_negative = Some(x);\n\
    \                }\n            } else {\n                largest_negative = Some(x);\n\
    \            }\n        } else if x > 0 {\n            if let Some(y) = smallest_positive\
    \ {\n                if x < y {\n                    smallest_positive = Some(x);\n\
    \                }\n            } else {\n                smallest_positive =\
    \ Some(x);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest_pos: Option<isize>\
    \ = None;\n    let mut largest_neg: Option<isize> = None;\n    for v in lst {\n\
    \        if v > 0 {\n            if let Some(x) = smallest_pos {\n           \
    \     if v < x {\n                    smallest_pos = Some(v);\n              \
    \  }\n            } else {\n                smallest_pos = Some(v);\n        \
    \    }\n        } else if v < 0 {\n            if let Some(x) = largest_neg {\n\
    \                if v > x {\n                    largest_neg = Some(v);\n    \
    \            }\n            } else {\n                largest_neg = Some(v);\n\
    \            }\n        }\n    }\n    (largest_neg, smallest_pos)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for i in lst {\n      \
    \  if i < 0 {\n            if neg.is_none() || i > neg.unwrap() {\n          \
    \      neg = Some(i);\n            }\n        } else if i > 0 {\n            if\
    \ pos.is_none() || i < pos.unwrap() {\n                pos = Some(i);\n      \
    \      }\n        }\n    }\n    (neg, pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    match lst.iter().max()\
    \ {\n        Some(x) => {\n            match x < &0 {\n                true =>\
    \ match lst.iter().min() {\n                    Some(y) => {\n               \
    \         match y > &0 {\n                            true => (Some(*x), Some(*y)),\n\
    \                            false => (Some(*x), None),\n                    \
    \    }\n                    }\n                    None => (Some(*x), None),\n\
    \                },\n                false => (None, None),\n            }\n \
    \       }\n        None => (None, None),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmps2gva8kq.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut small = None;\n\
    \    let mut large = None;\n    for i in lst {\n        if i > 0 {\n         \
    \   small = match small {\n                None => Some(i),\n                Some(n)\
    \ => Some(if i < n { i } else { n }),\n            };\n        } else if i < 0\
    \ {\n            large = match large {\n                None => Some(i),\n   \
    \             Some(n) => Some(if i > n { i } else { n }),\n            };\n  \
    \      }\n    }\n    (large, small)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n\
    \    let mut min_pos = None;\n    for num in lst {\n        if num > 0 {\n   \
    \         min_pos = min_pos.map_or(Some(num), |m| Some(num.min(m)));\n       \
    \ } else if num < 0 {\n            max_neg = max_neg.map_or(Some(num), |m| Some(num.max(m)));\n\
    \        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i > 0 {\n      \
    \      match smallest {\n                None => smallest = Some(i),\n       \
    \         Some(j) => if i < j { smallest = Some(i) },\n            }\n       \
    \ } else if i < 0 {\n            match largest {\n                None => largest\
    \ = Some(i),\n                Some(j) => if i > j { largest = Some(i) },\n   \
    \         }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n   \
    \ let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (\n        lst.iter().filter(|&n|\
    \ n < &0).max().cloned(),\n        lst.iter().filter(|&n| n > &0).min().cloned(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for item in lst {\n        if item < 0 {\n\
    \            if largest.is_none() || largest.unwrap() < item {\n             \
    \   largest = Some(item);\n            }\n        } else if item > 0 {\n     \
    \       if smallest.is_none() || smallest.unwrap() > item {\n                smallest\
    \ = Some(item);\n            }\n        }\n    }\n    (largest, smallest)\n}\n\
    \nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_neg = None;\n\
    \    let mut min_pos = None;\n    for x in lst {\n        if x > 0 {\n       \
    \     if min_pos.is_none() || x < min_pos.unwrap() {\n                min_pos\
    \ = Some(x);\n            }\n        } else if x < 0 {\n            if max_neg.is_none()\
    \ || x > max_neg.unwrap() {\n                max_neg = Some(x);\n            }\n\
    \        }\n    }\n    (max_neg, min_pos)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg = None;\n \
    \   let mut pos = None;\n    for i in lst {\n        if i > 0 {\n            if\
    \ neg.is_none() || neg.unwrap() < i {\n                neg = Some(i);\n      \
    \      }\n        } else if i < 0 {\n            if pos.is_none() || pos.unwrap()\
    \ > i {\n                pos = Some(i);\n            }\n        }\n    }\n   \
    \ (neg, pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(7), None)`,\n right: `(None, Some(1))`', /tmp/tmp47yzvtk6.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i < 0 {\n      \
    \      if largest.is_none() || i > largest.unwrap() {\n                largest\
    \ = Some(i);\n            }\n        } else if i > 0 {\n            if smallest.is_none()\
    \ || i < smallest.unwrap() {\n                smallest = Some(i);\n          \
    \  }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for v in lst {\n        if v > 0 {\n            if\
    \ let Some(val) = min {\n                if v < val {\n                    min\
    \ = Some(v);\n                }\n            } else {\n                min = Some(v);\n\
    \            }\n        } else if v < 0 {\n            if let Some(val) = max\
    \ {\n                if v > val {\n                    max = Some(v);\n      \
    \          }\n            } else {\n                max = Some(v);\n         \
    \   }\n        }\n    }\n    (max, min)\n}\n\nfn main() {\n    let candidate =\
    \ largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    match (lst.iter().min(),\
    \ lst.iter().max()) {\n        (Some(min), Some(max)) => {\n            if *min\
    \ >= 0 {\n                (None, min)\n            } else if *max <= 0 {\n   \
    \             (max, None)\n            } else {\n                (max, min)\n\
    \            }\n        }\n        _ => (None, None),\n    }\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3x0xtjfs.rs:16:24\n   |\n\
    16 |                 (None, min)\n   |                        ^^^ expected enum\
    \ `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n\
    \           found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3x0xtjfs.rs:18:18\n   |\n18 |                 (max, None)\n   |    \
    \              ^^^ expected enum `Option`, found `&isize`\n   |\n   = note:  \
    \ expected enum `Option<isize>`\n           found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3x0xtjfs.rs:20:18\n   |\n20 |              \
    \   (max, min)\n   |                  ^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<isize>`\n           found reference\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3x0xtjfs.rs:20:23\n\
    \   |\n20 |                 (max, min)\n   |                       ^^^ expected\
    \ enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<isize>`\n\
    \           found reference `&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for i in lst {\n        if i <\
    \ 0 {\n            if max_negative.is_none() || i > max_negative.unwrap() {\n\
    \                max_negative = Some(i);\n            }\n        } else if i >\
    \ 0 {\n            if min_positive.is_none() || i < min_positive.unwrap() {\n\
    \                min_positive = Some(i);\n            }\n        }\n    }\n  \
    \  (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_pos = None;\n\
    \    let mut max_neg = None;\n    for i in lst {\n        if i > 0 {\n       \
    \     if let Some(min) = min_pos {\n                if i < min {\n           \
    \         min_pos = Some(i);\n                }\n            } else {\n      \
    \          min_pos = Some(i);\n            }\n        } else if i < 0 {\n    \
    \        if let Some(max) = max_neg {\n                if i > max {\n        \
    \            max_neg = Some(i);\n                }\n            } else {\n   \
    \             max_neg = Some(i);\n            }\n        }\n    }\n    (max_neg,\
    \ min_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for n in lst {\n        if n < 0 {\n      \
    \      largest = match largest {\n                None => Some(n),\n         \
    \       Some(x) => Some(if n > x { n } else { x }),\n            };\n        }\
    \ else if n > 0 {\n            smallest = match smallest {\n                None\
    \ => Some(n),\n                Some(x) => Some(if n < x { n } else { x }),\n \
    \           };\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut lst_pos = Vec::new();\n\
    \    let mut lst_neg = Vec::new();\n    let mut largest = None;\n    let mut smallest\
    \ = None;\n    for i in lst {\n        if i > 0 {\n            lst_pos.push(i);\n\
    \        } else if i < 0 {\n            lst_neg.push(i);\n        }\n    }\n \
    \   match lst_pos.len() {\n        0 => {\n            smallest = None;\n    \
    \    }\n        _ => {\n            smallest = Some(lst_pos.iter().min().unwrap().clone());\n\
    \        }\n    }\n    match lst_neg.len() {\n        0 => {\n            largest\
    \ = None;\n        }\n        _ => {\n            largest = Some(lst_neg.iter().max().unwrap().clone());\n\
    \        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpos4ma9il.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpxsxz_o6w.rs:13:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 0
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for number in lst {\n        if number < 0 {\n            match largest_negative\
    \ {\n                None => largest_negative = Some(number),\n              \
    \  Some(value) => {\n                    if number > value {\n               \
    \         largest_negative = Some(number);\n                    }\n          \
    \      }\n            }\n        }\n        if number > 0 {\n            match\
    \ smallest_positive {\n                None => smallest_positive = Some(number),\n\
    \                Some(value) => {\n                    if number < value {\n \
    \                       smallest_positive = Some(number);\n                  \
    \  }\n                }\n            }\n        }\n    }\n    (largest_negative,\
    \ smallest_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010651
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdo6s1eep.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
