name: HumanEval_136_largest_smallest_integers
language: rs
results:
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut negative_numbers:\
    \ Vec<isize> = vec![];\n    let mut positive_numbers: Vec<isize> = vec![];\n \
    \   let mut negative_max: Option<isize> = None;\n    let mut positive_min: Option<isize>\
    \ = None;\n\n    for num in lst {\n        if num < 0 {\n            negative_numbers.push(num);\n\
    \        }\n        if num > 0 {\n            positive_numbers.push(num);\n  \
    \      }\n    }\n\n    for num in negative_numbers {\n        if negative_max\
    \ == None {\n            negative_max = Some(num);\n        }\n        if negative_max\
    \ != None && num > negative_max.unwrap() {\n            negative_max = Some(num);\n\
    \        }\n    }\n\n    for num in positive_numbers {\n        if positive_min\
    \ == None {\n            positive_min = Some(num);\n        }\n        if positive_min\
    \ != None && num < positive_min.unwrap() {\n            positive_min = Some(num);\n\
    \        }\n    }\n\n    (negative_max, positive_min)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut largest_neg = None;\n    let\
    \ mut smallest_pos = None;\n    for item in lst {\n        if item < 0 {\n   \
    \         match largest_neg {\n                None => largest_neg = Some(item),\n\
    \                Some(x) => if item > x { largest_neg = Some(item) }\n       \
    \     }\n        } else if item > 0 {\n            match smallest_pos {\n    \
    \            None => smallest_pos = Some(item),\n                Some(x) => if\
    \ item < x { smallest_pos = Some(item) }\n            }\n        }\n    }\n  \
    \  (largest_neg, smallest_pos)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpypw2y13z.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut large = None;\n\
    \    let mut small = None;\n    for i in lst {\n        if i > 0 {\n         \
    \   if small == None {\n                small = Some(i);\n            } else if\
    \ i < small.unwrap() {\n                small = Some(i);\n            }\n    \
    \    } else if i < 0 {\n            if large == None {\n                large\
    \ = Some(i);\n            } else if i > large.unwrap() {\n                large\
    \ = Some(i);\n            }\n        }\n    }\n    (large, small)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxsxz_o6w.rs:13:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut lst_neg = vec![];\n\
    \    let mut lst_pos = vec![];\n    for &i in &lst {\n        if i >= 0 {\n  \
    \          lst_pos.push(i);\n        } else {\n            lst_neg.push(i);\n\
    \        }\n    }\n    if lst_neg.len() > 0 {\n        lst_neg.sort();\n     \
    \   lst_neg.reverse();\n    }\n    if lst_pos.len() > 0 {\n        lst_pos.sort();\n\
    \    }\n    let mut res = (None, None);\n    if lst_neg.len() > 0 {\n        res.0\
    \ = Some(lst_neg[0]);\n    }\n    if lst_pos.len() > 0 {\n        res.1 = Some(lst_pos[0]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmprifd8jb4.rs:42:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max = None;\n \
    \   let mut min = None;\n    for e in lst {\n        if e > 0 {\n            min\
    \ = match min {\n                None => Some(e),\n                Some(m) =>\
    \ Some(cmp::min(m, e)),\n            };\n        } else if e < 0 {\n         \
    \   max = match max {\n                None => Some(e),\n                Some(m)\
    \ => Some(cmp::max(m, e)),\n            };\n        }\n    }\n    (max, min)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpr42ii_jw.rs:19:33\n   |\n19 |                 Some(m) => Some(cmp::min(m,\
    \ e)),\n   |                                 ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpr42ii_jw.rs:24:33\n   |\n24 |                 Some(m) =>\
    \ Some(cmp::max(m, e)),\n   |                                 ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min = None;\n \
    \   let mut max = None;\n    for x in lst {\n        if x > 0 {\n            if\
    \ min.is_none() || x < min.unwrap() {\n                min = Some(x);\n      \
    \      }\n        } else if x < 0 {\n            if max.is_none() || x > max.unwrap()\
    \ {\n                max = Some(x);\n            }\n        }\n    }\n    (max,\
    \ min)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    if lst.len() == 0 {\n \
    \       return (None, None);\n    }\n    let mut smallest = None;\n    let mut\
    \ largest = None;\n    for num in lst {\n        if num > 0 {\n            match\
    \ smallest {\n                None => smallest = Some(num),\n                Some(x)\
    \ => {\n                    if num < x {\n                        smallest = Some(num);\n\
    \                    }\n                }\n            }\n        } else if num\
    \ < 0 {\n            match largest {\n                None => largest = Some(num),\n\
    \                Some(x) => {\n                    if num > x {\n            \
    \            largest = Some(num);\n                    }\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpos4ma9il.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    // Your code here!\n  \
    \  let mut largest = None;\n    let mut smallest = None;\n    for i in lst.iter()\
    \ {\n        if i > &0 {\n            match smallest {\n                None =>\
    \ smallest = Some(*i),\n                Some(x) => if x > *i { smallest = Some(*i)\
    \ },\n            }\n        } else if i < &0 {\n            match largest {\n\
    \                None => largest = Some(*i),\n                Some(x) => if x\
    \ < *i { largest = Some(*i) },\n            }\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for el in lst {\n        if el > 0 {\n            match smallest_positive\
    \ {\n                None => smallest_positive = Some(el),\n                Some(x)\
    \ => {\n                    if el < x {\n                        smallest_positive\
    \ = Some(el);\n                    }\n                }\n            }\n     \
    \   } else if el < 0 {\n            match largest_negative {\n               \
    \ None => largest_negative = Some(el),\n                Some(x) => {\n       \
    \             if el > x {\n                        largest_negative = Some(el);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   (largest_negative, smallest_positive)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqwtjbi7_.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0fk6ll52.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdo6s1eep.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    (None, None)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, None)`,\n right: `(None, Some(1))`', /tmp/tmpgrqds2xv.rs:18:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n  unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpp548l3jy.rs:13:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let x = lst.iter().filter(|&x|\
    \ x < &0).max();\n    let y = lst.iter().filter(|&x| x > &0).min();\n    (x.map(|a|\
    \ *a), y.map(|a| *a))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut neg: Option<isize>\
    \ = None;\n    let mut pos: Option<isize> = None;\n    for i in lst {\n      \
    \  match i.signum() {\n            -1 => {\n                match neg {\n    \
    \                Some(x) => {\n                        if i > x {\n          \
    \                  neg = Some(i);\n                        }\n               \
    \     }\n                    None => neg = Some(i),\n                }\n     \
    \       }\n            1 => {\n                match pos {\n                 \
    \   Some(x) => {\n                        if i < x {\n                       \
    \     pos = Some(i);\n                        }\n                    }\n     \
    \               None => pos = Some(i),\n                }\n            }\n   \
    \         _ => continue,\n        }\n    }\n    (neg, pos)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a vector.\n/// If there is no negative or positive integers, return them\
    \ as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3,\
    \ 5, 7])\n/// (None, 1)\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut a: Option<isize>\
    \ = None;\n    let mut b: Option<isize> = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if let Some(a_val) = a {\n                if i > a_val\
    \ {\n                    a = Some(i);\n                }\n            } else {\n\
    \                a = Some(i);\n            }\n        } else if i > 0 {\n    \
    \        if let Some(b_val) = b {\n                if i < b_val {\n          \
    \          b = Some(i);\n                }\n            } else {\n           \
    \     b = Some(i);\n            }\n        }\n    }\n    (a, b)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
