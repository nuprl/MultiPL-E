language: rs
name: HumanEval_132_is_nested
results:
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ char in string.chars() {\n        match char {\n            '[' => stack.push(char),\n\
    \            ']' => {\n                if stack.last() == Some(&'[') {\n     \
    \               stack.pop();\n                } else {\n                    stack.push(char);\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptcp_bxwv.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ s in string.chars() {\n        if s == '[' {\n            stack.push(s);\n \
    \       } else if s == ']' {\n            match stack.pop() {\n              \
    \  Some(_) => (),\n                None => return false,\n            }\n    \
    \    }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpepey0yno.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut chars = string.chars();\n\
    \    let mut is_prev_open = false;\n    let mut is_prev_close = false;\n    let\
    \ mut is_valid = false;\n    for bracket in chars {\n        match bracket {\n\
    \            '[' => {\n                if is_prev_close {\n                  \
    \  return false;\n                }\n                is_prev_open = true;\n  \
    \          },\n            ']' => {\n                if is_prev_open {\n     \
    \               is_valid = true;\n                }\n                is_prev_close\
    \ = true;\n            },\n            _ => {},\n        }\n    }\n    is_valid\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4p_z90h3.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut left: usize = 0;\n    let\
    \ mut right: usize = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            left += 1;\n        } else {\n            right += 1;\n        }\n\
    \        if right > left {\n            return false;\n        }\n    }\n    right\
    \ == left\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvx1lrnhy.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(vec![], |mut stack,\
    \ x| {\n        if stack.len() == 0 || stack[stack.len() - 1] != x {\n       \
    \     stack.push(x);\n        } else {\n            stack.pop();\n        }\n\
    \        stack\n    }).len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5n3bgk_g.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut found_nested\
    \ = false;\n    for ch in string.chars() {\n        if ch == '[' {\n         \
    \   count += 1;\n        } else if ch == ']' {\n            count -= 1;\n    \
    \    }\n        if count < 0 {\n            break;\n        }\n        if count\
    \ > 1 {\n            found_nested = true;\n        }\n    }\n    count == 0 &&\
    \ found_nested\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3ys1com5.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzxzu0ozy.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ s in string.chars() {\n        if s == '[' {\n            stack.push(s);\n \
    \       } else if s == ']' {\n            if let Some(_) = stack.pop() {\n   \
    \             continue;\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp33gibu7b.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut open = 0;\n    let mut close\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            open\
    \ += 1;\n        } else if c == ']' {\n            close += 1;\n        }\n  \
    \      if close > open {\n            return false;\n        }\n    }\n    open\
    \ != close\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp67u328dz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9y7rovfj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().filter(|c| *c == '['\
    \ || *c == ']').fold(0, |acc, c| if c == '[' { acc + 1 } else { acc - 1 }).abs()\
    \ == 1\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6pu9xhzi.rs:17:114\n   |\n17 |     string.chars().filter(|c| *c\
    \ == '[' || *c == ']').fold(0, |acc, c| if c == '[' { acc + 1 } else { acc - 1\
    \ }).abs() == 1\n   |                                                        \
    \                                                          ^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0689`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut iter = string.chars();\n \
    \   let mut depth = 0;\n    while let Some(next) = iter.next() {\n        if next\
    \ == '[' {\n            depth += 1;\n        } else if next == ']' {\n       \
    \     depth -= 1;\n        } else {\n            panic!(\"Tried to parse a non-bracket\
    \ character\");\n        }\n        if depth < 0 {\n            return false;\n\
    \        }\n    }\n    depth != 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe8xeoou3.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let left = String::from(\"[\");\n\
    \    let right = String::from(\"]\");\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if stack.is_empty() {\n            stack.push(c);\n\
    \        } else {\n            let current = stack.pop().unwrap();\n         \
    \   if current == left && c == right {\n                stack.pop();\n       \
    \     } else {\n                stack.push(current);\n                stack.push(c);\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt245o8ok.rs:25:27\n   |\n\
    25 |             if current == left && c == right {\n   |                    \
    \       ^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt245o8ok.rs:25:40\n   |\n25 |             if current ==\
    \ left && c == right {\n   |                                        ^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut non_zero_depth\
    \ = false;\n    for ch in string.chars() {\n        if ch == '[' {\n         \
    \   depth += 1;\n        } else {\n            depth -= 1;\n        }\n      \
    \  if depth > 0 {\n            non_zero_depth = true;\n        }\n        if depth\
    \ < 0 {\n            return false;\n        }\n    }\n    return non_zero_depth;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkxkr96nw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(vec![], |mut stack,\
    \ c| {\n        match c {\n            '[' => stack.push(c),\n            ']'\
    \ => {\n                match stack.pop() {\n                    Some(_) => (),\n\
    \                    None => stack.push(c),\n                }\n            }\n\
    \            _ => (),\n        }\n        stack\n    }).is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3mp1j_u6.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut seen_opening_brackets = 0;\n\
    \    let mut seen_nested_brackets = 0;\n    for bracket in string.chars() {\n\
    \        if bracket == '[' {\n            seen_opening_brackets += 1;\n      \
    \  } else if bracket == ']' {\n            if seen_opening_brackets > 0 {\n  \
    \              seen_opening_brackets -= 1;\n                seen_nested_brackets\
    \ += 1;\n            } else {\n                return false;\n            }\n\
    \        }\n    }\n    seen_nested_brackets > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa6w3emb4.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut st = vec![];\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            st.push(ch);\n       \
    \ } else {\n            if st.len() == 0 {\n                return false;\n  \
    \          }\n            st.pop();\n        }\n    }\n    st.len() == 0\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpju143peh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(vec![], |mut stack,\
    \ ch| {\n        match ch {\n            '[' => stack.push(ch),\n            ']'\
    \ => {\n                if stack.last() == Some(&'[') {\n                    stack.pop();\n\
    \                } else {\n                    stack.push(ch);\n             \
    \   }\n            }\n            _ => ()\n        }\n        stack\n    }).into_iter().any(|ch|\
    \ ch == '[')\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgvqnbdfm.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO: implement function\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyz95b2wj.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj2tune48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut left = 0;\n    let mut right\
    \ = 0;\n    for c in string.chars() {\n        match c {\n            '[' => left\
    \ += 1,\n            ']' => {\n                if left > 0 {\n               \
    \     left -= 1;\n                } else {\n                    right += 1;\n\
    \                }\n            }\n            _ => panic!(\"Unexpected character:\
    \ {}\", c),\n        }\n    }\n    left == 0 && right == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4r0od2ps.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.len() >\
    \ 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp29phebgu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    if string.len() % 2 != 0 {\n     \
    \   return false;\n    }\n    let mut chars = string.chars();\n    let mut stack\
    \ = Vec::new();\n    while let Some(c) = chars.next() {\n        match c {\n \
    \           '[' => stack.push(c),\n            ']' => {\n                if let\
    \ Some(p) = stack.pop() {\n                    if p != '[' {\n               \
    \         return false;\n                    }\n                } else {\n   \
    \                 return false;\n                }\n            }\n          \
    \  _ => return false,\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdimoeme5.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Split characters into a vector\
    \ of char.\n    let chars: Vec<char> = string.chars().collect();\n    // The stack\
    \ of brackets.\n    let mut stack: Vec<char> = Vec::new();\n    // The previous\
    \ bracket.\n    let mut prev: char = '#';\n    // Iterate over the characters.\n\
    \    for c in chars {\n        // If the character is the same as the previous\
    \ bracket (opening or closing), return false.\n        if c == prev {\n      \
    \      return false;\n        }\n        // If the character is an opening bracket,\
    \ push it onto the stack.\n        if c == '[' {\n            stack.push(c);\n\
    \        }\n        // If the character is a closing bracket, pop the last opening\
    \ bracket from the stack.\n        if c == ']' {\n            stack.pop();\n \
    \       }\n        // Update the previous bracket.\n        prev = c;\n    }\n\
    \    // If there are still brackets on the stack, return false.\n    if !stack.is_empty()\
    \ {\n        return false;\n    }\n    // Return true if no return statements\
    \ were triggered.\n    true\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2ca8rra0.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else if c == ']'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count != 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwm2bf1ni.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let string = string.as_str();\n  \
    \  let mut valid = false;\n    let mut stack = vec![];\n    for bracket in string.chars()\
    \ {\n        match bracket {\n            '[' => stack.push(bracket),\n      \
    \      ']' => {\n                if stack.is_empty() {\n                    valid\
    \ = false;\n                    break;\n                } else {\n           \
    \         stack.pop();\n                    valid = true;\n                }\n\
    \            }\n            _ => panic!(\"This problem only supports square brackets\"\
    )\n        }\n    }\n    valid\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmparjnoha6.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            count += 1;\n      \
    \  } else if c == ']' {\n            count -= 1;\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    return count != 0;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfo28du7c.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut prev_count\
    \ = 0;\n    for ch in string.chars() {\n        match ch {\n            '[' =>\
    \ count += 1,\n            ']' => count -= 1,\n            _ => ()\n        }\n\
    \        if count < 0 {\n            return false;\n        }\n        if count\
    \ == 0 && prev_count > 0 {\n            return true;\n        }\n        prev_count\
    \ = count;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsgfm75rc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for char\
    \ in string.chars() {\n        if char == '[' {\n            stack.push(char);\n\
    \        } else if char == ']' {\n            if stack.len() > 0 {\n         \
    \       stack.pop();\n            } else {\n                return false;\n  \
    \          }\n        }\n    }\n    stack.len() > 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5o1j5gm3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |level, c|\
    \ {\n        match (level, c) {\n            (l, '[' ) => l + 1,\n           \
    \ (0, ']' ) => l - 1,\n            (l, ']' ) => l - 1,\n            (l, _   )\
    \ => l,\n        }\n    }) == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmp9r9axiju.rs:20:26\n\
    \   |\n20 |             (0, ']' ) => l - 1,\n   |                          ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(x) = stack.pop() {\n      \
    \              if x != '[' {\n                        return false;\n        \
    \            }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptwygels1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut open_count = 0;\n    let mut\
    \ closed_count = 0;\n    for c in string.chars() {\n        match c {\n      \
    \      '[' => open_count += 1,\n            ']' => closed_count += 1,\n      \
    \      _ => panic!(\"Unexpected character {}\", c),\n        }\n        if closed_count\
    \ > open_count {\n            return false;\n        }\n    }\n    closed_count\
    \ < open_count\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcxd4krxj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut vec = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            vec.push(i);\n   \
    \     } else if !vec.is_empty() {\n            vec.pop();\n        } else {\n\
    \            return false;\n        }\n    }\n    vec.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp69wm4_mb.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for ch\
    \ in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => (),\n                    None => return false,\n              \
    \  }\n            }\n            _ => panic!(\"Unexpected character {}\", ch),\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpahhvnh0z.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut left: Vec<u8> = Vec::new();\n\
    \    let mut right: Vec<u8> = Vec::new();\n    for ch in string.as_bytes() {\n\
    \        match ch {\n            b'[' => left.push(ch),\n            b']' => {\n\
    \                if left.len() > 0 {\n                    let _ = left.pop();\n\
    \                } else {\n                    right.push(ch);\n             \
    \   }\n            }\n            _ => panic!(\"Invalid character found\"),\n\
    \        }\n    }\n    left.len() == 0 && right.len() > 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp88b0issb.rs:21:31\n   |\n\
    21 |             b'[' => left.push(ch),\n   |                               ^^\
    \ expected `u8`, found `&u8`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |             b'[' => left.push(*ch),\n   |                        \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp88b0issb.rs:26:32\n\
    \   |\n26 |                     right.push(ch);\n   |                        \
    \        ^^ expected `u8`, found `&u8`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n26 |                     right.push(*ch);\n   |              \
    \                  +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if !stack.is_empty() {\n            stack.pop();\n        } else\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl8ixn1ei.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        match bracket {\n            '[' => stack.push(bracket),\n\
    \            ']' => {\n                if stack.pop() != Some('[') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmlogllcw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = vec![];\n\tlet s = string.chars().collect::<Vec<char>>();\n\
    \tfor i in 0..s.len() {\n\t\tmatch s[i] {\n\t\t\t'[' => stack.push(s[i]),\n\t\t\
    \t']' => match stack.pop() {\n\t\t\t\tSome(_) => continue,\n\t\t\t\tNone => return\
    \ false,\n\t\t\t},\n\t\t\t_ => panic!(\"unknown char\"),\n\t\t}\n\t}\n\tstack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt33psi_4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    !stack.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkz2tg06f.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(_) = stack.pop() {\n      \
    \              continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => return false,\n \
    \       }\n    }\n    if stack.len() == 0 {\n        return true;\n    }\n   \
    \ false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa7ncg9b_.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut open_b: Vec<char> = Vec::new();\n\
    \    let mut check = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            open_b.push(c);\n        } else {\n            if open_b.len() >\
    \ 0 {\n                open_b.pop();\n                check += 1;\n          \
    \  }\n        }\n    }\n    if check == 0 {\n        return false;\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0irbxgsu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut level = 0;\n\tfor c in string.chars()\
    \ {\n\t\tmatch c {\n\t\t\t'[' => level += 1,\n\t\t\t']' => {\n\t\t\t\tif level\
    \ == 0 {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tlevel -= 1;\n\t\t\t}\n\t\
    \t\t_ => ()\n\t\t}\n\t}\n\treturn level > 0;\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd8su7gsc.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                if stack.pop().unwrap()\
    \ != '[' {\n                    return false;\n                }\n           \
    \ }\n            _ => return false,\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9e40g19m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let (mut a, mut b) = (0, 0);\n   \
    \ for c in string.chars() {\n        match c {\n            '[' => a += 1,\n \
    \           ']' => if a == 0 {\n                b += 1\n            } else {\n\
    \                a -= 1\n            },\n            _ => panic!(\"Invalid char\"\
    ),\n        }\n    }\n    (a == 0) && (b > 0)\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuwc36unc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => stack.push(0),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => (),\n                    None => return false,\n              \
    \  }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqlu52ctz.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(0),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => panic!(\"Only square brackets\
    \ allowed.\"),\n        }\n    }\n    stack.len() != 0\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppn5qn8qy.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut open = 0;\n    let mut close = 0;\n\n    for ch\
    \ in string.chars() {\n        if ch == '[' {\n            open += 1;\n      \
    \  } else if ch == ']' {\n            close += 1;\n        }\n\n        if close\
    \ > open {\n            return false;\n        }\n    }\n\n    return open > close;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2swanazh.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(x) = stack.pop() {\n      \
    \              if x != '[' {\n                        return false;\n        \
    \            }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9yhgfire.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if !stack.is_empty() && matches!(stack.last(),\
    \ Some('[') && bracket == ']') {\n            stack.pop();\n        } else {\n\
    \            stack.push(bracket);\n        }\n    }\n    stack.iter().any(|bracket|\
    \ matches!(bracket, '['))\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `&&`\n  --> /tmp/tmpoapniurk.rs:19:66\n\
    \   |\n19 |         if !stack.is_empty() && matches!(stack.last(), Some('[') &&\
    \ bracket == ']') {\n   |                                                    \
    \              ^^ no rules expected this token in macro call\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() > 0 {\n                \
    \    stack.pop();\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => continue,\n        }\n   \
    \ }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb37qxh84.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut vec: Vec<char> = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            vec.push(c);\n\
    \        } else if c == ']' {\n            if vec.len() > 0 {\n              \
    \  vec.pop();\n            } else {\n                return false;\n         \
    \   }\n        }\n    }\n    vec.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzr7gfoaq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Remove non-bracket characters from\
    \ the string\n    let string = string.chars().filter(|&x| x == '[' || x == ']').collect::<String>();\n\
    \    // Declare an index variable to start looping through the string\n    let\
    \ mut index = 0;\n    // Declare a variable that tracks the number of open brackets\
    \ and initialise to 0\n    let mut open_brackets = 0;\n    // Declare a variable\
    \ that tracks the number of closed brackets and initialise to 0\n    let mut closed_brackets\
    \ = 0;\n    // Loop over the string\n    while index < string.len() {\n      \
    \  // If we encounter an open bracket, increment the open bracket counter and\
    \ continue\n        if string.chars().nth(index) == Some('[') {\n            open_brackets\
    \ += 1;\n            index += 1;\n            continue;\n        }\n        //\
    \ If we encounter a closed bracket, increment the closed bracket counter and continue\n\
    \        if string.chars().nth(index) == Some(']') {\n            closed_brackets\
    \ += 1;\n            index += 1;\n            continue;\n        }\n        //\
    \ We should never encounter a situation where neither of the above conditions\
    \ are true, \n        // so this should never execute\n        panic!(\"Invalid\
    \ string passed to is_nested.\");\n    }\n    // Return whether there are both\
    \ open and closed brackets, and if the number of closed brackets\n    // is larger\
    \ than the number of open brackets\n    (open_brackets > 0 && closed_brackets\
    \ > 0) && closed_brackets > open_brackets\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6a9nidrb.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut i = 0;\n    let mut result\
    \ = true;\n    let mut stack = Vec::new();\n    let mut chars = string.chars();\n\
    \    while let Some(c) = chars.next() {\n        match c {\n            '[' =>\
    \ {\n                stack.push(c);\n                i += 1;\n            }\n\
    \            ']' => {\n                if let Some(_) = stack.pop() {\n      \
    \              i -= 1;\n                } else {\n                    result =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       _ => result = false,\n        }\n    }\n    result && stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp31o_wh0h.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => match stack.pop() {\n                Some('[') => continue,\n\
    \                _ => return false,\n            },\n            _ => return false,\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqk1brzti.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => return false,\n        }\n    }\n    return\
    \ stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprz9b_p21.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut score = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => score += 1,\n            ']' => {\n\
    \                if score == 0 {\n                    return false;\n        \
    \        }\n                score -= 1;\n            }\n            _ => panic!(\"\
    Input must contain only brackets\"),\n        }\n    }\n    score > 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2np8u3mu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = Vec::new();\n\tfor c\
    \ in string.chars() {\n\t\tif c == '[' {\n\t\t\tstack.push(c);\n\t\t} else if\
    \ c == ']' {\n\t\t\tif let Some(open) = stack.pop() {\n\t\t\t\tif open != '['\
    \ {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\
    \t\t\t}\n\t\t}\n\t}\n\tstack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_ei0vzvu.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => count += 1,\n     \
    \       ']' => count -= 1,\n            _ => (),\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    count != 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm21r322e.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzxjgpqfq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(top) = stack.pop() {\n    \
    \                if top != '[' {\n                        return false;\n    \
    \                }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt1adg6tr.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO: Implement is_nested\n   \
    \ false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe5zwmy93.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |mut depth,\
    \ c| {\n        if c == '[' {\n            depth += 1;\n        } else if c ==\
    \ ']' {\n            depth -= 1;\n        }\n        if depth < 0 {\n        \
    \    return depth;\n        }\n        depth\n    }) == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbec1cxb0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => panic!(\"The input string contains characters other\
    \ than square brackets.\"),\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiy6mtydc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut closest_end = 0;\n    for (i, c) in string.chars().enumerate() {\n     \
    \   match c {\n            '[' => {\n                stack.push(i);\n        \
    \    }\n            ']' => {\n                match stack.pop() {\n          \
    \          Some(pos) => {\n                        if i - pos > closest_end {\n\
    \                            closest_end = i - pos;\n                        }\n\
    \                    }\n                    None => {\n                      \
    \  return false;\n                    }\n                }\n            }\n  \
    \          _ => {}\n        }\n    }\n    if stack.len() > 0 {\n        return\
    \ false;\n    }\n    if closest_end >= 2 {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdqrret2y.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut last_left_bracket_position = None;\n    for (index, character) in string.chars().enumerate()\
    \ {\n        match character {\n            '[' => {\n                stack.push(index);\n\
    \            }\n            ']' => {\n                match stack.pop() {\n  \
    \                  Some(stack_top) => {\n                        last_left_bracket_position\
    \ = Some(stack_top);\n                    }\n                    None => return\
    \ false,\n                }\n            }\n            _ => {}\n        }\n \
    \   }\n    match last_left_bracket_position {\n        Some(_) => true,\n    \
    \    None => false,\n    }\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxweob_qj.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut c: usize = 0;\n    let mut\
    \ d: usize = 0;\n    for i in string.chars() {\n        if i == '[' {\n      \
    \      c += 1;\n        } else if i == ']' {\n            d += 1;\n        }\n\
    \    }\n    if c == d {\n        return false;\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8wf5zfga.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => counter += 1,\n   \
    \         ']' => counter -= 1,\n            _ => (),\n        }\n        if counter\
    \ < 0 {\n            return false;\n        }\n    }\n    counter > 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplctk21ed.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |count, c|\
    \ {\n        match c {\n            '[' => {\n                let count = count\
    \ + 1;\n                if count == 0 {\n                    -1\n            \
    \    } else {\n                    count\n                }\n            },\n\
    \            ']' => {\n                let count = count - 1;\n              \
    \  if count == 0 {\n                    1\n                } else {\n        \
    \            count\n                }\n            },\n            _ => panic!(\"\
    Invalid character in string\")\n        }\n    }) < 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgdmy50wu.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for s in string.chars() {\n        if s == '[' {\n            stack.push(s);\n\
    \        } else if s == ']' {\n            if stack.pop() == '[' {\n         \
    \       continue;\n            } else {\n                return false;\n     \
    \       }\n        }\n    }\n    if stack.is_empty() {\n        return true;\n\
    \    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp46fmj4pi.rs:17:21\n   |\n17 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(Vec::new(), |mut\
    \ stack, x| {\n        match x {\n            '[' => stack.push(x),\n        \
    \    ']' => if stack.len() > 0 && stack[stack.len() - 1] == '[' { stack.pop();\
    \ } else { return false; },\n            _ => unreachable!()\n        }\n    \
    \    stack\n    }).len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0jfr93l1.rs:20:103\n   |\n\
    20 |             ']' => if stack.len() > 0 && stack[stack.len() - 1] == '[' {\
    \ stack.pop(); } else { return false; },\n   |                               \
    \                                                                        ^^^^^\
    \ expected struct `Vec`, found `bool`\n   |\n   = note: expected struct `Vec<char>`\n\
    \                found type `bool`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj2tune48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut negative_previous\
    \ = false;\n    for c in string.chars() {\n        if c == '[' {\n           \
    \ depth += 1;\n        } else if c == ']' {\n            depth -= 1;\n       \
    \ }\n        if depth < 0 {\n            negative_previous = true;\n        }\n\
    \    }\n    depth != 0 && negative_previous\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpezqplnrk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = Vec::new();\n\tfor c\
    \ in string.chars() {\n\t\tif c == '[' {\n\t\t\tstack.push(c);\n\t\t} else if\
    \ c == ']' {\n\t\t\tif stack.len() == 0 {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    \tif stack[stack.len() - 1] == '[' {\n\t\t\t\tstack.pop();\n\t\t\t} else {\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.len() > 0;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpge4hi8qm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => (),\n                    None => return false,\n              \
    \  }\n            }\n            _ => return false,\n        }\n    }\n    if\
    \ stack.len() > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7gltncvw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for s\
    \ in string.chars() {\n        match s {\n            '[' => stack.push(s),\n\
    \            ']' => match stack.pop() {\n                Some('[') => (),\n  \
    \              _ => return false,\n            },\n            _ => panic!(\"\
    Invalid char\"),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n \
    \   let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkdfufsu4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for character\
    \ in string.chars() {\n        match character {\n            '[' => stack.push(character),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some(_) => (),\n                    None => return false,\n              \
    \  }\n            }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpleinbs_a.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Your code here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvbgl0tzl.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for symbol\
    \ in string.chars() {\n        if symbol == '[' {\n            stack.push(symbol);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvqk2m72x.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut index = 0;\n    let mut open_count\
    \ = 0;\n    for c in string.chars() {\n        index += 1;\n        if c == '['\
    \ {\n            open_count += 1;\n        } else if c == ']' {\n            if\
    \ open_count > 0 {\n                open_count -= 1;\n            } else {\n \
    \               return false;\n            }\n        } else {\n            return\
    \ false;\n        }\n    }\n    open_count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzt921ytj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphnyhe_hp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                match stack.pop() {\n                 \
    \   Some('[') => (),\n                    _ => return false,\n               \
    \ }\n            }\n            _ => continue,\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2md9ecmh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(Vec::new(), |mut\
    \ acc, c| {\n        if acc.len() == 0 {\n            acc.push(c);\n        }\
    \ else {\n            let prev = acc[acc.len() - 1];\n            if prev == '['\
    \ && c == ']' {\n                acc.pop();\n            } else {\n          \
    \      acc.push(c);\n            }\n        }\n        acc\n    }).len() == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvwjrx67n.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if let Some(x) = stack.pop() {\n      \
    \              if x != '[' {\n                        return false;\n        \
    \            }\n                } else {\n                    return false;\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo0me1ynk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut last_open_bracket = -1;\n    for (index, c) in string.chars().enumerate()\
    \ {\n        match c {\n            '[' => { stack.push(index); last_open_bracket\
    \ = index; },\n            ']' => {\n                if let Some(open_bracket_index)\
    \ = stack.pop() {\n                    if open_bracket_index == last_open_bracket\
    \ {\n                        last_open_bracket = -1;\n                    }\n\
    \                } else {\n                    return false;\n               \
    \ }\n            },\n            _ => panic!(\"Invalid input\"),\n        }\n\
    \    }\n    return last_open_bracket == -1;\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpkyxhw_72.rs:18:33\n\
    \   |\n18 |     let mut last_open_bracket = -1;\n   |                        \
    \         ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpkyxhw_72.rs:25:45\n\
    \   |\n25 |                         last_open_bracket = -1;\n   |            \
    \                                 ^^\n   |                                   \
    \          |\n   |                                             cannot apply unary\
    \ operator `-`\n   |                                             help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n  --> /tmp/tmpkyxhw_72.rs:34:33\n   |\n34 |     return last_open_bracket\
    \ == -1;\n   |                                 ^^\n   |                      \
    \           |\n   |                                 cannot apply unary operator\
    \ `-`\n   |                                 help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphnyhe_hp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 {\n        return\
    \ false;\n    }\n    let mut left_brackets: i32 = 0;\n    let mut right_brackets:\
    \ i32 = 0;\n    for c in string.chars() {\n        if c == '[' {\n           \
    \ left_brackets += 1;\n        } else if c == ']' {\n            right_brackets\
    \ += 1;\n        }\n        if right_brackets > left_brackets {\n            return\
    \ false;\n        }\n    }\n    return left_brackets != right_brackets;\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2k3wqfgb.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = String::new();\n \
    \   for char in string.chars() {\n        match char {\n            '[' => stack.push('['),\n\
    \            ']' => {\n                if stack.pop() != Some('[') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ panic!(\"not a bracket\"),\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz4yazjdi.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut cnt = 0;\n    for c in string.chars() {\n        match c {\n           \
    \ '[' => {\n                stack.push(c);\n                cnt += 1;\n      \
    \      }\n            ']' => {\n                if stack.is_empty() {\n      \
    \              return false;\n                }\n                let last = stack.pop().unwrap();\n\
    \                match last {\n                    '[' => {\n                \
    \        cnt -= 1;\n                    }\n                    _ => return false,\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    return cnt == 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbge2ihm1.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                let last = stack.pop().unwrap();\n\
    \                if last != '[' {\n                    return false;\n       \
    \         }\n            }\n            _ => {}\n        }\n    }\n    stack.len()\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp90l9miv9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut a = Vec::new();\n    let mut\
    \ b = Vec::new();\n    let mut c = Vec::new();\n    let mut d = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            a.push(c);\n\
    \        } else if c == ']' {\n            b.push(c);\n        }\n    }\n    if\
    \ a.len() >= b.len() {\n        let mut i = 0;\n        let mut j = 0;\n     \
    \   while i < a.len() && j < b.len() {\n            if a[i] == '[' && b[j] ==\
    \ ']' {\n                c.push(a[i]);\n                d.push(b[j]);\n      \
    \          i += 1;\n                j += 1;\n            } else {\n          \
    \      break;\n            }\n        }\n        if a.len() - c.len() == b.len()\
    \ - d.len() {\n            true\n        } else {\n            false\n       \
    \ }\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu1y7frmz.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for ch in string.chars() {\n        match ch {\n            '[' => stack.push(1),\n\
    \            ']' => if stack.pop() != 1 {\n                return false;\n   \
    \         },\n            _ => {},\n        }\n    }\n    if stack.is_empty()\
    \ {\n        return false;\n    }\n    while !stack.is_empty() {\n        let\
    \ _ = stack.pop();\n        if stack.is_empty() {\n            return false;\n\
    \        }\n        let _ = stack.pop();\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp876hgldl.rs:17:21\n   |\n17 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for char in\
    \ string.chars() {\n        match char {\n            '[' => depth += 1,\n   \
    \         ']' => depth -= 1,\n            _ => panic!(\"{} is not a bracket\"\
    , char),\n        }\n        if depth < 0 {\n            return false;\n     \
    \   }\n    }\n    depth > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa9q6z40m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfflnr4vx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            stack.push(i);\n \
    \       } else {\n            if let Some(top) = stack.pop() {\n             \
    \   if top != '[' {\n                    return false;\n                }\n  \
    \          } else {\n                return false;\n            }\n        }\n\
    \    }\n    return stack.is_empty();\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp356uexqo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut found = false;\n    let mut\
    \ counter = 0;\n    for ch in string.chars() {\n        match ch {\n         \
    \   '[' => counter += 1,\n            ']' => counter -= 1,\n            _ => continue,\n\
    \        }\n        if counter < 0 {\n            break;\n        }\n        if\
    \ counter > 0 {\n            found = true;\n        }\n    }\n    found && counter\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphmx1eu_4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut left = 0;\n    let mut right\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            left\
    \ += 1;\n        } else {\n            right += 1;\n        }\n        if right\
    \ > left {\n            return false;\n        }\n    }\n    left > right\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmlepwwdc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if let Some(s) = stack.pop() {\n     \
    \           if s != '[' {\n                    return false;\n               \
    \ }\n            } else {\n                return false;\n            }\n    \
    \    }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxu73b2sc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut cnt = 0;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => cnt += 1,\n            ']' => cnt -=\
    \ 1,\n            _ => panic!(\"Wrong bracket character\"),\n        }\n     \
    \   if cnt < 0 {\n            return false;\n        }\n    }\n    cnt != 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpysbet6rq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    let last =\
    \ stack.pop().unwrap();\n                    if last != '[' {\n              \
    \          return false;\n                    }\n                }\n         \
    \   }\n            _ => return false,\n        }\n    }\n    return !stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd_3bt2y9.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut previous\
    \ = '\\0';\n    for bracket in string.chars() {\n        if bracket == '[' {\n\
    \            count += 1;\n        } else if bracket == ']' {\n            count\
    \ -= 1;\n        }\n        if count < 0 {\n            return false;\n      \
    \  }\n        if previous == '[' && bracket == ']' {\n            return true;\n\
    \        }\n        previous = bracket;\n    }\n    return false;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptmok9k_m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else if c == ']'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpza2dc12n.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut diff = 0;\n    for ch in chars {\n        if ch == '[' {\n      \
    \      diff += 1;\n        } else {\n            diff -= 1;\n        }\n     \
    \   if diff < 0 {\n            return false;\n        }\n    }\n    diff > 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8ppbyfxh.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut levels = 0;\n    for c in\
    \ string.chars() {\n        match c {\n            '[' => levels += 1,\n     \
    \       ']' => {\n                if levels == 0 {\n                    return\
    \ false;\n                }\n                levels -= 1;\n            }\n   \
    \         _ => return false,\n        }\n    }\n    levels > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmproou4e_w.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Input string contains invalid characters!\"\
    ),\n        }\n    }\n    return false;\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpna6hq3u5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfflnr4vx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut stack = vec![];\n\tfor c in\
    \ string.chars() {\n\t\tif c == '[' {\n\t\t\tstack.push(c);\n\t\t} else if c ==\
    \ ']' {\n\t\t\tif let Some(x) = stack.pop() {\n\t\t\t\tif x != '[' {\n\t\t\t\t\
    \treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\
    \t}\n\t}\n\tstack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnniuq149.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Vars\n    let mut counter: i8 =\
    \ 0;\n    // Loop through string chars\n    for c in string.chars() {\n      \
    \  if c == '[' {\n            counter += 1;\n        } else if c == ']' {\n  \
    \          counter -= 1;\n        }\n        // If ever we have a negative counter,\
    \ we have a bad sequence\n        if counter < 0 {\n            return false;\n\
    \        }\n    }\n    // If we end up at 0, it's all good\n    counter == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkh5dtpd3.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut index = 0;\n    let mut level\
    \ = 0;\n    let mut found_nesting = false;\n    for c in string.chars() {\n  \
    \      if c == '[' {\n            if level == 0 {\n                index += 1;\n\
    \            }\n            level += 1;\n        } else if c == ']' {\n      \
    \      level -= 1;\n            if level == 0 {\n                if index > 1\
    \ {\n                    found_nesting = true;\n                }\n          \
    \      index = 0;\n            }\n        }\n    }\n    return found_nesting;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphrcpr7pi.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut found_nesting\
    \ = false;\n    for c in string.chars() {\n        match c {\n            '['\
    \ => {\n                depth += 1;\n                if depth == 2 {\n       \
    \             found_nesting = true;\n                }\n            },\n     \
    \       ']' => {\n                depth -= 1;\n                if depth == 0 {\n\
    \                    break;\n                }\n            },\n            _\
    \ => {},\n        }\n    }\n    found_nesting && depth == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpawko_w_a.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut has_opening = false;\n   \
    \ let mut has_nested = false;\n    let mut stack = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack += 1;\n            has_opening =\
    \ true;\n        } else {\n            stack -= 1;\n            if stack < 0 {\n\
    \                break;\n            }\n            if stack > 0 {\n         \
    \       has_nested = true;\n            }\n        }\n    }\n    has_opening &&\
    \ has_nested && stack == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpecfls6br.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphnyhe_hp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    return false;\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfflnr4vx.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ character in string.chars() {\n        match character {\n            '[' =>\
    \ stack.push(character),\n            ']' => match stack.pop() {\n           \
    \     Some(_) => (),\n                None => return false,\n            },\n\
    \            _ => (),\n        }\n    }\n    return stack.is_empty();\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp08qcikj5.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    is_match_helper(string.chars())\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_match_helper` in this scope\n  -->\
    \ /tmp/tmpacqf0_x7.rs:17:5\n   |\n17 |     is_match_helper(string.chars())\n \
    \  |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets = Vec::new();\n \
    \   for char in string.chars() {\n        if char == '[' {\n            brackets.push(char);\n\
    \        } else if char == ']' {\n            if brackets.is_empty() {\n     \
    \           return false;\n            }\n            brackets.pop();\n      \
    \  }\n    }\n    !brackets.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwhtb2hm9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    is_nested_impl(string.chars())\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_nested_impl` in this scope\n  -->\
    \ /tmp/tmpa43a2uwy.rs:17:5\n   |\n17 |     is_nested_impl(string.chars())\n  \
    \ |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                if let Some('[') = stack.pop() {\n    \
    \                continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => (),\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe_3zirng.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // your code goes here\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvf99tllx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.len() == 0 {\n               \
    \     return false;\n                }\n                if stack.pop().unwrap()\
    \ != '[' {\n                    return false;\n                }\n           \
    \ }\n            _ => return false,\n        }\n    }\n    return stack.len()\
    \ == 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp231tfbw0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    is_nested_helper(string.as_str(),\
    \ false)\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_nested_helper` in this scope\n \
    \ --> /tmp/tmpasr154xq.rs:17:5\n   |\n17 |     is_nested_helper(string.as_str(),\
    \ false)\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut open = 0;\n    let mut close\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            open\
    \ += 1;\n        } else if c == ']' {\n            close += 1;\n        }\n  \
    \      if close > open {\n            return false;\n        }\n    }\n    open\
    \ > 0 && open == close\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzfpe33_1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let char_vec: Vec<char> = string.chars().collect();\n\
    \    let mut has_nested = false;\n    let mut open_counter = 0;\n    let mut curr_nest_level\
    \ = 0;\n    let mut prev_nest_level = 0;\n    for char in char_vec {\n       \
    \ if char == '[' {\n            open_counter += 1;\n            prev_nest_level\
    \ = curr_nest_level;\n            curr_nest_level = open_counter;\n          \
    \  if curr_nest_level > prev_nest_level {\n                has_nested = true;\n\
    \            }\n        } else {\n            open_counter -= 1;\n        }\n\
    \    }\n    has_nested && open_counter == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_swdvfjp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(0, |acc, c| {\n\
    \        let x = match c {\n            '[' => acc + 1,\n            ']' => acc\
    \ - 1,\n            _ => unreachable!()\n        };\n        if x < 0 {\n    \
    \        0\n        } else {\n            x\n        }\n    }) != 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcagz09ri.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut char_vec: Vec<char> = string.chars().collect();\n\
    \    let mut count = 0;\n    for c in char_vec {\n        if c == '[' {\n    \
    \        count += 1;\n        } else if c == ']' {\n            count -= 1;\n\
    \        }\n        if count < 0 {\n            return false;\n        }\n   \
    \ }\n    return count != 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2f2o8cse.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut current_nesting = 0;\n   \
    \ let mut max_nesting = 0;\n    for ch in string.chars() {\n        if ch == '['\
    \ {\n            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else {\n            current_nesting -= 1;\n        }\n    }\n    return max_nesting\
    \ > 1;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp98hai2z6.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut current_deep = 0;\n    let\
    \ mut max_deep = 0;\n    for ch in string.chars() {\n        if ch == '[' {\n\
    \            current_deep += 1;\n            if current_deep > max_deep {\n  \
    \              max_deep = current_deep;\n            }\n        } else {\n   \
    \         current_deep -= 1;\n        }\n    }\n    max_deep > 1\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp7maq5u6.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets = String::new();\n\
    \    for i in string.chars() {\n        if is_open_bracket(i) {\n            brackets.push(i);\n\
    \        } else if is_close_bracket(i) {\n            if let Some(top) = brackets.pop()\
    \ {\n                if top != get_open_bracket(i) {\n                    return\
    \ false;\n                }\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    brackets.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_open_bracket` in this scope\n  -->\
    \ /tmp/tmpn6rhiyny.rs:19:12\n   |\n19 |         if is_open_bracket(i) {\n   |\
    \            ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_close_bracket` in this scope\n  --> /tmp/tmpn6rhiyny.rs:21:19\n\
    \   |\n21 |         } else if is_close_bracket(i) {\n   |                   ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `get_open_bracket`\
    \ in this scope\n  --> /tmp/tmpn6rhiyny.rs:23:27\n   |\n23 |                 if\
    \ top != get_open_bracket(i) {\n   |                           ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            match stack.pop() {\n                Some(_) =>\
    \ continue,\n                None => return false,\n            }\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvw1g4wo7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    fn is_nested_inner(string: &str, n_open:\
    \ usize, n_closed: usize) -> bool {\n        let mut iter = string.chars();\n\
    \        if let Some(c) = iter.next() {\n            match c {\n             \
    \   '[' => {\n                    if n_open == 0 {\n                        if\
    \ let Some(next) = iter.next() {\n                            if next == ']' {\n\
    \                                return true;\n                            }\n\
    \                        }\n                    }\n                    is_nested_inner(&iter.as_str(),\
    \ n_open + 1, n_closed)\n                }\n                ']' => {\n       \
    \             is_nested_inner(&iter.as_str(), n_open, n_closed + 1)\n        \
    \        }\n                _ => false,\n            }\n        } else {\n   \
    \         false\n        }\n    }\n    is_nested_inner(&string, 0, 0)\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnkmxvirj.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    let mut is_nested\
    \ = false;\n    for character in string.chars() {\n        match character {\n\
    \            '[' => {\n                if count == 0 {\n                    is_nested\
    \ = true;\n                }\n                count += 1;\n            },\n  \
    \          ']' => {\n                count -= 1;\n            },\n           \
    \ _ => {\n                println!(\"No characters allowed other than square brackets.\"\
    );\n                return false;\n            }\n        }\n    }\n    is_nested\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpysr2u8gi.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Complete this function\n    let\
    \ mut test_stack = Vec::new();\n    let mut exit = false;\n    for char in string.chars()\
    \ {\n        if char == '[' {\n            test_stack.push(char);\n        } else\
    \ if char == ']' {\n            if test_stack.is_empty() {\n                return\
    \ false;\n            } else {\n                test_stack.pop();\n          \
    \  }\n        }\n    }\n    if test_stack.is_empty() {\n        exit = true;\n\
    \    }\n    return exit;\n}\n\nfn main() {\n    let candidate = is_nested;\n \
    \   assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgiz8fyxu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut squares = 0;\n    let mut\
    \ nested = false;\n    for x in string.chars() {\n        if x == '[' {\n    \
    \        squares += 1;\n        } else if x == ']' {\n            squares -= 1;\n\
    \        }\n        if squares < 0 {\n            break;\n        }\n        if\
    \ squares > 0 {\n            nested = true;\n        }\n    }\n    return nested\
    \ && squares == 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl73yuw87.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut balance = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            balance += 1;\n       \
    \ } else if c == ']' {\n            balance -= 1;\n        }\n        if balance\
    \ < 0 {\n            return false;\n        }\n    }\n    balance > 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzve9m6w6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for c in string.chars() {\n        match c {\n            '[' => stack.push(1),\n\
    \            ']' => match stack.pop() {\n                Some(_) => (),\n    \
    \            None => return false,\n            },\n            _ => (),\n   \
    \     }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpc7qjov32.rs:17:21\n   |\n17 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut single_open = 0;\n    let mut single_close = 0;\n    let mut state = State::Empty;\n\
    \    for ch in string.chars() {\n        match state {\n            State::Empty\
    \ => {\n                match ch {\n                    '[' => {\n           \
    \             single_open += 1;\n                        stack.push(ch);\n   \
    \                     state = State::Open;\n                    }\n          \
    \          _ => panic!(\"Invalid character encountered {}\", ch),\n          \
    \      }\n            }\n            State::Open => {\n                match ch\
    \ {\n                    '[' => {\n                        single_open += 1;\n\
    \                        stack.push(ch);\n                    }\n            \
    \        ']' => {\n                        single_close += 1;\n              \
    \          state = match stack.pop() {\n                            Some(value)\
    \ => match value {\n                                '[' => State::Nested,\n  \
    \                              _ => panic!(\"Invalid character encountered\"),\n\
    \                            },\n                            None => panic!(\"\
    Invalid character encountered\"),\n                        };\n              \
    \      }\n                    _ => panic!(\"Invalid character encountered {}\"\
    , ch),\n                }\n            }\n            State::Nested => {\n   \
    \             match ch {\n                    '[' => {\n                     \
    \   single_open += 1;\n                        stack.push(ch);\n             \
    \           state = State::Open;\n                    }\n                    ']'\
    \ => {\n                        single_close += 1;\n                        state\
    \ = match stack.pop() {\n                            Some(value) => match value\
    \ {\n                                '[' => State::Nested,\n                 \
    \               _ => panic!(\"Invalid character encountered\"),\n            \
    \                },\n                            None => panic!(\"Invalid character\
    \ encountered\"),\n                        };\n                    }\n       \
    \             _ => panic!(\"Invalid character encountered {}\", ch),\n       \
    \         }\n            }\n        }\n    }\n    match (single_open, single_close,\
    \ state) {\n        (1, 1, State::Nested) => true,\n        _ => false,\n    }\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `State`\n  -->\
    \ /tmp/tmpak460_gu.rs:20:21\n   |\n20 |     let mut state = State::Empty;\n  \
    \ |                     ^^^^^ use of undeclared type `State`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `State`\n  --> /tmp/tmpak460_gu.rs:23:13\n\
    \   |\n23 |             State::Empty => {\n   |             ^^^^^ use of undeclared\
    \ type `State`\n\nerror[E0433]: failed to resolve: use of undeclared type `State`\n\
    \  --> /tmp/tmpak460_gu.rs:28:33\n   |\n28 |                         state = State::Open;\n\
    \   |                                 ^^^^^ use of undeclared type `State`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `State`\n  --> /tmp/tmpak460_gu.rs:33:13\n\
    \   |\n33 |             State::Open => {\n   |             ^^^^^ use of undeclared\
    \ type `State`\n\nerror[E0433]: failed to resolve: use of undeclared type `State`\n\
    \  --> /tmp/tmpak460_gu.rs:43:40\n   |\n43 | ...                   '[' => State::Nested,\n\
    \   |                              ^^^^^ use of undeclared type `State`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `State`\n  --> /tmp/tmpak460_gu.rs:52:13\n\
    \   |\n52 |             State::Nested => {\n   |             ^^^^^ use of undeclared\
    \ type `State`\n\nerror[E0433]: failed to resolve: use of undeclared type `State`\n\
    \  --> /tmp/tmpak460_gu.rs:57:33\n   |\n57 |                         state = State::Open;\n\
    \   |                                 ^^^^^ use of undeclared type `State`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `State`\n  --> /tmp/tmpak460_gu.rs:63:40\n\
    \   |\n63 | ...                   '[' => State::Nested,\n   |                \
    \              ^^^^^ use of undeclared type `State`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `State`\n  --> /tmp/tmpak460_gu.rs:75:16\n \
    \  |\n75 |         (1, 1, State::Nested) => true,\n   |                ^^^^^ use\
    \ of undeclared type `State`\n\nerror: aborting due to 9 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(\n        (true,\
    \ Vec::new()),\n        |(valid, mut stack), c| match c {\n            '[' =>\
    \ {\n                stack.push(c);\n                (valid, stack)\n        \
    \    }\n            ']' => if stack.is_empty() {\n                (false, stack)\n\
    \            } else {\n                stack.pop();\n                (valid, stack)\n\
    \            },\n            _ => (valid, stack),\n        },\n    )\n    .0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwrtkfwoh.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO: implement me!\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqiqptsva.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut left = 0;\n    let mut right\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            left\
    \ += 1;\n        } else {\n            right += 1;\n        }\n        if right\
    \ > left {\n            return false;\n        }\n    }\n    left > right\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmlepwwdc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO: implement this function\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_nested;\n   \
    \ assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4cjshgb1.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut opening_brackets = 0;\n  \
    \  let mut nested = false;\n    for c in string.chars() {\n        if c == '['\
    \ {\n            opening_brackets += 1;\n        } else if c == ']' {\n      \
    \      if opening_brackets > 0 {\n                nested = true;\n           \
    \ }\n            opening_brackets -= 1;\n        }\n    }\n    nested\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2bc0lr25.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            stack.push(i);\n \
    \       } else if i == ']' {\n            if stack.is_empty() {\n            \
    \    return false;\n            } else {\n                stack.pop();\n     \
    \       }\n        }\n    }\n    return stack.is_empty();\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi0slckqz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut open = 0;\n    let mut close\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            open\
    \ += 1;\n        } else if c == ']' {\n            close += 1;\n        }\n  \
    \      if close > open {\n            return false;\n        }\n    }\n    open\
    \ != close\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp67u328dz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for b\
    \ in string.chars() {\n        match b {\n            '[' => stack.push(b),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => unreachable!(),\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp13xatqos.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe5bxpvn0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Split the input string into a stack\
    \ of characters.\n    let mut stack: Vec<char> = string.chars().collect();\n \
    \   // Pop from the stack in reverse order.\n    while let Some(c) = stack.pop()\
    \ {\n        // If the character is an opening bracket, then search for the matching\
    \ closing bracket.\n        if c == '[' {\n            let mut count = 0;\n  \
    \          for c2 in stack.iter().rev() {\n                if *c2 == ']' {\n \
    \                   count += 1;\n                } else {\n                  \
    \  // If there is a closing bracket before the first opening bracket, then the\n\
    \                    // string is not nested.\n                    if count >\
    \ 0 {\n                        return false;\n                    }\n        \
    \        }\n            }\n            // If there is not a closing bracket, then\
    \ the string is not nested.\n            if count == 0 {\n                return\
    \ false;\n            }\n        }\n    }\n    // If the stack is empty, then\
    \ the string is valid.\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdwuhqb7r.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for i in string.chars()\
    \ {\n        if i == '[' {\n            count += 1;\n        } else if i == ']'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    if count == 0 {\n        return true;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphbddsflc.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 {\n        return\
    \ false;\n    }\n\n    let mut stack = Vec::new();\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack.push(c);\n        } else if c ==\
    \ ']' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n\n    return stack.len() == 0;\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjlukimi5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Find the last relevant index.\n\
    \    let last_index = string.rfind(\"[\").unwrap_or(0);\n    let slice = &string[..last_index\
    \ + 1];\n    let mut stack = Vec::new();\n    for c in slice.chars() {\n     \
    \   if c == '[' {\n            stack.push(c);\n        } else {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   stack.pop();\n        }\n    }\n    !stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4bhahabz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut start\
    \ = None;\n    for i in 0..string.len() {\n        match string.chars().nth(i).unwrap()\
    \ {\n            '[' => {\n                if depth == 0 {\n                 \
    \   start = Some(i);\n                }\n                depth += 1;\n       \
    \     },\n            ']' => {\n                depth -= 1;\n                if\
    \ depth == 0 {\n                    return is_nested(string[start.unwrap()+1..i].to_string())\n\
    \                        || is_nested(string[i+1..].to_string());\n          \
    \      }\n            },\n            _ => (),\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4ur36tkf.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut nested = 0;\n    for char\
    \ in string.chars() {\n        match char {\n            '[' => nested += 1,\n\
    \            ']' => nested -= 1,\n            _ => ()\n        }\n        if nested\
    \ < 0 {\n            return false;\n        }\n    }\n    if nested > 0 {\n  \
    \      return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx2dozgmh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                if stack.pop().unwrap()\
    \ != '[' {\n                    return false;\n                }\n           \
    \ }\n            _ => return false,\n        }\n    }\n    if stack.is_empty()\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu2qa7xps.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ (i, c) in string.chars().enumerate() {\n        if c == '[' {\n            stack.push((i,\
    \ '['))\n        } else if c == ']' {\n            if let Some(j) = stack.iter().rev().position(|(_,\
    \ s)| *s == '[') {\n                stack.remove(stack.len() - 1 - j);\n     \
    \       } else {\n                return false;\n            }\n        }\n  \
    \  }\n    if let Some(j) = stack.iter().rev().position(|(_, s)| *s == '[') {\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp38vlqslo.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.pop() != Some('[') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1zu1nuyt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for x in string.chars()\
    \ {\n        match x {\n            '[' => count += 1,\n            ']' => count\
    \ -= 1,\n            _ => continue,\n        }\n        if count < 0 {\n     \
    \       return false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprnhybpcz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut levels = 0;\n    for c in\
    \ string.chars() {\n        match c {\n            '[' => levels += 1,\n     \
    \       ']' => levels -= 1,\n            _ => continue,\n        }\n        if\
    \ levels == 0 {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp36v0_mj3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphnyhe_hp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut brackets: Vec<char> = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            brackets.push(c);\n\
    \        } else if c == ']' {\n            if brackets.len() > 0 {\n         \
    \       brackets.pop();\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    return brackets.len() == 0;\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpixr0ez4i.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: -1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // type of brackets\n    enum Bracket\
    \ {\n        Opened,\n        Closed,\n    }\n\n    // get bracket type\n    fn\
    \ get_bracket_type(character: char) -> Bracket {\n        match character {\n\
    \            '[' => Bracket::Opened,\n            ']' => Bracket::Closed,\n  \
    \          _ => panic!(\"Invalid character\"),\n        }\n    }\n\n    // checks\
    \ if brackets are nested. returns false if not, or offset of closed bracket if\
    \ yes\n    fn check_brackets(string: &[char]) -> Option<usize> {\n        let\
    \ mut position = 0;\n        let mut depth = 0;\n        for character in string\
    \ {\n            match get_bracket_type(*character) {\n                Bracket::Opened\
    \ => depth += 1,\n                Bracket::Closed => {\n                    if\
    \ depth > 0 {\n                        depth -= 1;\n                    } else\
    \ {\n                        return None;\n                    }\n           \
    \     }\n            }\n            position += 1;\n        }\n        if depth\
    \ == 0 {\n            Some(position)\n        } else {\n            None\n   \
    \     }\n    }\n\n    // convert string to vector of characters\n    let mut chars:\
    \ Vec<char> = string.chars().collect();\n\n    // check if brackets are nested.\
    \ remove them if yes\n    while let Some(offset) = check_brackets(&chars) {\n\
    \        chars.drain(..offset);\n    }\n\n    // if all brackets were nested,\
    \ we should have no characters left\n    chars.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010693
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => return false,\n        }\n\
    \    }\n    if stack.is_empty() {\n        return false;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0as1jwx6.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Stack::new();\n  \
    \  for bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmptwjplkvq.rs:17:21\n   |\n17 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            count += 1;\n        } else if c == ']'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9lj6jmc_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  !stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_6_um6to.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            depth += 1;\n        } else if c == ']'\
    \ {\n            depth -= 1;\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n    }\n    depth > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfqvt8_68.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let char_vec: Vec<char> = string.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    for c in char_vec {\n       \
    \ if c == '[' {\n            stack.push(c);\n        } else if c == ']' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\
    \ else {\n                stack.pop();\n            }\n        }\n    }\n    if\
    \ stack.len() == 0 {\n        return true;\n    } else {\n        return false;\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqrmkrovb.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    let mut to_be_nested = false;\n\
    \    for c in chars {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \                to_be_nested = true;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    to_be_nested\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpijpbnhpl.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut _is_nested = false;\n    for\
    \ i in 0..string.len() {\n        for j in i+1..string.len() {\n            let\
    \ mut is_nested = true;\n            for k in i..j {\n                if string.chars().nth(k).unwrap()\
    \ == '[' && string.chars().nth(k+1).unwrap() == ']' {\n                    is_nested\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         if is_nested {\n                _is_nested = true;\n               \
    \ break;\n            }\n        }\n        if _is_nested {\n            break;\n\
    \        }\n    }\n    _is_nested\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxgstom9z.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut is_nested = false;\n    let\
    \ mut opens = Vec::new();\n    for ch in string.chars() {\n        match ch {\n\
    \            '[' => opens.push(ch),\n            ']' => {\n                if\
    \ opens.len() > 0 {\n                    is_nested = true;\n                 \
    \   opens.pop();\n                }\n            }\n            _ => {}\n    \
    \    }\n    }\n    is_nested\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiqf8f58s.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Brute force approach - try every\
    \ subsequence and attempt to match\n    // with valid patterns\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprs3tdc92.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut vec: Vec<char> = Vec::new();\n\
    \    for x in string.chars() {\n        if x == '[' {\n            vec.push(x);\n\
    \        } else if x == ']' {\n            match vec.pop() {\n               \
    \ Some(_) => (),\n                None => return false,\n            }\n     \
    \   }\n    }\n    return vec.is_empty();\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprbl94070.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count: i32 = 0;\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            count += 1;\n      \
    \  } else if c == ']' {\n            count -= 1;\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    return count > 0;\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7zv03_6v.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ bracket in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if let Some(top) = stack.pop() {\n            \
    \    if top != '[' {\n                    return false;\n                }\n \
    \           } else {\n                return false;\n            }\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp894shc8a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for ch in\
    \ string.chars() {\n        if ch == '[' {\n            depth += 1;\n        }\
    \ else if ch == ']' {\n            depth -= 1;\n        }\n        if depth ==\
    \ 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxbt5xil_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // TODO: Implement\n\n    true\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjsgfsq2p.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for x in string.chars()\
    \ {\n        if x == '[' {\n            count += 1;\n        } else if x == ']'\
    \ {\n            count -= 1;\n        }\n        if count < 0 {\n            return\
    \ false;\n        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx3pihl3z.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n\tlet mut queue: Vec<char> = Vec::new();\n\
    \tfor letter in string.chars() {\n\t\tif letter == '[' {\n\t\t\tqueue.push(letter);\n\
    \t\t} else if letter == ']' {\n\t\t\tif queue.is_empty() {\n\t\t\t\treturn false;\n\
    \t\t\t} else {\n\t\t\t\tlet popped = queue.pop().unwrap();\n\t\t\t\tif popped\
    \ != '[' {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ true;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpitvs4v84.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut sequence = Vec::new();\n \
    \   for c in string.chars() {\n        match c {\n            '[' => sequence.push(c),\n\
    \            ']' => {\n                if sequence.is_empty() {\n            \
    \        return false;\n                } else {\n                    sequence.pop();\n\
    \                }\n            }\n            _ => panic!(\"Input contains invalid\
    \ characters\"),\n        }\n    }\n    sequence.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpognjweu7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj2tune48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for bracket\
    \ in string.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            let top = stack.pop().unwrap();\n            if top\
    \ != '[' {\n                return false;\n            }\n        }\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcn7wbp_0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 {\n        return\
    \ false;\n    }\n    let mut stack = Vec::new();\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack.push(c);\n        } else {\n   \
    \         if stack.len() > 0 {\n                stack.pop();\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    stack.len()\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxiyt53tt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut has_nesting\
    \ = false;\n    for c in string.chars() {\n        match c {\n            '['\
    \ => {\n                depth += 1;\n                if depth > 1 {\n        \
    \            has_nesting = true;\n                }\n            },\n        \
    \    ']' => {\n                depth -= 1;\n            },\n            _ => {},\n\
    \        }\n    }\n    has_nesting && depth == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq8w5nv6o.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for char in\
    \ string.chars() {\n        if char == '[' {\n            count += 1;\n      \
    \  } else if char == ']' {\n            count -= 1;\n        }\n        if count\
    \ < 0 {\n            return false;\n        }\n    }\n    count > 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr_k6zaxe.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj2tune48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    fn match_char(c: char) -> bool {\n\
    \        c == '[' || c == ']'\n    }\n\n    fn inverse_char(c: char) -> char {\n\
    \        match c {\n            '[' => ']',\n            ']' => '[',\n       \
    \     _ => '\\0',\n        }\n    }\n\n    // String method \"chars\" returns\
    \ an iterator, which evaluates on demand.\n    let mut stack: Vec<char> = string.chars().filter(match_char).collect();\n\
    \n    // If the length of the list is odd, \n    // the first and last elements\
    \ will not be equal.\n    if stack.len() % 2 != 0 {\n        return false;\n \
    \   }\n\n    // Iterate the list, remove characters that are the inverse of each\
    \ other.\n    loop {\n        let mut previous_stack_len = stack.len();\n    \
    \    stack = stack.windows(2).filter(|&w| w[0] != inverse_char(w[1])).flatten().collect();\n\
    \        if stack.len() == previous_stack_len {\n            break;\n        }\n\
    \    }\n\n    // The final stack length should be 0\n    stack.len() == 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0631]: type mismatch in function arguments\n   --> /tmp/tmp88515pla.rs:30:54\n\
    \    |\n17  |     fn match_char(c: char) -> bool {\n    |     ------------------------------\
    \ found signature of `fn(char) -> _`\n...\n30  |     let mut stack: Vec<char>\
    \ = string.chars().filter(match_char).collect();\n    |                      \
    \                         ------ ^^^^^^^^^^ expected signature of `for<'r> fn(&'r\
    \ char) -> _`\n    |                                               |\n    |  \
    \                                             required by a bound introduced by\
    \ this call\n    |\nnote: required by a bound in `filter`\n\nerror[E0599]: the\
    \ method `collect` exists for struct `Filter<Chars<'_>, fn(char) -> bool {match_char}>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp88515pla.rs:30:66\n \
    \  |\n30 |       let mut stack: Vec<char> = string.chars().filter(match_char).collect();\n\
    \   |                                                                    ^^^^^^^\
    \ method cannot be called on `Filter<Chars<'_>, fn(char) -> bool {match_char}>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<fn(char) -> bool {match_char} as FnOnce<(&char,)>>::Output\
    \ = bool`\n           which is required by `Filter<Chars<'_>, fn(char) -> bool\
    \ {match_char}>: Iterator`\n           `fn(char) -> bool {match_char}: FnMut<(&char,)>`\n\
    \           which is required by `Filter<Chars<'_>, fn(char) -> bool {match_char}>:\
    \ Iterator`\n           `Filter<Chars<'_>, fn(char) -> bool {match_char}>: Iterator`\n\
    \           which is required by `&mut Filter<Chars<'_>, fn(char) -> bool {match_char}>:\
    \ Iterator`\n\nerror[E0277]: a value of type `Vec<char>` cannot be built from\
    \ an iterator over elements of type `&char`\n    --> /tmp/tmp88515pla.rs:41:84\n\
    \     |\n41   |         stack = stack.windows(2).filter(|&w| w[0] != inverse_char(w[1])).flatten().collect();\n\
    \     |                                                                      \
    \              ^^^^^^^ value of type `Vec<char>` cannot be built from `std::iter::Iterator<Item=&char>"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => {\n                if let Some(_) = stack.pop() {\n      \
    \              continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => continue,\n     \
    \   }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplu6krfgm.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    for character\
    \ in string.chars() {\n        if character == '[' {\n            depth += 1;\n\
    \        } else if character == ']' {\n            depth -= 1;\n        }\n  \
    \      if depth < 0 {\n            return false;\n        }\n    }\n    depth\
    \ > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjy_nxhfk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(vec![], |mut stack,\
    \ c| {\n        match c {\n            '[' => stack.push(c),\n            ']'\
    \ => {\n                match stack.pop() {\n                    Some('[') =>\
    \ (),\n                    _ => stack.push(c),\n                }\n          \
    \  }\n            _ => (),\n        }\n        stack\n    }).len() == 0\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpabom6rab.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Write your code here\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptk119unx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ ch in string.chars() {\n        match ch {\n            '[' => stack.push(ch),\n\
    \            ']' => match stack.pop() {\n                Some('[') => (),\n  \
    \              Some(_) => return false,\n                None => return false,\n\
    \            },\n            _ => (),\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1o0uzsms.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpocs9e1fq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010687
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    // Your code here\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmptd1ztj1a.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.pop() != Some('[') {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ (),\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1zu1nuyt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj2tune48.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for b\
    \ in string.chars() {\n        match b {\n            '[' => stack.push(b),\n\
    \            ']' => {\n                if let Some(_) = stack.pop() {\n      \
    \              continue;\n                } else {\n                    return\
    \ false;\n                }\n            }\n            _ => {\n             \
    \   return false;\n            }\n        }\n    }\n    return stack.is_empty();\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxvwzeooj.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    !stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6d9l0a2u.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ i in string.chars() {\n        if i == '[' {\n            stack.push(i);\n \
    \       } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    !stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp31orqr0_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010689
