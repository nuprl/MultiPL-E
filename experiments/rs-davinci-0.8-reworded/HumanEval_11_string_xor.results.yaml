language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let xored = xor(Vec::from(a.as_bytes()), Vec::from(b.as_bytes()));\n\
    \    String::from_utf8(xored).unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpol8bam8_.rs:6:17\n\
    \  |\n6 |     let xored = xor(Vec::from(a.as_bytes()), Vec::from(b.as_bytes()));\n\
    \  |                 ^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822350
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    let c_bytes = xor(&a_bytes, &b_bytes);\n    String::from_utf8(c_bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpp0kixomj.rs:8:19\n\
    \  |\n8 |     let c_bytes = xor(&a_bytes, &b_bytes);\n  |                   ^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822350
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let n = a.len();\n\
    \    assert_eq!(n, b.len());\n    for i in 0..n {\n        let bit_a = a.chars().nth(i).unwrap();\n\
    \        let bit_b = b.chars().nth(i).unwrap();\n        let bit_c = match (bit_a,\
    \ bit_b) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n \
    \           ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => panic!(\"invalid input\"),\n        };\n        result.push(bit_c);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.into_bytes()\n        .iter()\n        .zip(b.into_bytes().iter())\n\
    \        .map(|(x, y)| x ^ y)\n        .map(|i| i.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut out = Vec::with_capacity(a.len());\n   \
    \ for (c1, c2) in a.chars().zip(b.chars()) {\n        out.push(match (c1, c2)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"\
    invalid input\"),\n        });\n    }\n    out.iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822350
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n\
    \    let mut max_size = a.len();\n    if b.len() > max_size {\n        max_size\
    \ = b.len();\n    }\n    let mut res = Vec::with_capacity(max_size);\n    for\
    \ i in 0..max_size {\n        let (a_byte, b_byte) = if i >= a.len() {\n     \
    \       (0, b[i])\n        } else if i >= b.len() {\n            (a[i], 0)\n \
    \       } else {\n            (a[i], b[i])\n        };\n        let out = match\
    \ (a_byte, b_byte) {\n            (48, 48) => String::from(\"0\"),\n         \
    \   (48, 49) => String::from(\"1\"),\n            (49, 48) => String::from(\"\
    1\"),\n            (49, 49) => String::from(\"0\"),\n            (_, _) => panic!(\"\
    WAT?\"),\n        };\n        res.push(out.as_bytes()[0]);\n    }\n    return\
    \ String::from_utf8(res).unwrap();\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822350
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    for (c1, c2) in\
    \ a.chars().zip(b.chars()) {\n        let x = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n\
    \        ret.push_str(&x.to_string());\n    }\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8>\
    \ = b.into_bytes();\n    let c: Vec<u8> = a.iter().zip(b.iter()).map(|(x, y)|\
    \ x ^ y).collect();\n    String::from_utf8(c).unwrap()\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpyu0irygl.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        let v1 = c1.to_digit(10).unwrap();\n\
    \        let v2 = c2.to_digit(10).unwrap();\n        result.push_str(&(v1 ^ v2).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() != b.len() {\n        return String::from(\"\
    error\");\n    }\n    let mut r = String::new();\n    for c in a.chars().zip(b.chars())\
    \ {\n        r.push(match c {\n            (x, y) if x == y => '0',\n        \
    \    _ => '1',\n        });\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(l,\
    \ r)| if l == r { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let x = hex::decode(a).unwrap();\n    let y = hex::decode(b).unwrap();\n\
    \    hex::encode(xor(&x, &y))\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hex`\n\
    \ --> /tmp/tmpcr2q3w4m.rs:6:13\n  |\n6 |     let x = hex::decode(a).unwrap();\n\
    \  |             ^^^ use of undeclared crate or module `hex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `hex`\n --> /tmp/tmpcr2q3w4m.rs:7:13\n\
    \  |\n7 |     let y = hex::decode(b).unwrap();\n  |             ^^^ use of undeclared\
    \ crate or module `hex`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `hex`\n --> /tmp/tmpcr2q3w4m.rs:8:5\n  |\n8 |     hex::encode(xor(&x,\
    \ &y))\n  |     ^^^ use of undeclared crate or module `hex`\n\nerror[E0425]: cannot\
    \ find function `xor` in this scope\n --> /tmp/tmpcr2q3w4m.rs:8:17\n  |\n8 | \
    \    hex::encode(xor(&x, &y))\n  |                 ^^^ not found in this scope\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822350
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a = a.as_bytes();\n\
    \    let b = b.as_bytes();\n    for (a, b) in a.iter().zip(b.iter()) {\n     \
    \   result.push(format!(\"{:x}\", a ^ b)[3..4].to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwlgck5f_.rs:10:21\n   |\n\
    10 |         result.push(format!(\"{:x}\", a ^ b)[3..4].to_string());\n   |  \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822350
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwh18re0.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut binary = String::new();\n    let a_chars:\
    \ Vec<char> = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\
    \    for i in 0..a_chars.len() {\n        if a_chars[i] == b_chars[i] {\n    \
    \        binary.push('0');\n        } else {\n            binary.push('1');\n\
    \        }\n    }\n    binary\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for (i, j) in\
    \ a.chars().zip(b.chars()) {\n        res.push(if i == j { '0' } else { '1' });\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    let length = a_bytes.len();\n    let mut output = Vec::with_capacity(length);\n\
    \    for i in 0..length {\n        let result = a_bytes[i] ^ b_bytes[i];\n   \
    \     output.push(result);\n    }\n    String::from_utf8(output).unwrap()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpfw3tusp3.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"Sizes\
    \ do not match!\");\n    }\n    let mut output = Vec::new();\n    for (bit_a,\
    \ bit_b) in a.chars().zip(b.chars()) {\n        if bit_a == bit_b {\n        \
    \    output.push('0');\n        } else {\n            output.push('1');\n    \
    \    }\n    }\n    return output.iter().collect();\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    let mut xor_str = String::new();\n    loop {\n        let\
    \ a_char = a_chars.next();\n        let b_char = b_chars.next();\n        match\
    \ (a_char, b_char) {\n            (Some(a_char), Some(b_char)) => {\n        \
    \        xor_str.push(match (a_char, b_char) {\n                    ('0', '0')\
    \ => '0',\n                    ('0', '1') => '1',\n                    ('1', '0')\
    \ => '1',\n                    ('1', '1') => '0',\n                    _ => unreachable!(),\n\
    \                });\n            }\n            (None, None) => break,\n    \
    \        _ => panic!(),\n        }\n    }\n    xor_str\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut v1 = a.chars().map(|c| c.to_digit(10).unwrap());\n\
    \    let mut v2 = b.chars().map(|c| c.to_digit(10).unwrap());\n    let mut v =\
    \ Vec::new();\n    while let (Some(x), Some(y)) = (v1.next(), v2.next()) {\n \
    \       v.push(x ^ y);\n    }\n    v.iter().map(|&i| i.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut bin_a = String::new();\n    let mut bin_b\
    \ = String::new();\n    let mut res = String::new();\n\n    for i in a.chars()\
    \ {\n        bin_a.push(i);\n    }\n    for i in b.chars() {\n        bin_b.push(i);\n\
    \    }\n\n    for i in 0..bin_a.len() {\n        if bin_a.chars().nth(i) == bin_b.chars().nth(i)\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    assert!(a.is_ascii());\n\
    \    assert!(b.is_ascii());\n    assert!(a.len() > 0);\n    let mut res = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n         \
    \   res.push('0');\n        } else {\n            res.push('1');\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| (x, y).into())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmplo90rvn7.rs:8:10\n\
    \  |\n8 |         .map(|(x, y)| (x, y).into())\n  |          ^^^          -------------\
    \ this method call resolves to `T`\n  |          |\n  |          cannot infer\
    \ type for type parameter `B` declared on the associated function `map`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = \"\".to_string();\n    for i in\
    \ 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for (x, y) in\
    \ a.chars().zip(b.chars()) {\n        res.push(match (x, y) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Both a and b must be\
    \ string with only 1s and 0s\"),\n        });\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut xor =\
    \ String::new();\n    for (ab, bb) in a.chars().zip(b.chars()) {\n        match\
    \ (ab, bb) {\n            ('0', '0') => xor.push('0'),\n            ('0', '1')\
    \ => xor.push('1'),\n            ('1', '0') => xor.push('1'),\n            ('1',\
    \ '1') => xor.push('0'),\n            _ => panic!(\"Invalid input found.\"),\n\
    \        }\n    }\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let as_bytes = a.into_bytes();\n    let bs_bytes\
    \ = b.into_bytes();\n    let mut result = Vec::new();\n    let mut index = 0;\n\
    \    while index < as_bytes.len() {\n        let a_byte = as_bytes[index];\n \
    \       let b_byte = bs_bytes[index];\n        let result_byte = a_byte ^ b_byte;\n\
    \        result.push(result_byte);\n        index += 1;\n    }\n    let result_string\
    \ = String::from_utf8(result).unwrap();\n    result_string\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpjy8b597h.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() == b.len() {\n        a.chars()\n   \
    \         .zip(b.chars())\n            .map(|(a, b)| if a == b { '0' } else {\
    \ '1' })\n            .collect()\n    } else {\n        panic!(\"Strings must\
    \ be of equal length.\");\n    }\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let b = b.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let mut r = String::new();\n    for i in 0..a.len() {\n        let xor =\
    \ a[i] ^ b[i];\n        r.push_str(&xor.to_string());\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let n = a.len();\n    let m = b.len();\n    let\
    \ mut res = String::new();\n    if n != m {\n        panic!(\"invalid inputs\"\
    );\n    }\n    for i in 0..n {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwh18re0.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO\n    let len = a.len();\n    let mut result\
    \ = String::new();\n    for i in 0..len {\n        let x = a.chars().nth(i).unwrap();\n\
    \        let y = b.chars().nth(i).unwrap();\n        if x == y {\n           \
    \ result.push('0');\n        } else {\n            result.push('1');\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = \"\".to_string();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        let mut xor = i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap();\n        result.push_str(&xor.to_string());\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let result = (0..a.len())\n        .map(|i| {\n\
    \            let a_bit = a.chars().nth(i).unwrap();\n            let b_bit = b.chars().nth(i).unwrap();\n\
    \            (a_bit, b_bit)\n        })\n        .map(|(a_bit, b_bit)| {\n   \
    \         let a_bit = a_bit.to_digit(10).unwrap();\n            let b_bit = b_bit.to_digit(10).unwrap();\n\
    \            format!(\"{}\", a_bit ^ b_bit)\n        })\n        .collect::<String>();\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    while let (Some(a_digit),\
    \ Some(b_digit)) = (a_iter.next(), b_iter.next()) {\n        ret.push(match (a_digit,\
    \ b_digit) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n\
    \            ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => panic!(\"malformed input string\"),\n        });\n    }\n    ret\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| if x == y { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"Inputs\
    \ are not equal length\");\n    }\n    a.chars()\n        .zip(b.chars())\n  \
    \      .map(|(a, b)| {\n            if a == b {\n                '0'\n       \
    \     } else {\n                '1'\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.chars().collect::<Vec<char>>();\n    let\
    \ b = b.chars().collect::<Vec<char>>();\n    let mut result = Vec::new();\n  \
    \  let c = a.len().min(b.len());\n    for i in 0..c {\n        let x = a[i].to_digit(10).unwrap();\n\
    \        let y = b[i].to_digit(10).unwrap();\n        result.push((x ^ y).to_string());\n\
    \    }\n    result.join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = bin2int(a);\n    let b = bin2int(b);\n \
    \   int2bin(a ^ b)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bin2int` in this scope\n --> /tmp/tmpret7gywi.rs:6:13\n\
    \  |\n6 |     let a = bin2int(a);\n  |             ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `bin2int` in this scope\n --> /tmp/tmpret7gywi.rs:7:13\n\
    \  |\n7 |     let b = bin2int(b);\n  |             ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `int2bin` in this scope\n --> /tmp/tmpret7gywi.rs:8:5\n\
    \  |\n8 |     int2bin(a ^ b)\n  |     ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n        .map(|(a,\
    \ b)| (a ^ b).to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    let mut last_a\
    \ = '0';\n    let mut last_b = '0';\n    let mut i = 0;\n    while i < a.len()\
    \ || i < b.len() {\n        if i < a.len() {\n            last_a = a.chars().nth(i).unwrap();\n\
    \        }\n        if i < b.len() {\n            last_b = b.chars().nth(i).unwrap();\n\
    \        }\n        let c = if last_a == last_b {\n            '0'\n        }\
    \ else {\n            '1'\n        };\n        res.push(c);\n        i += 1;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    let mut result = String::new();\n    loop {\n        let a_c\
    \ = a_chars.next();\n        let b_c = b_chars.next();\n        if a_c.is_none()\
    \ || b_c.is_none() {\n            break;\n        }\n        let a_c = a_c.unwrap();\n\
    \        let b_c = b_c.unwrap();\n        if a_c == b_c {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    let res = a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n\
    \        .map(|(x, y)| *x ^ *y)\n        .collect::<Vec<u8>>();\n    String::from_utf8(res).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpzc53cx47.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| ((x == '1') ^ (y == '1')).to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"falsetruefalsefalsetruefalse\"`,\n right: `\"010010\"`', /tmp/tmpjl7pzgty.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    let mut result: String = String::new();\n    loop {\n    \
    \    let a_val = a_iter.next();\n        let b_val = b_iter.next();\n        match\
    \ (a_val, b_val) {\n            (Some(a), Some(b)) => {\n                if a\
    \ == b {\n                    result.push('0');\n                } else {\n  \
    \                  result.push('1');\n                }\n            }\n     \
    \       (Some(_), None) => {\n                result.push('0');\n            }\n\
    \            (None, Some(_)) => {\n                result.push('0');\n       \
    \     }\n            (None, None) => {\n                break;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| match (a == '1', b == '1') {\n            (true, true) => '0',\n       \
    \     (false, false) => '0',\n            _ => '1',\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    format!(\"{:b}\", a.parse::<u32>().unwrap() ^ b.parse::<u32>().unwrap())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"11101100001010\"`,\n right: `\"010010\"`', /tmp/tmpb8927__x.rs:11:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    assert_eq!(a_bytes.len(), b_bytes.len());\n    let mut result = String::new();\n\
    \    for i in 0..a_bytes.len() {\n        let a_chr = a_bytes[i];\n        let\
    \ b_chr = b_bytes[i];\n        result.push(if a_chr == b_chr { '0' } else { '1'\
    \ });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_vec:\
    \ Vec<u8> = a.into_bytes();\n    let b_vec: Vec<u8> = b.into_bytes();\n    for\
    \ i in 0..a_vec.len() {\n        let result_char = (a_vec[i] ^ b_vec[i]) as char;\n\
    \        result.push(result_char);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpcdoroge9.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = Vec::new();\n    let mut a_iter =\
    \ a.chars();\n    let mut b_iter = b.chars();\n    while let (Some(a_c), Some(b_c))\
    \ = (a_iter.next(), b_iter.next()) {\n        res.push(\n            if a_c ==\
    \ b_c {\n                '0'\n            } else {\n                '1'\n    \
    \        }\n        );\n    }\n    res.iter().collect()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::from(\"\");\n    for i\
    \ in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let s: String = a\n        .chars()\n        .zip(b.chars())\n\
    \        .map(|(ac, bc)| if ac == bc { '0' } else { '1' })\n        .collect();\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() != b.len() {\n        return String::from(\"\
    \");\n    }\n    let mut new_str = String::new();\n    for i in 0..a.len() {\n\
    \        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n       \
    \     new_str.push('0');\n        } else {\n            new_str.push('1');\n \
    \       }\n    }\n    new_str\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(char::from(digit_xor(i, j)));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `digit_xor` in this scope\n --> /tmp/tmp82hbwxm6.rs:8:32\n\
    \  |\n8 |         result.push(char::from(digit_xor(i, j)));\n  |             \
    \                   ^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let res = a.iter().zip(b.iter()).map(|(&x, &y)| x ^ y).collect::<Vec<u8>>();\n\
    \    String::from_utf8(res).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmph0dikex_.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(c1,\
    \ c2)| (c1 == '1') ^ (c2 == '1'))\n        .map(|b| if b { '1' } else { '0' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.chars()\n \
    \       .zip(b.chars())\n        .map(|(a, b)| format!(\"{}\", if a == b { 0 }\
    \ else { 1 }))\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(c1,\
    \ c2)| (c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap()).to_string())\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| if x == y { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008975
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_iter = a.chars();\n    let mut b_iter\
    \ = b.chars();\n    let mut res = String::from(\"\");\n    let mut a = 0;\n  \
    \  let mut b = 0;\n    while a_iter.as_str().len() > 0 && b_iter.as_str().len()\
    \ > 0 {\n        a = char_to_int(a_iter.next().unwrap());\n        b = char_to_int(b_iter.next().unwrap());\n\
    \        res.push(int_to_char(a ^ b));\n    }\n    if a_iter.as_str().len() >\
    \ 0 {\n        res.push_str(a_iter.as_str());\n    } else if b_iter.as_str().len()\
    \ > 0 {\n        res.push_str(b_iter.as_str());\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_to_int` in this scope\n  --> /tmp/tmpi8fuxc9c.rs:12:13\n\
    \   |\n12 |         a = char_to_int(a_iter.next().unwrap());\n   |           \
    \  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `char_to_int`\
    \ in this scope\n  --> /tmp/tmpi8fuxc9c.rs:13:13\n   |\n13 |         b = char_to_int(b_iter.next().unwrap());\n\
    \   |             ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `int_to_char` in this scope\n  --> /tmp/tmpi8fuxc9c.rs:14:18\n\
    \   |\n14 |         res.push(int_to_char(a ^ b));\n   |                  ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // Make sure the string are of equal length.\n \
    \   if a.len() != b.len() {\n        panic!(\"Cannot xor strings of different\
    \ length\");\n    }\n\n    // Convert the string to Vec<u8> and xor.\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let result_bytes\
    \ = xor(&a_bytes, &b_bytes);\n\n    // Convert the result to a String.\n    String::from_utf8(result_bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmp0ff6z192.rs:14:24\n\
    \   |\n14 |     let result_bytes = xor(&a_bytes, &b_bytes);\n   |            \
    \            ^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.as_bytes();\n    let b = b.as_bytes();\n\
    \    let mut xor = vec![0u8; a.len()];\n    for (i, (ai, bi)) in a.iter().zip(b.iter()).enumerate()\
    \ {\n        xor[i] = ai ^ bi;\n    }\n    return String::from_utf8(xor).unwrap();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpcx2tb4ou.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(aa,\
    \ bb)| (aa == '1') ^ (bb == '1'))\n        .map(|b| if b { '1' } else { '0' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut c = String::from(\"\");\n    for (i, (x,\
    \ y)) in a.chars().zip(b.chars()).enumerate() {\n        let x = x.to_digit(10).unwrap();\n\
    \        let y = y.to_digit(10).unwrap();\n        let z = x ^ y;\n        c.push_str(&z.to_string());\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| match (x, y) {\n            ('0', '0') => '0',\n            ('0', '1') =>\
    \ '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n     \
    \       _ => panic!(\"a and b must consist only of 1s and 0s\"),\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut c = String::from(\"\");\n    for i in 0..a.len()\
    \ {\n        c += &xor_strings(&a[i..i+1], &b[i..i+1]).to_string();\n    }\n \
    \   c\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor_strings` in this scope\n --> /tmp/tmpvummrxf8.rs:8:15\n\
    \  |\n8 |         c += &xor_strings(&a[i..i+1], &b[i..i+1]).to_string();\n  |\
    \               ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008975
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut output: String = String::new();\n    for\
    \ i in 0..a.len() {\n        output.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    output\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let char_list: Vec<char> = a.chars().zip(b.chars()).map(|(a,\
    \ b)| {\n        if a == b {\n            '0'\n        } else {\n            '1'\n\
    \        }\n    }).collect();\n    char_list.iter().cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid characters\
    \ in string\"),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        if a_char == b_char {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n        .map(|(a,\
    \ b)| a ^ b)\n        .map(|a| a.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8>\
    \ = b.into_bytes();\n    let mut result = Vec::with_capacity(std::cmp::max(a.len(),\
    \ b.len()));\n    // Pad the shorter string with 0's\n    if a.len() < b.len()\
    \ {\n        result.extend(std::iter::repeat(b'0').take(b.len() - a.len()));\n\
    \        result.extend(a);\n    } else {\n        result.extend(std::iter::repeat(b'0').take(a.len()\
    \ - b.len()));\n        result.extend(b);\n    }\n    // Perform binary XOR on\
    \ each character\n    for i in 0..result.len() {\n        let val = result[i]\
    \ ^ result[i];\n        result[i] = val + 48;\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000000\"`,\n right: `\"010010\"`', /tmp/tmpn15it1h3.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let result = xor(&string_to_bytes(&a), &string_to_bytes(&b));\n\
    \    hex::encode(result)\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hex`\n\
    \ --> /tmp/tmp75j7m5of.rs:7:5\n  |\n7 |     hex::encode(result)\n  |     ^^^ use\
    \ of undeclared crate or module `hex`\n\nerror[E0425]: cannot find function `xor`\
    \ in this scope\n --> /tmp/tmp75j7m5of.rs:6:18\n  |\n6 |     let result = xor(&string_to_bytes(&a),\
    \ &string_to_bytes(&b));\n  |                  ^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `string_to_bytes` in this scope\n --> /tmp/tmp75j7m5of.rs:6:23\n\
    \  |\n6 |     let result = xor(&string_to_bytes(&a), &string_to_bytes(&b));\n\
    \  |                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `string_to_bytes` in this scope\n --> /tmp/tmp75j7m5of.rs:6:45\n\
    \  |\n6 |     let result = xor(&string_to_bytes(&a), &string_to_bytes(&b));\n\
    \  |                                             ^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| format!(\"{}\", a ^ b))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpv5117onu.rs:8:39\n\
    \  |\n8 |         .map(|(a, b)| format!(\"{}\", a ^ b))\n  |                 \
    \                    - ^ - char\n  |                                     |\n \
    \ |                                     char\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let result: String = a\n        .chars()\n     \
    \   .zip(b.chars())\n        .map(|(c1, c2)| if c1 == c2 { '0' } else { '1' })\n\
    \        .collect();\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut s = String::new();\n    for pair in a.chars().zip(b.chars())\
    \ {\n        s.push(\n            match pair {\n                (x, y) if x ==\
    \ y => '0',\n                _ => '1',\n            }\n        );\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpf1yctm9n.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let chars_a: Vec<char> = a.chars().collect();\n\
    \    let chars_b: Vec<char> = b.chars().collect();\n    let mut result: String\
    \ = String::new();\n    for i in 0..chars_a.len() {\n        if chars_a[i] ==\
    \ chars_b[i] {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    let a_bytes =\
    \ a.as_bytes();\n    let b_bytes = b.as_bytes();\n    assert_eq!(a_bytes.len(),\
    \ b_bytes.len());\n    for i in 0..a_bytes.len() {\n        ret.push(char::from(a_bytes[i]\
    \ ^ b_bytes[i]));\n    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpjbrgv2o4.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.chars()\n \
    \       .zip(b.chars())\n        .map(|(a, b)| xor(a, b))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpnvfaqfw4.rs:9:23\n\
    \  |\n9 |         .map(|(a, b)| xor(a, b))\n  |                       ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    let mut iter =\
    \ a.chars().zip(b.chars());\n    while let Some((a, b)) = iter.next() {\n    \
    \    if a == b {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: implement your function body\n    let mut\
    \ c = String::from(\"\");\n    for i in 0..a.len() {\n        c.push(match (a.chars().nth(i),\
    \ b.chars().nth(i)) {\n            (Some('0'), Some('0')) => '0',\n          \
    \  (Some('0'), Some('1')) => '1',\n            (Some('1'), Some('0')) => '1',\n\
    \            (Some('1'), Some('1')) => '0',\n            _ => ' ',\n        });\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(i,\
    \ j)| match (i, j) {\n            ('0', '0') => '0',\n            ('0', '1') =>\
    \ '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n     \
    \       _ => panic!(\"Invalid input\"),\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    if a_bytes.len() != b_bytes.len() {\n        return String::from(\"\");\n\
    \    }\n    let mut result = String::new();\n    for i in 0..a_bytes.len() {\n\
    \        let a_byte = a_bytes[i];\n        let b_byte = b_bytes[i];\n        let\
    \ a_char = char::from(a_byte);\n        let b_char = char::from(b_byte);\n   \
    \     if a_char == b_char {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut output = String::new();\n    let mut a_chars\
    \ = a.chars();\n    let mut b_chars = b.chars();\n    while let (Some(a_val),\
    \ Some(b_val)) = (a_chars.next(), b_chars.next()) {\n        if a_val == b_val\
    \ {\n            output.push('0');\n        } else {\n            output.push('1');\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(n1,\
    \ n2)| match (n1, n2) {\n            ('0', '0') => '0',\n            ('0', '1')\
    \ => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n  \
    \          _ => '0',\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let min_len\
    \ = min(a.len(), b.len());\n    for i in 0..min_len {\n        let mut a_char:\
    \ Vec<char> = a.chars().collect();\n        let mut b_char: Vec<char> = b.chars().collect();\n\
    \        result.push(\n            if a_char[i] == b_char[i] {\n             \
    \   '0'\n            } else {\n                '1'\n            }\n        );\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp504u777n.rs:7:19\n\
    \   |\n7  |     let min_len = min(a.len(), b.len());\n   |                   ^^^\n\
    ...\n22 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n7  |     let\
    \ min_len = main(a.len(), b.len());\n   |                   ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let v1: Vec<u8> = a.into_bytes();\n    let v2: Vec<u8>\
    \ = b.into_bytes();\n    let mut xor: Vec<u8> = Vec::new();\n    for (i, j) in\
    \ v1.iter().zip(v2.iter()) {\n        if *i == b'0' && *j == b'0' {\n        \
    \    xor.push(b'0');\n        } else if *i == b'1' && *j == b'1' {\n         \
    \   xor.push(b'0');\n        } else {\n            xor.push(b'1');\n        }\n\
    \    }\n    let xor: String = xor.iter().collect();\n    xor\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&u8`\n    --> /tmp/tmpfp_mlh1d.rs:18:34\n     |\n18 \
    \  |     let xor: String = xor.iter().collect();\n     |                     \
    \             ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&u8>`\n\
    \     |\n     = help: the trait `FromIterator<&u8>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    if a.len()\
    \ != b.len() {\n        return result;\n    }\n    for (a_char, b_char) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (a_char, b_char) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => '0',\n        });\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut output = String::new();\n    let a_chars\
    \ = a.chars();\n    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        output.push(if a_char == b_char { '0' } else { '1' });\n    }\n \
    \   output\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push_str(&format!(\"{}\", c1.to_digit(10).unwrap()\
    \ ^ c2.to_digit(10).unwrap()));\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n\
    \        .map(|(a, b)| a ^ b)\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let res = xor(a.as_bytes(), b.as_bytes());\n   \
    \ String::from_utf8(res).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmp5g33sflx.rs:6:15\n\
    \  |\n6 |     let res = xor(a.as_bytes(), b.as_bytes());\n  |               ^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    fn binary_xor(a: u8, b: u8) -> u8 {\n        //\
    \ If a is equal to b, return 0.\n        if a == b {\n            0\n        }\
    \ else {\n            1\n        }\n    }\n\n    // Convert to bytes, perform\
    \ XOR and return as a string\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    a_bytes\n        .iter()\n        .zip(b_bytes)\n     \
    \   .map(|(a, b)| binary_xor(*a, *b))\n        .map(|x| x.to_string())\n     \
    \   .collect::<Vec<String>>()\n        .join(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // First convert inputs to byte arrays.\n    let\
    \ a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\n    // Then\
    \ XOR together, perform to_string on each element, then join.\n    a_bytes\n \
    \       .iter()\n        .zip(b_bytes.iter())\n        .map(|(a, b)| (a ^ b).to_string())\n\
    \        .collect::<Vec<String>>()\n        .join(\"\")\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    while let (Some(a_ch), Some(b_ch))\
    \ = (a_iter.next(), b_iter.next()) {\n        let a_bit = if a_ch == '1' { 1 }\
    \ else { 0 };\n        let b_bit = if b_ch == '1' { 1 } else { 0 };\n        let\
    \ result_bit = (a_bit ^ b_bit) as u8;\n        result.push(result_bit.to_string().chars().next().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    /// This implementation iterates over the bytes\
    \ of the strings and then\n    /// bitwise xors them together.\n    let mut result\
    \ = String::new();\n    for (a, b) in a.bytes().zip(b.bytes()) {\n        result.push_str(&format!(\"\
    {:01b}\", a ^ b));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO\n    String::from(\"\")\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmpsbu4ba4p.rs:12:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut output\
    \ = String::with_capacity(a.len());\n    for (ch_a, ch_b) in a.chars().zip(b.chars())\
    \ {\n        let xor = match (ch_a, ch_b) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Unhandled character found: {} or {}\"\
    , ch_a, ch_b),\n        };\n        output.push(xor);\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    \"0110100100011010010101001010101101010101\".to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0110100100011010010101001010101101010101\"`,\n right: `\"010010\"`', /tmp/tmp0vi2l2eg.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // Convert the strings to byte vectors\n    let\
    \ mut bytes_a = Vec::new();\n    for b in a.chars() {\n        bytes_a.push(b\
    \ as u8 - '0' as u8);\n    }\n    let mut bytes_b = Vec::new();\n    for b in\
    \ b.chars() {\n        bytes_b.push(b as u8 - '0' as u8);\n    }\n\n    // Ensure\
    \ they are the same length\n    while bytes_a.len() < bytes_b.len() {\n      \
    \  bytes_a.insert(0, 0);\n    }\n    while bytes_b.len() < bytes_a.len() {\n \
    \       bytes_b.insert(0, 0);\n    }\n\n    // Compute the xor\n    let mut bytes_c\
    \ = Vec::new();\n    for i in 0..bytes_a.len() {\n        bytes_c.push(bytes_a[i]\
    \ ^ bytes_b[i]);\n    }\n\n    // Convert back to a string\n    let mut result\
    \ = String::new();\n    for b in bytes_c {\n        result.push((b + '0' as u8)\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: Implement here\n    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n\
    \        let b_char = b.chars().nth(i).unwrap();\n        let a_value = match\
    \ a_char {\n            '0' => false,\n            '1' => true,\n            _\
    \ => false,\n        };\n        let b_value = match b_char {\n            '0'\
    \ => false,\n            '1' => true,\n            _ => false,\n        };\n \
    \       let mut xor_value = a_value ^ b_value;\n        if xor_value {\n     \
    \       result.push('1');\n        } else {\n            result.push('0');\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        let c = match (a, b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Unexpected input\"\
    ),\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         ret.push('0');\n        } else {\n            ret.push('1');\n     \
    \   }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n   \
    \ assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut out = String::new();\n    for (c1, c2) in\
    \ a.chars().zip(b.chars()) {\n        out.push(match (c1, c2) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"),\n\
    \        });\n    }\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut s = String::new();\n    for (ai, bi) in\
    \ a.chars().zip(b.chars()) {\n        let ai = ai.to_digit(10).unwrap();\n   \
    \     let bi = bi.to_digit(10).unwrap();\n        s.push_str(&(ai ^ bi).to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        if c1 == c2 {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let length = std::cmp::max(a.len(), b.len());\n\
    \    let mut a_iter = a.chars().rev();\n    let mut b_iter = b.chars().rev();\n\
    \    let mut result = String::new();\n    for _ in 0..length {\n        let mut\
    \ a_char = '0';\n        if let Some(c) = a_iter.next() {\n            a_char\
    \ = c;\n        }\n        let mut b_char = '0';\n        if let Some(c) = b_iter.next()\
    \ {\n            b_char = c;\n        }\n        result.push(xor(a_char, b_char));\n\
    \    }\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmp_q7_9qjp.rs:19:21\n\
    \   |\n19 |         result.push(xor(a_char, b_char));\n   |                  \
    \   ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut xored = vec![];\n    let chars_a = a.chars();\n\
    \    let chars_b = b.chars();\n    for (a, b) in chars_a.zip(chars_b) {\n    \
    \    let xor = match (a, b) {\n            ('0', '0') => '0',\n            ('0',\
    \ '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n\
    \            _ => panic!(\"Invalid input.\"),\n        };\n        xored.push(xor);\n\
    \    }\n    xored.iter().collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_len = a.len();\n    let b_len = b.len();\n\
    \    if a_len != b_len {\n        panic!(\"Inconsistent input lengths {} {}\"\
    , a_len, b_len);\n    }\n    let mut res = String::new();\n    for i in 0..a_len\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         res.push('0');\n        } else {\n            res.push('1');\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n   \
    \ assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmp6vd3we1c.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    let mut result = String::from(\"\");\n    loop {\n       \
    \ match (a_chars.next(), b_chars.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                let xor_result = if a_char == b_char {\n             \
    \       '0'\n                } else {\n                    '1'\n             \
    \   };\n                result.push(xor_result);\n            }\n            _\
    \ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut out: String = String::new();\n    for (x,\
    \ y) in a.chars().zip(b.chars()) {\n        if x == y {\n            out.push('0');\n\
    \        } else {\n            out.push('1');\n        }\n    }\n    out\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| (a, b).into())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmp6xsdp310.rs:8:10\n\
    \  |\n8 |         .map(|(a, b)| (a, b).into())\n  |          ^^^          -------------\
    \ this method call resolves to `T`\n  |          |\n  |          cannot infer\
    \ type for type parameter `B` declared on the associated function `map`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    assert_eq!(a_bytes.len(), b_bytes.len());\n    let mut\
    \ xor_result: Vec<u8> = Vec::new();\n    for i in 0..a_bytes.len() {\n       \
    \ let xor_res = a_bytes[i] ^ b_bytes[i];\n        xor_result.push(xor_res);\n\
    \    }\n    String::from_utf8(xor_result).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmplpqz_w5w.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // convert both strings to u8\n    let a_u8 = bit_string_to_u8(&a);\n\
    \    let b_u8 = bit_string_to_u8(&b);\n\n    // xor both u8s and convert back\
    \ to bitstring\n    let xor_u8 = a_u8 ^ b_u8;\n    let xor_string = u8_to_bit_string(xor_u8);\n\
    \n    xor_string\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `bit_string_to_u8` in this scope\n -->\
    \ /tmp/tmpzh7b4bd3.rs:7:16\n  |\n7 |     let a_u8 = bit_string_to_u8(&a);\n  |\
    \                ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `bit_string_to_u8` in this scope\n --> /tmp/tmpzh7b4bd3.rs:8:16\n\
    \  |\n8 |     let b_u8 = bit_string_to_u8(&b);\n  |                ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `u8_to_bit_string`\
    \ in this scope\n  --> /tmp/tmpzh7b4bd3.rs:12:22\n   |\n12 |     let xor_string\
    \ = u8_to_bit_string(xor_u8);\n   |                      ^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: Implement here!\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp6rk16_4q.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut s = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        if a == b {\n            s.push('0');\n        } else {\n       \
    \     s.push('1');\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(c1,\
    \ c2)| {\n            if c1 == c2 {\n                '0'\n            } else {\n\
    \                '1'\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a = a.as_bytes();\n\
    \    let b = b.as_bytes();\n    for (byte_a, byte_b) in a.iter().zip(b.iter())\
    \ {\n        if *byte_a != *byte_b {\n            result.push('1');\n        }\
    \ else {\n            result.push('0');\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::from(\"\");\n    for c\
    \ in a.chars().zip(b.chars()) {\n        result.push_str(&(c.0 ^ c.1).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp9unelafs.rs:8:31\n\
    \  |\n8 |         result.push_str(&(c.0 ^ c.1).to_string());\n  |            \
    \               --- ^ --- char\n  |                           |\n  |         \
    \                  char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.chars()\n \
    \       .zip(b.chars())\n        .map(|(aa, bb)| match (aa, bb) {\n          \
    \  ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"a or b contains\
    \ a non-binary value\"),\n        })\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut ret = String::with_capacity(a_bytes.len());\n    for (a, b) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        ret.push_str(&format!(\"{}\", (a ^ b) & 1));\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwh18re0.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822351
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_bytes = a.into_bytes();\n    let mut b_bytes\
    \ = b.into_bytes();\n    let max_len = std::cmp::max(a_bytes.len(), b_bytes.len());\n\
    \    a_bytes.resize(max_len, b'0');\n    b_bytes.resize(max_len, b'0');\n    let\
    \ mut result: Vec<u8> = Vec::with_capacity(max_len);\n    for i in 0..max_len\
    \ {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    std::str::from_utf8(&result).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpttjarqws.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut s = String::new();\n    for (ai, bi) in\
    \ a.chars().zip(b.chars()) {\n        if ai == bi {\n            s.push('0');\n\
    \        } else {\n            s.push('1');\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut ret =\
    \ String::new();\n    for i in 0..a.len() {\n        ret.push(if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::from(\"\");\n    for i in\
    \ 0..a.len() {\n        res.push_str(&match a.chars().nth(i).unwrap() {\n    \
    \        '0' => match b.chars().nth(i).unwrap() {\n                '0' => \"0\"\
    ,\n                '1' => \"1\",\n                _ => \"\",\n            },\n\
    \            '1' => match b.chars().nth(i).unwrap() {\n                '0' =>\
    \ \"1\",\n                '1' => \"0\",\n                _ => \"\",\n        \
    \    },\n            _ => \"\",\n        });\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n        .map(|(x,\
    \ y)| (x ^ y).to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.chars()\n \
    \       .zip(b.chars())\n        .map(|(x, y)| match (x, y) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => unreachable!(),\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let zipped = a.chars().zip(b.chars());\n    zipped.map(|(a,\
    \ b)| (a != b) as char).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `bool`\n --> /tmp/tmp7bk46261.rs:7:25\n\
    \  |\n7 |     zipped.map(|(a, b)| (a != b) as char).collect()\n  |           \
    \              ^^^^^^^^^^^^^^^^ invalid cast\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| match (a, b) {\n            ('0', '0') => '0',\n            ('0', '1') =>\
    \ '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n     \
    \       _ => '0',\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| {\n            if x == y {\n                '0'\n            } else {\n\
    \                '1'\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret: String = String::from(\"\");\n    let\
    \ mut i = 0;\n    for c in a.chars() {\n        if c == b.chars().nth(i).unwrap()\
    \ {\n            ret.push('0');\n        } else {\n            ret.push('1');\n\
    \        }\n        i += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.into_bytes()\n        .iter()\n        .zip(b.into_bytes().iter())\n\
    \        .map(|(a, b)| (a ^ b) as char)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpyozkgmrm.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_vec: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    let b_vec: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    return a_vec\n        .iter()\n        .zip(b_vec.iter())\n\
    \        .map(|(a, b)| (a ^ b).to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\");\n}\n\nfn main() {\n    let candidate = string_xor;\n   \
    \ assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut a = a.into_bytes();\n\
    \    let mut b = b.into_bytes();\n    for (x, y) in a.iter_mut().zip(b.iter_mut())\
    \ {\n        *x ^= *y;\n    }\n    String::from_utf8(a).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpbupk7x_o.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(match (a_char, b_char) {\n                    ('0', '0') =>\
    \ '0',\n                    ('0', '1') => '1',\n                    ('1', '0')\
    \ => '1',\n                    ('1', '1') => '0',\n                    _ => unreachable!(),\n\
    \                });\n            }\n            (None, None) => break,\n    \
    \        _ => panic!(\"String lengths must be equal\"),\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a: Vec<_> = a.chars().collect();\n    let b:\
    \ Vec<_> = b.chars().collect();\n    a.iter()\n        .zip(b.iter())\n      \
    \  .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n            ('0',\
    \ '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n\
    \            _ => ' ',\n        })\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    format!(\"{:?}\", xor(a.into_bytes(), b.into_bytes()))\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmp5gtiekp8.rs:6:21\n\
    \  |\n6 |     format!(\"{:?}\", xor(a.into_bytes(), b.into_bytes()))\n  |    \
    \                 ^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(c1,\
    \ c2)| if c1 == c2 { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (c1, c2) {\n      \
    \      ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid input!\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"010010\"`', /tmp/tmp6vd3we1c.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008976
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut c = String::new();\n    let mut a_chars\
    \ = a.chars();\n    let mut b_chars = b.chars();\n    while let (Some(a_i), Some(b_i))\
    \ = (a_chars.next(), b_chars.next()) {\n        let a_int = a_i.to_digit(10).unwrap();\n\
    \        let b_int = b_i.to_digit(10).unwrap();\n        c.push_str(&xor(a_int,\
    \ b_int).to_string());\n    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmpw1k1i36c.rs:12:21\n\
    \   |\n12 |         c.push_str(&xor(a_int, b_int).to_string());\n   |        \
    \             ^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_int = i32::from_str_radix(&a, 2).unwrap();\n\
    \    let b_int = i32::from_str_radix(&b, 2).unwrap();\n    let result = a_int\
    \ ^ b_int;\n    return format!(\"{:b}\", result);\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmp6dmkbitn.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    let a = a.as_bytes();\n\
    \    let b = b.as_bytes();\n    for i in 0..a.len() {\n        let x = if a[i]\
    \ == b'0' {\n            b'0'\n        } else {\n            b'1'\n        };\n\
    \        let y = if b[i] == b'0' {\n            b'0'\n        } else {\n     \
    \       b'1'\n        };\n        let z = x ^ y;\n        ret.push(z as char);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpf7p6vwbl.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_vec: Vec<u8> = a.as_bytes().iter().map(|a|\
    \ char::from(*a).to_digit(10).unwrap() as u8).collect();\n    let b_vec: Vec<u8>\
    \ = b.as_bytes().iter().map(|b| char::from(*b).to_digit(10).unwrap() as u8).collect();\n\
    \    let xor_iter = a_vec.iter().zip(b_vec.iter()).map(|(a, b)| a ^ b);\n    let\
    \ xor_string: String = xor_iter.map(|x| x.to_string()).collect();\n    xor_string\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut result: Vec<u8> = Vec::new();\n    for i in 0..a_bytes.len() {\n\
    \        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp119khf8b.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let binary_a = u8::from_str_radix(&a, 2).unwrap();\n\
    \    let binary_b = u8::from_str_radix(&b, 2).unwrap();\n    let binary_c = binary_a\
    \ ^ binary_b;\n    format!(\"{:b}\", binary_c)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmpcg0a179j.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::from(\"\");\n    for i in\
    \ 0..a.len() {\n        let a_bit = a.chars().nth(i).unwrap();\n        let b_bit\
    \ = b.chars().nth(i).unwrap();\n        ret.push(match (a_bit, b_bit) {\n    \
    \        ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"string_xor:\
    \ invalid bit sequence\"),\n        });\n    }\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // ...\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgmpp0df6.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"strings\
    \ are not equal\");\n    }\n    let a_bytes = hex::decode(a).unwrap();\n    let\
    \ b_bytes = hex::decode(b).unwrap();\n    let mut result = Vec::new();\n    for\
    \ i in 0..a_bytes.len() {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n   \
    \ }\n    hex::encode(result)\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hex`\n\
    \ --> /tmp/tmp59hq816y.rs:9:19\n  |\n9 |     let a_bytes = hex::decode(a).unwrap();\n\
    \  |                   ^^^ use of undeclared crate or module `hex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `hex`\n  --> /tmp/tmp59hq816y.rs:10:19\n\
    \   |\n10 |     let b_bytes = hex::decode(b).unwrap();\n   |                 \
    \  ^^^ use of undeclared crate or module `hex`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `hex`\n  --> /tmp/tmp59hq816y.rs:15:5\n  \
    \ |\n15 |     hex::encode(result)\n   |     ^^^ use of undeclared crate or module\
    \ `hex`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // get lengths of strings\n    let mut la = a.len();\n\
    \    let mut lb = b.len();\n    // calculate lengths of new string\n    let mut\
    \ l = if la > lb { la } else { lb };\n    // make new string\n    let mut c =\
    \ String::new();\n    // set cursor to end of strings\n    let mut ca = a.chars().rev();\n\
    \    let mut cb = b.chars().rev();\n    // get next char from string\n    let\
    \ mut x = ca.next();\n    let mut y = cb.next();\n    // while we have some chars\n\
    \    while x.is_some() || y.is_some() {\n        // if we have both chars\n  \
    \      if x.is_some() && y.is_some() {\n            // get them and calculate\
    \ xor\n            let (a, b) = (x.unwrap(), y.unwrap());\n            let r =\
    \ if a == b { '0' } else { '1' };\n            // push result to new string\n\
    \            c.push(r);\n            // get next char\n            x = ca.next();\n\
    \            y = cb.next();\n        } else if x.is_some() {\n            // only\
    \ we have char from a\n            let a = x.unwrap();\n            c.push(a);\n\
    \            x = ca.next();\n        } else if y.is_some() {\n            // only\
    \ we have char from b\n            let b = y.unwrap();\n            c.push(b);\n\
    \            y = cb.next();\n        }\n    }\n    // reverse to normal string\
    \ and return\n    c.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push_str(&format!(\"{}\", a ^\
    \ b));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmphtc_5rs5.rs:8:42\n\
    \  |\n8 |         result.push_str(&format!(\"{}\", a ^ b));\n  |             \
    \                           - ^ - char\n  |                                  \
    \      |\n  |                                        char\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (ch_a,\
    \ ch_b) in a.chars().zip(b.chars()) {\n        let mut a = ch_a.to_digit(10).unwrap();\n\
    \        let mut b = ch_b.to_digit(10).unwrap();\n        a ^= b;\n        result.push_str(&a.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    if a_bytes.len() != b_bytes.len() {\n        return String::from(\"\
    ERROR\");\n    }\n    let mut out = String::new();\n    for (a, b) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        let value = *a ^ *b;\n        out.push(char::from(value));\n    }\n\
    \    out\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpqb2oteit.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n        .map(|(c1,\
    \ c2)| c1 ^ c2)\n        .map(|c| c.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(aa,\
    \ bb)| (aa.to_digit(2).unwrap() ^ bb.to_digit(2).unwrap()).to_string())\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::from(\"\");\n    for i\
    \ in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n        let\
    \ b_char = b.chars().nth(i).unwrap();\n        let new_char = match (a_char, b_char)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => '0',\n\
    \        };\n        result.push(new_char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    let mut output = String::new();\n    loop {\n        match (a.next(), b.next())\
    \ {\n            (Some(c1), Some(c2)) => {\n                if c1 == c2 {\n  \
    \                  output.push('0');\n                } else {\n             \
    \       output.push('1');\n                }\n            }\n            _ =>\
    \ break,\n        }\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| char_xor(a, b))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n --> /tmp/tmprwe7lyfx.rs:8:23\n\
    \  |\n8 |         .map(|(a, b)| char_xor(a, b))\n  |                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // unimplemented!()\n    let a: Vec<u8> = a.into_bytes();\n\
    \    let b: Vec<u8> = b.into_bytes();\n    let mut c: Vec<u8> = Vec::new();\n\
    \    for i in 0..a.len() {\n        if a[i] == b[i] {\n            c.push(48);\n\
    \        } else {\n            c.push(49);\n        }\n    }\n    let c: String\
    \ = String::from_utf8(c).unwrap();\n    return c;\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    format!(\"{:0b}\", u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b,\
    \ 2))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `Result<u8, ParseIntError> ^ Result<u8,\
    \ ParseIntError>`\n --> /tmp/tmp5e07hx7x.rs:6:48\n  |\n6 |     format!(\"{:0b}\"\
    , u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b, 2))\n  |                \
    \      ------------------------- ^ ------------------------- Result<u8, ParseIntError>\n\
    \  |                      |\n  |                      Result<u8, ParseIntError>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut ret = String::new();\n    for (c1, c2) in\
    \ a.chars().zip(b.chars()) {\n        ret.push(match (c1, c2) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Illegal characters\
    \ in strings a and b\"),\n        });\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| xor(a, b))\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpdfzvgyr3.rs:8:23\n\
    \  |\n8 |         .map(|(a, b)| xor(a, b))\n  |                       ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push_str(&format!(\"{}\", a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpg9x1lkok.rs:8:66\n\
    \  |\n8 |         result.push_str(&format!(\"{}\", a.chars().nth(i).unwrap() ^\
    \ b.chars().nth(i).unwrap()));\n  |                                        -------------------------\
    \ ^ ------------------------- char\n  |                                      \
    \  |\n  |                                        char\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::from(\"\");\n    let mut a:\
    \ Vec<char> = a.chars().collect();\n    let mut b: Vec<char> = b.chars().collect();\n\
    \    let mut len = if a.len() > b.len() { a.len() } else { b.len() };\n    a.reverse();\n\
    \    b.reverse();\n    for i in 0..len {\n        if i < a.len() && i < b.len()\
    \ {\n            if a[i] == b[i] {\n                res.push('0');\n         \
    \   } else {\n                res.push('1');\n            }\n        } else if\
    \ i < a.len() {\n            res.push(a[i]);\n        } else {\n            res.push(b[i]);\n\
    \        }\n    }\n    res.chars().rev().collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| match (x, y) {\n            ('0', '0') => '0',\n            ('0', '1') =>\
    \ '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n     \
    \       _ => panic!(\"There should be only 1s and 0s!\"),\n        })\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    format!(\"{:0>1$b}\", parse_binary(a) ^ parse_binary(b),\
    \ a.len())\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_binary` in this scope\n --> /tmp/tmp04xuyfl1.rs:6:25\n\
    \  |\n6 |     format!(\"{:0>1$b}\", parse_binary(a) ^ parse_binary(b), a.len())\n\
    \  |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `parse_binary` in this scope\n --> /tmp/tmp04xuyfl1.rs:6:43\n\
    \  |\n6 |     format!(\"{:0>1$b}\", parse_binary(a) ^ parse_binary(b), a.len())\n\
    \  |                                           ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.chars()\n \
    \       .zip(b.chars())\n        .map(|(c1, c2)| (c1 == '1') ^ (c2 == '1'))\n\
    \        .map(|b| if b { '1' } else { '0' })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // Transform to Vec<u8>\n    let a = hex::decode(a).unwrap();\n\
    \    let b = hex::decode(b).unwrap();\n\n    // XOR\n    let mut bytes = Vec::new();\n\
    \    for i in 0..a.len() {\n        bytes.push(a[i] ^ b[i]);\n    }\n\n    //\
    \ Transform to String\n    let result = String::from_utf8(bytes).unwrap();\n \
    \   hex::encode(result)\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hex`\n\
    \ --> /tmp/tmpionfbvem.rs:7:13\n  |\n7 |     let a = hex::decode(a).unwrap();\n\
    \  |             ^^^ use of undeclared crate or module `hex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `hex`\n --> /tmp/tmpionfbvem.rs:8:13\n\
    \  |\n8 |     let b = hex::decode(b).unwrap();\n  |             ^^^ use of undeclared\
    \ crate or module `hex`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `hex`\n  --> /tmp/tmpionfbvem.rs:18:5\n   |\n18 |     hex::encode(result)\n\
    \   |     ^^^ use of undeclared crate or module `hex`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| format!(\"{}\", num_xor(a.to_digit(2).unwrap(), b.to_digit(2).unwrap())))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_xor` in this scope\n --> /tmp/tmp2q8dr7cm.rs:8:37\n\
    \  |\n8 |         .map(|(a, b)| format!(\"{}\", num_xor(a.to_digit(2).unwrap(),\
    \ b.to_digit(2).unwrap())))\n  |                                     ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // check if lengths are the same\n    if a.len()\
    \ != b.len() {\n        panic!(\"Different lengths! Error!\");\n    }\n\n    //\
    \ initialize vector\n    let mut result: Vec<u8> = Vec::new();\n\n    // convert\
    \ strings to chars and XOR\n    for i in 0..a.len() {\n        let a = a.chars().nth(i).unwrap();\n\
    \        let b = b.chars().nth(i).unwrap();\n        let c = match (a, b) {\n\
    \            ('0', '0') => \"0\",\n            ('0', '1') => \"1\",\n        \
    \    ('1', '0') => \"1\",\n            ('1', '1') => \"0\",\n            _ =>\
    \ panic!(\"Error! Not a binary string!\"),\n        };\n        result.push(c.as_bytes()[0]);\n\
    \    }\n\n    // convert vector to string\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let mut result = Vec::new();\n    for i in 0..a.len() {\n        let value\
    \ = if a[i] == 48 && b[i] == 48 { 48 } else if a[i] == 49 && b[i] == 49 { 48 }\
    \ else { 49 };\n        result.push(value);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut output = Vec::new();\n    for i in 0..a_bytes.len() {\n        let\
    \ a_char = if a_bytes[i] == b'0' { false } else { true };\n        let b_char\
    \ = if b_bytes[i] == b'0' { false } else { true };\n        let res = a_char ^\
    \ b_char;\n        output.push(if res { b'1' } else { b'0' });\n    }\n    String::from_utf8(output).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a =\
    \ a.into_bytes();\n    let mut b = b.into_bytes();\n    let len = a.len().max(b.len());\n\
    \    a.resize(len, 0x30);\n    b.resize(len, 0x30);\n    for i in 0..len {\n \
    \       if a[i] == b[i] {\n            result.push('0');\n        } else {\n \
    \           result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    let max_len = max(a_bytes.len(), b_bytes.len());\n    let\
    \ mut result = Vec::with_capacity(max_len);\n    for i in 0..max_len {\n     \
    \   let a_byte = a_bytes.get(i).unwrap_or(&0);\n        let b_byte = b_bytes.get(i).unwrap_or(&0);\n\
    \        result.push(a_byte ^ b_byte);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmp11bh1fer.rs:8:19\n\
    \  |\n8 |     let max_len = max(a_bytes.len(), b_bytes.len());\n  |          \
    \         ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::from(\"\");\n    for i\
    \ in 0..a.len() {\n        let a_i = match a.get(i..i + 1) {\n            Some(s)\
    \ => s,\n            None => \"\",\n        };\n        let b_i = match b.get(i..i\
    \ + 1) {\n            Some(s) => s,\n            None => \"\",\n        };\n \
    \       if a_i == b_i {\n            result.push_str(\"0\");\n        } else {\n\
    \            result.push_str(\"1\");\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::from(\"\");\n    for i\
    \ in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008976
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let res = (0..a.len())\n        .map(|i| {\n   \
    \         let a_ch = a.chars().nth(i).unwrap();\n            let b_ch = b.chars().nth(i).unwrap();\n\
    \            if a_ch == b_ch {\n                \"0\"\n            } else {\n\
    \                \"1\"\n            }\n        })\n        .collect::<String>();\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_u8: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    let b_u8: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    let a_b_u8: Vec<u8> = a_u8.iter().zip(b_u8.iter()).map(|(x,\
    \ y)| x ^ y).collect();\n    a_b_u8.iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let len = if\
    \ a.len() < b.len() { a.len() } else { b.len() };\n    for i in 0..len {\n   \
    \     let c = a.chars().nth(i).unwrap();\n        let d = b.chars().nth(i).unwrap();\n\
    \        let xor = xor(c, d);\n        result.push(xor);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmpfzxpzfyp.rs:11:19\n\
    \   |\n11 |         let xor = xor(c, d);\n   |                   ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(if\
    \ a[i] == b[i] { '0' } else { '1' });\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n        .map(|(ac,\
    \ bc)| match (ac, bc) {\n            ('0', '0') => '0',\n            ('0', '1')\
    \ => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n  \
    \          _ => panic!(\"Unexpected input\"),\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        result.push(if a_char == b_char { '0' } else { '1' });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut v = vec![];\n    let mut iter = a.chars().zip(b.chars());\n\
    \    while let Some((x, y)) = iter.next() {\n        v.push(x.to_digit(2).unwrap()\
    \ ^ y.to_digit(2).unwrap());\n    }\n    v.iter().map(|&x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008977
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpm1j7u6ks.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008976
