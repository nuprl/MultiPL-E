language: rs
name: HumanEval_158_find_max
results:
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_word = String::new();\n    for word in words {\n        let v\
    \ = uniq_chars(word.clone());\n        if v.len() > max {\n            max = v.len();\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `uniq_chars` in this scope\n  --> /tmp/tmpj19ucdr1.rs:15:17\n\
    \   |\n15 |         let v = uniq_chars(word.clone());\n   |                 ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let res = words.iter().fold(None,\
    \ |result, x| match result {\n        None => Some((x.len(), x)),\n        Some((cnt,\
    \ y)) => {\n            let x_cnt = x.chars().collect::<HashSet<_>>().len();\n\
    \            if x_cnt > cnt {\n                Some((x_cnt, x))\n            }\
    \ else if x_cnt == cnt {\n                if x < y {\n                    Some((x_cnt,\
    \ x))\n                } else {\n                    Some((cnt, y))\n        \
    \        }\n            } else {\n                Some((cnt, y))\n           \
    \ }\n        }\n    });\n    res.unwrap().1.to_string()\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpud4yyxij.rs:15:45\n\
    \   |\n15 |             let x_cnt = x.chars().collect::<HashSet<_>>().len();\n\
    \   |                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: Implement\
    \ me!\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpva63n__z.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let mut seen_chars = HashSet::new();\n        for char in word.chars() {\n\
    \            seen_chars.insert(char);\n        }\n        if seen_chars.len()\
    \ > max_count || (seen_chars.len() == max_count && word < max_word) {\n      \
    \      max_count = seen_chars.len();\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpi4ykjnk9.rs:15:30\n   |\n15 |         let mut seen_chars = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|word|\
    \ {\n        let mut chars = HashSet::new();\n        for c in word.chars() {\n\
    \            chars.insert(c);\n        }\n        chars.len()\n    }).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmppmuu6i1b.rs:13:25\n   |\n13 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique_chars\
    \ = 0;\n    let mut max_word = \"\".to_string();\n    for word in words {\n  \
    \      let unique_chars = word.chars().collect::<HashSet<char>>().len();\n   \
    \     if unique_chars > max_unique_chars ||\n            (unique_chars == max_unique_chars\
    \ && word < max_word) {\n            max_unique_chars = unique_chars;\n      \
    \      max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpw3ka4u89.rs:15:51\n\
    \   |\n15 |         let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                   ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_string = String::new();\n    for word in words {\n     \
    \   let mut chars = HashSet::new();\n        for c in word.chars() {\n       \
    \     chars.insert(c);\n        }\n        if chars.len() > max_len {\n      \
    \      max_len = chars.len();\n            max_string = word;\n        }\n   \
    \ }\n    max_string\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp4ah6pk1r.rs:15:25\n   |\n15 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_string = String::new();\n    for word in words {\n        let\
    \ mut char_set = HashSet::new();\n        for c in word.chars() {\n          \
    \  char_set.insert(c);\n        }\n        if char_set.len() > max {\n       \
    \     max = char_set.len();\n            max_string = word;\n        }\n    }\n\
    \    max_string\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpu3zz012r.rs:15:28\n   |\n15 |         let mut char_set = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = (String::from(\"\
    \"), 0);\n    for word in words {\n        let mut chars = HashSet::new();\n \
    \       for c in word.chars() {\n            chars.insert(c);\n        }\n   \
    \     if chars.len() > max.1 {\n            max = (word, chars.len());\n     \
    \   }\n    }\n    max.0\n}\n\nfn main() {\n    let candidate = find_max;\n   \
    \ assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpl5ro59ui.rs:14:25\n   |\n14 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_set_size = unique_chars(&max_word).len();\n\
    \    for i in 1..words.len() {\n        let set_size = unique_chars(&words[i]).len();\n\
    \        if set_size > max_set_size {\n            max_set_size = set_size;\n\
    \            max_word = words[i].clone();\n        }\n    }\n    max_word\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpnrxv75ns.rs:13:28\n   |\n13 |     let mut max_set_size = unique_chars(&max_word).len();\n\
    \   |                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `unique_chars` in this scope\n  --> /tmp/tmpnrxv75ns.rs:15:24\n\
    \   |\n15 |         let set_size = unique_chars(&words[i]).len();\n   |      \
    \                  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let unique_chars = unique_chars(&word);\n        if unique_chars > max_unique_chars\
    \ {\n            max_unique_chars = unique_chars;\n            max_word = word;\n\
    \        } else if unique_chars == max_unique_chars && word < max_word {\n   \
    \         max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp785mqdo2.rs:15:28\n   |\n15 |         let unique_chars = unique_chars(&word);\n\
    \   |                            ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_unique_chars`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res: String\
    \ = String::from(\"\");\n    let mut max: usize = 0;\n    for word in words {\n\
    \        let len = set(word.clone()).len();\n        if len > max {\n        \
    \    max = len;\n            res = word;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `set` in this scope\n  --> /tmp/tmp81h7w69g.rs:15:19\n\
    \   |\n15 |         let len = set(word.clone()).len();\n   |                 \
    \  ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique\
    \ = 0;\n    let mut unique_index = 0;\n    for (index, word) in words.iter().enumerate()\
    \ {\n        let mut letters = HashSet::new();\n        for letter in word.chars()\
    \ {\n            letters.insert(letter);\n        }\n        if letters.len()\
    \ > max_unique {\n            max_unique = letters.len();\n            unique_index\
    \ = index;\n        }\n    }\n    words[unique_index].clone()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpgszs_0gr.rs:15:27\n   |\n15 |         let mut letters = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word = \"\".to_string();\n    for word in words {\n  \
    \      let mut map = HashMap::new();\n        for c in word.chars() {\n      \
    \      if map.contains_key(&c) {\n                let n = map.get_mut(&c).unwrap();\n\
    \                *n += 1;\n            } else {\n                map.insert(c,\
    \ 1);\n            }\n        }\n        let count = map.len();\n        if count\
    \ > max_count {\n            max_count = count;\n            max_word = word;\n\
    \        } else if count == max_count && word < max_word {\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpq78nfoo9.rs:15:23\n   |\n15 |         let mut map = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut len = 0;\n\
    \    let mut max = String::new();\n    for word in words {\n        let curr_len\
    \ = word.len();\n        if curr_len > len {\n            len = curr_len;\n  \
    \          max = word;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpjbjpnxo5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpq6v08rlp.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|word|\
    \ word.chars().unique().count()).unwrap().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp2qy58g11.rs:12:49\n   |\n12 |     words.iter().max_by_key(|word|\
    \ word.chars().unique().count()).unwrap().to_string()\n   |                  \
    \                               ^^^^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words_counts:\
    \ Vec<(String, i32)> = Vec::new();\n    for s in words {\n        let mut count\
    \ = 0;\n        let mut seen = HashSet::new();\n        for c in s.chars() {\n\
    \            if !seen.contains(&c) {\n                count += 1;\n          \
    \      seen.insert(c);\n            }\n        }\n        words_counts.push((s,\
    \ count));\n    }\n    words_counts.sort_by(|a, b| (b.1, &a.0).cmp(&(a.1, &b.0)));\n\
    \    words_counts[0].0\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvehznvoj.rs:15:24\n   |\n15 |         let mut seen = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_word = \"\".to_string();\n    for word in words {\n    \
    \    let mut chars = vec![];\n        for ch in word.chars() {\n            if\
    \ !chars.contains(&ch) {\n                chars.push(ch);\n            }\n   \
    \     }\n        if chars.len() > max_len {\n            max_len = chars.len();\n\
    \            max_word = word;\n        } else if chars.len() == max_len {\n  \
    \          if word < max_word {\n                max_word = word;\n          \
    \  }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_count = 0;\n    for word in words {\n\
    \        let unique_count = unique_count(&word);\n        if unique_count > max_unique_count\
    \ {\n            max_unique_count = unique_count;\n            max_word = word;\n\
    \        } else if unique_count == max_unique_count {\n            max_word =\
    \ String::from(\n                &[max_word.as_str(), word.as_str()].iter().min().unwrap().to_string(),\n\
    \            );\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_count` in this scope\n  -->\
    \ /tmp/tmpo4cdzern.rs:15:28\n   |\n15 |         let unique_count = unique_count(&word);\n\
    \   |                            ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_unique_count`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut max_unique_count = 0;\n    for word in words {\n\
    \        let unique_count = word.len() - word.matches(char::is_alphabetic).count();\n\
    \        if unique_count > max_unique_count {\n            max_unique_count =\
    \ unique_count;\n            result = word;\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmppgalcjsb.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_size = count_unique_chars(&max_word);\n\
    \    for word in words {\n        let word_unique_chars = count_unique_chars(&word);\n\
    \        if word_unique_chars > max_size {\n            max_size = word_unique_chars;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmpx17qeqai.rs:13:24\n   |\n13 |     let mut max_size = count_unique_chars(&max_word);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpx17qeqai.rs:15:33\n\
    \   |\n15 |         let word_unique_chars = count_unique_chars(&word);\n   | \
    \                                ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold((\"\
    \", 0), |acc, w| {\n        let count = unique_letters(w);\n        if count >\
    \ acc.1 {\n            (w, count)\n        } else if count == acc.1 {\n      \
    \      if w < acc.0 {\n                (w, count)\n            } else {\n    \
    \            acc\n            }\n        } else {\n            acc\n        }\n\
    \    }).0.to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_letters` in this scope\n  -->\
    \ /tmp/tmpup7nmlev.rs:13:21\n   |\n13 |         let count = unique_letters(w);\n\
    \   |                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpup7nmlev.rs:17:20\n   |\n17 |             if\
    \ w < acc.0 {\n   |                    ^^^^^ expected struct `String`, found `str`\n\
    \   |\n   = note: expected reference `&String`\n              found reference\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word_char_map:\
    \ HashMap<String, HashSet<char>> = HashMap::new();\n    let mut word_char_size_map:\
    \ HashMap<String, usize> = HashMap::new();\n    let mut max_size: usize = 0;\n\
    \    let mut unique_max_str: String = String::new();\n    for word in words {\n\
    \        let mut unique_chars: HashSet<char> = HashSet::new();\n        for c\
    \ in word.chars() {\n            unique_chars.insert(c);\n        }\n        word_char_map.insert(word.clone(),\
    \ unique_chars);\n        word_char_size_map.insert(word.clone(), unique_chars.len());\n\
    \        if unique_chars.len() > max_size {\n            max_size = unique_chars.len();\n\
    \            unique_max_str = word.clone();\n        } else if unique_chars.len()\
    \ == max_size {\n            if word < unique_max_str {\n                unique_max_str\
    \ = word.clone();\n            }\n        }\n    }\n    unique_max_str\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpquq4jv4o.rs:12:28\n\
    \   |\n12 |     let mut word_char_map: HashMap<String, HashSet<char>> = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpquq4jv4o.rs:12:44\n\
    \   |\n12 |     let mut word_char_map: HashMap<String, HashSet<char>> = HashMap::new();\n\
    \   |                                            ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpquq4jv4o.rs:12:61\n   |\n12 |     let mut word_char_map: HashMap<String,\
    \ HashSet<char>> = HashMap::new();\n   |                                     \
    \                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n  --> /tmp/tmpquq4jv4o.rs:13:33\n\
    \   |\n13 |     let mut word_char_size_map: HashMap<String, usize> = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpquq4jv4o.rs:13:58\n   |\n13 |     let mut word_char_size_map: HashMap<String,\
    \ usize> = HashMap::new();\n   |                                             \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashSet` in this scope\n  --> /tmp/tmpquq4jv4o.rs:17:31\n\
    \   |\n17 |         let mut unique_chars: HashSet<char> = HashSet::new();\n  \
    \ |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerr"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_len = unique_chars(&max_word);\n    for\
    \ word in words.iter().skip(1) {\n        let len = unique_chars(word);\n    \
    \    if len > max_len {\n            max_len = len;\n            max_word = word.clone();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp63y24d7i.rs:13:23\n   |\n13 |     let mut max_len = unique_chars(&max_word);\n\
    \   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `unique_chars` in this scope\n  --> /tmp/tmp63y24d7i.rs:15:19\n\
    \   |\n15 |         let len = unique_chars(word);\n   |                   ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word = String::new();\n    for word in words {\n     \
    \   let mut chars = word.chars().collect::<Vec<char>>();\n        chars.sort();\n\
    \        chars.dedup();\n        let count = chars.len();\n        if count >\
    \ max_count {\n            max_count = count;\n            max_word = word;\n\
    \        } else if count == max_count {\n            if word < max_word {\n  \
    \              max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = \"\".to_string();\n    let mut max_len = 0;\n    for word in words {\n   \
    \     let len = word.chars().fold(0, |acc, c| {\n            acc | 1 << (c as\
    \ u8 - b'a')\n        });\n        if len.count_ones() > max_len || (len.count_ones()\
    \ == max_len && word < max_word) {\n            max_word = word;\n           \
    \ max_len = len.count_ones();\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `count_ones` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmphz28rrfp.rs:18:16\n   |\n18 |         if len.count_ones()\
    \ > max_len || (len.count_ones() == max_len && word < max_word) {\n   |      \
    \          ^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n15 |         let len: i32 = word.chars().fold(0, |acc, c| {\n \
    \  |             ~~~~~~~~\n\nerror[E0689]: can't call method `count_ones` on ambiguous\
    \ numeric type `{integer}`\n  --> /tmp/tmphz28rrfp.rs:18:47\n   |\n18 |      \
    \   if len.count_ones() > max_len || (len.count_ones() == max_len && word < max_word)\
    \ {\n   |                                               ^^^^^^^^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n15 |         let\
    \ len: i32 = word.chars().fold(0, |acc, c| {\n   |             ~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `count_ones` on ambiguous numeric type `{integer}`\n  -->\
    \ /tmp/tmphz28rrfp.rs:20:27\n   |\n20 |             max_len = len.count_ones();\n\
    \   |                           ^^^^^^^^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `i32`\n   |\n15 |         let len: i32 = word.chars().fold(0,\
    \ |acc, c| {\n   |             ~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let unique_chars = word.chars().collect::<HashSet<char>>().len();\n \
    \       if unique_chars >= max_unique_chars {\n            max_unique_chars =\
    \ unique_chars;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpoq6tg8wd.rs:15:51\n\
    \   |\n15 |         let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                   ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ words[0].clone();\n    let mut max_number_of_unique_characters = find_number_of_unique_characters(&result);\n\
    \    for word in words.iter().skip(1) {\n        let current_number_of_unique_characters\
    \ = find_number_of_unique_characters(word);\n        if current_number_of_unique_characters\
    \ > max_number_of_unique_characters {\n            max_number_of_unique_characters\
    \ = current_number_of_unique_characters;\n            result = word.clone();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_number_of_unique_characters` in\
    \ this scope\n  --> /tmp/tmphc_5hla_.rs:13:47\n   |\n13 |     let mut max_number_of_unique_characters\
    \ = find_number_of_unique_characters(&result);\n   |                         \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `find_number_of_unique_characters` in this\
    \ scope\n  --> /tmp/tmphc_5hla_.rs:15:51\n   |\n15 |         let current_number_of_unique_characters\
    \ = find_number_of_unique_characters(word);\n   |                            \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `max_number_of_unique_characters`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut res = words[0].clone();\n\
    \    let mut max_len = res.len();\n    for i in 1..words.len() {\n        let\
    \ word = words[i].clone();\n        let len = word.len();\n        if len > max_len\
    \ {\n            max_len = len;\n            res = word;\n        } else if len\
    \ == max_len {\n            res = if word < res { word } else { res.clone() };\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"prrk\"`,\n right: `\"this\"`', /tmp/tmpsool849w.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut max_unique_char = 0;\n    for word in words {\n\
    \        let mut char_set = HashSet::new();\n        for c in word.chars() {\n\
    \            char_set.insert(c);\n        }\n        if char_set.len() > max_unique_char\
    \ {\n            max_unique_char = char_set.len();\n            result = word;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpibs_58ny.rs:15:28\n   |\n15 |         let mut char_set = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(String::new(),\
    \ |acc, word| {\n        if word.len() > acc.len() {\n            acc\n      \
    \  } else {\n            word.clone()\n        }\n    })\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpcvh6y1mu.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = words[0].clone();\n\
    \    let mut max_length = res.len();\n    for i in 1..words.len() {\n        let\
    \ mut count = 0;\n        let mut char_set = HashSet::new();\n        for c in\
    \ words[i].chars() {\n            if !char_set.contains(&c) {\n              \
    \  count += 1;\n                char_set.insert(c);\n            }\n        }\n\
    \        if count > max_length {\n            max_length = count;\n          \
    \  res = words[i].clone();\n        } else if count == max_length && words[i]\
    \ < res {\n            res = words[i].clone();\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpjdj0owbj.rs:16:28\n   |\n16 |         let mut char_set = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_idx = 0;\n    for (i, w) in words.iter().enumerate() {\n    \
    \    let letters = w.chars().collect::<HashSet<char>>();\n        if letters.len()\
    \ > max {\n            max = letters.len();\n            max_idx = i;\n      \
    \  }\n    }\n    words[max_idx].clone()\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpwns1qr5g.rs:15:43\n\
    \   |\n15 |         let letters = w.chars().collect::<HashSet<char>>();\n   |\
    \                                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_word = String::new();\n    for word in words {\n        let new_max\
    \ = max_unique_chars(&word);\n        if new_max > max {\n            max = new_max;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_unique_chars` in this scope\n \
    \ --> /tmp/tmp2s35w0rj.rs:15:23\n   |\n15 |         let new_max = max_unique_chars(&word);\n\
    \   |                       ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let current_count = word.chars().collect::<Vec<char>>().len();\n        if\
    \ current_count > max_count {\n            max_count = current_count;\n      \
    \      max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp2pugppmj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut max_unique_characters = 0;\n    for current_word in words {\n   \
    \     let current_unique_characters = unique_characters(current_word);\n     \
    \   if current_unique_characters > max_unique_characters {\n            max_unique_characters\
    \ = current_unique_characters;\n            word = current_word;\n        }\n\
    \    }\n    word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_characters` in this scope\n\
    \  --> /tmp/tmpeq5b2ky8.rs:15:41\n   |\n15 |         let current_unique_characters\
    \ = unique_characters(current_word);\n   |                                   \
    \      ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_unique_characters`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut out: Option<String>\
    \ = None;\n    let mut max = 0;\n    for word in words {\n        let unique =\
    \ unique_chars(&word);\n        if unique > max {\n            max = unique;\n\
    \            out = Some(word);\n        } else if unique == max {\n          \
    \  if let Some(o) = out {\n                if word < o {\n                   \
    \ out = Some(word);\n                }\n            }\n        }\n    }\n    if\
    \ let Some(o) = out {\n        o\n    } else {\n        String::from(\"\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpyhy5beim.rs:15:22\n   |\n15 |         let unique = unique_chars(&word);\n\
    \   |                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique_count\
    \ = 0;\n    let mut max_unique_word = String::new();\n    for word in words {\n\
    \        let unique_count = find_unique_count(&word);\n        if unique_count\
    \ > max_unique_count {\n            max_unique_count = unique_count;\n       \
    \     max_unique_word = word;\n        } else if unique_count == max_unique_count\
    \ {\n            max_unique_word = if word < max_unique_word {\n             \
    \   word\n            } else {\n                max_unique_word\n            }\n\
    \        }\n    }\n    max_unique_word\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_unique_count` in this scope\n\
    \  --> /tmp/tmpd4u71qy3.rs:15:28\n   |\n15 |         let unique_count = find_unique_count(&word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `max_unique_count`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut result = String::new();\n    for w in words {\n        let\
    \ count = w.chars().collect::<std::collections::HashSet<char>>().len();\n    \
    \    if count > max_count {\n            max_count = count;\n            result\
    \ = w;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpkab_iwrc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_string = String::new();\n    for word in words {\n   \
    \     let set: HashSet<char> = word.chars().collect();\n        if set.len() >\
    \ max_count {\n            max_count = set.len();\n            max_string = word;\n\
    \        }\n    }\n    max_string\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyy0h78it.rs:15:18\n\
    \   |\n15 |         let set: HashSet<char> = word.chars().collect();\n   |   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_characters_count = 0;\n    for word\
    \ in words {\n        let unique_characters_count = word.chars().collect::<HashSet<char>>().len();\n\
    \        if unique_characters_count > max_unique_characters_count\n          \
    \  || unique_characters_count == max_unique_characters_count\n               \
    \ && word < max_word\n        {\n            max_word = word;\n            max_unique_characters_count\
    \ = unique_characters_count;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5rjpea44.rs:15:62\n\
    \   |\n15 |         let unique_characters_count = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                              ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut word = String::new();\n\
    \    let mut max_unique_chars = 0;\n    for s in words {\n        let mut chars\
    \ = HashSet::new();\n        for c in s.chars() {\n            chars.insert(c);\n\
    \        }\n        if chars.len() > max_unique_chars {\n            max_unique_chars\
    \ = chars.len();\n            word = s;\n        }\n    }\n    word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp7y0f2p4d.rs:15:25\n   |\n15 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_uniq\
    \ = 0;\n    let mut found = \"\".to_string();\n    for word in words {\n     \
    \   let uniq = word.chars().collect::<HashSet<char>>().len();\n        if uniq\
    \ > max_uniq {\n            max_uniq = uniq;\n            found = word;\n    \
    \    }\n    }\n    found\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp_gysihtq.rs:15:43\n\
    \   |\n15 |         let uniq = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_char = 0;\n    for word in words {\n     \
    \   let chars: HashSet<char> = word.chars().collect();\n        if chars.len()\
    \ > max_char {\n            max_char = chars.len();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9riv5eoj.rs:15:20\n\
    \   |\n15 |         let chars: HashSet<char> = word.chars().collect();\n   | \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut set = HashSet::new();\n    let mut len = 0;\n    for word in words\
    \ {\n        set.clear();\n        for ch in word.chars() {\n            set.insert(ch);\n\
    \        }\n        if set.len() >= len {\n            if set.len() > len || word\
    \ < max {\n                max = word;\n                len = set.len();\n   \
    \         }\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpds0ynzpx.rs:13:19\n   |\n13 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|word|\
    \ {\n        let mut count = 0;\n        let mut chars = word.chars();\n     \
    \   let mut prev_char = chars.next();\n        loop {\n            match chars.next()\
    \ {\n                Some(c) => {\n                    if prev_char != Some(c)\
    \ {\n                        count += 1;\n                    }\n            \
    \        prev_char = Some(c);\n                }\n                None => break,\n\
    \            }\n        }\n        count\n    }).unwrap().to_string()\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmpnyvktoe3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut candidate: Option<String> = None;\n    for word in words {\n\
    \        let unique_chars = count_unique_chars(&word);\n        if unique_chars\
    \ > max_count {\n            max_count = unique_chars;\n            candidate\
    \ = Some(word);\n        } else if unique_chars == max_count {\n            if\
    \ let Some(cur_word) = candidate {\n                if word < cur_word {\n   \
    \                 candidate = Some(word);\n                }\n            }\n\
    \        }\n    }\n    if let Some(word) = candidate {\n        word\n    } else\
    \ {\n        String::new()\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmplyc64y3q.rs:15:28\n   |\n15 |         let unique_chars = count_unique_chars(&word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_count = max_word.len();\n    for i in 1..words.len()\
    \ {\n        let curr_count = words[i].len();\n        if curr_count > max_count\
    \ {\n            max_count = curr_count;\n            max_word = words[i].clone();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmprogs_j0k.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut chars: Vec<usize>\
    \ = vec![];\n    for mut word in words {\n        let mut chars_count = 0;\n \
    \       word.make_ascii_lowercase();\n        for c in word.chars() {\n      \
    \      if word.matches(c).count() == 1 {\n                chars_count += 1;\n\
    \            }\n        }\n        chars.push(chars_count);\n    }\n    let max\
    \ = chars.iter().max().unwrap();\n    let index = chars.iter().position(|&x| x\
    \ == *max).unwrap();\n    String::from(&words[index])\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `words`\n   --> /tmp/tmpgg51wfcn.rs:25:19\n\
    \    |\n11  | fn find_max(words: Vec<String>) -> String {\n    |             -----\
    \ move occurs because `words` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n12  |     let mut chars: Vec<usize> = vec![];\n13  |     for\
    \ mut word in words {\n    |                     ----- `words` moved due to this\
    \ implicit call to `.into_iter()`\n...\n25  |     String::from(&words[index])\n\
    \    |                   ^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `words`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n13  |     for mut word in &words {\n    |      \
    \               +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words;\n\
    \    words.sort_by(|a, b| count_chars(b).cmp(&count_chars(a)));\n    words[0].clone()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_chars` in this scope\n  --> /tmp/tmpx1xi4c5r.rs:13:26\n\
    \   |\n13 |     words.sort_by(|a, b| count_chars(b).cmp(&count_chars(a)));\n \
    \  |                          ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_chars` in this scope\n  --> /tmp/tmpx1xi4c5r.rs:13:46\n\
    \   |\n13 |     words.sort_by(|a, b| count_chars(b).cmp(&count_chars(a)));\n \
    \  |                                              ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique\
    \ = 1;\n    let mut word = &words[0];\n    for string in words {\n        let\
    \ unique_chars = string.chars().collect::<HashSet<char>>().len();\n        if\
    \ unique_chars > max_unique {\n            max_unique = unique_chars;\n      \
    \      word = &string;\n        }\n    }\n    word.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpbmeipk0o.rs:15:53\n\
    \   |\n15 |         let unique_chars = string.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                     ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let (curr_max, curr_max_ind)\
    \ = words.iter().enumerate().fold(\n        (words[0].len(), 0),\n        |(curr_max,\
    \ curr_max_ind), (ind, s)| {\n            if s.len() > curr_max {\n          \
    \      (s.len(), ind)\n            } else {\n                (curr_max, curr_max_ind)\n\
    \            }\n        },\n    );\n    words[curr_max_ind].clone()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpg62wfzhk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_str =\
    \ String::new();\n    let mut max_len = 0;\n    for i in words {\n        let\
    \ x = unique_characters(&i);\n        if x > max_len {\n            max_len =\
    \ x;\n            max_str = i;\n        } else if x == max_len {\n           \
    \ max_str = String::from(min(max_str.as_str(), i.as_str()));\n        }\n    }\n\
    \    max_str\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_characters` in this scope\n\
    \  --> /tmp/tmpq9f58a5m.rs:15:17\n   |\n15 |         let x = unique_characters(&i);\n\
    \   |                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpq9f58a5m.rs:20:36\n\
    \   |\n20 |             max_str = String::from(min(max_str.as_str(), i.as_str()));\n\
    \   |                                    ^^^\n...\n26 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n20 |             max_str = String::from(main(max_str.as_str(),\
    \ i.as_str()));\n   |                                    ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut best = words[0].clone();\n\
    \    let mut b_len = 0;\n    for word in words {\n        let len = word.chars().collect::<HashSet<char>>().len();\n\
    \        if len > b_len {\n            best = word.clone();\n            b_len\
    \ = len;\n        }\n    }\n    best\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8xn4_5qr.rs:15:42\n\
    \   |\n15 |         let len = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_words = vec![];\n    for word in words {\n        let mut set\
    \ = HashSet::new();\n        for ch in word.chars() {\n            set.insert(ch);\n\
    \        }\n        if set.len() > max {\n            max = set.len();\n     \
    \       max_words = vec![word];\n        } else if set.len() == max {\n      \
    \      max_words.push(word);\n        }\n    }\n    max_words.sort();\n    max_words[0].clone()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpv3d_j3nb.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let len = unique_characters(word);\n        if len > max_len {\n          \
    \  max_len = len;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_characters` in this scope\n\
    \  --> /tmp/tmp6zc9nu4k.rs:15:19\n   |\n15 |         let len = unique_characters(word);\n\
    \   |                   ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(String::new(),\
    \ |acc, x| {\n        if acc.len() < x.len() {\n            acc.clone()\n    \
    \    } else {\n            x.clone()\n        }\n    })\n}\n\nfn main() {\n  \
    \  let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmptnbj5rqn.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_chars:\
    \ HashSet<char> = HashSet::new();\n    let mut max_word = String::new();\n   \
    \ for word in words {\n        let mut chars: HashSet<char> = HashSet::new();\n\
    \        for c in word.chars() {\n            chars.insert(c);\n        }\n  \
    \      if chars.len() > max_chars.len() {\n            max_chars = chars;\n  \
    \          max_word = word;\n        } else if chars.len() == max_chars.len()\
    \ {\n            if word < max_word {\n                max_word = word;\n    \
    \        }\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfdxlxuht.rs:12:24\n\
    \   |\n12 |     let mut max_chars: HashSet<char> = HashSet::new();\n   |     \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpfdxlxuht.rs:12:40\n\
    \   |\n12 |     let mut max_chars: HashSet<char> = HashSet::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfdxlxuht.rs:15:24\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpfdxlxuht.rs:15:40\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let mut seen_characters = HashSet::new();\n        for c in word.chars()\
    \ {\n            seen_characters.insert(c);\n        }\n        if seen_characters.len()\
    \ > max_unique_chars {\n            max_unique_chars = seen_characters.len();\n\
    \            result = word;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp6nrlqf5j.rs:15:35\n   |\n15 |         let mut seen_characters = HashSet::new();\n\
    \   |                                   ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // unimplemented!()\n\
    \    // TODO: Implement your own solution here\n    let mut max_word = String::from(\"\
    \");\n    let mut max_cnt = 0;\n    for word in words {\n        let cnt = count_unique(word);\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_word\
    \ = word;\n        } else if cnt == max_cnt {\n            if word < max_word\
    \ {\n                max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique` in this scope\n  -->\
    \ /tmp/tmp5f7687p2.rs:17:19\n   |\n17 |         let cnt = count_unique(word);\n\
    \   |                   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|w|\
    \ w.chars().collect::<HashSet<_>>().len()).unwrap().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpawihzxkk.rs:12:53\n\
    \   |\n12 |     words.iter().max_by_key(|w| w.chars().collect::<HashSet<_>>().len()).unwrap().to_string()\n\
    \   |                                                     ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut sorted =\
    \ words.clone();\n    sorted.sort_by(|a, b| a.chars().collect::<HashSet<_>>().len().cmp(&b.chars().collect::<HashSet<_>>().len()));\n\
    \    sorted.last().unwrap().to_string()\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpq9yxg1ss.rs:13:47\n\
    \   |\n13 |     sorted.sort_by(|a, b| a.chars().collect::<HashSet<_>>().len().cmp(&b.chars().collect::<HashSet<_>>().len()));\n\
    \   |                                               ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpq9yxg1ss.rs:13:92\n\
    \   |\n13 |     sorted.sort_by(|a, b| a.chars().collect::<HashSet<_>>().len().cmp(&b.chars().collect::<HashSet<_>>().len()));\n\
    \   |                                                                        \
    \                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let mut count = 0;\n        let mut characters = std::collections::HashSet::new();\n\
    \        for c in word.chars() {\n            if !characters.contains(&c) {\n\
    \                count += 1;\n                characters.insert(c);\n        \
    \    }\n        }\n        if count > max_count {\n            max_count = count;\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpxuizv7xb.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    match words.len()\
    \ {\n        0 => String::new(),\n        1 => words[0].clone(),\n        _ =>\
    \ {\n            let mut max_word = words[0].clone();\n            let mut max_unique_characters\
    \ = unique_chars(&max_word);\n            for i in 1..words.len() {\n        \
    \        let word = &words[i];\n                let unique_characters = unique_chars(word);\n\
    \                if unique_characters > max_unique_characters {\n            \
    \        max_word = word.clone();\n                    max_unique_characters =\
    \ unique_characters;\n                } else if unique_characters == max_unique_characters\
    \ && word < &max_word {\n                    max_word = word.clone();\n      \
    \          }\n            }\n            max_word\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpmn38c_vp.rs:17:45\n   |\n17 |             let mut max_unique_characters\
    \ = unique_chars(&max_word);\n   |                                           \
    \  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `unique_chars` in this scope\n  --> /tmp/tmpmn38c_vp.rs:20:41\n   |\n20 |  \
    \               let unique_characters = unique_chars(word);\n   |            \
    \                             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word = String::new();\n    for word in words {\n     \
    \   let freq = count_unique_chars(&word);\n        if freq > max_count {\n   \
    \         max_count = freq;\n            max_word = word;\n        } else if freq\
    \ == max_count {\n            if word < max_word {\n                max_word =\
    \ word;\n            }\n        }\n    }\n    max_word\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmpab3ul47z.rs:15:20\n   |\n15 |         let freq = count_unique_chars(&word);\n\
    \   |                    ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_unique_char = unique_char_in_string(&max_word);\n\
    \    for word in words.iter() {\n        let unique_char = unique_char_in_string(word);\n\
    \        if unique_char > max_unique_char {\n            max_unique_char = unique_char;\n\
    \            max_word = word.clone();\n        }\n    }\n    max_word\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_char_in_string` in this scope\n\
    \  --> /tmp/tmpcue47u6n.rs:13:31\n   |\n13 |     let mut max_unique_char = unique_char_in_string(&max_word);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `unique_char_in_string` in this scope\n \
    \ --> /tmp/tmpcue47u6n.rs:15:27\n   |\n15 |         let unique_char = unique_char_in_string(word);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_string\
    \ = words[0].clone();\n    let mut max_chars = words[0].chars().collect::<HashSet<char>>().len();\n\
    \    for word in words.iter().skip(1) {\n        let chars = word.chars().collect::<HashSet<char>>().len();\n\
    \        if chars > max_chars {\n            max_chars = chars;\n            max_string\
    \ = word.clone();\n        }\n    }\n    max_string\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmptf4ezdjw.rs:13:52\n\
    \   |\n13 |     let mut max_chars = words[0].chars().collect::<HashSet<char>>().len();\n\
    \   |                                                    ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmptf4ezdjw.rs:15:44\n\
    \   |\n15 |         let chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                            ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_unique_chars = 0;\n    for word in words\
    \ {\n        let unique_chars = find_unique_chars(&word);\n        if unique_chars\
    \ > max_unique_chars {\n            max_unique_chars = unique_chars;\n       \
    \     max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_unique_chars` in this scope\n\
    \  --> /tmp/tmpdrxg8txh.rs:15:28\n   |\n15 |         let unique_chars = find_unique_chars(&word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `max_unique_chars`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_count = word_count(&words[0]);\n    for\
    \ i in 1..words.len() {\n        let count = word_count(&words[i]);\n        if\
    \ count > max_count {\n            max_count = count;\n            max_word =\
    \ words[i].clone();\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `word_count` in this scope\n  --> /tmp/tmpkvdo4yqw.rs:13:25\n\
    \   |\n13 |     let mut max_count = word_count(&words[0]);\n   |             \
    \            ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `word_count` in this scope\n  --> /tmp/tmpkvdo4yqw.rs:15:21\n   |\n15 |    \
    \     let count = word_count(&words[i]);\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|x|\
    \ unique_chars(x)).unwrap().to_string()\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp5vx5hr22.rs:12:33\n   |\n12 |     words.iter().max_by_key(|x| unique_chars(x)).unwrap().to_string()\n\
    \   |                                 ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_string\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let word_set: HashSet<char> = word.chars().collect();\n        if word_set.len()\
    \ > max_len {\n            max_len = word_set.len();\n            max_string =\
    \ word;\n        }\n    }\n    max_string\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp_kuacacg.rs:15:23\n\
    \   |\n15 |         let word_set: HashSet<char> = word.chars().collect();\n  \
    \ |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique\
    \ = 0;\n    let mut max_unique_string = String::new();\n    for word in words\
    \ {\n        let num_unique = count_unique_chars(&word);\n        if num_unique\
    \ > max_unique {\n            max_unique = num_unique;\n            max_unique_string\
    \ = word;\n        }\n    }\n    max_unique_string\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmp7ofzn7bl.rs:15:26\n   |\n15 |         let num_unique = count_unique_chars(&word);\n\
    \   |                          ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut max_count = 0;\n    let\
    \ mut max_index = 0;\n    for (index, word) in words.iter().enumerate() {\n  \
    \      let unique_count = unique_char_count(word);\n        if unique_count >\
    \ max_count {\n            max_count = unique_count;\n            max_index =\
    \ index;\n        }\n    }\n    words[max_index].clone()\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_char_count` in this scope\n\
    \  --> /tmp/tmpf1fsfiww.rs:18:28\n   |\n18 |         let unique_count = unique_char_count(word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut uniq_cnt: usize = 0;\n    for i in 0..words.len()\
    \ {\n        let curr_cnt = unique_chars(&words[i]);\n        if uniq_cnt < curr_cnt\
    \ {\n            uniq_cnt = curr_cnt;\n            result = words[i].clone();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpz7se3dm8.rs:15:24\n   |\n15 |         let curr_cnt = unique_chars(&words[i]);\n\
    \   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = words[0].clone();\n\
    \    let mut num_max_unique_chars = max.len();\n    for i in 1..words.len() {\n\
    \        let unique_chars = get_unique_chars(words[i].clone());\n        if unique_chars.len()\
    \ > num_max_unique_chars {\n            max = words[i].clone();\n            num_max_unique_chars\
    \ = unique_chars.len();\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_unique_chars` in this scope\n \
    \ --> /tmp/tmp_b2bhvdz.rs:15:28\n   |\n15 |         let unique_chars = get_unique_chars(words[i].clone());\n\
    \   |                            ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = &words[0];\n    let mut max_num_unique_characters = 0;\n    for word in words\
    \ {\n        let mut letters = BTreeSet::new();\n        for c in word.chars()\
    \ {\n            letters.insert(c);\n        }\n        if letters.len() > max_num_unique_characters\
    \ {\n            max_num_unique_characters = letters.len();\n            max_word\
    \ = &word;\n        }\n    }\n    max_word.clone()\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  -->\
    \ /tmp/tmpleg2zvx6.rs:15:27\n   |\n15 |         let mut letters = BTreeSet::new();\n\
    \   |                           ^^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::BTreeSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = \"\".to_string();\n    let mut max_chars = 0;\n    for word in words {\n \
    \       let unique_chars = unique_characters(word);\n        if unique_chars >\
    \ max_chars {\n            max_chars = unique_chars;\n            max_word = word;\n\
    \        } else if unique_chars == max_chars {\n            if word < max_word\
    \ {\n                max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_characters` in this scope\n\
    \  --> /tmp/tmpx0juw6qt.rs:15:28\n   |\n15 |         let unique_chars = unique_characters(word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_count\
    \ = 0;\n    let mut max_word = String::new();\n    for word in words {\n     \
    \   let s: Vec<char> = word.chars().collect();\n        let mut found_chars =\
    \ HashSet::new();\n        for c in s {\n            found_chars.insert(c);\n\
    \        }\n        if found_chars.len() > max_count {\n            max_count\
    \ = found_chars.len();\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkmkr1hdy.rs:16:31\n   |\n16 |         let mut found_chars = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold((0,\
    \ String::new()), |acc, x| {\n        let mut b = HashSet::new();\n        for\
    \ ch in x.chars() {\n            b.insert(ch);\n        }\n        if b.len()\
    \ > acc.0 {\n            (b.len(), x.clone())\n        } else {\n            acc\n\
    \        }\n    }).1\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpzsmp3wsd.rs:13:21\n   |\n13 |         let mut b = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // unimplemented!(\"\
    Find word in {:?} with maximum number of unique characters. {:?}\", words, words.iter().map(|s|\
    \ (s, s.chars().collect::<HashSet<_>>().len())).collect::<Vec<_>>())\n    let\
    \ mut it = words.iter();\n    match it.next() {\n        Some(word) => it.fold(word,\
    \ |r, w| if w.chars().collect::<HashSet<_>>().len() > r.chars().collect::<HashSet<_>>().len()\
    \ {w} else {r}),\n        None => \"\".to_string(),\n    }\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpjof52e84.rs:15:67\n\
    \   |\n15 | ...   Some(word) => it.fold(word, |r, w| if w.chars().collect::<HashSet<_>>().len()\
    \ > r.chars().collect::<HashSet<_>>().len() {w} else {r}),\n   |             \
    \                                                    ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpjof52e84.rs:15:109\n\
    \   |\n15 | ...ollect::<HashSet<_>>().len() > r.chars().collect::<HashSet<_>>().len()\
    \ {w} else {r}),\n   |                                                       ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjof52e84.rs:15:31\n   |\n15 | ...   Some(word) => it.fold(word,\
    \ |r, w| if w.chars().collect::<HashSet<_>>().len() > r.chars().collect::<HashSet<_>>().len()\
    \ {w} else {r}),\n   |                             ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                             |\n   |           \
    \                  expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjof52e84.rs:15:130\n   |\n15 | ....chars().collect::<HashSet<_>>().len()\
    \ {w} else {r}),\n   |                                            ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \                |\n   |                                            expected struct\
    \ `String`, found `&String`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut best = &words[0];\n\
    \    for i in 1..words.len() {\n        if unique_char_count(&words[i]) > unique_char_count(best)\
    \ {\n            best = &words[i];\n        }\n    }\n    best.clone()\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_char_count` in this scope\n\
    \  --> /tmp/tmpigl66_qb.rs:14:12\n   |\n14 |         if unique_char_count(&words[i])\
    \ > unique_char_count(best) {\n   |            ^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `unique_char_count` in this\
    \ scope\n  --> /tmp/tmpigl66_qb.rs:14:43\n   |\n14 |         if unique_char_count(&words[i])\
    \ > unique_char_count(best) {\n   |                                          \
    \ ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut res = words[0].clone();\n\
    \    let mut max_unique = count_unique_char(words[0].clone());\n    for i in 1..words.len()\
    \ {\n        let tmp = count_unique_char(words[i].clone());\n        if tmp >\
    \ max_unique {\n            max_unique = tmp;\n            res = words[i].clone();\n\
    \        } else if tmp == max_unique && words[i] < res {\n            res = words[i].clone();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_char` in this scope\n\
    \  --> /tmp/tmp5pron4ml.rs:16:26\n   |\n16 |     let mut max_unique = count_unique_char(words[0].clone());\n\
    \   |                          ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_unique_char` in this scope\n  --> /tmp/tmp5pron4ml.rs:18:19\n\
    \   |\n18 |         let tmp = count_unique_char(words[i].clone());\n   |     \
    \              ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_num =\
    \ 0;\n    let mut max_word = \"\".to_string();\n    for word in words {\n    \
    \    let mut dict = std::collections::HashSet::new();\n        for c in word.chars()\
    \ {\n            dict.insert(c);\n        }\n        if dict.len() > max_num {\n\
    \            max_num = dict.len();\n            max_word = word;\n        } else\
    \ if dict.len() == max_num {\n            if word < max_word {\n             \
    \   max_word = word;\n            }\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut candidate:\
    \ String = words[0].clone();\n    let mut candidate_len: usize = unique_chars(&candidate);\n\
    \    for word in words.iter().skip(1) {\n        let word_len = unique_chars(word);\n\
    \        if word_len > candidate_len {\n            candidate = word.clone();\n\
    \            candidate_len = word_len;\n        }\n    }\n    candidate\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpeo01or0s.rs:13:36\n   |\n13 |     let mut candidate_len: usize = unique_chars(&candidate);\n\
    \   |                                    ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `unique_chars` in this scope\n  --> /tmp/tmpeo01or0s.rs:15:24\n\
    \   |\n15 |         let word_len = unique_chars(word);\n   |                 \
    \       ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = String::new();\n\
    \    let mut uniques = 0;\n    for word in words {\n        let mut uniques_here\
    \ = 0;\n        for c in word.chars() {\n            if !res.contains(c) {\n \
    \               uniques_here += 1;\n            }\n        }\n        if uniques_here\
    \ > uniques {\n            res = word;\n            uniques = uniques_here;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp33hxf502.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpq6v08rlp.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len:\
    \ usize = 0;\n    let mut res = String::new();\n    for word in words {\n    \
    \    let mut set = std::collections::HashSet::new();\n        for c in word.chars()\
    \ {\n            set.insert(c);\n        }\n        if set.len() > max_len {\n\
    \            max_len = set.len();\n            res = word;\n        } else if\
    \ set.len() == max_len {\n            res = res.cmp(&word).min().unwrap();\n \
    \       }\n    }\n    res\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp_fskw2as.rs:23:34\n    |\n23  |             res = res.cmp(&word).min().unwrap();\n\
    \    |                                  ^^^- supplied 0 arguments\n    |     \
    \                             |\n    |                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n\
    \  --> /tmp/tmp_fskw2as.rs:23:40\n   |\n23 |             res = res.cmp(&word).min().unwrap();\n\
    \   |                                        ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    match words.len()\
    \ {\n        0 => String::new(),\n        1 => words[0].clone(),\n        _ =>\
    \ {\n            let mut max = words[0].clone();\n            let mut max_len\
    \ = max.len();\n            for word in words {\n                let mut word_set\
    \ = HashSet::new();\n                for ch in word.chars() {\n              \
    \      word_set.insert(ch);\n                }\n                if word_set.len()\
    \ > max_len {\n                    max = word;\n                    max_len =\
    \ word_set.len();\n                }\n            }\n            max\n       \
    \ }\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyycwhnu3.rs:19:36\n   |\n19 |                 let mut word_set = HashSet::new();\n\
    \   |                                    ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_str = \"\".to_string();\n    for word in words {\n        let\
    \ mut set = HashSet::new();\n        for char in word.chars() {\n            set.insert(char);\n\
    \        }\n        if set.len() > max {\n            max = set.len();\n     \
    \       max_str = word;\n        }\n    }\n    max_str\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp2q8_j_60.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut max_count = 0;\n    let\
    \ mut max_word = String::new();\n    for word in words {\n        let current_count\
    \ = count_uniq_chars(&word);\n        if current_count > max_count {\n       \
    \     max_count = current_count;\n            max_word = word;\n        } else\
    \ if current_count == max_count {\n            max_word = if word < max_word {\
    \ word } else { max_word };\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_uniq_chars` in this scope\n \
    \ --> /tmp/tmpurjr53dt.rs:18:29\n   |\n18 |         let current_count = count_uniq_chars(&word);\n\
    \   |                             ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_uniq_chars_num = 0;\n    for word in words\
    \ {\n        let mut uniq_chars_num = 0;\n        let mut chars = HashSet::new();\n\
    \        for c in word.chars() {\n            if !chars.contains(&c) {\n     \
    \           uniq_chars_num += 1;\n                chars.insert(c);\n         \
    \   }\n        }\n        if uniq_chars_num > max_uniq_chars_num {\n         \
    \   max_uniq_chars_num = uniq_chars_num;\n            max_word = word;\n     \
    \   }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpaadd42c1.rs:16:25\n   |\n16 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let mut map = HashMap::new();\n        for c in word.chars() {\n        \
    \    map.insert(c, 1);\n        }\n        let count = map.len();\n        if\
    \ count > max_count {\n            max_count = count;\n            max_word =\
    \ word;\n        } else if count == max_count {\n            if word < max_word\
    \ {\n                max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprvuf4z7f.rs:15:23\n   |\n15 |         let mut map = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_count = 0;\n    for word in words {\n        let mut set = HashSet::new();\n\
    \        for ch in word.chars() {\n            set.insert(ch);\n        }\n  \
    \      if set.len() > max_count {\n            max = word;\n            max_count\
    \ = set.len();\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp7sph1yrd.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // FIXME\n    \"\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpeomfnk_o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_index\
    \ = 0;\n    let mut max_len = 0;\n    for (index, word) in words.iter().enumerate()\
    \ {\n        let new_len = find_length(word);\n        if new_len > max_len {\n\
    \            max_len = new_len;\n            max_index = index;\n        }\n \
    \   }\n    return words[max_index].clone();\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_length` in this scope\n  --> /tmp/tmpcwdab5iv.rs:15:23\n\
    \   |\n15 |         let new_len = find_length(word);\n   |                   \
    \    ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_chars = 0;\n    for word in words {\n \
    \       let chars = word.chars().collect::<HashSet<char>>().len();\n        if\
    \ chars > max_chars {\n            max_chars = chars;\n            max_word =\
    \ word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpuvnn2rpl.rs:15:44\n\
    \   |\n15 |         let chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                            ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let word_set: HashSet<char> = word.chars().collect();\n        if word_set.len()\
    \ > max_len {\n            max_len = word_set.len();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpibhky03r.rs:15:23\n\
    \   |\n15 |         let word_set: HashSet<char> = word.chars().collect();\n  \
    \ |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let max_unique =\
    \ words.iter().map(|w| w.chars().count()).max().unwrap();\n    let max_words:\
    \ Vec<&String> = words.iter().filter(|w| w.chars().count() == max_unique).collect();\n\
    \    max_words[0].clone()\n}\n\nfn main() {\n    let candidate = find_max;\n \
    \   assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpxweeb53i.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: Implement\
    \ the function here\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpet5qitmo.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut words = words;\n\
    \    words.sort_by(|a, b| a.len().cmp(&b.len()));\n    words.iter().rev().skip_while(|word|\
    \ {\n        word.bytes().map(|b| b as usize).collect::<Vec<usize>>().len()\n\
    \            != word.bytes().collect::<Vec<u8>>().len()\n    }).next().unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmpvxa1zlrr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut max_chars = 0;\n    for word in words {\n      \
    \  let mut chars = HashSet::new();\n        for c in word.chars() {\n        \
    \    chars.insert(c);\n        }\n        if chars.len() > max_chars {\n     \
    \       max_chars = chars.len();\n            result = word;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5lji_h28.rs:15:25\n   |\n15 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold((\"\
    \", 0), |acc, w| {\n        let curr_unique_chars = w.chars().unique().count();\n\
    \        if curr_unique_chars > acc.1 {\n            (w, curr_unique_chars)\n\
    \        } else {\n            acc\n        }\n    }).0.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpqosiqse_.rs:13:43\n   |\n13 |         let curr_unique_chars\
    \ = w.chars().unique().count();\n   |                                        \
    \   ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_count = count_unique_characters(&max_word);\n\
    \    for (i, word) in words.iter().enumerate() {\n        if i == 0 {\n      \
    \      continue;\n        }\n        let count = count_unique_characters(word);\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word.clone();\n        } else if count == max_count {\n            if word\
    \ < &max_word {\n                max_word = word.clone();\n            }\n   \
    \     }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_characters` in this scope\n\
    \  --> /tmp/tmp6i4whlx9.rs:13:25\n   |\n13 |     let mut max_count = count_unique_characters(&max_word);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `count_unique_characters` in this scope\n\
    \  --> /tmp/tmp6i4whlx9.rs:18:21\n   |\n18 |         let count = count_unique_characters(word);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    let\
    \ mut result: String = words[0].clone();\n    let mut max_count: usize = count_unique_chars(&words[0]);\n\
    \    for word in words.iter() {\n        let count = count_unique_chars(word);\n\
    \        if count > max_count {\n            max_count = count;\n            result\
    \ = word.clone();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmp_p68c2uf.rs:14:32\n   |\n14 |     let mut max_count: usize = count_unique_chars(&words[0]);\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  -->\
    \ /tmp/tmp_p68c2uf.rs:16:21\n   |\n16 |         let count = count_unique_chars(word);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut uniq_chars\
    \ = Vec::new();\n    let mut res = String::new();\n    for word in words {\n \
    \       let mut chars = HashSet::new();\n        for ch in word.chars() {\n  \
    \          chars.insert(ch);\n        }\n        uniq_chars.push(chars.len());\n\
    \    }\n    let max = uniq_chars.iter().max().unwrap();\n    for i in 0..uniq_chars.len()\
    \ {\n        if uniq_chars[i] == *max {\n            res = words[i].clone();\n\
    \            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8uvlmb71.rs:15:25\n   |\n15 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut min_word = String::new();\n    for word in words {\n        let unique_count\
    \ = unique_char_count(&word);\n        if unique_count > max {\n            max\
    \ = unique_count;\n            min_word = word;\n        } else if unique_count\
    \ == max {\n            if word < min_word {\n                min_word = word;\n\
    \            }\n        }\n    }\n    min_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_char_count` in this scope\n\
    \  --> /tmp/tmprr3xny9k.rs:15:28\n   |\n15 |         let unique_count = unique_char_count(&word);\n\
    \   |                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_unique_chars = max_word.len();\n    for\
    \ word in words {\n        let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \        if unique_chars > max_unique_chars {\n            max_unique_chars =\
    \ unique_chars;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpuz570x2h.rs:15:51\n\
    \   |\n15 |         let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                   ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = \"\"\
    .to_string();\n    let mut max_unique = 0;\n    for word in words {\n        let\
    \ unique = unique_characters(&word);\n        if unique > max_unique {\n     \
    \       max = word;\n            max_unique = unique;\n        } else if unique\
    \ == max_unique && word < max {\n            max = word;\n        }\n    }\n \
    \   max\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_characters` in this scope\n\
    \  --> /tmp/tmpoag4fthf.rs:15:22\n   |\n15 |         let unique = unique_characters(&word);\n\
    \   |                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_num = 0;\n    for word in words {\n   \
    \     let num = count_unique_chars(&word);\n        if num > max_num {\n     \
    \       max_num = num;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmpk960q9wv.rs:15:19\n   |\n15 |         let num = count_unique_chars(&word);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(\n\
    \        (0, String::from(\"\")),\n        |(max_len, max_word), x| {\n      \
    \      let x_len = x.chars().collect::<HashSet<char>>().len();\n            if\
    \ x_len > max_len {\n                (x_len, x.clone())\n            } else if\
    \ x_len == max_len {\n                if x < &max_word {\n                   \
    \ (x_len, x.clone())\n                } else {\n                    (max_len,\
    \ max_word)\n                }\n            } else {\n                (max_len,\
    \ max_word)\n            }\n        },\n    )\n    .1\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpszjxjxk3.rs:15:45\n\
    \   |\n15 |             let x_len = x.chars().collect::<HashSet<char>>().len();\n\
    \   |                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut max_count = 0;\n    for word in words {\n      \
    \  let mut freq = HashMap::new();\n        for c in word.chars() {\n         \
    \   *freq.entry(c).or_insert(0) += 1;\n        }\n        if freq.len() > max_count\
    \ {\n            max_count = freq.len();\n            result = word;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpjz4acco5.rs:15:24\n   |\n15 |         let mut freq = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let (mut max_word,\
    \ mut max_unique) = (String::new(), 0);\n    for word in words {\n        let\
    \ mut seen = HashSet::new();\n        for c in word.chars() {\n            seen.insert(c);\n\
    \        }\n        if seen.len() > max_unique {\n            max_word = word;\n\
    \            max_unique = seen.len();\n        }\n    }\n    max_word\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptqex4x1n.rs:14:24\n   |\n14 |         let mut seen = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = words[0].clone();\n\
    \    let mut max_count = count_unique(words[0].clone());\n    for word in words.iter().skip(1)\
    \ {\n        let count = count_unique(word.clone());\n        if count > max_count\
    \ {\n            max = word.clone();\n            max_count = count;\n       \
    \ }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique` in this scope\n  -->\
    \ /tmp/tmp87m9ah6j.rs:13:25\n   |\n13 |     let mut max_count = count_unique(words[0].clone());\n\
    \   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_unique` in this scope\n  --> /tmp/tmp87m9ah6j.rs:15:21\n\
    \   |\n15 |         let count = count_unique(word.clone());\n   |            \
    \         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().fold(String::new(),\
    \ |prev, word| {\n        if word.len() > prev.len() {\n            word.clone()\n\
    \        } else {\n            prev\n        }\n    })\n}\n\nfn main() {\n   \
    \ let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp_kzbm8h0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ \"\".to_string();\n    let mut count = 0;\n    for word in words {\n       \
    \ let mut chars: HashSet<char> = HashSet::new();\n        for c in word.chars()\
    \ {\n            chars.insert(c);\n        }\n        if chars.len() > count {\n\
    \            count = chars.len();\n            result = word;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpxd_ok5eu.rs:15:24\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxd_ok5eu.rs:15:40\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpq6v08rlp.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|word|\
    \ {\n        word.chars().fold(HashSet::new(), |mut set, ch| {\n            set.insert(ch);\n\
    \            set\n        }).len()\n    }).unwrap().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8f5d0yok.rs:13:27\n   |\n13 |         word.chars().fold(HashSet::new(),\
    \ |mut set, ch| {\n   |                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut max_count = 0;\n    let\
    \ mut max_word = words[0].clone();\n    for word in words {\n        let count\
    \ = is_unique(&word);\n        if count > max_count {\n            max_count =\
    \ count;\n            max_word = word;\n        }\n    }\n    max_word\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_unique` in this scope\n  --> /tmp/tmpbiudma3z.rs:18:21\n\
    \   |\n18 |         let count = is_unique(&word);\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut sorted_words\
    \ = words.clone();\n    sorted_words.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    let mut count = 0;\n    let mut max_word = String::new();\n    for word in\
    \ sorted_words {\n        let chars = word.chars().collect::<Vec<char>>();\n \
    \       let new_count = chars.iter().unique().count();\n        if new_count >\
    \ count {\n            count = new_count;\n            max_word = word;\n    \
    \    }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp3wtj_mmi.rs:18:38\n   |\n18 |         let\
    \ new_count = chars.iter().unique().count();\n   |                           \
    \           ^^^^^^ method not found in `std::slice::Iter<'_, char>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|w|\
    \ (w.chars().collect::<HashSet<_>>().len(), w)).unwrap().to_string()\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpicq561zv.rs:12:54\n\
    \   |\n12 |     words.iter().max_by_key(|w| (w.chars().collect::<HashSet<_>>().len(),\
    \ w)).unwrap().to_string()\n   |                                             \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmpz_f5f57g.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut result = \"\".to_string();\n    for word in words {\n      \
    \  let mut set = HashSet::new();\n        for ch in word.chars() {\n         \
    \   set.insert(ch);\n        }\n        if set.len() > max_len {\n           \
    \ max_len = set.len();\n            result = word;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_gizs5kn.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = &words[0];\n    let mut max_num_of_chars = max_word.len();\n    for word in\
    \ words.iter() {\n        let mut uniq_chars = HashSet::new();\n        for c\
    \ in word.chars() {\n            uniq_chars.insert(c);\n        }\n        if\
    \ uniq_chars.len() > max_num_of_chars {\n            max_num_of_chars = uniq_chars.len();\n\
    \            max_word = word;\n        }\n    }\n    max_word.clone()\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpqgt0ievt.rs:15:30\n   |\n15 |         let mut uniq_chars = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_chars = 0;\n    for word in words {\n    \
    \    let chars = unique_chars(word);\n        if chars > max_chars {\n       \
    \     max_chars = chars;\n            max_word = word;\n        } else if chars\
    \ == max_chars && word < max_word {\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp58ry3rwe.rs:15:21\n   |\n15 |         let chars = unique_chars(word);\n\
    \   |                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_string\
    \ = String::new();\n    let mut max_counter = 0;\n    for word in words {\n  \
    \      let mut counter = 0;\n        let mut chars = HashSet::new();\n       \
    \ for character in word.chars() {\n            if !chars.contains(&character)\
    \ {\n                chars.insert(character);\n                counter += 1;\n\
    \            }\n        }\n        if counter > max_counter {\n            max_counter\
    \ = counter;\n            max_string = word;\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp41igrpqv.rs:16:25\n   |\n16 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let unique_chars = unique_chars(&word);\n        if unique_chars.len() > max_len\
    \ {\n            max_len = unique_chars.len();\n            max_word = word;\n\
    \        } else if unique_chars.len() == max_len {\n            if word < max_word\
    \ {\n                max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp_q1xyewn.rs:15:28\n   |\n15 |         let unique_chars = unique_chars(&word);\n\
    \   |                            ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_str =\
    \ String::new();\n    let mut max_unique_num = 0;\n    for word in words {\n \
    \       let mut set = std::collections::HashSet::new();\n        for ch in word.chars()\
    \ {\n            set.insert(ch);\n        }\n        if set.len() > max_unique_num\
    \ {\n            max_unique_num = set.len();\n            max_str = word;\n  \
    \      }\n    }\n    max_str\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpz7a0zptk.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut uniq_count\
    \ = std::collections::HashMap::new();\n    for word in words {\n        let mut\
    \ set = std::collections::HashSet::new();\n        for letter in word.chars()\
    \ {\n            set.insert(letter);\n        }\n        uniq_count.insert(word,\
    \ set.len());\n    }\n    let max_count = uniq_count.values().max().unwrap();\n\
    \    for word in words {\n        if *uniq_count.get(&word).unwrap() == *max_count\
    \ {\n            return word;\n        }\n    }\n    panic!();\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `words`\n   --> /tmp/tmpu7tdl7cp.rs:21:17\n\
    \    |\n11  | fn find_max(words: Vec<String>) -> String {\n    |             -----\
    \ move occurs because `words` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n12  |     let mut uniq_count = std::collections::HashMap::new();\n\
    13  |     for word in words {\n    |                 ----- `words` moved due to\
    \ this implicit call to `.into_iter()`\n...\n21  |     for word in words {\n \
    \   |                 ^^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `words`\nhelp: consider\
    \ iterating over a slice of the `Vec<String>`'s content to avoid moving into the\
    \ `for` loop\n    |\n13  |     for word in &words {\n    |                 +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_uniq_chars_count = 0;\n    for word in words {\n        let chars:\
    \ Vec<char> = word.chars().collect();\n        let count = chars.len();\n    \
    \    let uniq_chars_count = chars.iter().collect::<std::collections::HashSet<_>>().len();\n\
    \        if uniq_chars_count > max_uniq_chars_count {\n            max = word;\n\
    \            max_uniq_chars_count = uniq_chars_count;\n        } else if uniq_chars_count\
    \ == max_uniq_chars_count && word < max {\n            max = word;\n        }\n\
    \    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut v: Vec<(String,\
    \ u32)> = Vec::new();\n    for s in words {\n        let mut temp = String::new();\n\
    \        let mut m = s.len();\n        for c in s.chars() {\n            if !temp.contains(c)\
    \ {\n                temp.push(c);\n                m -= 1;\n            }\n \
    \       }\n        v.push((s, m as u32));\n    }\n    v.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    v.last().unwrap().0.clone()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmpoqkz0hr7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ \"\".to_string();\n    let mut max_count = 0;\n    for word in words {\n   \
    \     let mut char_counts = vec![0; 26];\n        for ch in word.chars() {\n \
    \           char_counts[ch as usize - 'a' as usize] += 1;\n        }\n       \
    \ let unique_count = char_counts.iter().filter(|&&count| count == 1).count();\n\
    \        if unique_count > max_count {\n            max_count = unique_count;\n\
    \            result = word;\n        } else if unique_count == max_count && word\
    \ < result {\n            result = word;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"aaaaaaa\"`', /tmp/tmp5tqogw1u.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = (0,\
    \ 0); //(length, index)\n    for (i, word) in words.iter().enumerate() {\n   \
    \     let chars = word.chars().collect::<HashSet<_>>();\n        if chars.len()\
    \ > max.0 {\n            max = (chars.len(), i);\n        }\n    }\n    words[max.1].clone()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfomsbbr4.rs:14:44\n\
    \   |\n14 |         let chars = word.chars().collect::<HashSet<_>>();\n   |  \
    \                                          ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_char_counts\
    \ = words\n        .iter()\n        .map(|s| count_unique_chars(&s))\n       \
    \ .collect::<Vec<usize>>();\n    let max_index = unique_char_counts\n        .iter()\n\
    \        .enumerate()\n        .max_by(|a, b| a.1.cmp(b.1))\n        .unwrap()\n\
    \        .0;\n    words[max_index].clone()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_chars` in this scope\n\
    \  --> /tmp/tmpxm8gnju0.rs:14:18\n   |\n14 |         .map(|s| count_unique_chars(&s))\n\
    \   |                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut count_max = 0;\n    for word in words {\n    \
    \    let count = count_unique_characters(&word);\n        if count_max < count\
    \ {\n            count_max = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_characters` in this scope\n\
    \  --> /tmp/tmpqe9ekx01.rs:15:21\n   |\n15 |         let count = count_unique_characters(&word);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_idx = 0;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let len = word.chars().collect::<HashSet<char>>().len();\n      \
    \  if len > max_len {\n            max_len = len;\n            max_idx = i;\n\
    \        }\n    }\n    words[max_idx].clone()\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpj_hpwvmn.rs:15:42\n\
    \   |\n15 |         let len = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = \"\".to_string();\n    let mut max_score = 0;\n    for word in words {\n \
    \       let score = word.chars().unique().count();\n        if score > max_score\
    \ {\n            max_score = score;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpd5minauz.rs:15:34\n   |\n15 |         let score\
    \ = word.chars().unique().count();\n   |                                  ^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_index = 0;\n    for i in 0..words.len() {\n        let unique\
    \ = unique_chars(&words[i]);\n        if unique.len() > max_len {\n          \
    \  max_len = unique.len();\n            max_index = i;\n        }\n    }\n   \
    \ return words[max_index].clone();\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp3b3s2gy5.rs:15:22\n   |\n15 |         let unique = unique_chars(&words[i]);\n\
    \   |                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut prev_count\
    \ = 0;\n    let mut prev_result = String::new();\n    for word in words {\n  \
    \      let mut unique_chars = HashSet::new();\n        for c in word.chars() {\n\
    \            unique_chars.insert(c);\n        }\n        if unique_chars.len()\
    \ > prev_count {\n            prev_count = unique_chars.len();\n            prev_result\
    \ = word;\n        }\n    }\n    prev_result\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpw6l3mqfd.rs:15:32\n   |\n15 |         let mut unique_chars = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ words[0].clone();\n    let mut max_len = result.len();\n    for word in words\
    \ {\n        let mut chars = BTreeSet::new();\n        for ch in word.chars()\
    \ {\n            chars.insert(ch);\n        }\n        if chars.len() > max_len\
    \ {\n            max_len = chars.len();\n            result = word;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n  -->\
    \ /tmp/tmpb1avcpot.rs:15:25\n   |\n15 |         let mut chars = BTreeSet::new();\n\
    \   |                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeSet;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_length = 0;\n    for word in words {\n        let set: HashSet<_>\
    \ = word.chars().collect();\n        if set.len() > max_length {\n           \
    \ max = word;\n            max_length = set.len();\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp1pqdzn6y.rs:15:18\n\
    \   |\n15 |         let set: HashSet<_> = word.chars().collect();\n   |      \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let mut found_chars = HashSet::new();\n        for char in word.chars() {\n\
    \            found_chars.insert(char);\n        }\n        if found_chars.len()\
    \ > max_count {\n            max_count = found_chars.len();\n            max_word\
    \ = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvllxzjyn.rs:15:31\n   |\n15 |         let mut found_chars = HashSet::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let mut word_chars = HashSet::new();\n        for ch in word.chars()\
    \ {\n            word_chars.insert(ch);\n        }\n        if word_chars.len()\
    \ > max_unique_chars {\n            max_unique_chars = word_chars.len();\n   \
    \         max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5mhgd5mn.rs:15:30\n   |\n15 |         let mut word_chars = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpq6v08rlp.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_max\
    \ = 0;\n    let mut len_max = 0;\n    let mut result = String::new();\n    for\
    \ word in words {\n        let mut set = HashSet::new();\n        for c in word.chars()\
    \ {\n            set.insert(c);\n        }\n        let len = set.len();\n   \
    \     if len > unique_max {\n            unique_max = len;\n            len_max\
    \ = word.len();\n            result = word;\n        } else if len == unique_max\
    \ && word.len() < len_max {\n            len_max = word.len();\n            result\
    \ = word;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5xayb6va.rs:16:23\n   |\n16 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut count = 0;\n\
    \    let mut result = String::new();\n    for i in words {\n        let c = count_distinct_chars(&i);\n\
    \        if c >= count {\n            count = c;\n            result = i;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_distinct_chars` in this scope\n\
    \  --> /tmp/tmpixtrb742.rs:15:17\n   |\n15 |         let c = count_distinct_chars(&i);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_str = String::new();\n    for word in words {\n        let\
    \ mut set = HashSet::new();\n        for c in word.chars() {\n            set.insert(c);\n\
    \        }\n        if set.len() > max_len {\n            max_len = set.len();\n\
    \            max_str = word;\n        } else if set.len() == max_len {\n     \
    \       if word < max_str {\n                max_str = word;\n            }\n\
    \        }\n    }\n    max_str\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp31orky5s.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_count = 0;\n    for word in words {\n        let mut set = HashSet::new();\n\
    \        for c in word.chars() {\n            set.insert(c);\n        }\n    \
    \    if set.len() > max_count {\n            max = word;\n            max_count\
    \ = set.len();\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9n84zh62.rs:15:23\n   |\n15 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_count = count_unique(words[0].as_str());\n\
    \    for word in words.iter().skip(1) {\n        let count = count_unique(word.as_str());\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word.clone();\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique` in this scope\n  -->\
    \ /tmp/tmpo33zoljh.rs:13:25\n   |\n13 |     let mut max_count = count_unique(words[0].as_str());\n\
    \   |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `count_unique` in this scope\n  --> /tmp/tmpo33zoljh.rs:15:21\n\
    \   |\n15 |         let count = count_unique(word.as_str());\n   |           \
    \          ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_len = unique_chars(&max_word);\n    for\
    \ word in words.iter().skip(1) {\n        let len = unique_chars(word);\n    \
    \    if len > max_len {\n            max_len = len;\n            max_word = word.clone();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmp63y24d7i.rs:13:23\n   |\n13 |     let mut max_len = unique_chars(&max_word);\n\
    \   |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `unique_chars` in this scope\n  --> /tmp/tmp63y24d7i.rs:15:19\n\
    \   |\n15 |         let len = unique_chars(word);\n   |                   ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976054
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp2or7hxkf.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut unique_characters_count = 0;\n    for word in\
    \ words {\n        let mut characters_set = HashSet::new();\n        for character\
    \ in word.chars() {\n            characters_set.insert(character);\n        }\n\
    \        if characters_set.len() > unique_characters_count\n            || (characters_set.len()\
    \ == unique_characters_count\n                && word < max_word)\n        {\n\
    \            max_word = word;\n            unique_characters_count = characters_set.len();\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpamv93aga.rs:15:34\n   |\n15 |         let mut characters_set = HashSet::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n\
    \    let mut max_word = words[0].clone();\n    for word in words {\n        let\
    \ len = word.chars().collect::<HashSet<char>>().len();\n        if len > max {\n\
    \            max = len;\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp_531jm12.rs:15:42\n\
    \   |\n15 |         let len = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    use std::collections::HashSet;\n\
    \    let word_unique_character_counts: Vec<(String, HashSet<char>)> = words\n\
    \        .iter()\n        .map(|word| {\n            let chars = word.chars().collect::<HashSet<char>>();\n\
    \            (word.clone(), chars)\n        })\n        .collect();\n    let max_unique_characters_count\
    \ = word_unique_character_counts\n        .iter()\n        .map(|(_, chars)| chars.len())\n\
    \        .max()\n        .unwrap();\n    let candidates = word_unique_character_counts\n\
    \        .iter()\n        .filter(|(_, chars)| chars.len() == max_unique_characters_count)\n\
    \        .map(|(word, _)| word.clone())\n        .collect::<Vec<String>>();\n\
    \    if candidates.len() == 1 {\n        candidates[0].clone()\n    } else {\n\
    \        candidates\n            .iter()\n            .min_by(|a, b| a.cmp(b))\n\
    \            .unwrap()\n            .clone()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_unique_char_word\
    \ = String::new();\n    let mut max_unique_char_word_count = 0;\n    for word\
    \ in words {\n        let mut unique_chars = HashSet::new();\n        for char\
    \ in word.chars() {\n            unique_chars.insert(char);\n        }\n     \
    \   if unique_chars.len() > max_unique_char_word_count {\n            max_unique_char_word\
    \ = word;\n            max_unique_char_word_count = unique_chars.len();\n    \
    \    }\n    }\n    max_unique_char_word\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp2t01x4f3.rs:15:32\n   |\n15 |         let mut unique_chars = HashSet::new();\n\
    \   |                                ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_unique = 0;\n    for word in words {\n        let set: HashSet<char>\
    \ = word.chars().collect();\n        if set.len() > max_unique {\n           \
    \ max = word;\n            max_unique = set.len();\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5q4zmays.rs:15:18\n\
    \   |\n15 |         let set: HashSet<char> = word.chars().collect();\n   |   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let len = word.chars().collect::<Vec<char>>().len();\n        if len > max_len\
    \ {\n            max_len = len;\n            max_word = word;\n        }\n   \
    \ }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpzfr3hqm_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // unimplemented!(\"\
    Return the word in `words` with the most unique characters\");\n    let mut max\
    \ = String::from(\"\");\n    let mut max_char = 0;\n    for word in words {\n\
    \        let mut set = HashSet::new();\n        for c in word.chars() {\n    \
    \        set.insert(c);\n        }\n        if set.len() > max_char {\n      \
    \      max = word;\n            max_char = set.len();\n        }\n    }\n    max\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptmqvl115.rs:16:23\n   |\n16 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let mut chars = HashSet::new();\n        for ch in word.chars() {\n       \
    \     chars.insert(ch);\n        }\n        if chars.len() > max_len {\n     \
    \       max_len = chars.len();\n            max_word = word;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpblbrk09t.rs:15:25\n   |\n15 |         let mut chars = HashSet::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // PENDING\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpvi6sz5z7.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let mut chars: HashSet<char> = HashSet::new();\n        for ch in word.chars()\
    \ {\n            chars.insert(ch);\n        }\n        if chars.len() > max_count\
    \ {\n            max_count = chars.len();\n            max_word = word;\n    \
    \    }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp8q_gygin.rs:15:24\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8q_gygin.rs:15:40\n\
    \   |\n15 |         let mut chars: HashSet<char> = HashSet::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut uniques =\
    \ 0;\n    let mut result = String::new();\n    for word in words {\n        let\
    \ mut uniques_in_word = 0;\n        for letter in word.chars() {\n           \
    \ if !result.contains(letter) {\n                uniques_in_word += 1;\n     \
    \       }\n        }\n        if uniques_in_word > uniques {\n            uniques\
    \ = uniques_in_word;\n            result = word;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp8f_8w6vs.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_count = 0;\n    for word in words {\n    \
    \    let word_count = word.chars().collect::<HashSet<char>>().len();\n       \
    \ if word_count > max_count {\n            max_count = word_count;\n         \
    \   max_word = word;\n        } else if word_count == max_count {\n          \
    \  max_word = if word < max_word { word } else { max_word };\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5rsq6gzc.rs:15:49\n\
    \   |\n15 |         let word_count = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                 ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let max = words.iter().map(|w|\
    \ w.len()).max().unwrap();\n    let w = words.iter().filter(|w| w.len() == max).min().unwrap();\n\
    \    w.to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"prrk\"`,\n right: `\"this\"`', /tmp/tmp_6yihpdf.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ String::new();\n    let mut count = 0;\n    for i in words {\n        let mut\
    \ char_count = std::collections::HashSet::new();\n        for j in i.chars() {\n\
    \            char_count.insert(j);\n        }\n        if char_count.len() > count\
    \ {\n            count = char_count.len();\n            result = i;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpz44tex8b.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut res = &words[0];\n\
    \    let mut count = 0;\n    for word in words {\n        let length = count_unique_characters(&word);\n\
    \        if length > count {\n            count = length;\n            res = &word;\n\
    \        }\n    }\n    res.clone()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_unique_characters` in this scope\n\
    \  --> /tmp/tmpaw35hchr.rs:15:22\n   |\n15 |         let length = count_unique_characters(&word);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_unique_chars = 0;\n    for word in words {\n\
    \        let unique_chars = unique_chars(word);\n        if unique_chars > max_unique_chars\
    \ {\n            max_unique_chars = unique_chars;\n            max_word = word;\n\
    \        } else if unique_chars == max_unique_chars {\n            if word < max_word\
    \ {\n                max_word = word;\n            }\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars` in this scope\n  -->\
    \ /tmp/tmpvcggnxqv.rs:15:28\n   |\n15 |         let unique_chars = unique_chars(word);\n\
    \   |                            ^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `max_unique_chars`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: Complete\
    \ this function.\n    unimplemented!();\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp102w2xks.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_len =\
    \ 0;\n    let mut max_word = String::new();\n    for word in words {\n       \
    \ let set: HashSet<char> = word.chars().collect();\n        if set.len() > max_len\
    \ {\n            max_len = set.len();\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpcckznpmg.rs:15:18\n\
    \   |\n15 |         let set: HashSet<char> = word.chars().collect();\n   |   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut unique_characters\
    \ = HashMap::new();\n    let mut max_chars = 0;\n    let mut max_word = String::new();\n\
    \    for (index, word) in words.iter().enumerate() {\n        let number_of_unique_chars\
    \ = get_number_of_unique_chars(word);\n        if number_of_unique_chars > max_chars\
    \ {\n            max_chars = number_of_unique_chars;\n            max_word = word.clone();\n\
    \        } else if number_of_unique_chars == max_chars {\n            let mut\
    \ words_with_same_unique_chars =\n                unique_characters.entry(number_of_unique_chars).or_insert(Vec::new());\n\
    \            words_with_same_unique_chars.push(index);\n        }\n    }\n   \
    \ let words_with_same_unique_chars = unique_characters.get(&max_chars).unwrap();\n\
    \    if words_with_same_unique_chars.len() > 1 {\n        let idx = words_with_same_unique_chars[0];\n\
    \        words[idx].clone()\n    } else {\n        max_word\n    }\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpovjswo3r.rs:12:33\n   |\n12 |     let mut unique_characters = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find function `get_number_of_unique_chars` in this\
    \ scope\n  --> /tmp/tmpovjswo3r.rs:16:38\n   |\n16 |         let number_of_unique_chars\
    \ = get_number_of_unique_chars(word);\n   |                                  \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 0
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut ret = String::new();\n\
    \    let mut cnt = 0;\n    for word in words {\n        let mut visited = vec![false;\
    \ 26];\n        let mut cur = 0;\n        for ch in word.chars() {\n         \
    \   let idx = ch as usize - 'a' as usize;\n            if !visited[idx] {\n  \
    \              visited[idx] = true;\n                cur += 1;\n            }\n\
    \        }\n        if cur > cnt {\n            cnt = cur;\n            ret =\
    \ word;\n        } else if cur == cnt && word < ret {\n            ret = word;\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976056
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_chars = 0;\n    for word in words {\n    \
    \    let chars: HashSet<char> = word.chars().collect();\n        if chars.len()\
    \ > max_chars {\n            max_chars = chars.len();\n            max_word =\
    \ word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpyhafp0e1.rs:15:20\n\
    \   |\n15 |         let chars: HashSet<char> = word.chars().collect();\n   | \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpkwbt97t0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821617
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut ret = String::new();\n\
    \    let mut max_cnt = 0;\n    for s in words {\n        let (cnt, hash) = unique_chars_count(s);\n\
    \        if cnt > max_cnt {\n            max_cnt = cnt;\n            ret = hash;\n\
    \        } else if cnt == max_cnt {\n            if hash < ret {\n           \
    \     ret = hash;\n            }\n        }\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `unique_chars_count` in this scope\n\
    \  --> /tmp/tmpm9go883s.rs:15:27\n   |\n15 |         let (cnt, hash) = unique_chars_count(s);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let res = words.iter().map(|word|\
    \ (word, word.chars().collect::<HashSet<_>>().len())).max_by_key(|(_, len)| *len);\n\
    \    match res {\n        Some((word, _)) => word.to_string(),\n        None =>\
    \ String::new(),\n    }\n}\n\nfn main() {\n    let candidate = find_max;\n   \
    \ assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpxtx2336i.rs:12:69\n\
    \   |\n12 |     let res = words.iter().map(|word| (word, word.chars().collect::<HashSet<_>>().len())).max_by_key(|(_,\
    \ len)| *len);\n   |                                                         \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = String::new();\n    let mut max_len = 0;\n    for word in words {\n      \
    \  let mut char_set = HashSet::new();\n        for c in word.chars() {\n     \
    \       char_set.insert(c);\n        }\n        if char_set.len() > max_len {\n\
    \            max_len = char_set.len();\n            max_word = word;\n       \
    \ }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n  \
    \  assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_xycrha_.rs:15:28\n   |\n15 |         let mut char_set = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_count = find_max_count(words[0].clone());\n\
    \    for word in words.iter().skip(1) {\n        let count = find_max_count(word.clone());\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word.clone();\n        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate\
    \ = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_count` in this scope\n  -->\
    \ /tmp/tmp6nmb6wg3.rs:13:25\n   |\n13 |     let mut max_count = find_max_count(words[0].clone());\n\
    \   |                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `find_max_count` in this scope\n  --> /tmp/tmp6nmb6wg3.rs:15:21\n\
    \   |\n15 |         let count = find_max_count(word.clone());\n   |          \
    \           ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word\
    \ = words[0].clone();\n    let mut max_char = 0;\n    for word in words {\n  \
    \      let chars: HashSet<char> = word.chars().collect();\n        if chars.len()\
    \ > max_char {\n            max_char = chars.len();\n            max_word = word;\n\
    \        }\n    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpsdkbe3sd.rs:15:20\n\
    \   |\n15 |         let chars: HashSet<char> = word.chars().collect();\n   | \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_words\
    \ = words.first().unwrap().clone();\n    let mut max_word_count = set_of_chars(max_words.clone()).len();\n\
    \    for word in words.iter().skip(1) {\n        let word_count = set_of_chars(word.clone()).len();\n\
    \        if word_count > max_word_count {\n            max_words = word.clone();\n\
    \            max_word_count = word_count;\n        }\n    }\n    max_words\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `set_of_chars` in this scope\n  -->\
    \ /tmp/tmp082687nc.rs:13:30\n   |\n13 |     let mut max_word_count = set_of_chars(max_words.clone()).len();\n\
    \   |                              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `set_of_chars` in this scope\n  --> /tmp/tmp082687nc.rs:15:26\n\
    \   |\n15 |         let word_count = set_of_chars(word.clone()).len();\n   | \
    \                         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut result =\
    \ words[0].clone();\n    let mut len = num_unique_chars(&result);\n    for word\
    \ in words {\n        let curr_len = num_unique_chars(&word);\n        if curr_len\
    \ > len || (curr_len == len && result > word) {\n            result = word;\n\
    \            len = curr_len;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `num_unique_chars` in this scope\n \
    \ --> /tmp/tmpsoc20hcr.rs:13:19\n   |\n13 |     let mut len = num_unique_chars(&result);\n\
    \   |                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `num_unique_chars` in this scope\n  --> /tmp/tmpsoc20hcr.rs:15:24\n\
    \   |\n15 |         let curr_len = num_unique_chars(&word);\n   |            \
    \            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976055
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings.\n/// The vector\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"\
    string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"\
    aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    // TODO: Write code\
    \ here\n    return String::from(\"\");\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"string\"`', /tmp/tmp8v7jy69x.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976056
