name: HumanEval_153_Strongest_Extension
language: rs
prompt: "/// You will be given the name of a class (a string) and a vector of extensions.\n\
  /// The extensions are to be used to load additional classes to the class. The\n\
  /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  /// letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n/// You should find the strongest extension and return a string in this \n///\
  \ format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
  \ with the same strength, you should\n/// choose the one that comes first in the\
  \ vector.\n/// For example, if you are given \"Slices\" as the class and a vector\
  \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"\
  my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\"\
  )])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String,\
  \ extensions: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = Strongest_Extension;\n    assert_eq!(candidate(String::from(\"\
  Watashi\"), vec![String::from(\"tEN\"), String::from(\"niNE\"), String::from(\"\
  eIGHt8OKe\")]), String::from(\"Watashi.eIGHt8OKe\"));\n    assert_eq!(candidate(String::from(\"\
  Boku123\"), vec![String::from(\"nani\"), String::from(\"NazeDa\"), String::from(\"\
  YEs.WeCaNe\"), String::from(\"32145tggg\")]), String::from(\"Boku123.YEs.WeCaNe\"\
  ));\n    assert_eq!(candidate(String::from(\"__YESIMHERE\"), vec![String::from(\"\
  t\"), String::from(\"eMptY\"), String::from(\"nothing\"), String::from(\"zeR00\"\
  ), String::from(\"NuLl__\"), String::from(\"123NoooneB321\")]), String::from(\"\
  __YESIMHERE.NuLl__\"));\n    assert_eq!(candidate(String::from(\"K\"), vec![String::from(\"\
  Ta\"), String::from(\"TAR\"), String::from(\"t234An\"), String::from(\"cosSo\")]),\
  \ String::from(\"K.TAR\"));\n    assert_eq!(candidate(String::from(\"__HAHA\"),\
  \ vec![String::from(\"Tab\"), String::from(\"123\"), String::from(\"781345\"), String::from(\"\
  -_-\")]), String::from(\"__HAHA.123\"));\n    assert_eq!(candidate(String::from(\"\
  YameRore\"), vec![String::from(\"HhAas\"), String::from(\"okIWILL123\"), String::from(\"\
  WorkOut\"), String::from(\"Fails\"), String::from(\"-_-\")]), String::from(\"YameRore.okIWILL123\"\
  ));\n    assert_eq!(candidate(String::from(\"finNNalLLly\"), vec![String::from(\"\
  Die\"), String::from(\"NowW\"), String::from(\"Wow\"), String::from(\"WoW\")]),\
  \ String::from(\"finNNalLLly.WoW\"));\n    assert_eq!(candidate(String::from(\"\
  _\"), vec![String::from(\"Bb\"), String::from(\"91245\")]), String::from(\"_.Bb\"\
  ));\n    assert_eq!(candidate(String::from(\"Sp\"), vec![String::from(\"671235\"\
  ), String::from(\"Bb\")]), String::from(\"Sp.671235\"));\n}\n"
completions: ["    let mut strongest = String::new();\n    let mut max_strength =\
    \ 0;\n    for ext in extensions {\n        let strength = calc_strength(&ext);\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            strongest = ext;\n        }\n    }\n    return format!(\"{}.{}\"\
    , class_name, strongest);", "    let mut strongest_extension = &extensions[0];\n\
    \    let mut strongest_extension_strength = calculate_strength(&extensions[0]);\n\
    \    for x in extensions.iter() {\n        let strength = calculate_strength(x);\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension\
    \ = x;\n            strongest_extension_strength = strength;\n        }\n    }\n\
    \    format!(\"{}.{}\", class_name, strongest_extension)", "    let mut strongest\
    \ = \"\";\n    let mut strength = -100.0;\n    for ext in extensions {\n     \
    \   let cap = ext.chars().filter(|x| x.is_uppercase()).count();\n        let sm\
    \ = ext.chars().filter(|x| x.is_lowercase()).count();\n        let s = cap as\
    \ f64 - sm as f64;\n        if s > strength {\n            strength = s;\n   \
    \         strongest = ext.as_str();\n        }\n    }\n    return format!(\"{}.{}\"\
    , class_name, strongest);", "    let mut strongest_idx = 0;\n    let mut strongest_score\
    \ = 0.0;\n    for (idx, ext) in extensions.iter().enumerate() {\n        let mut\
    \ score = 0.0;\n        for c in ext.chars() {\n            if c.is_lowercase()\
    \ {\n                score -= 1.0;\n            } else {\n                score\
    \ += 1.0;\n            }\n        }\n        if score > strongest_score {\n  \
    \          strongest_score = score;\n            strongest_idx = idx;\n      \
    \  }\n    }\n    return format!(\"{}.{}\", class_name, extensions[strongest_idx]);",
  "    // First, calculate the strength for each extension.\n    let mut extension_strengths:\
    \ Vec<(String, i32)> = Vec::new();\n    for extension in extensions {\n      \
    \  let mut upper_count = 0;\n        let mut lower_count = 0;\n        for character\
    \ in extension.chars() {\n            if character.is_lowercase() {\n        \
    \        lower_count += 1;\n            } else {\n                upper_count\
    \ += 1;\n            }\n        }\n        let strength = upper_count - lower_count;\n\
    \        extension_strengths.push((extension, strength));\n    }\n    // Then,\
    \ sort the strengths.\n    extension_strengths.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    // Finally, choose the top extension.\n    let top_extension = extension_strengths[0].0;\n\
    \    let mut result = class_name.clone();\n    result.push('.');\n    result.push_str(&top_extension);\n\
    \    result", "    let mut strongest_extension = \"\".to_string();\n    let mut\
    \ strongest_extension_strength = 0;\n    for extension in extensions {\n     \
    \   let mut extension_strength = 0;\n        for c in extension.chars() {\n  \
    \          if c.is_uppercase() {\n                extension_strength += 1;\n \
    \           } else {\n                extension_strength -= 1;\n            }\n\
    \        }\n        if extension_strength > strongest_extension_strength {\n \
    \           strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)",
  "    let mut strongest_extension = \"\";\n    let mut strongest_strength = 0f64;\n\
    \    for ext in extensions {\n        let strength = (ext.matches(char::is_uppercase).count()\
    \ as f64) - (ext.matches(char::is_lowercase).count() as f64);\n        if strength\
    \ > strongest_strength {\n            strongest_strength = strength;\n       \
    \     strongest_extension = &ext;\n        }\n    }\n    return format!(\"{}.{}\"\
    , class_name, strongest_extension);", "    let mut strongest_extension = \"\"\
    ;\n    let mut strongest_strength = 0.0;\n    for extension in extensions {\n\
    \        let extension_strength = Calc_Extension_Strength(extension);\n      \
    \  if extension_strength > strongest_strength {\n            strongest_strength\
    \ = extension_strength;\n            strongest_extension = extension.as_str();\n\
    \        }\n    }\n    let ret_str = format!(\"{}.{}\", class_name, strongest_extension);\n\
    \    ret_str", "    let mut max_name: String = String::from(\"\");\n    let mut\
    \ max_strength: f64 = 0.0;\n    for ext in extensions {\n        let strength\
    \ = extension_strength(&ext);\n        if strength > max_strength {\n        \
    \    max_strength = strength;\n            max_name = ext;\n        }\n    }\n\
    \    class_name + \".\" + &max_name", "    let mut strongest_extension = \"\"\
    .to_string();\n    let mut strongest_strength = 0f64;\n    for extension in extensions\
    \ {\n        let strength = extension.chars().filter(|&c| c.is_uppercase()).count()\
    \ as f64 - extension.chars().filter(|&c| c.is_lowercase()).count() as f64;\n \
    \       if strength > strongest_strength {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return format!(\"\
    {}.{}\", class_name, strongest_extension);", "\tlet mut strongest_extension =\
    \ String::new();\n\tlet mut strength = 0.0;\n\tfor extension in extensions {\n\
    \t\tlet upper_count = extension.chars().filter(|c| c.is_uppercase()).count();\n\
    \t\tlet lower_count = extension.chars().filter(|c| c.is_lowercase()).count();\n\
    \t\tlet tmp_strength = (upper_count as f64 - lower_count as f64) / extension.len()\
    \ as f64;\n\t\tif tmp_strength > strength {\n\t\t\tstrength = tmp_strength;\n\t\
    \t\tstrongest_extension = extension;\n\t\t}\n\t}\n\tformat!(\"{}.{}\", class_name,\
    \ strongest_extension)", "    // Your code goes here\n    return String::from(\"\
    \");", "    // get the lowercase count for each letter\n    let mut sum_lowercase_letter\
    \ = HashMap::new();\n    // get the uppercase count for each letter\n    let mut\
    \ sum_uppercase_letter = HashMap::new();\n    // get the strength for each extension\n\
    \    let mut strength_extension = HashMap::new();\n    // get the result for each\
    \ extension\n    let mut result_extension = HashMap::new();\n    // get the initial\
    \ result\n    let mut initial_result = String::from(\"\");\n    // get the weakest\
    \ strength\n    let mut weakest_strength = 0.0;\n    // get the strongest strength\n\
    \    let mut strongest_strength = 0.0;\n    // get the strongest index\n    let\
    \ mut strongest_index = 0;\n    // get the strongest result\n    let mut strongest_result\
    \ = String::from(\"\");\n    // get the count length of the class name\n    let\
    \ class_count = class_name.len();\n    // calculate the lowercase and uppercase\
    \ count for each letter in the class name\n    for i in 0..class_count {\n   \
    \     let temp_class_letter = class_name.chars().nth(i).unwrap();\n        let\
    \ mut temp_class_count = 0;\n        if sum_lowercase_letter.contains_key(&temp_class_letter)\
    \ {\n            temp_class_count = *sum_lowercase_letter.get(&temp_class_letter).unwrap();\n\
    \        }\n        sum_lowercase_letter.insert(temp_class_letter, temp_class_count\
    \ + 1);\n    }\n    // calculate the lowercase and uppercase count for each letter\
    \ in the extension\n    for i in 0..extensions.len() {\n        let temp_extension\
    \ = extensions[i].clone();\n        let temp_extension_count = temp_extension.len();\n\
    \        for j in 0..temp_extension_count {\n            let temp_extension_letter\
    \ = temp_extension.chars().nth(j).unwrap();\n            let mut temp_lowercase_count\
    \ = 0;\n            let mut temp_uppercase_count = 0;\n            if sum_lowercase_letter.contains_key(&temp",
  "    class_name + \".\" + \n    extensions.iter()\n        .max_by(|&a, &b| {\n\
    \            let a_upper = a.chars().filter(|&c| c.is_uppercase()).count();\n\
    \            let a_lower = a.chars().filter(|&c| c.is_lowercase()).count();\n\
    \            let b_upper = b.chars().filter(|&c| c.is_uppercase()).count();\n\
    \            let b_lower = b.chars().filter(|&c| c.is_lowercase()).count();\n\
    \            let a_strength = a_upper - a_lower;\n            let b_strength =\
    \ b_upper - b_lower;\n            a_strength.cmp(&b_strength)\n        })\n  \
    \      .unwrap()", "    let mut strong_extension: String = \"\".to_string();\n\
    \    let mut strong_strength: i32 = 0;\n    for ext in extensions {\n        let\
    \ mut cap_counter: i32 = 0;\n        let mut sm_counter: i32 = 0;\n        for\
    \ ch in ext.chars() {\n            if ch.is_uppercase() {\n                cap_counter\
    \ += 1;\n            } else if ch.is_lowercase() {\n                sm_counter\
    \ += 1;\n            }\n        }\n        let strength: i32 = cap_counter - sm_counter;\n\
    \        if strength > strong_strength {\n            strong_strength = strength;\n\
    \            strong_extension = ext;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strong_extension)", "    let mut strongest = \"\".to_string();\n\
    \    let mut strength = std::f64::NEG_INFINITY;\n    for ext in extensions {\n\
    \        let mut cap = 0;\n        let mut sm = 0;\n        for c in ext.chars()\
    \ {\n            if c.is_uppercase() {\n                cap += 1;\n          \
    \  } else {\n                sm += 1;\n            }\n        }\n        let ratio\
    \ = cap as f64 - sm as f64;\n        if ratio > strength {\n            strength\
    \ = ratio;\n            strongest = ext;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest)", "    //Your code here!\n    let mut strongest_extension\
    \ = \"\";\n    let mut strongest_strength = 0;\n    for extension in extensions\
    \ {\n        let mut upper_case_count = 0;\n        let mut lower_case_count =\
    \ 0;\n        for character in extension.chars() {\n            if character.is_uppercase()\
    \ {\n                upper_case_count += 1;\n            } else if character.is_lowercase()\
    \ {\n                lower_case_count += 1;\n            }\n        }\n      \
    \  let strength = upper_case_count - lower_case_count;\n        if strength >\
    \ strongest_strength {\n            strongest_strength = strength;\n         \
    \   strongest_extension = &extension;\n        }\n    }\n    format!(\"{}.{}\"\
    , class_name, strongest_extension)", "    // Determine strength of extension\n\
    \    fn strength(extension: &String) -> f64 {\n        let upper = extension.chars().filter(|c|\
    \ c.is_uppercase()).count();\n        let lower = extension.chars().filter(|c|\
    \ c.is_lowercase()).count();\n        (upper as f64) - (lower as f64)\n    }\n\
    \n    // Get the strongest extension and its strength\n    let (index, strongest)\
    \ = extensions.iter().enumerate().fold((0, 0.), |a, b| {\n        let (i, str1)\
    \ = a;\n        let (ni, str2) = b;\n        if strength(&extensions[i]) > strength(&extensions[ni])\
    \ {\n            (i, str1)\n        } else {\n            (ni, str2)\n       \
    \ }\n    });\n\n    // Return string\n    format!(\"{}.{}\", class_name, extensions[index])",
  "    let mut strongest = 0.0;\n    let mut result = class_name.clone();\n    for\
    \ extension in extensions {\n        let upper = extension.chars().filter(|x|\
    \ x.is_uppercase()).count();\n        let lower = extension.chars().filter(|x|\
    \ x.is_lowercase()).count();\n        let strn = (upper as f64 - lower as f64)\
    \ / extension.len() as f64;\n        if strn > strongest {\n            strongest\
    \ = strn;\n            result = format!(\"{}.{}\", class_name, extension);\n \
    \       }\n    }\n    result", "    let mut strongest_extension_strength = 0;\n\
    \    let mut strongest_extension_name = \"\";\n    for ext in extensions {\n \
    \       let mut caps_count = 0;\n        let mut sm_count = 0;\n        for c\
    \ in ext.chars() {\n            if c.is_uppercase() {\n                caps_count\
    \ += 1;\n            } else {\n                sm_count += 1;\n            }\n\
    \        }\n        let strength = caps_count - sm_count;\n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ strength;\n            strongest_extension_name = &ext;\n        }\n    }\n\
    \    class_name + \".\" + strongest_extension_name"]
stop_tokens:
- "\n}"
