language: rs
name: HumanEval_5_intersperse
results:
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    result.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n\n    let mut result = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    for i in 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n\
    \        result.push(delimeter);\n    }\n    result.push(numbers[numbers.len()\
    \ - 1]);\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret: Vec<isize> =\
    \ Vec::new();\n    for i in 0..numbers.len() {\n        ret.push(numbers[i]);\n\
    \        if i != numbers.len() - 1 {\n            ret.push(delimeter);\n     \
    \   }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for num in numbers {\n        if result.len() > 0 {\n            result.push(delimeter);\n\
    \        }\n        result.push(num);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for x in numbers {\n        result.push(x);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    intersperse_v1(numbers, delimeter)\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `intersperse_v1` in this scope\n -->\
    \ /tmp/tmpfp6unaa0.rs:7:5\n  |\n7 |     intersperse_v1(numbers, delimeter)\n \
    \ |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823109
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    //--- IMPLEMENT HERE --\n\
    \    let mut interspersed: Vec<isize> = Vec::new();\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        interspersed.push(*num);\n        if i != numbers.len() - 1 {\n \
    \           interspersed.push(delimeter);\n        }\n    }\n    return interspersed;\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        if i < numbers.len() - 1 {\n       \
    \     result.push(numbers[i]);\n            result.push(delimeter);\n        }\
    \ else {\n            result.push(numbers[i]);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut iter = numbers.iter();\n    if let Some(number) = iter.next() {\n\
    \        result.push(*number);\n        for number in iter {\n            result.push(delimeter);\n\
    \            result.push(*number);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    fn intersperse_helper(\n\
    \        prefix: Vec<isize>,\n        numbers: Vec<isize>,\n        delimeter:\
    \ isize,\n    ) -> Vec<isize> {\n        if numbers.is_empty() {\n           \
    \ prefix\n        } else {\n            let (first, rest) = (numbers[0], &numbers[1..]);\n\
    \            intersperse_helper(\n                prefix,\n                rest.to_vec(),\n\
    \                delimeter,\n            )\n            .into_iter()\n       \
    \     .chain(Some(delimeter))\n            .chain(Some(first))\n            .collect()\n\
    \        }\n    }\n    intersperse_helper(Vec::new(), numbers, delimeter)\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[8, 2, 8, 3, 8, 6, 8, 5]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpno7x0mt2.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    match numbers.split_first() {\n        None => {},\n        Some((head, tail))\
    \ => {\n            result.push(*head);\n            for elem in tail {\n    \
    \            result.push(delimeter);\n                result.push(*elem);\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    for x in numbers.iter()\
    \ {\n        result.push(*x);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    match numbers.len() {\n \
    \       0 => numbers,\n        1 => numbers,\n        _ => {\n            let\
    \ mut numbers: Vec<isize> = numbers;\n            numbers.drain(1..).for_each(|n|\
    \ {\n                numbers.push(delimeter);\n                numbers.push(n);\n\
    \            });\n            numbers\n        }\n    }\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0499]: cannot borrow `numbers` as mutable more than once at a time\n\
    \  --> /tmp/tmpzrpduqm4.rs:12:41\n   |\n12 |             numbers.drain(1..).for_each(|n|\
    \ {\n   |             -------            -------- ^^^ second mutable borrow occurs\
    \ here\n   |             |                  |\n   |             |            \
    \      first borrow later used by call\n   |             first mutable borrow\
    \ occurs here\n13 |                 numbers.push(delimeter);\n   |           \
    \      ------- second borrow occurs due to use of `numbers` in closure\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1659823109
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut inter = vec![];\n\
    \    for i in 0..numbers.len() {\n        inter.push(numbers[i]);\n        if\
    \ i < numbers.len() - 1 {\n            inter.push(delimeter);\n        }\n   \
    \ }\n    inter\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let (mut result, mut iter)\
    \ = (vec![], numbers.into_iter());\n    while let Some(x) = iter.next() {\n  \
    \      result.push(x);\n        if let Some(&y) = iter.next() {\n            result.push(delimeter);\n\
    \            result.push(y);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2drfn9m.rs:10:21\n   |\n\
    10 |         if let Some(&y) = iter.next() {\n   |                     ^^    -----------\
    \ this expression has type `Option<isize>`\n   |                     |\n   | \
    \                    expected `isize`, found reference\n   |                 \
    \    help: you can probably remove the explicit borrow: `y`\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659823109
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut output = vec![];\n\
    \    if numbers.len() == 0 {\n        return output;\n    }\n    output.push(numbers[0]);\n\
    \    let mut index = 1;\n    while index < numbers.len() {\n        output.push(delimeter);\n\
    \        output.push(numbers[index]);\n        index += 1;\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    for num in numbers {\n        v.push(num);\n        v.push(delimeter);\n\
    \    }\n    if v.len() > 0 {\n        v.pop();\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823110
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.iter().flat_map(|x|\
    \ vec![x, &delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n --> /tmp/tmpe2y3h9ue.rs:7:54\n  |\n7 |    \
    \ numbers.iter().flat_map(|x| vec![x, &delimeter]).collect()\n  |            \
    \                                          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n  |\n  = help: the\
    \ trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823109
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let length = numbers.len();\n    let last_item = numbers.last().unwrap();\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        result.push(*number);\n\
    \        if i + 1 != length {\n            result.push(delimeter);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpaqo60ud4.rs:9:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        res.push(numbers[i]);\n        if i\
    \ + 1 < numbers.len() {\n            res.push(delimeter);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut output: Vec<isize>\
    \ = Vec::new();\n    for i in 0..numbers.len() {\n        output.push(numbers[i]);\n\
    \        if i != numbers.len() - 1 {\n            output.push(delimeter);\n  \
    \      }\n    }\n    output\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    for number in numbers {\n        v.push(number);\n        v.push(delimeter);\n\
    \    }\n    if v.len() > 0 {\n        v.pop();\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        res.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            res.push(delimeter);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    loop {\n        match iter.next() {\n\
    \            Some(number) => {\n                result.push(*number);\n      \
    \          match iter.next() {\n                    Some(_) => result.push(delimeter),\n\
    \                    None => break,\n                }\n            }\n      \
    \      None => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpi5z5igau.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO: delete this line,\
    \ and implement the function!\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp6jxuuu82.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut interspersed = vec![];\n\
    \    for i in 0..numbers.len() {\n        if i != 0 {\n            interspersed.push(delimeter);\n\
    \        }\n        interspersed.push(numbers[i]);\n    }\n    interspersed\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for &number in numbers.iter() {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut it = numbers.iter();\n    if let Some(n) = it.next() {\n        result.push(*n);\n\
    \        for n in it {\n            result.push(delimeter);\n            result.push(*n);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut out = Vec::new();\n\
    \    for n in numbers {\n        out.push(n);\n        out.push(delimeter);\n\
    \    }\n    out.pop();\n    out\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return numbers;\n    }\n    let mut interspersed: Vec<isize> = vec![];\n\
    \    let mut iter = numbers.iter();\n    interspersed.push(*iter.next().unwrap());\n\
    \    while let Some(n) = iter.next() {\n        interspersed.push(delimeter);\n\
    \        interspersed.push(*n);\n    }\n    interspersed\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return vec![];\n    }\n\n    numbers.iter().fold(vec![], |mut acc, elem|\
    \ {\n        if acc.len() != 0 {\n            acc.push(delimeter);\n        }\n\
    \        acc.push(*elem);\n        acc\n    })\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() > 0 {\n        result.push(numbers[0]);\n        for i in\
    \ 1..numbers.len() {\n            result.push(delimeter);\n            result.push(numbers[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpohbrih9e.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut intersperse_right = false;\n    for number in numbers {\n       \
    \ if intersperse_right {\n            result.push(delimeter);\n        }\n   \
    \     result.push(number);\n        intersperse_right = true;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    for i in 0..numbers.len()\
    \ - 1 {\n        res.push(numbers[i]);\n        res.push(delimeter);\n    }\n\
    \    res.push(numbers[numbers.len() - 1]);\n    res\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n     \
    \   result.push(delimeter);\n    }\n    result.push(numbers[numbers.len() - 1]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpjgwd1f8z.rs:8:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.iter().enumerate().fold(vec![],\
    \ |mut acc, (i, x)| {\n        if i != 0 {\n            acc.push(delimeter);\n\
    \        }\n        acc.push(*x);\n        acc\n    })\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    match numbers.len() {\n \
    \       0 => vec![],\n        1 => numbers,\n        2 => vec![numbers[0], delimeter,\
    \ numbers[1]],\n        _ => {\n            let mut ret = Vec::new();\n      \
    \      ret.push(numbers[0]);\n            for i in 1..numbers.len() - 1 {\n  \
    \              ret.push(delimeter);\n                ret.push(numbers[i]);\n \
    \           }\n            ret.push(delimeter);\n            ret.push(numbers[numbers.len()\
    \ - 1]);\n            ret\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut out: Vec<isize> =\
    \ Vec::new();\n    let mut i = 0;\n    while i < numbers.len() {\n        out.push(numbers[i]);\n\
    \        if i < numbers.len() - 1 {\n            out.push(delimeter);\n      \
    \  }\n        i += 1;\n    }\n    out\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.chunks(2).flat_map(|x|\
    \ {\n        if x.len() == 2 {\n            x.iter().chain(std::iter::once(&delimeter))\n\
    \        } else {\n            x.iter()\n        }\n    }).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpl2puanic.rs:11:13\n\
    \   |\n8  | /         if x.len() == 2 {\n9  | |             x.iter().chain(std::iter::once(&delimeter))\n\
    \   | |             ------------------------------------------- expected because\
    \ of this\n10 | |         } else {\n11 | |             x.iter()\n   | |      \
    \       ^^^^^^^^ expected struct `std::iter::Chain`, found struct `std::slice::Iter`\n\
    12 | |         }\n   | |_________- `if` and `else` have incompatible types\n \
    \  |\n   = note: expected struct `std::iter::Chain<std::slice::Iter<'_, _>, std::iter::Once<&isize>>`\n\
    \              found struct `std::slice::Iter<'_, _>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_vec = vec![];\n\
    \    let mut idx = 0;\n    while idx < numbers.len() {\n        new_vec.push(numbers[idx]);\n\
    \        if idx + 1 < numbers.len() {\n            new_vec.push(delimeter);\n\
    \        }\n        idx += 1;\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n\
    \        return numbers;\n    }\n    let mut interspersed: Vec<isize> = Vec::new();\n\
    \    for (index, number) in numbers.iter().enumerate() {\n        interspersed.push(*number);\n\
    \        if index != numbers.len() - 1 {\n            interspersed.push(delimeter);\n\
    \        }\n    }\n    interspersed\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        ret.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            ret.push(delimeter);\n        }\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if !numbers.is_empty() {\n        result.push(numbers[0]);\n        for &number\
    \ in numbers.iter().skip(1) {\n            result.push(delimeter);\n         \
    \   result.push(number);\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for &number in numbers.iter() {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut out = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        out.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            out.push(delimeter);\n        }\n    }\n\
    \    out\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    match numbers.len() {\n \
    \       0 => vec![],\n        1 => numbers,\n        _ => {\n            let mut\
    \ result = vec![];\n            for i in 0..numbers.len() {\n                result.push(numbers[i]);\n\
    \                if i != numbers.len() - 1 {\n                    result.push(delimeter);\n\
    \                }\n            }\n            result\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if !numbers.is_empty() {\n        result.push(numbers[0]);\n        for number\
    \ in numbers.iter().skip(1) {\n            result.push(delimeter);\n         \
    \   result.push(*number);\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return numbers;\n    }\n    let mut new_numbers = vec![numbers[0]];\n\
    \    for i in 1..numbers.len() {\n        new_numbers.push(delimeter);\n     \
    \   new_numbers.push(numbers[i]);\n    }\n    new_numbers\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpme08oxsw.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut first = true;\n    for n in numbers {\n        if first {\n     \
    \       first = false;\n        } else {\n            result.push(delimeter);\n\
    \        }\n        result.push(n);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    if let Some(first) = iter.next() {\n\
    \        result.push(*first);\n        for num in iter {\n            result.push(delimeter);\n\
    \            result.push(*num);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut it = numbers.iter();\n\
    \    let mut result = Vec::new();\n    if let Some(first) = it.next() {\n    \
    \    result.push(*first);\n        while let Some(current) = it.next() {\n   \
    \         result.push(delimeter);\n            result.push(*current);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n    let mut result = Vec::new();\n    for i in\
    \ 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n\
    \    }\n    result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    while let Some(number) = iter.next()\
    \ {\n        result.push(*number);\n        if let Some(_) = iter.next() {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpsm3ksro5.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        vec![]\n    } else {\n        let mut result = vec![numbers[0]];\n  \
    \      for i in 1..numbers.len() {\n            result.push(delimeter);\n    \
    \        result.push(numbers[i]);\n        }\n        result\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for (index, number) in numbers.iter().enumerate() {\n        result.push(*number);\n\
    \        if index < numbers.len() - 1 {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut output: Vec<isize>\
    \ = Vec::new();\n    for (i, num) in numbers.iter().enumerate() {\n        output.push(*num);\n\
    \        if i != numbers.len() - 1 {\n            output.push(delimeter);\n  \
    \      }\n    }\n    output\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ans = Vec::new();\n\
    \    for idx in 0..numbers.len() {\n        if idx != 0 {\n            ans.push(delimeter);\n\
    \        }\n        ans.push(numbers[idx]);\n    }\n    ans\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return v;\n    }\n    for i in 0..numbers.len()\
    \ - 1 {\n        v.push(numbers[i]);\n        v.push(delimeter);\n    }\n    v.push(numbers[numbers.len()\
    \ - 1]);\n    v\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.chunks(2).flat_map(|chunk|\
    \ {\n        let mut chunk = chunk.to_vec();\n        if chunk.len() == 2 {\n\
    \            chunk.push(delimeter);\n        }\n        chunk\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 8, 3, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmphp3rw12k.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, num) in numbers.iter().enumerate() {\n        result.push(*num);\n\
    \        if i != numbers.len() - 1 {\n            result.push(delimeter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut interspersed = false;\n    for n in numbers {\n        if interspersed\
    \ {\n            result.push(delimeter);\n        }\n        result.push(n);\n\
    \        interspersed = true;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.chunks(2).flat_map(|ns|\
    \ ns.iter().copied().chain(once(delimeter))).collect()\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `once` in this scope\n --> /tmp/tmpgmkb8gy_.rs:7:62\n\
    \  |\n7 |     numbers.chunks(2).flat_map(|ns| ns.iter().copied().chain(once(delimeter))).collect()\n\
    \  |                                                              ^^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this function\n  |\n1 | use std::iter::once;\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // Is it an empty vector?\n\
    \    if numbers.len() == 0 {\n        return numbers;\n    }\n\n    // Is it a\
    \ vector of size 1?\n    if numbers.len() == 1 {\n        return numbers;\n  \
    \  }\n\n    // Prepare a vector to store the results\n    let mut results: Vec<isize>\
    \ = Vec::new();\n\n    // There is at least two numbers, so `numbers[1]` is a\
    \ valid index\n    // Push the first number\n    results.push(numbers[0]);\n\n\
    \    // Iterate over the vector from 1 until the second last element\n    for\
    \ i in 1..numbers.len() - 1 {\n        // Push the delimeter\n        results.push(delimeter);\n\
    \        // Push the next number\n        results.push(numbers[i]);\n    }\n\n\
    \    // Push the last number\n    results.push(numbers[numbers.len() - 1]);\n\n\
    \    // Return the results\n    results\n}\n\nfn main() {\n    let candidate =\
    \ intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpkid_2v6x.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = vec![];\n   \
    \ let mut b = false;\n    for i in numbers {\n        if b {\n            v.push(delimeter);\n\
    \        }\n        v.push(i);\n        b = true;\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let mut interspersed = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    for number in numbers.iter() {\n        interspersed.push(*number);\n\
    \        interspersed.push(delimeter);\n    }\n    interspersed.pop();\n    interspersed\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpme08oxsw.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n\
    \        return numbers;\n    }\n    let mut res = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        res.push(delimeter);\n        res.push(numbers[i]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iterator = numbers.iter();\n    match iterator.next() {\n       \
    \ Some(head) => {\n            result.push(*head);\n            for &element in\
    \ iterator {\n                result.push(delimeter);\n                result.push(element);\n\
    \            }\n        }\n        None => {}\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut interspersed: Vec<isize>\
    \ = Vec::new();\n    let mut first = true;\n    for elem in numbers {\n      \
    \  if first {\n            first = false;\n        } else {\n            interspersed.push(delimeter);\n\
    \        }\n        interspersed.push(elem);\n    }\n    interspersed\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n\n    result.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        ret.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            ret.push(delimeter);\n        }\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n\n    let mut ret = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    let mut iter = numbers.iter();\n    ret.push(*iter.next().unwrap());\n\
    \    for number in iter {\n        ret.push(delimeter);\n        ret.push(*number);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, num) in numbers.iter().enumerate() {\n        result.push(*num);\n\
    \        if i != numbers.len() - 1 {\n            result.push(delimeter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpsiu47cl8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for e in numbers {\n        result.push(e);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n\n    let mut interspersed: Vec<isize> = Vec::new();\n\
    \    let mut prev_number = &numbers[0];\n    interspersed.push(*prev_number);\n\
    \n    for number in &numbers[1..] {\n        interspersed.push(delimeter);\n \
    \       interspersed.push(*number);\n        prev_number = number;\n    }\n\n\
    \    interspersed\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return ret;\n    }\n\n    let mut it = numbers.iter();\n\
    \    let mut first = it.next().unwrap();\n    ret.push(*first);\n    for next\
    \ in it {\n        ret.push(delimeter);\n        ret.push(*next);\n    }\n   \
    \ ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        if i != 0 {\n            result.push(delimeter);\n\
    \        }\n        result.push(numbers[i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = vec![];\n   \
    \ for (i, &n) in numbers.iter().enumerate() {\n        v.push(n);\n        if\
    \ i != numbers.len() - 1 {\n            v.push(delimeter);\n        }\n    }\n\
    \    v\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for &number in numbers.iter() {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for number in numbers {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_vec = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        if i != 0 {\n            new_vec.push(delimeter);\n\
    \        }\n        new_vec.push(numbers[i]);\n    }\n    new_vec\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut first = true;\n    for n in numbers {\n        if first {\n     \
    \       first = false;\n        } else {\n            result.push(delimeter);\n\
    \        }\n        result.push(n);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    let mut iter\
    \ = numbers.iter();\n    let mut last = iter.next().unwrap();\n    result.push(*last);\n\
    \    for i in iter {\n        result.push(delimeter);\n        result.push(*i);\n\
    \        last = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, v) in numbers.iter().enumerate() {\n        result.push(*v);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n\
    \        return numbers;\n    }\n    let mut interspersed: Vec<isize> = vec![];\n\
    \    for (i, el) in numbers.iter().enumerate() {\n        interspersed.push(*el);\n\
    \        if i < numbers.len() - 1 {\n            interspersed.push(delimeter);\n\
    \        }\n    }\n    interspersed\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_numbers = Vec::with_capacity(numbers.len()\
    \ + numbers.len() - 1);\n    for i in 0..numbers.len() {\n        new_numbers.push(numbers[i]);\n\
    \        if i != numbers.len() - 1 {\n            new_numbers.push(delimeter);\n\
    \        }\n    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpboxsmg4n.rs:7:46

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        ret.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            ret.push(delimeter);\n        }\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for num in numbers {\n        result.push(num);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for (idx, number) in numbers.iter().enumerate() {\n        res.push(*number);\n\
    \        if idx < numbers.len() - 1 {\n            res.push(delimeter);\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n \
    \   assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut results = Vec::new();\n\
    \    for num in numbers {\n        results.push(num);\n        results.push(delimeter);\n\
    \    }\n    results.pop();\n    results\n}\n\nfn main() {\n    let candidate =\
    \ intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, num) in numbers.iter().enumerate() {\n        result.push(*num);\n\
    \        if i != numbers.len() - 1 {\n            result.push(delimeter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // \u8FD9\u4E2A\u51FD\u6570\
    \u5B9E\u73B0\u4E86 intersperse \u51FD\u6570\uFF0C\u5E76\u8FD4\u56DE vector\n \
    \   // \u5982\u679C\u4F60\u60F3\u8981\u66F4\u8FDB\u4E00\u6B65\u4E86\u89E3\u8FD9\
    \u4E2A\u51FD\u6570\uFF0C\u8BF7\u9605\u8BFB std::iter::Iterator\n    numbers.into_iter().flat_map(|x|\
    \ vec![x, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpcan7x_o8.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    while let Some(n) = iter.next() {\n \
    \       res.push(*n);\n        if let Some(_) = iter.next() {\n            res.push(delimeter);\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpglfw9txc.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let len = numbers.len();\n    if len == 0 {\n        return result;\n   \
    \ }\n    result.push(numbers[0]);\n    for index in 1..len {\n        result.push(delimeter);\n\
    \        result.push(numbers[index]);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().fold(Vec::new(),\
    \ |mut acc, n| {\n        if acc.len() > 0 {\n            acc.push(delimeter);\n\
    \        }\n        acc.push(n);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i < numbers.len() - 1 {\n  \
    \          result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpsiu47cl8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n\n    let mut ret = Vec::new();\n    let mut\
    \ iter = numbers.iter();\n    ret.push(*iter.next().unwrap());\n    while let\
    \ Some(n) = iter.next() {\n        ret.push(delimeter);\n        ret.push(*n);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() > 0 {\n        result.push(numbers[0]);\n        for index\
    \ in 1..numbers.len() {\n            result.push(delimeter);\n            result.push(numbers[index]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // Create a new vector with\
    \ size = 2 * input-size + 1\n    let mut result: Vec<isize> = Vec::with_capacity(2\
    \ * numbers.len() + 1);\n    // Push the first element\n    if numbers.len() >\
    \ 0 {\n        result.push(numbers[0]);\n    }\n    // Loop through the rest numbers,\
    \ insert delimeter between them\n    for i in 1..numbers.len() {\n        result.push(delimeter);\n\
    \        result.push(numbers[i]);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // \u6CE8\u610F: \u987A\u5E8F\
    \u662F tail \u4E2D\u7684\u5143\u7D20\u5728\u524D, head \u4E2D\u7684\u5143\u7D20\
    \u5728\u540E\n    fn inner(head: Vec<isize>, tail: Vec<isize>) -> Vec<isize> {\n\
    \        match tail {\n            [] => head,\n            [h, ..t] => inner(head\
    \ + [delimeter, h], t),\n        }\n    }\n    match numbers {\n        [] =>\
    \ vec![],\n        [h, ..t] => inner(vec![h], t),\n    }\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmph4m9_peg.rs:11:39\n\
    \   |\n11 |             [h, ..t] => inner(head + [delimeter, h], t),\n   |   \
    \                                    ^^^^^^^^^\n   |\n   = help: use the `|| {\
    \ ... }` closure form instead\n\nerror[E0425]: cannot find value `t` in this scope\n\
    \  --> /tmp/tmph4m9_peg.rs:11:19\n   |\n11 |             [h, ..t] => inner(head\
    \ + [delimeter, h], t),\n   |                   ^ not found in this scope\n\n\
    error[E0425]: cannot find value `t` in this scope\n  --> /tmp/tmph4m9_peg.rs:11:54\n\
    \   |\n11 |             [h, ..t] => inner(head + [delimeter, h], t),\n   |   \
    \                                                   ^ help: a local variable with\
    \ a similar name exists: `h`\n\nerror[E0425]: cannot find value `t` in this scope\n\
    \  --> /tmp/tmph4m9_peg.rs:16:15\n   |\n16 |         [h, ..t] => inner(vec![h],\
    \ t),\n   |               ^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `t` in this scope\n  --> /tmp/tmph4m9_peg.rs:16:36\n   |\n16 |       \
    \  [h, ..t] => inner(vec![h], t),\n   |                                    ^ help:\
    \ a local variable with a similar name exists: `h`\n\nerror[E0658]: half-open\
    \ range patterns are unstable\n  --> /tmp/tmph4m9_peg.rs:11:17\n   |\n11 |   \
    \          [h, ..t] => inner(head + [delimeter, h], t),\n   |                \
    \ ^^^\n   |\n   = note: see issue #67264 <https://github.com/rust-lang/rust/issues/67264>\
    \ for more information\n\nerror[E0658]: half-open range patterns are unstable\n\
    \  --> /tmp/tmph4m9_peg.rs:16:13\n   |\n16 |         [h, ..t] => inner(vec![h],\
    \ t),\n   |             ^^^\n   |\n   = note: see issue #67264 <https://github.com/rust-lang/rust/issues/67264>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmph4m9_peg.rs:11:17\n   |\n11 |             [h, ..t] => inner(head\
    \ + [delimeter, h], t),\n   |                 ^^^\n   |\n   = note: see issue\
    \ #37854 <https://github.com/rust-lang/rust/issues/37854> for more information\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmph4m9"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().fold(Vec::new(),\
    \ |mut acc, i| {\n        if acc.len() > 0 {\n            acc.push(delimeter);\n\
    \        }\n        acc.push(i);\n        acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.iter().map(|x| x.clone()).intersperse(delimeter).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: use of unstable library feature 'iter_intersperse': recently\
    \ added\n --> /tmp/tmp8foxqnyy.rs:7:39\n  |\n7 |     numbers.iter().map(|x| x.clone()).intersperse(delimeter).collect()\n\
    \  |                                       ^^^^^^^^^^^\n  |\n  = note: see issue\
    \ #79524 <https://github.com/rust-lang/rust/issues/79524> for more information\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut results = Vec::new();\n\
    \    let mut numbers = numbers.iter();\n    while let Some(n) = numbers.next()\
    \ {\n        results.push(*n);\n        if let Some(next) = numbers.next() {\n\
    \            results.push(delimeter);\n            results.push(*next);\n    \
    \    }\n    }\n    results\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 3, 8, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp6f7fws11.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let n = numbers.len();\n\
    \    let mut i = 0;\n    let mut result = Vec::with_capacity(2 * n - 1);\n   \
    \ while i < n {\n        result.push(numbers[i]);\n        if i < n - 1 {\n  \
    \          result.push(delimeter);\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpg0k30s_6.rs:9:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut ret = vec![];\n \
    \   for (i, number) in numbers.iter().enumerate() {\n        ret.push(*number);\n\
    \        if i < numbers.len() - 1 {\n            ret.push(delimeter);\n      \
    \  }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for (i, e) in numbers.iter().enumerate() {\n        result.push(*e);\n  \
    \      if i < numbers.len() - 1 {\n            result.push(delimeter);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() < 2 {\n        return numbers;\n    }\n    for (i, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        result.push(*number);\n\
    \        if i != numbers.len() - 1 {\n            result.push(delimeter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.windows(2).flat_map(|xs|\
    \ {\n        let mut v = xs.to_vec();\n        v.push(delimeter);\n        v\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 8, 6, 3, 8, 3, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpnrlnjs1u.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        result.push(*n);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n\n    let mut iter\
    \ = numbers.iter();\n    let mut prev = iter.next().unwrap();\n    result.push(*prev);\n\
    \    for i in iter {\n        result.push(delimeter);\n        result.push(*i);\n\
    \        prev = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_numbers = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    loop {\n        let next = iter.next();\n\
    \        match next {\n            Some(n) => {\n                new_numbers.push(*n);\n\
    \                let next_next = iter.next();\n                match next_next\
    \ {\n                    Some(n) => new_numbers.push(delimeter),\n           \
    \         None => return new_numbers,\n                }\n            }\n    \
    \        None => return new_numbers,\n        }\n    }\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpj5855mjw.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n\
    \        return numbers;\n    }\n    let mut result = Vec::new();\n    for i in\
    \ 0..numbers.len() {\n        result.push(numbers[i]);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, v) in numbers.iter().enumerate() {\n        result.push(*v);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n\
    \        return numbers;\n    }\n    let mut r = vec![];\n    let mut rest = numbers;\n\
    \    while rest.len() > 1 {\n        r.push(rest[0]);\n        r.push(delimeter);\n\
    \        rest = rest[1..].to_vec();\n    }\n    r.push(rest[0]);\n    r\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO :: Use vec![] to\
    \ initialise a mutable vector\n    let mut result: Vec<isize> = vec![];\n    //\
    \ TODO :: Use the 'insert' function to insert elements into the vector\n    //\
    \ TODO :: Insert the first element separately\n    result.insert(0, numbers[0]);\n\
    \    // TODO :: Insert `delimeter' between consecutive elements\n    for i in\
    \ 1..numbers.len() {\n        result.insert(i * 2 - 1, delimeter);\n        result.insert(i\
    \ * 2, numbers[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpv_3x5omw.rs:11:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        result.push(*n);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n     \
    \   result.push(delimeter);\n    }\n    if numbers.len() > 0 {\n        result.push(numbers[numbers.len()\
    \ - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmplpxnsepo.rs:8:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut rest = intersperse(numbers[1..].to_vec(),\
    \ delimeter);\n    let mut result = vec![numbers[0]];\n    result.append(&mut\
    \ rest);\n    rest = result;\n    rest.insert(1, delimeter);\n    rest\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmplox0nith.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return numbers;\n    }\n    let mut result = vec![numbers[0]];\n    for\
    \ index in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    match numbers.len() {\n \
    \       0 => vec![],\n        1 => numbers,\n        _ => {\n            let mut\
    \ v = vec![];\n            for num in numbers {\n                v.push(num);\n\
    \                v.push(delimeter);\n            }\n            v.pop();\n   \
    \         v\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        res.push(numbers[i]);\n        if i\
    \ != numbers.len() - 1 {\n            res.push(delimeter);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, val) in numbers.iter().enumerate() {\n        result.push(*val);\n\
    \        if i < numbers.len() - 1 {\n            result.push(delimeter);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut slice = &numbers[..];\n    while !slice.is_empty() {\n        let\
    \ (head, tail) = split_first(slice);\n        result.push(*head);\n        if\
    \ !tail.is_empty() {\n            result.push(delimeter);\n        }\n       \
    \ slice = tail;\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `split_first` in this scope\n  --> /tmp/tmp5hs9sg8c.rs:10:28\n\
    \   |\n10 |         let (head, tail) = split_first(slice);\n   |             \
    \               ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i < numbers.len() - 1 {\n            result.push(delimeter);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut prev = numbers[0];\n    for current in numbers.iter().skip(1) {\n\
    \        result.push(prev);\n        result.push(delimeter);\n        prev = *current;\n\
    \    }\n    result.push(prev);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpfraqswum.rs:8:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut result = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    while let Some(element) = iter.next()\
    \ {\n        result.push(*element);\n        if let Some(next_element) = iter.next()\
    \ {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpdxc1bsri.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        if i > 0 {\n            result.push(delimeter);\n\
    \        }\n        result.push(numbers[i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        if !new_numbers.is_empty() {\n            new_numbers.push(delimeter);\n\
    \        }\n        new_numbers.push(n);\n    }\n    new_numbers\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut first = true;\n    for &number in numbers.iter() {\n        if first\
    \ {\n            first = false;\n        } else {\n            result.push(delimeter);\n\
    \        }\n        result.push(number);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    intersperse_helper(numbers,\
    \ delimeter, true)\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `intersperse_helper` in this scope\n\
    \ --> /tmp/tmp2dd8k_k_.rs:7:5\n  |\n7 |     intersperse_helper(numbers, delimeter,\
    \ true)\n  |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    if let Some(x) = iter.next() {\n    \
    \    result.push(*x);\n        for x in iter {\n            result.push(delimeter);\n\
    \            result.push(*x);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    for (i, &n) in numbers.iter().enumerate() {\n        result.push(n);\n\
    \        if i != numbers.len() - 1 {\n            result.push(delimeter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpo_x20li7.rs:7:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let last_i = numbers.len() - 1;\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        result.push(*number);\n        if i != last_i {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpn98wwenv.rs:8:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // `iter` can be used to\
    \ iterate over the vector\n    let mut result = Vec::new();\n    let mut first\
    \ = true;\n    for number in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(number);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut r = Vec::new();\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        r.push(*n);\n       \
    \ if i < numbers.len() - 1 {\n            r.push(delimeter);\n        }\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut first = true;\n    for num in numbers {\n        if first {\n   \
    \         first = false;\n        } else {\n            result.push(delimeter);\n\
    \        }\n        result.push(num);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for &number in numbers.iter() {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    match numbers.len() {\n \
    \       0 => vec![],\n        1 => numbers,\n        _ => {\n            let first_half\
    \ = numbers.iter().take(numbers.len() / 2).cloned().collect();\n            let\
    \ second_half = numbers.iter().skip(numbers.len() / 2).cloned().collect();\n \
    \           intersperse(first_half, delimeter)\n                .into_iter()\n\
    \                .chain(std::iter::once(delimeter))\n                .chain(intersperse(second_half,\
    \ delimeter))\n                .collect()\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        v.push(numbers[i]);\n        if i +\
    \ 1 < numbers.len() {\n            v.push(delimeter);\n        }\n    }\n    v\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpme08oxsw.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return numbers;\n    }\n    let mut result = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    result.push(numbers[0]);\n    for i in 1..numbers.len() {\n \
    \       result.push(delimeter);\n        result.push(numbers[i]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for num in numbers {\n        if !result.is_empty() {\n            result.push(delimeter);\n\
    \        }\n        result.push(num);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.clone().into_iter().flat_map(|n|\
    \ vec![n, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmph1oidv71.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    let mut previous = numbers[0];\n    for number in numbers {\n        result.push(previous);\n\
    \        result.push(delimeter);\n        previous = number;\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpln87t79o.rs:8:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_vec = vec![];\n\
    \    if numbers.len() == 0 {\n        return new_vec;\n    }\n    new_vec.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        new_vec.push(delimeter);\n        new_vec.push(numbers[i]);\n\
    \    }\n    new_vec\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        result.push(*n);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    for (i, num) in numbers.iter().enumerate() {\n        v.push(*num);\n   \
    \     if i < numbers.len() - 1 {\n            v.push(delimeter);\n        }\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|x|\
    \ vec![x, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpsmx_0sbi.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let (mut result, mut done):\
    \ (Vec<isize>, bool) = (vec![], false);\n    for x in numbers {\n        result.push(x);\n\
    \        if !done {\n            result.push(delimeter);\n        }\n        done\
    \ = true;\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 3, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp99ih7vl_.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for x in numbers {\n        result.push(x);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut interspersed = Vec::new();\n\
    \    if numbers.len() > 0 {\n        interspersed.push(numbers[0]);\n        for\
    \ i in 1..numbers.len() {\n            interspersed.push(delimeter);\n       \
    \     interspersed.push(numbers[i]);\n        }\n    }\n    interspersed\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|x|\
    \ vec![x, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpsmx_0sbi.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|x|\
    \ vec![x, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpsmx_0sbi.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = vec![];\n \
    \   let mut it = numbers.into_iter();\n    if let Some(first) = it.next() {\n\
    \        res.push(first);\n        for x in it {\n            res.push(delimeter);\n\
    \            res.push(x);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|x|\
    \ vec![x, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpsmx_0sbi.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for num in numbers {\n        result.push(num);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976044
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    intersperse_inner(numbers,\
    \ delimeter).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n \
    \   assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `intersperse_inner` in this scope\n\
    \ --> /tmp/tmpro92p0u9.rs:7:5\n  |\n7 |     intersperse_inner(numbers, delimeter).collect()\n\
    \  |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976045
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|i|\
    \ vec![i, delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmppod8k0px.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO Write an implementation\
    \ for this function\n    vec![]\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp5wf0vt73.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n\
    \        return numbers;\n    }\n    let mut result = Vec::new();\n    for num\
    \ in numbers.iter() {\n        result.push(*num);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for i in numbers {\n        result.push(i);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        result.push(*n);\n  \
    \      if i != numbers.len() - 1 {\n            result.push(delimeter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976045
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for n in numbers {\n        if result.len() != 0 {\n            result.push(delimeter);\n\
    \        }\n        result.push(n);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if numbers.len() == 0 {\n        return result;\n    }\n    result.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut v = vec![];\n   \
    \ for i in 0..numbers.len() {\n        if i != 0 {\n            v.push(delimeter);\n\
    \        }\n        v.push(numbers[i]);\n    }\n    v\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for num in numbers {\n        if !result.is_empty() {\n            result.push(delimeter);\n\
    \        }\n        result.push(num);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (idx, n) in numbers.iter().enumerate() {\n        result.push(*n);\n\
    \        if idx < numbers.len() - 1 {\n            result.push(delimeter);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    numbers.windows(2).flat_map(|pair|\
    \ {\n        let mut result = vec![pair[0]];\n        if pair.len() == 2 {\n \
    \           result.push(delimeter);\n        }\n        result\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpxs0otzwp.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpme08oxsw.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976044
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    for (i, item) in numbers.iter().enumerate() {\n        result.push(*item);\n\
    \        if i < numbers.len() - 1 {\n            result.push(delimeter);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    fn is_empty(v: &Vec<isize>)\
    \ -> bool {\n        if v.len() == 0 {\n            true\n        } else {\n \
    \           false\n        }\n    }\n\n    fn delimeter_the_input(v: &Vec<isize>,\
    \ delim: isize) -> Vec<isize> {\n        let mut v_dlim = vec![];\n        for\
    \ i in 0..v.len() {\n            v_dlim.push(v[i]);\n            if i != v.len()\
    \ - 1 {\n                v_dlim.push(delim);\n            }\n        }\n     \
    \   v_dlim\n    }\n\n    if is_empty(&numbers) {\n        numbers\n    } else\
    \ {\n        delimeter_the_input(&numbers, delimeter)\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphc79eb7d.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823110
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut intersperse = false;\n    for x in numbers {\n        if intersperse\
    \ {\n            result.push(delimeter);\n        }\n        result.push(x);\n\
    \        intersperse = true;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    let mut iter = numbers.iter();\n    loop {\n        match iter.next() {\n\
    \            Some(x) => {\n                result.push(*x);\n                match\
    \ iter.next() {\n                    Some(y) => {\n                        result.push(delimeter);\n\
    \                        result.push(*y);\n                    }\n           \
    \         None => {\n                        break;\n                    }\n \
    \               }\n            }\n            None => {\n                break;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 3, 8, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpayz990fu.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n\
    \        return numbers;\n    }\n\n    let mut res = vec![numbers[0]];\n    for\
    \ i in 1..numbers.len() {\n        res.push(delimeter);\n        res.push(numbers[i]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    vec![]\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpml1zm3j8.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpsiu47cl8.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976044
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut numbers_copy = numbers.clone();\n\
    \    numbers_copy.dedup();\n    let mut interspersed = Vec::new();\n    for number\
    \ in numbers_copy {\n        interspersed.push(number);\n        interspersed.push(delimeter);\n\
    \    }\n    interspersed.pop();\n    interspersed\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[2, 2, 2, 2, 2]`', /tmp/tmpcz0syfpm.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = vec![];\n\
    \    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if\
    \ i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976043
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut res = vec![];\n \
    \   for (idx, elem) in numbers.iter().enumerate() {\n        res.push(*elem);\n\
    \        if idx < numbers.len() - 1 {\n            res.push(delimeter);\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n \
    \   assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut output: Vec<isize>\
    \ = Vec::new();\n    let mut prev = 0;\n    for number in numbers {\n        if\
    \ prev != 0 {\n            output.push(delimeter);\n        }\n        output.push(number);\n\
    \        prev = number;\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut new_vec = vec![];\n\
    \    for num in numbers {\n        new_vec.push(num);\n        new_vec.push(delimeter);\n\
    \    }\n    new_vec.pop();\n    new_vec\n}\n\nfn main() {\n    let candidate =\
    \ intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659976046
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// vec![]\n/// >>>\
    \ intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n    for (idx, number) in numbers.iter().enumerate() {\n        result.push(*number);\n\
    \        if idx != numbers.len() - 1 {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmphug8v_sf.rs:7:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976046
