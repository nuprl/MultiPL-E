name: HumanEval_116_sort_array
language: rs
prompt: "/// In this Kata, you have to sort a vector of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
  /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
  \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
  \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
  \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3,\
  \ 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
  \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4,\
  \ 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]),\
  \ vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
  \ vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2,\
  \ 4, 8, 16, 32]);\n}\n"
completions: ["    if arr.is_empty() {\n        return vec![];\n    }\n    // using\
    \ a double binary representation can be enough for this Kata\n    let mut sorted_arr:\
    \ Vec<_> = arr\n        .iter()\n        .map(|num| (num.count_ones(), *num))\n\
    \        .collect();\n    sorted_arr.sort();\n    sorted_arr.iter().map(|&num|\
    \ num.1).collect()", "    arr.iter()\n        .map(|x| (x, count_ones(*x)))\n\
    \        .sort_by(|x, y| if x.1 == y.1 { x.0.cmp(y.0) } else { x.1.cmp(&y.1) })\n\
    \        .into_iter()\n        .map(|x| x.0)\n        .collect()", "    let mut\
    \ count = HashMap::new();\n    for n in arr.clone() {\n        let mut bits =\
    \ 0;\n        for i in 0..8 {\n            if n & (1 << i) != 0 {\n          \
    \      bits += 1;\n            }\n        }\n        count.entry(bits).or_insert(Vec::new()).push(n);\n\
    \    }\n    let mut ans = Vec::new();\n    for i in 0..8 {\n        if let Some(x)\
    \ = count.get(&i) {\n            for n in x {\n                ans.push(*n);\n\
    \            }\n        }\n    }\n    ans", "    let bits: Vec<isize> = arr.iter().map(|x|\
    \ x.count_ones() as isize).collect();\n    arr.iter().zip(bits.iter()).sorted_by(|x,\
    \ y| match x.1.cmp(y.1) {\n        Ordering::Equal => x.0.cmp(y.0),\n        o\
    \ => o,\n    }).map(|x| *x.0).collect()", "    arr.iter()\n        .map(|&x| (x,\
    \ x.count_ones()))\n        .collect::<Vec<_>>()\n        .sort_by(|&(a, b), &(c,\
    \ d)| match b.cmp(&d) {\n            Ordering::Equal => a.cmp(&c),\n         \
    \   other => other,\n        });\n    arr", "    let mut arr_cloned = arr.clone();\n\
    \    arr_cloned.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n     \
    \   let b_ones = b.count_ones();\n        if a_ones == b_ones {\n            a.cmp(b)\n\
    \        } else {\n            a_ones.cmp(&b_ones)\n        }\n    });\n    arr_cloned",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let (a, b) = (ones(*a),\
    \ ones(*b));\n        if a == b {\n            a.cmp(&b)\n        } else {\n \
    \           a.cmp(&b)\n        }\n    });\n    arr", "    let mut arr: Vec<(isize,\
    \ usize)> = arr.into_iter().map(|x| (x, format!(\"{:b}\", x).chars().filter(|x|\
    \ *x == '1').count())).collect();\n    arr.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n\
    \    arr.into_iter().map(|x| x.0).collect()", "    let mut v: Vec<isize> = arr.clone();\n\
    \    let mut sorted: Vec<isize> = arr.clone();\n    sorted.sort_by(|a, b| {\n\
    \        let x = count_ones(*a);\n        let y = count_ones(*b);\n        match\
    \ x.cmp(&y) {\n            Ordering::Equal => a.cmp(b),\n            Ordering::Less\
    \ => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n  \
    \      }\n    });\n    v.sort_by(|a, b| {\n        let x = count_ones(*a);\n \
    \       let y = count_ones(*b);\n        match x.cmp(&y) {\n            Ordering::Equal\
    \ => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    sorted", "    arr.into_iter()\n\
    \        .map(|x| {\n            let ones = x.count_ones();\n            (ones,\
    \ x)\n        })\n        .sorted_by(|a, b| {\n            let cmp = a.0.cmp(&b.0);\n\
    \            if cmp == Ordering::Equal {\n                a.1.cmp(&b.1)\n    \
    \        } else {\n                cmp\n            }\n        })\n        .map(|(_,\
    \ x)| x)\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let a_one = num_of_ones(a);\n        let b_one = num_of_ones(b);\n\
    \        b_one.cmp(&a_one).then(a.cmp(b))\n    });\n    arr", "    // Complete\
    \ the function\n    let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n\
    \        format!(\"{:b}\", a).matches('1').count().cmp(&format!(\"{:b}\", b).matches('1').count())\n\
    \            .then(a.cmp(b))\n    });\n    sorted", "    let mut aux = arr.clone();\n\
    \    aux.sort_by(|a, b| {\n        let a = (a.abs() as u64).count_ones();\n  \
    \      let b = (b.abs() as u64).count_ones();\n        a.cmp(&b).then(a.cmp(&b))\n\
    \    });\n    aux", "    arr.iter()\n        .map(|x| (x, format!(\"{:b}\", x).chars().filter(|&c|\
    \ c == '1').count()))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b| {\n\
    \            a.1.cmp(&b.1).then(a.0.cmp(&b.0))\n        })\n        .iter()\n\
    \        .map(|x| *x.0)\n        .collect()", "    use std::collections::BTreeMap;\n\
    \    let mut btree = BTreeMap::new();\n    let mut ans = Vec::new();\n    for\
    \ &x in &arr {\n        *btree.entry(x.count_ones()).or_insert(Vec::new()).push(x);\n\
    \    }\n    for (cnt, arr) in btree {\n        arr.sort();\n        ans.extend(arr);\n\
    \    }\n    ans", "    arr.iter()\n        .enumerate()\n        .map(|(i, &v)|\
    \ (v, i))\n        .sorted_by(|&(a, _), &(b, _)| {\n            // From what I\
    \ can tell, we have to sort by number of one bits, then\n            // by value.\n\
    \            let a_ones = a.count_ones();\n            let b_ones = b.count_ones();\n\
    \            if a_ones == b_ones {\n                a.cmp(&b)\n            } else\
    \ {\n                a_ones.cmp(&b_ones)\n            }\n        })\n        .map(|(v,\
    \ _)| v)\n        .collect()", "    let mut counts = HashMap::new();\n    for\
    \ x in arr.iter() {\n        let mut x = *x;\n        let mut count = 0;\n   \
    \     while x > 0 {\n            if x % 2 == 1 {\n                count += 1;\n\
    \            }\n            x /= 2;\n        }\n        counts.entry(count).or_insert(Vec::new()).push(*x);\n\
    \    }\n    let mut counts: Vec<_> = counts.into_iter().collect();\n    counts.sort_by_key(|x|\
    \ x.0);\n    let mut arr = Vec::new();\n    for c in counts {\n        arr.extend(c.1);\n\
    \    }\n    arr", "    let cmp = |a: &isize, b: &isize| -> Ordering {\n      \
    \  a.count_ones().cmp(&b.count_ones()).then(a.cmp(b))\n    };\n    let mut res\
    \ = arr;\n    res.sort_by(cmp);\n    res", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let (a_ones, a_dec) = get_ones_and_dec(*a);\n        let (b_ones,\
    \ b_dec) = get_ones_and_dec(*b);\n        b_ones.cmp(&a_ones).then(a_dec.cmp(&b_dec))\n\
    \    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n      \
    \  let bin_a = format!(\"{:b}\", a);\n        let bin_b = format!(\"{:b}\", b);\n\
    \        let ones_a = bin_a.chars().filter(|&c| c == '1').count();\n        let\
    \ ones_b = bin_b.chars().filter(|&c| c == '1').count();\n        ones_a.cmp(&ones_b).then(a.cmp(&b))\n\
    \    });\n    arr"]
stop_tokens:
- "\n}"
