name: HumanEval_116_sort_array
language: rs
prompt: "/// In this Kata, you have to sort a vector of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n\
  /// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n///\
  \ >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
  \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
  \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3,\
  \ 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
  \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4,\
  \ 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]),\
  \ vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
  \ vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2,\
  \ 4, 8, 16, 32]);\n}\n"
completions: ["    if arr.is_empty() {\n        return vec![];\n    }\n    // using\
    \ a double binary representation can be enough for this Kata\n    let mut sorted_arr:\
    \ Vec<_> = arr\n        .iter()\n        .map(|num| (num.count_ones(), *num))\n\
    \        .collect();\n    sorted_arr.sort();\n    sorted_arr.iter().map(|&num|\
    \ num.1).collect()", "    arr.iter()\n        .map(|x| (x, count_ones(*x)))\n\
    \        .sort_by(|x, y| if x.1 == y.1 { x.0.cmp(y.0) } else { x.1.cmp(&y.1) })\n\
    \        .into_iter()\n        .map(|x| x.0)\n        .collect()", "    let mut\
    \ count = HashMap::new();\n    for n in arr.clone() {\n        let mut bits =\
    \ 0;\n        for i in 0..8 {\n            if n & (1 << i) != 0 {\n          \
    \      bits += 1;\n            }\n        }\n        count.entry(bits).or_insert(Vec::new()).push(n);\n\
    \    }\n    let mut ans = Vec::new();\n    for i in 0..8 {\n        if let Some(x)\
    \ = count.get(&i) {\n            for n in x {\n                ans.push(*n);\n\
    \            }\n        }\n    }\n    ans", "    let bits: Vec<isize> = arr.iter().map(|x|\
    \ x.count_ones() as isize).collect();\n    arr.iter().zip(bits.iter()).sorted_by(|x,\
    \ y| match x.1.cmp(y.1) {\n        Ordering::Equal => x.0.cmp(y.0),\n        o\
    \ => o,\n    }).map(|x| *x.0).collect()", "    arr.iter()\n        .map(|&x| (x,\
    \ x.count_ones()))\n        .collect::<Vec<_>>()\n        .sort_by(|&(a, b), &(c,\
    \ d)| match b.cmp(&d) {\n            Ordering::Equal => a.cmp(&c),\n         \
    \   other => other,\n        });\n    arr", "    let mut arr_cloned = arr.clone();\n\
    \    arr_cloned.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n     \
    \   let b_ones = b.count_ones();\n        if a_ones == b_ones {\n            a.cmp(b)\n\
    \        } else {\n            a_ones.cmp(&b_ones)\n        }\n    });\n    arr_cloned",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let (a, b) = (ones(*a),\
    \ ones(*b));\n        if a == b {\n            a.cmp(&b)\n        } else {\n \
    \           a.cmp(&b)\n        }\n    });\n    arr", "    let mut arr: Vec<(isize,\
    \ usize)> = arr.into_iter().map(|x| (x, format!(\"{:b}\", x).chars().filter(|x|\
    \ *x == '1').count())).collect();\n    arr.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n\
    \    arr.into_iter().map(|x| x.0).collect()", "    let mut v: Vec<isize> = arr.clone();\n\
    \    let mut sorted: Vec<isize> = arr.clone();\n    sorted.sort_by(|a, b| {\n\
    \        let x = count_ones(*a);\n        let y = count_ones(*b);\n        match\
    \ x.cmp(&y) {\n            Ordering::Equal => a.cmp(b),\n            Ordering::Less\
    \ => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n  \
    \      }\n    });\n    v.sort_by(|a, b| {\n        let x = count_ones(*a);\n \
    \       let y = count_ones(*b);\n        match x.cmp(&y) {\n            Ordering::Equal\
    \ => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        }\n    });\n    sorted", "    arr.into_iter()\n\
    \        .map(|x| {\n            let ones = x.count_ones();\n            (ones,\
    \ x)\n        })\n        .sorted_by(|a, b| {\n            let cmp = a.0.cmp(&b.0);\n\
    \            if cmp == Ordering::Equal {\n                a.1.cmp(&b.1)\n    \
    \        } else {\n                cmp\n            }\n        })\n        .map(|(_,\
    \ x)| x)\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let a_one = num_of_ones(a);\n        let b_one = num_of_ones(b);\n\
    \        b_one.cmp(&a_one).then(a.cmp(b))\n    });\n    arr", "    // Complete\
    \ the function\n    let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n\
    \        format!(\"{:b}\", a).matches('1').count().cmp(&format!(\"{:b}\", b).matches('1').count())\n\
    \            .then(a.cmp(b))\n    });\n    sorted", "    let mut aux = arr.clone();\n\
    \    aux.sort_by(|a, b| {\n        let a = (a.abs() as u64).count_ones();\n  \
    \      let b = (b.abs() as u64).count_ones();\n        a.cmp(&b).then(a.cmp(&b))\n\
    \    });\n    aux", "    arr.iter()\n        .map(|x| (x, format!(\"{:b}\", x).chars().filter(|&c|\
    \ c == '1').count()))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b| {\n\
    \            a.1.cmp(&b.1).then(a.0.cmp(&b.0))\n        })\n        .iter()\n\
    \        .map(|x| *x.0)\n        .collect()", "    use std::collections::BTreeMap;\n\
    \    let mut btree = BTreeMap::new();\n    let mut ans = Vec::new();\n    for\
    \ &x in &arr {\n        *btree.entry(x.count_ones()).or_insert(Vec::new()).push(x);\n\
    \    }\n    for (cnt, arr) in btree {\n        arr.sort();\n        ans.extend(arr);\n\
    \    }\n    ans", "    arr.iter()\n        .enumerate()\n        .map(|(i, &v)|\
    \ (v, i))\n        .sorted_by(|&(a, _), &(b, _)| {\n            // From what I\
    \ can tell, we have to sort by number of one bits, then\n            // by value.\n\
    \            let a_ones = a.count_ones();\n            let b_ones = b.count_ones();\n\
    \            if a_ones == b_ones {\n                a.cmp(&b)\n            } else\
    \ {\n                a_ones.cmp(&b_ones)\n            }\n        })\n        .map(|(v,\
    \ _)| v)\n        .collect()", "    let mut counts = HashMap::new();\n    for\
    \ x in arr.iter() {\n        let mut x = *x;\n        let mut count = 0;\n   \
    \     while x > 0 {\n            if x % 2 == 1 {\n                count += 1;\n\
    \            }\n            x /= 2;\n        }\n        counts.entry(count).or_insert(Vec::new()).push(*x);\n\
    \    }\n    let mut counts: Vec<_> = counts.into_iter().collect();\n    counts.sort_by_key(|x|\
    \ x.0);\n    let mut arr = Vec::new();\n    for c in counts {\n        arr.extend(c.1);\n\
    \    }\n    arr", "    let cmp = |a: &isize, b: &isize| -> Ordering {\n      \
    \  a.count_ones().cmp(&b.count_ones()).then(a.cmp(b))\n    };\n    let mut res\
    \ = arr;\n    res.sort_by(cmp);\n    res", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let (a_ones, a_dec) = get_ones_and_dec(*a);\n        let (b_ones,\
    \ b_dec) = get_ones_and_dec(*b);\n        b_ones.cmp(&a_ones).then(a_dec.cmp(&b_dec))\n\
    \    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n      \
    \  let bin_a = format!(\"{:b}\", a);\n        let bin_b = format!(\"{:b}\", b);\n\
    \        let ones_a = bin_a.chars().filter(|&c| c == '1').count();\n        let\
    \ ones_b = bin_b.chars().filter(|&c| c == '1').count();\n        ones_a.cmp(&ones_b).then(a.cmp(&b))\n\
    \    });\n    arr", "    let mut arr: Vec<(usize, isize)> = arr.into_iter().map(|x|\
    \ (x.count_ones(), x)).collect();\n    arr.sort_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)));\n\
    \    arr.into_iter().map(|x| x.1).collect()", "    let mut max_num_of_ones = 0;\n\
    \    let mut ones_map = std::collections::HashMap::new();\n    for &x in &arr\
    \ {\n        let ones = x.count_ones();\n        max_num_of_ones = std::cmp::max(max_num_of_ones,\
    \ ones);\n        ones_map.entry(ones).or_insert(Vec::new()).push(x);\n    }\n\
    \    let mut res = Vec::new();\n    for num_of_ones in 0..=max_num_of_ones {\n\
    \        let mut v = ones_map.get(&num_of_ones).unwrap_or(&vec![]).clone();\n\
    \        v.sort();\n        res.extend(v);\n    }\n    res", "    let mut ones_index:\
    \ Vec<(usize, usize)> = arr\n        .iter()\n        .enumerate()\n        .map(|(idx,\
    \ e)| (idx, get_ones(*e)))\n        .collect();\n    ones_index.sort_by(|(a, b),\
    \ (c, d)| match b.cmp(d) {\n        Ordering::Equal => arr[*a].cmp(&arr[*c]),\n\
    \        Ordering::Less => Ordering::Less,\n        Ordering::Greater => Ordering::Greater,\n\
    \    });\n    ones_index\n        .iter()\n        .map(|(_, idx)| arr[*idx])\n\
    \        .collect::<Vec<isize>>()", "    let mut one_count = vec![(0, 0); arr.len()];\n\
    \    for (i, x) in arr.iter().enumerate() {\n        let mut count = 0;\n    \
    \    let mut x = *x;\n        while x > 0 {\n            if x % 2 == 1 {\n   \
    \             count += 1;\n            }\n            x /= 2;\n        }\n   \
    \     one_count[i] = (count, *x);\n    }\n    one_count.sort();\n    one_count.iter().map(|&x|\
    \ x.1).collect()", "    if arr.len() <= 1 {\n        return arr;\n    }\n    let\
    \ mut res = arr.clone();\n    res.sort_by(|a, b| {\n        let as = format!(\"\
    {:b}\", a);\n        let bs = format!(\"{:b}\", b);\n        if as.matches('1').count()\
    \ == bs.matches('1').count() {\n            a.cmp(b)\n        } else {\n     \
    \       as.matches('1').count().cmp(&bs.matches('1').count())\n        }\n   \
    \ });\n    res", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let\
    \ a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n        if a_ones\
    \ == b_ones {\n            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    arr", "    arr.into_iter()\n        .map(|x| (x, ones_in_binary(x)))\n\
    \        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n        .map(|x|\
    \ x.0)\n        .collect()", "    arr.iter()\n        .map(|n| (n, format!(\"\
    {:b}\", n).chars().filter(|c| *c == '1').count()))\n        .collect::<Vec<(&isize,\
    \ usize)>>()\n        .sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n   \
    \     .iter()\n        .map(|&(n, _)| *n)\n        .collect()", "    let mut arr\
    \ = arr;\n    arr.sort_by(|a, b| {\n        let a = format!(\"{:b}\", a);\n  \
    \      let b = format!(\"{:b}\", b);\n        let ans = a.chars().filter(|c| *c\
    \ == '1').count().cmp(&b.chars().filter(|c| *c == '1').count());\n        if ans\
    \ == Ordering::Equal {\n            a.cmp(&b)\n        } else {\n            ans\n\
    \        }\n    });\n    arr", "    arr.iter()\n        .map(|&x| (x, x.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| match a.1.cmp(&b.1) {\n\
    \            Ordering::Equal => a.0.cmp(&b.0),\n            x => x,\n        })\n\
    \        .into_iter()\n        .map(|x| x.0)\n        .collect()", "    let mut\
    \ counts = arr.iter().map(|&n| (count_ones(n), n)).collect::<Vec<_>>();\n    counts.sort();\n\
    \    counts.iter().map(|&(_, n)| n).collect()", "    let mut vec = arr.clone();\n\
    \    vec.sort_by(|a, b| {\n        let a_count = a.count_ones();\n        let\
    \ b_count = b.count_ones();\n        match a_count.cmp(&b_count) {\n         \
    \   Ordering::Equal => a.cmp(b),\n            otherwise => otherwise,\n      \
    \  }\n    });\n    vec", "    // Your code here!\n    return arr;", "    let mut\
    \ res = arr.iter().cloned().collect::<Vec<isize>>();\n    res.sort_by(|a, b| {\n\
    \        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n        } else\
    \ {\n            a.cmp(&b)\n        }\n    });\n    res", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| (a.count_ones(), a).cmp(&(b.count_ones(), b)));\n    arr",
  "    let mut result = arr.clone();\n    result.sort_by(|a, b| {\n        let a_ones\
    \ = num_ones(*a);\n        let b_ones = num_ones(*b);\n        if a_ones == b_ones\
    \ {\n            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    result", "    let mut count_vec: Vec<(usize, isize)>\
    \ = arr\n        .iter()\n        .map(|&x| {\n            let bin = format!(\"\
    {:b}\", x);\n            (bin.len() - bin.chars().filter(|&x| x == '0').count(),\
    \ x)\n        })\n        .collect();\n    count_vec.sort();\n    count_vec.iter().map(|&x|\
    \ x.1).collect()", "    // create a vector of tuples (count of bits, value)\n\
    \    let counts: Vec<(u32, isize)> = arr.iter().map(|&x| (count_bits(x), x)).collect();\n\
    \    // sort the tuples by count of bits, then by value\n    let mut counts =\
    \ counts.into_iter().sorted_by(|a, b| match a.0.cmp(&b.0) {\n        Ordering::Equal\
    \ => a.1.cmp(&b.1),\n        other => other,\n    });\n    // return the values\n\
    \    counts.map(|c| c.1).collect()", "    let mut sorted_ones: Vec<isize> = Vec::new();\n\
    \    let mut sorted_zeros: Vec<isize> = Vec::new();\n    let mut results: Vec<isize>\
    \ = Vec::new();\n\n    for v in arr {\n        if v < 0 {\n            panic!(\"\
    Incorrect input\");\n        }\n\n        let binary = v.to_string();\n      \
    \  let mut ones = 0;\n        for b in binary.chars() {\n            if b == '1'\
    \ {\n                ones += 1;\n            }\n        }\n\n        if ones ==\
    \ 0 {\n            sorted_zeros.push(v);\n        } else {\n            sorted_ones.push(v);\n\
    \        }\n    }\n\n    sorted_ones.sort();\n    sorted_zeros.sort();\n\n   \
    \ results.append(&mut sorted_ones);\n    results.append(&mut sorted_zeros);\n\n\
    \    results", "    let mut arr: Vec<_> = arr.into_iter().map(|a| {\n        (\n\
    \            a,\n            format!(\"{:b}\", a)\n                .chars()\n\
    \                .filter(|&c| c == '1')\n                .count(),\n        )\n\
    \    }).collect();\n    arr.sort_by(|(a, ones), (b, ones_1)| {\n        if ones\
    \ == ones_1 {\n            a.cmp(b)\n        } else {\n            ones.cmp(&ones_1)\n\
    \        }\n    });\n    arr.into_iter().map(|(a, _)| a).collect()", "    use\
    \ std::cmp::Ordering;\n    let mut v: Vec<_> = arr.iter().map(|&x| (x, x.count_ones())).collect();\n\
    \    v.sort_by(|&(a, a_ones), &(b, b_ones)| {\n        let ones_cmp = a_ones.cmp(&b_ones);\n\
    \        match ones_cmp {\n            Ordering::Equal => a.cmp(&b),\n       \
    \     Ordering::Less => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n\
    \        }\n    });\n    v.into_iter().map(|(x, _)| x).collect()", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| ones_in_binary(a).cmp(&ones_in_binary(b)).then(a.cmp(b)));\n\
    \    arr", "    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a,\
    \ b| {\n        if count_ones(*a) == count_ones(*b) {\n            a.cmp(b)\n\
    \        } else {\n            count_ones(*a).cmp(&count_ones(*b))\n        }\n\
    \    });\n    sorted_arr", "    let mut arr_bin: Vec<(isize, isize)> = arr.iter().map(|x|\
    \ (x.clone(), x.count_ones())).collect();\n    arr_bin.sort_by(|a, b| {\n    \
    \    if a.1 == b.1 {\n            a.0.cmp(&b.0)\n        } else {\n          \
    \  a.1.cmp(&b.1)\n        }\n    });\n    let mut result: Vec<isize> = arr_bin.iter().map(|x|\
    \ x.0).collect();\n    result", "    let mut result = arr;\n    result.sort_by(|x,\
    \ y| {\n        let ones_x = x.count_ones();\n        let ones_y = y.count_ones();\n\
    \        match ones_x.cmp(&ones_y) {\n            Ordering::Equal => x.cmp(y),\n\
    \            other => other,\n        }\n    });\n    result", "    arr.into_iter()\n\
    \        .map(|x| (x, x.count_ones()))\n        .sorted_by(|a, b| {\n        \
    \    a.1.cmp(&b.1).then(\n                a.0\n                    .checked_add(0)\n\
    \                    .expect(\"failed to convert from isize to u64\")\n      \
    \              .cmp(&(b.0.checked_add(0).expect(\"failed to convert from isize\
    \ to u64\"))),\n            )\n        })\n        .map(|(x, _)| x)\n        .collect()",
  "    let mut vec: Vec<(usize, isize)> = arr.iter().map(|x| (x.count_ones(), *x)).collect();\n\
    \    vec.sort();\n    vec.iter().map(|x| x.1).collect()", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n        let b_ones\
    \ = b.count_ones();\n        if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    arr", "    let\
    \ mut ret = arr.clone();\n    ret.sort_by(|x, y| {\n        let x_ones = x.count_ones();\n\
    \        let y_ones = y.count_ones();\n        if x_ones == y_ones {\n       \
    \     x.cmp(y)\n        } else {\n            x_ones.cmp(&y_ones)\n        }\n\
    \    });\n    ret", "    arr.into_iter()\n        .map(|v| (v, v.count_ones()))\n\
    \        .collect::<Vec<_>>()\n        .sort_by(|a, b| {\n            if a.1 !=\
    \ b.1 {\n                a.1.cmp(&b.1)\n            } else {\n               \
    \ a.0.cmp(&b.0)\n            }\n        })\n        .into_iter()\n        .map(|v|\
    \ v.0)\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n\
    \        let cmp = a.count_ones().cmp(&b.count_ones());\n        if cmp == std::cmp::Ordering::Equal\
    \ {\n            a.cmp(b)\n        } else {\n            cmp\n        }\n    });\n\
    \    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let mut\
    \ a_ones = 0;\n        let mut b_ones = 0;\n        let mut tmp = *a;\n      \
    \  while tmp > 0 {\n            a_ones += 1;\n            tmp = tmp & (tmp - 1);\n\
    \        }\n        tmp = *b;\n        while tmp > 0 {\n            b_ones +=\
    \ 1;\n            tmp = tmp & (tmp - 1);\n        }\n        if a_ones == b_ones\
    \ {\n            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let a_ones = count_ones(*a);\n        let b_ones = count_ones(*b);\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    arr", "    let mut binary_arr:\
    \ Vec<_> = arr.into_iter().map(|x| x.to_string(2)).collect();\n    binary_arr.sort_by(|x,\
    \ y| {\n        match x.len().cmp(&y.len()) {\n            Ordering::Equal =>\
    \ {\n                let num_ones_x = x.chars().filter(|c| *c == '1').count();\n\
    \                let num_ones_y = y.chars().filter(|c| *c == '1').count();\n \
    \               match num_ones_x.cmp(&num_ones_y) {\n                    Ordering::Equal\
    \ => x.cmp(y),\n                    otherwise => otherwise,\n                }\n\
    \            }\n            otherwise => otherwise,\n        }\n    });\n    binary_arr.into_iter().map(|x|\
    \ x.parse::<isize>().unwrap()).collect()", "    let mut ones: Vec<(usize, isize)>\
    \ = arr\n        .iter()\n        .map(|x| (format!(\"{:b}\", x).matches('1').count(),\
    \ *x))\n        .collect();\n    ones.sort();\n    ones.iter().map(|x| x.1).collect()",
  "    let mut counts = arr.iter().map(|&n| (n, count_ones(n))).collect::<Vec<_>>();\n\
    \    counts.sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n    counts.into_iter().map(|(n,\
    \ _)| n).collect()", "    let ones: Vec<(isize, usize)> = arr\n        .iter()\n\
    \        .map(|x| (x.clone(), x.count_ones() as usize))\n        .collect();\n\
    \    let mut ones_sorted: Vec<isize> = ones\n        .iter()\n        .sorted_by(|a,\
    \ b| if a.1 == b.1 { a.0.cmp(&b.0) } else { a.1.cmp(&b.1) })\n        .map(|x|\
    \ x.0)\n        .collect();\n    ones_sorted", "    arr.into_iter()\n        .map(|x|\
    \ (x, x.count_ones()))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b|\
    \ match a.1.cmp(&b.1) {\n            Ordering::Equal => a.0.cmp(&b.0),\n     \
    \       ordering => ordering,\n        });\n    arr", "    let mut sort_arr =\
    \ vec![];\n    for i in arr {\n        let mut num = 0;\n        let mut tmp =\
    \ i;\n        while tmp > 0 {\n            num += tmp % 2;\n            tmp /=\
    \ 2;\n        }\n        sort_arr.push((num, i));\n    }\n    sort_arr.sort();\n\
    \    sort_arr.iter().map(|t| t.1).collect()", "    let len = arr.len();\n    let\
    \ mut temp = arr.clone();\n    arr.iter().enumerate().for_each(|(i, n)| {\n  \
    \      temp[i] = n - n.count_ones() as isize * len as isize;\n    });\n    temp.sort();\n\
    \    temp.iter().enumerate().for_each(|(i, n)| {\n        temp[i] = n + n.count_ones()\
    \ as isize * len as isize;\n    });\n    temp", "    let mut arr: Vec<_> = arr.into_iter().map(|x|\
    \ (x, x.count_ones())).collect();\n    arr.sort_by_key(|x| x.1);\n    arr.sort_by_key(|x|\
    \ x.0);\n    arr.into_iter().map(|x| x.0).collect()", "    let mut arr = arr;\n\
    \    arr.sort_by(|x, y| {\n        let cnt_x = x.count_ones();\n        let cnt_y\
    \ = y.count_ones();\n        if cnt_x == cnt_y {\n            return x.cmp(y);\n\
    \        }\n        cnt_x.cmp(&cnt_y)\n    });\n    arr", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut ones = Vec::new();\n    let mut\
    \ zeros = Vec::new();\n    for i in arr {\n        if i < 0 {\n            ones.push(i.clone());\n\
    \            continue;\n        }\n        let s = format!(\"{:b}\", i);\n   \
    \     let n = s.matches('1').count();\n        ones.push(i.clone());\n       \
    \ zeros.push((n, i.clone()));\n    }\n    zeros.sort();\n    for (i, (n, k)) in\
    \ zeros.iter().enumerate() {\n        let x = ones.iter().position(|&y| y == k).unwrap();\n\
    \        ones.swap(i, x);\n    }\n    ones", "    arr.into_iter()\n        .map(|x|\
    \ (x, binary_ones(x)))\n        .sorted_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n\
    \        .map(|(x, _)| x)\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        format!(\"{:08b}\", a).matches('1').count().cmp(&format!(\"{:08b}\"\
    , b).matches('1').count())\n    });\n    arr", "    let sorted = arr.iter().map(|n|\
    \ {\n        let a = n.abs() as usize;\n        let mut b = 0;\n        let mut\
    \ c = a;\n        while c > 0 {\n            if c % 2 == 1 {\n               \
    \ b += 1;\n            }\n            c /= 2;\n        }\n        (a, b)\n   \
    \ }).collect::<Vec<(usize, usize)>>();\n    sorted.iter().map(|(a, _)| a).collect::<Vec<usize>>().sort();\n\
    \    let mut res = vec![];\n    for (a, b) in sorted {\n        let mut x = a;\n\
    \        let mut v = vec![];\n        while x > 0 {\n            if x % 2 == 1\
    \ {\n                v.push(1);\n            } else {\n                v.push(0);\n\
    \            }\n            x /= 2;\n        }\n        while v.len() < b {\n\
    \            v.push(0);\n        }\n        res.push((a, v));\n    }\n    res.sort_by(|(_,\
    \ a), (_, b)| b.cmp(a));\n    res.iter().map(|(a, _)| *a as isize).collect()",
  "    return arr\n        .into_iter()\n        .map(|n| {\n            let mut n\
    \ = n.abs();\n            let mut ones = 0;\n            while n > 0 {\n     \
    \           ones += n % 2;\n                n /= 2;\n            }\n         \
    \   (ones, n)\n        })\n        .sorted_by(|a, b| {\n            let (a_ones,\
    \ a_n) = a;\n            let (b_ones, b_n) = b;\n            a_ones.cmp(&b_ones).then(a_n.cmp(&b_n))\n\
    \        })\n        .map(|(_, n)| n)\n        .collect();", "    let mut nums\
    \ = arr.iter().map(|n| Ones {\n        ones: n.count_ones(),\n        n: *n,\n\
    \    }).collect::<Vec<_>>();\n    nums.sort_by(|a, b| (a.ones, a.n).cmp(&(b.ones,\
    \ b.n)));\n    nums.iter().map(|n| n.n).collect()", "    let mut map = HashMap::new();\n\
    \    let mut decimal_order = vec![];\n    let mut binary_order = vec![];\n   \
    \ for &num in arr.iter() {\n        let mut ones = 0;\n        let mut decimal\
    \ = num;\n        while decimal > 0 {\n            if decimal % 2 == 1 {\n   \
    \             ones += 1;\n            }\n            decimal /= 2;\n        }\n\
    \        map.insert(num, ones);\n        decimal_order.push(num);\n        binary_order.push(ones);\n\
    \    }\n    decimal_order.sort_by(|a, b| binary_order[*a as usize].cmp(&binary_order[*b\
    \ as usize]));\n    decimal_order", "    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let a = count_ones(*a);\n        let b = count_ones(*b);\n   \
    \     if a == b {\n            a.cmp(&b)\n        } else {\n            a.cmp(&b)\n\
    \        }\n    });\n    arr", "    arr.into_iter()\n        .map(|x| {\n    \
    \        let mut ones = 0;\n            let mut n = x;\n            while n >\
    \ 0 {\n                ones += n % 2;\n                n /= 2;\n            }\n\
    \            (ones, x)\n        })\n        .sorted_by(|a, b| {\n            a.0.cmp(&b.0).then(a.1.cmp(&b.1))\n\
    \        })\n        .map(|x| x.1)\n        .collect()", "    let mut res = arr;\n\
    \    res.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()).then(a.cmp(b)));\n\
    \    res", "    let mut data = arr.iter().map(|i| {\n        let mut tmp = i.clone();\n\
    \        let mut ones = 0;\n        while tmp > 0 {\n            if tmp % 2 ==\
    \ 1 {\n                ones += 1;\n            }\n            tmp /= 2;\n    \
    \    }\n        (ones, i.clone())\n    }).collect::<Vec<(isize, isize)>>();\n\
    \    data.sort_by(|a, b| {\n        if a.0 != b.0 {\n            a.0.cmp(&b.0)\n\
    \        } else {\n            a.1.cmp(&b.1)\n        }\n    });\n    data.iter().map(|i|\
    \ i.1).collect()", "    let mut v = arr;\n    v.sort_by(|a, b| {\n        let\
    \ t = format!(\"{:b}\", a)\n            .chars()\n            .filter(|&x| x ==\
    \ '1')\n            .count()\n            .cmp(&format!(\"{:b}\", b).chars().filter(|&x|\
    \ x == '1').count());\n        if t == Ordering::Equal {\n            a.cmp(b)\n\
    \        } else {\n            t\n        }\n    });\n    v", "    // per rosettacode.org\n\
    \    fn bitcount(n: usize) -> usize {\n        let mut r = 0;\n        let mut\
    \ v = n;\n        while v > 0 {\n            r += v & 1;\n            v >>= 1;\n\
    \        }\n        r\n    }\n\n    arr.into_iter()\n        .map(|v| (bitcount(v\
    \ as usize), v))\n        .sorted()\n        .into_iter()\n        .map(|(_, v)|\
    \ v)\n        .collect()", "    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n        } else\
    \ {\n            a.cmp(b)\n        }\n    });\n    res", "    let mut ones_map\
    \ = BTreeMap::new();\n    for n in arr {\n        let mut ones = 0;\n        let\
    \ mut n = n;\n        while n > 0 {\n            ones += n & 1;\n            n\
    \ >>= 1;\n        }\n        if ones_map.contains_key(&ones) {\n            ones_map.get_mut(&ones).unwrap().push(n);\n\
    \        } else {\n            ones_map.insert(ones, vec![n]);\n        }\n  \
    \  }\n    let mut result = vec![];\n    for (_, v) in ones_map {\n        for\
    \ n in v {\n            result.push(n);\n        }\n    }\n    result", "    use\
    \ std::cmp::Ordering;\n    let result: Vec<isize> = arr\n        .into_iter()\n\
    \        .map(|x| (x, count_ones(x)))\n        .sorted_by(|a, b| match a.1.cmp(&b.1)\
    \ {\n            Ordering::Equal => a.0.cmp(&b.0),\n            x => x,\n    \
    \    })\n        .into_iter()\n        .map(|(x, _)| x)\n        .collect();\n\
    \    result", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones\
    \ = ones_count(*a);\n        let b_ones = ones_count(*b);\n        if a_ones ==\
    \ b_ones {\n            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n\
    \        }\n    });\n    arr", "    let mut res = arr.clone();\n    res.sort_by(|a,\
    \ b| {\n        let a_ones = count_ones(*a);\n        let b_ones = count_ones(*b);\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    res", "    let mut arr =\
    \ arr;\n    arr.sort_by(|a, b| {\n        let ba = format!(\"{:b}\", a);\n   \
    \     let bb = format!(\"{:b}\", b);\n        ba.matches('1').count().cmp(&bb.matches('1').count()).then(a.cmp(b))\n\
    \    });\n    arr", "    let mut ones: Vec<(usize, isize)> = arr\n        .iter()\n\
    \        .map(|x| (format!(\"{:b}\", x).matches('1').count(), *x))\n        .collect();\n\
    \    ones.sort();\n    ones.iter().map(|x| x.1).collect()", "    arr.into_iter()\n\
    \        .map(|x| (x, x.to_string(2).chars().filter(|&c| c == '1').count()))\n\
    \        .sorted_by(|a, b| match a.1.cmp(&b.1) {\n            std::cmp::Ordering::Equal\
    \ => a.0.cmp(&b.0),\n            x => x,\n        })\n        .map(|x| x.0)\n\
    \        .collect()", "    let ones = |num: &isize| -> usize {\n        num.to_string()\n\
    \            .chars()\n            .filter(|x| *x == '1')\n            .count()\n\
    \    };\n    let mut arr = arr;\n    arr.sort_by(|a, b| match ones(a).cmp(&ones(b))\
    \ {\n        Ordering::Equal => a.cmp(b),\n        x => x,\n    });\n    arr",
  "    let mut result = arr.clone();\n    result.sort_by(|a, b| {\n        let ones_a\
    \ = format!(\"{:b}\", a).chars().filter(|&c| c == '1').count();\n        let ones_b\
    \ = format!(\"{:b}\", b).chars().filter(|&c| c == '1').count();\n        if ones_a\
    \ == ones_b {\n            a.cmp(b)\n        } else {\n            ones_a.cmp(&ones_b)\n\
    \        }\n    });\n    result", "    arr.iter()\n        .map(|x| {\n      \
    \      let ones = x.abs().to_string(2).matches('1').count();\n            (x,\
    \ ones)\n        })\n        .collect::<Vec<(&isize, usize)>>()\n        .sort_by(|a,\
    \ b| {\n            a.1\n                .cmp(&b.1)\n                .then_with(||\
    \ a.0.abs().cmp(&b.0.abs()))\n                .then_with(|| a.0.cmp(&b.0))\n \
    \       })\n        .iter()\n        .map(|x| *x.0)\n        .collect()", "  \
    \  if arr.len() == 0 {\n        return vec![];\n    }\n    let max_ones = arr.iter().map(|n|\
    \ count_ones(*n)).max().unwrap();\n    let mut result = Vec::with_capacity(arr.len());\n\
    \    let mut one_count = 0;\n    while one_count <= max_ones {\n        for n\
    \ in arr.iter() {\n            if count_ones(*n) == one_count {\n            \
    \    result.push(*n);\n            }\n        }\n        one_count += 1;\n   \
    \ }\n    result", "    let mut v = arr.clone();\n    v.sort_by(|a, b| {\n    \
    \    match num_ones(*a).cmp(&num_ones(*b)) {\n            Ordering::Equal => a.cmp(b),\n\
    \            o => o,\n        }\n    });\n    v", "    let mut arr_ones: Vec<isize>\
    \ = arr.iter().map(|num| num.count_ones() as isize).collect();\n    arr_ones.sort();\n\
    \    let mut result: Vec<isize> = vec![];\n    let mut ones_iter = arr_ones.iter();\n\
    \    let mut ones = ones_iter.next();\n    while ones.is_some() {\n        let\
    \ mut indexes = arr\n            .iter()\n            .enumerate()\n         \
    \   .filter(|(_, num)| num.count_ones() as isize == *ones.unwrap())\n        \
    \    .map(|(index, _)| index)\n            .collect::<Vec<usize>>();\n       \
    \ indexes.sort_by_key(|&index| arr[index]);\n        for index in indexes {\n\
    \            result.push(arr[index]);\n        }\n        ones = ones_iter.next();\n\
    \    }\n    result", "    // Your code here!\n    arr", "    if arr.is_empty()\
    \ {\n        return arr;\n    }\n    let mut result = arr.clone();\n    result.sort_by(|a,\
    \ b| {\n        let a_count = a.count_ones();\n        let b_count = b.count_ones();\n\
    \        match a_count.cmp(&b_count) {\n            Ordering::Equal => a.cmp(b),\n\
    \            _ => a_count.cmp(&b_count),\n        }\n    });\n    result", " \
    \   let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| count_ones(*a).cmp(&count_ones(*b)));\n\
    \    sorted", "    let mut v: Vec<(usize, isize)> = arr.iter().map(|&x| (x.count_ones(),\
    \ x)).collect();\n    v.sort();\n    v.iter().map(|&x| x.1).collect()", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        let x = format!(\"{:b}\",\
    \ a);\n        let y = format!(\"{:b}\", b);\n        let n = x.chars().filter(|c|\
    \ *c == '1').count();\n        let m = y.chars().filter(|c| *c == '1').count();\n\
    \        if n == m {\n            a.cmp(b)\n        } else {\n            n.cmp(&m)\n\
    \        }\n    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let mut a_ones = 0;\n        let mut b_ones = 0;\n        let mut\
    \ n = *a;\n        while n > 0 {\n            a_ones += n & 1;\n            n\
    \ >>= 1;\n        }\n        n = *b;\n        while n > 0 {\n            b_ones\
    \ += n & 1;\n            n >>= 1;\n        }\n        if a_ones == b_ones {\n\
    \            a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n   \
    \     }\n    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n\
    \        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    arr", "    // 1. Sort by\
    \ number of ones in binary (not including sign bit)\n    // 2. Sort by value\n\
    \n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a, b| {\n   \
    \     let a_ones = count_binary_ones(*a);\n        let b_ones = count_binary_ones(*b);\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    sorted_arr", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b|\n        a.count_ones().cmp(&b.count_ones())\n\
    \            .then(a.cmp(b))\n    );\n    arr", "    let mut ones_counts: Vec<_>\
    \ = arr\n        .iter()\n        .map(|n| (n, n.count_ones()))\n        .collect();\n\
    \    ones_counts.sort_by(|a, b| match a.1.cmp(&b.1) {\n        Ordering::Equal\
    \ => a.0.cmp(&b.0),\n        other => other,\n    });\n    ones_counts.into_iter().map(|(n,\
    \ _)| *n).collect()", "    arr.iter()\n        .enumerate()\n        .map(|(i,\
    \ &x)| {\n            let binary = format!(\"{:b}\", x);\n            (\n    \
    \            binary.chars().filter(|&c| c == '1').count(),\n                binary.len(),\n\
    \                x,\n                i,\n            )\n        })\n        .collect::<Vec<_>>()\n\
    \        .sort_by(|&(a, _, _, _), &(b, _, _, _)| a.cmp(&b))\n        .sort_by(|&(_,\
    \ a, _, _), &(_, b, _, _)| a.cmp(&b))\n        .sort_by(|&(_, _, a, _), &(_, _,\
    \ b, _)| a.cmp(&b))\n        .into_iter()\n        .map(|(_, _, _, i)| arr[i])\n\
    \        .collect()", "    let mut arr: Vec<(usize, isize)> = arr.into_iter().map(|x|\
    \ (x.count_ones(), x)).collect();\n    arr.sort_by(|a, b| {\n        if a.0 ==\
    \ b.0 {\n            a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    arr.into_iter().map(|(_, x)| x).collect()", "    arr.into_iter()\n\
    \        .map(|x| (x, x.count_ones()))\n        .collect::<Vec<_>>()\n       \
    \ .sort_by(|a, b| if a.1 != b.1 { a.1.cmp(&b.1) } else { a.0.cmp(&b.0) });\n \
    \   arr", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let nb_ones_a\
    \ = ones_in_binary(*a);\n        let nb_ones_b = ones_in_binary(*b);\n       \
    \ match nb_ones_a.cmp(&nb_ones_b) {\n            std::cmp::Ordering::Equal =>\
    \ a.cmp(b),\n            ord => ord,\n        }\n    });\n    arr", "    let mut\
    \ a = arr.clone();\n    a.sort_by(|a, b| {\n        let a_ones = |n: isize| {\n\
    \            n.to_string()\n                .chars()\n                .filter(|c|\
    \ *c == '1')\n                .count() as isize\n        };\n        let a_ones\
    \ = a_ones(*a);\n        let b_ones = a_ones(*b);\n        b_ones.cmp(&a_ones).then_with(||\
    \ a.cmp(b))\n    });\n    a", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let x = a.count_ones() as isize;\n        let y = b.count_ones()\
    \ as isize;\n        if x != y {\n            x.cmp(&y)\n        } else {\n  \
    \          a.cmp(&b)\n        }\n    });\n    arr", "    let mut arr = arr;\n\
    \    arr.sort_by(|x, y| {\n        let x = to_base2(x.abs());\n        let y =\
    \ to_base2(y.abs());\n        x.cmp(&y).then(x.signum().cmp(&y.signum()))\n  \
    \  });\n    arr", "    let mut out = arr.clone();\n    out.sort_by(|a, b| {\n\
    \        let a_ones = ones(*a);\n        let b_ones = ones(*b);\n        if a_ones\
    \ != b_ones {\n            a_ones.cmp(&b_ones)\n        } else {\n           \
    \ a.cmp(b)\n        }\n    });\n    out", "    let mut nums = arr\n        .into_iter()\n\
    \        .map(|n| Num::new(n))\n        .collect::<Vec<_>>();\n    nums.sort();\n\
    \    nums.into_iter().map(|n| n.num).collect()", "    let mut vec = arr.clone();\n\
    \    vec.sort_by(|a, b| {\n        let a_ones = count_ones(*a);\n        let b_ones\
    \ = count_ones(*b);\n        if a_ones < b_ones {\n            std::cmp::Ordering::Less\n\
    \        } else if a_ones > b_ones {\n            std::cmp::Ordering::Greater\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    vec", "    if\
    \ arr.is_empty() {\n        return arr;\n    }\n    let mut arr = arr;\n    arr.sort_by(|a,\
    \ b| {\n        if a.count_ones() != b.count_ones() {\n            a.count_ones().cmp(&b.count_ones())\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    arr", "    if\
    \ arr.len() == 0 {\n        return arr;\n    }\n    let mut map = arr.iter().map(|&num|\
    \ (num, format!(\"{:b}\", num).chars().filter(|&x| x == '1').count())).collect::<Vec<_>>();\n\
    \    map.sort_by(|a, b| b.1.cmp(&a.1));\n    map.iter().map(|&(a, _)| a).collect()",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        match a_ones.cmp(&b_ones) {\n \
    \           Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ arr", "    arr.into_iter()\n        .map(|x| (x, x.count_ones()))\n        .sorted_by(|x,\
    \ y| (x.1, x.0).cmp(&(y.1, y.0)))\n        .map(|x| x.0)\n        .collect()",
  "    let mut arr_ones: Vec<(usize, isize)> = arr\n        .iter()\n        .map(|n|\
    \ (n.count_ones(), *n))\n        .collect();\n    arr_ones.sort_by(|a, b| a.cmp(b));\n\
    \    arr_ones.iter().map(|n| n.1).collect()", "    let mut result = arr.clone();\n\
    \    result.sort_by(|a, b| {\n        let x = a.count_ones();\n        let y =\
    \ b.count_ones();\n        if x == y {\n            return a.cmp(b);\n       \
    \ }\n        x.cmp(&y)\n    });\n    result", "    let mut new_arr = arr.clone();\n\
    \    new_arr.sort_by(|a, b| {\n        let a_ones = format!(\"{:b}\", a).matches('1').count();\n\
    \        let b_ones = format!(\"{:b}\", b).matches('1').count();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n\
    \    });\n    new_arr", "    let mut v = arr.clone();\n    v.sort_by(|a, b| {\n\
    \        let a1 = a.count_ones();\n        let b1 = b.count_ones();\n        if\
    \ a1 == b1 {\n            a.cmp(b)\n        } else {\n            a1.cmp(&b1)\n\
    \        }\n    });\n    v", "    let result: Vec<_> = arr\n        .into_iter()\n\
    \        .map(|x| (format!(\"{:b}\", x), x))\n        .collect();\n    result\n\
    \        .into_iter()\n        .sorted_by(|a, b| {\n            a.0.chars().filter(|x|\
    \ *x == '1').count()\n                .cmp(&b.0.chars().filter(|x| *x == '1').count())\n\
    \                .then(a.1.cmp(&b.1))\n        })\n        .map(|x| x.1)\n   \
    \     .collect()", "    let mut result = arr.clone();\n    result.sort_by(|a,\
    \ b| {\n        if ones(*a) == ones(*b) {\n            a.cmp(b)\n        } else\
    \ {\n            ones(*a).cmp(&ones(*b))\n        }\n    });\n    result", " \
    \   let mut sorted = arr.iter().map(|i| (i, num_ones(*i as u64))).collect::<Vec<_>>();\n\
    \    sorted.sort_by(|(i1, n1), (i2, n2)| {\n        if n1 == n2 {\n          \
    \  i1.cmp(i2)\n        } else {\n            n1.cmp(n2)\n        }\n    });\n\
    \    sorted.iter().map(|i| *i.0).collect()", "    let mut ones: Vec<usize> = arr.iter().map(|&x|\
    \ x.count_ones()).collect();\n    let mut a = arr.clone();\n    a.sort_by(|a,\
    \ b| {\n        let a1 = a.count_ones();\n        let b1 = b.count_ones();\n \
    \       if a1 == b1 {\n            a.cmp(b)\n        } else {\n            a1.cmp(&b1)\n\
    \        }\n    });\n    a", "    let mut ones: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in arr.iter() {\n        *ones.entry(*i).or_insert(0) += 1;\n    }\n\
    \    let mut sorted = vec![];\n    for i in arr.iter() {\n        if sorted.len()\
    \ == 0 {\n            sorted.push(*i);\n        } else {\n            let mut\
    \ j = 0;\n            for j in sorted.iter() {\n                if ones.get(j).unwrap()\
    \ < ones.get(i).unwrap() {\n                    break;\n                } else\
    \ if ones.get(j).unwrap() == ones.get(i).unwrap() {\n                    if j\
    \ > i {\n                        break;\n                    }\n             \
    \   }\n            }\n            sorted.insert(j, *i);\n        }\n    }\n  \
    \  sorted", "    arr.into_iter()\n        .map(|a| (a, count_ones(a)))\n     \
    \   .sorted_by(|(a, cnt_a), (b, cnt_b)| {\n            cnt_a.cmp(&cnt_b).then(a.cmp(&b))\n\
    \        })\n        .map(|(v, _)| v)\n        .collect()", "    let mut result\
    \ = arr.iter().map(|i| (i, *i as usize)).collect::<Vec<_>>();\n    result.sort_by(|a,\
    \ b| {\n        if let (Ok(a), Ok(b)) = (\n            a.1.count_ones(),\n   \
    \         b.1.count_ones(),\n        ) {\n            a.cmp(&b)\n        } else\
    \ {\n            a.0.cmp(&b.0)\n        }\n    });\n    result.iter().map(|i|\
    \ i.0).collect()", "    // sort\n    let mut new_arr = arr.clone();\n    new_arr.sort_by(|a,\
    \ b| {\n        let a_count = a.count_ones();\n        let b_count = b.count_ones();\n\
    \        if a_count != b_count {\n            a_count.cmp(&b_count)\n        }\
    \ else {\n            a.cmp(b)\n        }\n    });\n    new_arr", "    let mut\
    \ res = vec![];\n    let mut bits = vec![];\n    for n in arr {\n        let bin\
    \ = format!(\"{:b}\", n);\n        let mut one_count = 0;\n        for c in bin.chars()\
    \ {\n            if c == '1' {\n                one_count += 1;\n            }\n\
    \        }\n        bits.push((one_count, n));\n    }\n    bits.sort();\n    for\
    \ (_, n) in bits {\n        res.push(n);\n    }\n    res", "    let mut result\
    \ = arr.clone();\n    result.sort_by(|a, b| {\n        match a.count_ones().cmp(&b.count_ones())\
    \ {\n            Ordering::Equal => a.cmp(b),\n            x => x,\n        }\n\
    \    });\n    result", "    let mut clone = arr.clone();\n    clone.sort_by(|a,\
    \ b| {\n        if a == b {\n            return a.cmp(b);\n        }\n       \
    \ ones_count(*a).cmp(&ones_count(*b))\n    });\n    clone", "    fn count_ones(num:\
    \ isize) -> usize {\n        num.count_ones() as usize\n    }\n\n    fn abs(x:\
    \ isize) -> isize {\n        if x >= 0 {\n            x\n        } else {\n  \
    \          -x\n        }\n    }\n\n    arr.into_iter()\n        .map(|n| (count_ones(n),\
    \ abs(n)))\n        .collect::<Vec<_>>()\n        .sort_by(|a, b| match a.0.cmp(&b.0)\
    \ {\n            std::cmp::Ordering::Equal => a.1.cmp(&b.1),\n            y =>\
    \ y,\n        })\n        .into_iter()\n        .map(|(_, a)| a)\n        .collect()",
  "    let mut counts = vec![0; arr.len()];\n    let mut arr = arr;\n    for i in\
    \ 0..arr.len() {\n        let mut n = arr[i];\n        let mut count = 0;\n  \
    \      while n > 0 {\n            if n % 2 != 0 {\n                count += 1;\n\
    \            }\n            n /= 2;\n        }\n        counts[i] = count;\n \
    \   }\n    arr.sort_by(|a, b| {\n        counts[*a as usize].cmp(&counts[*b as\
    \ usize])\n            .then(a.cmp(b))\n    });\n    arr", "    let mut sorted_ones\
    \ = arr.iter().map(|x| (x, x.count_ones())).collect::<Vec<_>>();\n    sorted_ones.sort_by(|a,\
    \ b| {\n        if a.1 != b.1 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    sorted_ones.iter().map(|x|\
    \ *x.0).collect()", "    let mut v = arr.clone();\n    v.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()));\n\
    \    return v;", "    let mut ones_counts: Vec<_> = arr\n        .iter()\n   \
    \     .map(|i| (*i, num_ones(*i as u32)))\n        .collect();\n    ones_counts.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    ones_counts.into_iter().map(|i| i.0).collect()", " \
    \   let mut result = arr;\n    result.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     a.cmp(b)\n        } else {\n            a_ones.cmp(&b_ones)\n        }\n\
    \    });\n    result", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        match a_ones.cmp(&b_ones) {\n            std::cmp::Ordering::Equal =>\
    \ a.cmp(b),\n            _ => a_ones.cmp(&b_ones),\n        }\n    });\n    sorted",
  "    let mut one_counts: Vec<(isize, usize)> = arr\n        .iter()\n        .map(|&x|\
    \ (x, count_ones(x)))\n        .collect();\n    one_counts.sort_by(|a, b| {\n\
    \        if a.1 == b.1 {\n            a.0.cmp(&b.0)\n        } else {\n      \
    \      a.1.cmp(&b.1)\n        }\n    });\n    let mut sorted_arr: Vec<isize> =\
    \ one_counts.iter().map(|x| x.0).collect();\n    sorted_arr", "    arr.into_iter()\n\
    \        .map(|x| (x, format!(\"{:b}\", x.abs()).matches(\"1\").count()))\n  \
    \      .collect::<Vec<_>>()\n        .sort_by(|a, b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n\
    \        .into_iter()\n        .map(|x| x.0)\n        .collect()", "    let mut\
    \ ret = arr.clone();\n    let mut index = 0;\n    let mut new_index = 0;\n   \
    \ let mut one_counts = Vec::new();\n    while index < ret.len() {\n        let\
    \ mut count = 0;\n        let mut bits = ret[index];\n        while bits > 0 {\n\
    \            count += bits & 1;\n            bits >>= 1;\n        }\n        one_counts.push(count);\n\
    \        index += 1;\n    }\n    // println!(\"{:?}\", one_counts);\n    index\
    \ = 0;\n    while index < ret.len() {\n        let mut min_count = one_counts[index];\n\
    \        let mut min_index = index;\n        let mut one_index = index;\n    \
    \    while one_index < one_counts.len() {\n            if one_counts[one_index]\
    \ < min_count {\n                min_count = one_counts[one_index];\n        \
    \        min_index = one_index;\n            }\n            one_index += 1;\n\
    \        }\n        if min_index != index {\n            one_counts.swap(min_index,\
    \ index);\n            ret.swap(min_index, index);\n        }\n        index +=\
    \ 1;\n    }\n    index = 0;\n    while index < ret.len() {\n        let mut min_count\
    \ = one_counts[index];\n        let mut min_index = index;\n        let mut one_index\
    \ = index;\n        while one_index < one_counts.len() {\n            if one_counts[one_index]\
    \ == min_count && ret[one_index] < ret[min_index] {\n                min_count\
    \ = one_counts[one_index];\n                min_index = one_index;\n         \
    \   }\n            one_index += 1;\n        }\n        if min_index != index {\n\
    \            one_counts.swap(min_index, index);\n            ret.swap(min_index,\
    \ index);\n        }\n        index += 1;\n    }\n    // println!(\"{:?}\", one_counts);\n\
    \    ret", "    // your code here\n    arr", "    let mut sort_arr = arr;\n  \
    \  sort_arr.sort_by(|a, b| count_ones(*a).cmp(&count_ones(*b)));\n    sort_arr",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let mut a_bit = *a;\n\
    \        let mut b_bit = *b;\n        let mut a_count = 0;\n        let mut b_count\
    \ = 0;\n        while a_bit > 0 {\n            a_count += a_bit % 2;\n       \
    \     a_bit /= 2;\n        }\n        while b_bit > 0 {\n            b_count +=\
    \ b_bit % 2;\n            b_bit /= 2;\n        }\n        if a_count == b_count\
    \ {\n            a.cmp(b)\n        } else {\n            a_count.cmp(&b_count)\n\
    \        }\n    });\n    arr", "    let mut vec = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    vec.sort_by(|a, b| {\n        let f = |x| x.count_ones();\n        let a\
    \ = (f(*a), *a);\n        let b = (f(*b), *b);\n        a.cmp(&b)\n    });\n \
    \   vec", "    let mut og = arr.clone();\n    og.sort_by(|a, b| {\n        match\
    \ get_ones(*a)\n            .cmp(&get_ones(*b))\n            .then(a.cmp(b))\n\
    \        {\n            Ordering::Equal => Ordering::Equal,\n            Ordering::Greater\
    \ => Ordering::Less,\n            Ordering::Less => Ordering::Greater,\n     \
    \   }\n    });\n    og", "    let mut arr = arr;\n    arr.sort_by(|a, b| match\
    \ a.count_ones().cmp(&b.count_ones()) {\n        Ordering::Equal => a.cmp(b),\n\
    \        Ordering::Less => Ordering::Less,\n        Ordering::Greater => Ordering::Greater,\n\
    \    });\n    arr", "    let mut arr_with_ones = arr\n        .iter()\n      \
    \  .map(|&x| (count_ones(x), x))\n        .collect::<Vec<_>>();\n    arr_with_ones.sort();\n\
    \    arr_with_ones.iter().map(|&(_, x)| x).collect()", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let a_bit_count = a.count_ones();\n       \
    \ let b_bit_count = b.count_ones();\n        if a_bit_count == b_bit_count {\n\
    \            a.cmp(b)\n        } else {\n            a_bit_count.cmp(&b_bit_count)\n\
    \        }\n    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let (a_ones, a_dec) = get_ones_and_decimal(*a);\n        let (b_ones,\
    \ b_dec) = get_ones_and_decimal(*b);\n        if a_ones != b_ones {\n        \
    \    a_ones.cmp(&b_ones)\n        } else {\n            a_dec.cmp(&b_dec)\n  \
    \      }\n    });\n    arr", "    let mut ones_arr: Vec<(usize, isize)> = arr\n\
    \        .iter()\n        .map(|x| (format!(\"{:b}\", x).matches('1').count(),\
    \ *x))\n        .collect();\n    ones_arr.sort();\n    ones_arr.iter().map(|x|\
    \ x.1).collect()", "    let mut vec: Vec<isize> = arr.iter().map(|&e| e.abs()).collect();\n\
    \    let mut ones: Vec<isize> = vec![];\n    let mut more: Vec<isize> = vec![];\n\
    \    let mut less: Vec<isize> = vec![];\n    for &e in &vec {\n        let mut\
    \ count = 0;\n        let mut x = e;\n        while x > 0 {\n            if x\
    \ % 2 == 1 {\n                count += 1;\n            }\n            x /= 2;\n\
    \        }\n        if count == 0 {\n            more.push(e);\n        } else\
    \ {\n            if ones.len() <= count as usize {\n                ones.resize(count\
    \ as usize + 1, vec![]);\n            }\n            ones[count as usize].push(e);\n\
    \        }\n    }\n    for v in ones {\n        less.append(&mut v);\n    }\n\
    \    less.append(&mut more);\n    let mut count = 0;\n    let mut ans: Vec<isize>\
    \ = vec![];\n    for e in vec {\n        if e == less[count] {\n            ans.push(e);\n\
    \            count += 1;\n        } else {\n            ans.push(-e);\n      \
    \  }\n    }\n    ans", "    let mut arr: Vec<_> = arr.into_iter().map(|x| (x,\
    \ x.count_ones())).collect();\n    arr.sort_by_key(|x| x.1);\n    arr.into_iter().map(|x|\
    \ x.0).collect()", "    use std::cmp::Ordering;\n    let mut sorted = arr.clone();\n\
    \    sorted.sort_by(|a, b| {\n        match (a.count_ones(), b.count_ones()) {\n\
    \            (x, y) if x < y => Ordering::Less,\n            (x, y) if x > y =>\
    \ Ordering::Greater,\n            _ => a.cmp(b),\n        }\n    });\n    sorted",
  "    let mut arr_clone = arr.clone();\n    arr_clone.sort_by(|a, b| {\n        let\
    \ ones_a = binary_ones(a);\n        let ones_b = binary_ones(b);\n        if ones_a\
    \ != ones_b {\n            ones_a.cmp(&ones_b)\n        } else {\n           \
    \ a.cmp(&b)\n        }\n    });\n    arr_clone", "    let len = arr.len();\n \
    \   if len < 2 {\n        return arr;\n    }\n    let (mut ones, mut zeros): (Vec<isize>,\
    \ Vec<isize>) = arr.into_iter().partition(|x| count_one(*x) == 1);\n    ones.sort_by(|a,\
    \ b| count_one(*a).cmp(&count_one(*b)));\n    zeros.sort_by(|a, b| count_one(*a).cmp(&count_one(*b)));\n\
    \    ones.extend(zeros);\n    ones", "    fn count_ones(n: isize) -> u8 {\n  \
    \      n.count_ones()\n    }\n\n    let mut sorted: Vec<isize> = arr.clone();\n\
    \    sorted.sort_by(|a, b| match count_ones(*a).cmp(&count_ones(*b)) {\n     \
    \   Ordering::Equal => a.cmp(b),\n        other => other,\n    });\n    sorted",
  "    let mut a = arr.clone();\n    a.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones == b_ones {\n       \
    \     return a.cmp(b);\n        }\n        a_ones.cmp(&b_ones)\n    });\n    a",
  "    fn count_ones(mut num: usize) -> usize {\n        let mut count = 0;\n    \
    \    while num > 0 {\n            count += num & 1;\n            num >>= 1;\n\
    \        }\n        count\n    }\n\n    fn sort_by_ones(a: &isize, b: &isize)\
    \ -> std::cmp::Ordering {\n        let count_a = count_ones(a.abs() as usize);\n\
    \        let count_b = count_ones(b.abs() as usize);\n        if count_a == count_b\
    \ {\n            a.cmp(b)\n        } else {\n            count_a.cmp(&count_b)\n\
    \        }\n    }\n\n    let mut arr_copy = arr.clone();\n    arr_copy.sort_by(sort_by_ones);\n\
    \    arr_copy", "    if arr.is_empty() {\n        return arr;\n    }\n    let\
    \ mut v: Vec<_> = arr.iter().map(|x| (x, ones_in_binary(*x))).collect();\n   \
    \ v.sort_by(|a, b| match a.1.cmp(&b.1) {\n        Ordering::Equal => a.0.cmp(b.0),\n\
    \        other => other,\n    });\n    v.iter().map(|&(x, _)| x).collect()", " \
    \   let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let ones_a = a.count_ones();\n\
    \        let ones_b = b.count_ones();\n        if ones_a == ones_b {\n       \
    \     a.cmp(b)\n        } else {\n            ones_a.cmp(&ones_b)\n        }\n\
    \    });\n    arr", "    let mut arr: Vec<isize> = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        a_ones.cmp(&b_ones).then(a.cmp(b))\n    });\n    arr", "    arr.into_iter()\n\
    \        .map(|x| (x, format!(\"{:b}\", x)))\n        .map(|(x, y)| (x, y.matches(\"\
    1\").count()))\n        .collect::<Vec<(isize, usize)>>()\n        .sort_by(|a,\
    \ b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)))\n        .into_iter()\n        .map(|x|\
    \ x.0)\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n\
    \        let count_a = a.count_ones();\n        let count_b = b.count_ones();\n\
    \        if count_a == count_b {\n            a.cmp(b)\n        } else {\n   \
    \         count_a.cmp(&count_b)\n        }\n    });\n    arr", "    arr.into_iter()\n\
    \        .map(|n| (n, n.count_ones()))\n        .sorted_by(|(a, a_ones), (b, b_ones)|\
    \ match a_ones.cmp(b_ones) {\n            Ordering::Equal => a.cmp(b),\n     \
    \       Ordering::Less => Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n\
    \        })\n        .map(|(n, _)| n)\n        .collect()", "    // let mut arr\
    \ = arr;\n    // arr.sort_by(|a, b| {\n    //     let count_a = a.count_ones();\n\
    \    //     let count_b = b.count_ones();\n    //     match count_a.cmp(&count_b)\
    \ {\n    //         std::cmp::Ordering::Equal => a.cmp(b),\n    //         ord\
    \ => ord,\n    //     }\n    // });\n    // arr\n    let mut arr: Vec<_> = arr.into_iter().map(|a|\
    \ (a, format!(\"{:b}\", a).chars().filter(|a| *a == '1').count())).collect();\n\
    \    arr.sort_by(|a, b| {\n        match a.1.cmp(&b.1) {\n            std::cmp::Ordering::Equal\
    \ => a.0.cmp(&b.0),\n            ord => ord,\n        }\n    });\n    arr.into_iter().map(|a|\
    \ a.0).collect()", "    let mut values: Vec<(isize, isize)> = arr.iter().map(|&x|\
    \ (x, x.count_ones())).collect();\n    values.sort_by(|a, b| match a.1.cmp(&b.1)\
    \ {\n        Ordering::Equal => a.0.cmp(&b.0),\n        Ordering::Less => Ordering::Less,\n\
    \        Ordering::Greater => Ordering::Greater,\n    });\n    values.iter().map(|&(x,\
    \ _)| x).collect()", "    let mut arr: Vec<isize> = arr;\n    arr.sort_by(|a,\
    \ b| {\n        let x = a.count_ones();\n        let y = b.count_ones();\n   \
    \     if x == y {\n            a.cmp(b)\n        } else {\n            x.cmp(&y)\n\
    \        }\n    });\n    arr", "    let mut res = arr.clone();\n    res.sort_by(|x,\
    \ y| {\n        let (x1, y1) = (ones_cnt(x), ones_cnt(y));\n        if x1 != y1\
    \ {\n            x1.cmp(&y1)\n        } else {\n            x.cmp(&y)\n      \
    \  }\n    });\n    res", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n \
    \       let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n \
    \       if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n        } else\
    \ {\n            a.cmp(b)\n        }\n    });\n    arr", "    let mut arr = arr;\n\
    \    arr.sort_by(|a, b| {\n        let a = (ones_in_binary(a), a);\n        let\
    \ b = (ones_in_binary(b), b);\n        a.cmp(&b)\n    });\n    arr", "    arr.iter()\n\
    \        .map(|x| {\n            (\n                format!(\"{:b}\", x).chars().filter(|&c|\
    \ c == '1').count(),\n                x,\n            )\n        })\n        .sorted_by(|a,\
    \ b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)))\n        .map(|x| x.1)\n        .collect()",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let mut a = *a;\n   \
    \     let mut b = *b;\n        let mut cmp = 0;\n        while a > 0 || b > 0\
    \ {\n            if a & 1 == 1 && b & 1 == 0 {\n                cmp = cmp.saturating_sub(1);\n\
    \            } else if a & 1 == 0 && b & 1 == 1 {\n                cmp = cmp.saturating_add(1);\n\
    \            }\n            a = a.saturating_shr(1);\n            b = b.saturating_shr(1);\n\
    \        }\n        cmp.cmp(&0)\n    });\n    arr", "    arr.into_iter()\n   \
    \     .map(|n| (format!(\"{:b}\", n).matches('1').count(), n))\n        .sorted()\n\
    \        .into_iter()\n        .map(|(_, n)| n)\n        .collect()", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_count = count_ones(*a);\n\
    \        let b_count = count_ones(*b);\n        if a_count == b_count {\n    \
    \        a.cmp(b)\n        } else {\n            a_count.cmp(&b_count)\n     \
    \   }\n    });\n    arr", "    let mut result = arr.clone();\n    result.sort_by(|a,\
    \ b| (a.count_ones(), *a).cmp(&(b.count_ones(), *b)));\n    result", "    return\
    \ arr.into_iter().enumerate().collect::<Vec<(usize, isize)>>()\n        .sort_by(|a,\
    \ b| {\n            let a_ones = a.1.count_ones();\n            let b_ones = b.1.count_ones();\n\
    \            if a_ones == b_ones {\n                a.0.cmp(&b.0)\n          \
    \  } else {\n                a_ones.cmp(&b_ones)\n            }\n        })\n\
    \        .into_iter()\n        .map(|t| t.1)\n        .collect();", "    let mut\
    \ cloned = arr.clone();\n    cloned.sort_by(|a, b| {\n        let bina = format!(\"\
    {:b}\", a);\n        let binb = format!(\"{:b}\", b);\n        bina.chars().filter(|&c|\
    \ c == '1').count().cmp(&binb.chars().filter(|&c| c == '1').count())\n       \
    \     .then(a.cmp(b))\n    });\n    cloned", "    let mut arr: Vec<isize> = arr.into_iter().map(|n|\
    \ {\n        n as usize\n    }).collect();\n    arr.sort_by(|a, b| {\n       \
    \ let (count_a, count_b) = (ones_count(*a), ones_count(*b));\n        if count_a\
    \ == count_b {\n            a.cmp(b)\n        } else {\n            count_a.cmp(&count_b)\n\
    \        }\n    });\n    arr.into_iter().map(|n| {\n        n as isize\n    }).collect()",
  "    arr.into_iter()\n        .map(|x| {\n            let ones = x.abs().count_ones();\n\
    \            (-ones, x)\n        })\n        .sorted_by(|x, y| {\n           \
    \ if x.0 != y.0 {\n                x.0.cmp(&y.0)\n            } else {\n     \
    \           x.1.cmp(&y.1)\n            }\n        })\n        .map(|x| x.1)\n\
    \        .collect()", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        let b_count = b.count_ones();\n        let a_count = a.count_ones();\n\
    \        if a_count == b_count {\n            a.cmp(b)\n        } else {\n   \
    \         a_count.cmp(&b_count)\n        }\n    });\n    sorted", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        if a_ones != b_ones {\n       \
    \     a_ones.cmp(&b_ones)\n        } else {\n            a.cmp(b)\n        }\n\
    \    });\n    arr", "    let mut sorted_arr = arr.clone();\n    sorted_arr.sort_by(|a,\
    \ b| {\n        let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n\
    \        ones_a.cmp(&ones_b).then(a.cmp(b))\n    });\n    sorted_arr", "    let\
    \ mut arr = arr;\n    arr.sort_by(|x, y| {\n        let x = count_ones(*x);\n\
    \        let y = count_ones(*y);\n        if x == y {\n            x.cmp(&y)\n\
    \        } else {\n            x.cmp(&y)\n        }\n    });\n    arr", "    let\
    \ mut arr = arr;\n    arr.sort_by(|a, b| {\n        let c = a.count_ones().cmp(&b.count_ones());\n\
    \        if c == Ordering::Equal {\n            a.cmp(b)\n        } else {\n \
    \           c\n        }\n    });\n    arr", "    let mut res = arr;\n    res.sort_by(|a,\
    \ b| {\n        let a_ones = format!(\"{:b}\", a).chars().filter(|c| *c == '1').count();\n\
    \        let b_ones = format!(\"{:b}\", b).chars().filter(|c| *c == '1').count();\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    res", "    let mut v = arr.clone();\n\
    \    v.sort_by(|a, b| {\n        let bin_a = format!(\"{:b}\", a);\n        let\
    \ bin_b = format!(\"{:b}\", b);\n        bin_a.as_bytes().iter().filter(|&&x|\
    \ x == b'1').count().cmp(&bin_b.as_bytes().iter().filter(|&&x| x == b'1').count())\n\
    \            .then(a.cmp(b))\n    });\n    v", "    let mut result = arr;\n  \
    \  result.sort_by(|a, b| {\n        let a_ones = count_ones(a);\n        let b_ones\
    \ = count_ones(b);\n        if a_ones != b_ones {\n            a_ones.cmp(&b_ones)\n\
    \        } else {\n            a.cmp(&b)\n        }\n    });\n    result", " \
    \   let n = arr.len();\n    let mut ones = arr.iter().map(|&x| (x as usize).count_ones()).collect::<Vec<_>>();\n\
    \    let mut aux = arr.clone();\n    sort_three_way(&mut ones, &mut aux, 0, n\
    \ - 1);\n    aux", "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n       \
    \ let ones_a = a.count_ones();\n        let ones_b = b.count_ones();\n       \
    \ ones_a.cmp(&ones_b).then(a.cmp(b))\n    });\n    arr", "    let mut arr = arr;\n\
    \    let mut sorted = Vec::with_capacity(arr.len());\n    let mut ones = arr.iter().map(|i|\
    \ (i, count_ones(i))).collect::<Vec<_>>();\n    let mut zeros = Vec::new();\n\
    \    let mut minus_ones = Vec::new();\n    while !ones.is_empty() {\n        let\
    \ mut i = 0;\n        while i < ones.len() {\n            let (n, o) = ones[i];\n\
    \            if o == 1 {\n                minus_ones.push(n);\n              \
    \  ones.remove(i);\n            } else {\n                i += 1;\n          \
    \  }\n        }\n        let min = ones.iter().min_by_key(|(_, o)| *o).unwrap().1;\n\
    \        i = 0;\n        while i < ones.len() {\n            let (n, o) = ones[i];\n\
    \            if o == min {\n                zeros.push(n);\n                ones.remove(i);\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \ }\n    sorted.append(&mut minus_ones);\n    sorted.append(&mut zeros);\n   \
    \ for i in 0..arr.len() {\n        for j in 0..arr.len() {\n            if arr[j]\
    \ == sorted[i] {\n                arr.remove(j);\n                break;\n   \
    \         }\n        }\n    }\n    arr.extend(sorted);\n    arr", "    let mut\
    \ vec = arr.clone();\n    vec.sort_by(|a, b| {\n        let a_bin = format!(\"\
    {:b}\", a).len();\n        let b_bin = format!(\"{:b}\", b).len();\n        a_bin.cmp(&b_bin).then(a.cmp(b))\n\
    \    });\n    vec", "    let mut sorted = arr.clone();\n    sorted.sort_by(|a,\
    \ b| {\n        let (ones_a, dec_a) = count_ones(*a);\n        let (ones_b, dec_b)\
    \ = count_ones(*b);\n        ones_a.cmp(&ones_b).then(dec_a.cmp(&dec_b))\n   \
    \ });\n    sorted", "    let mut arr = arr;\n    arr.sort_by(|x, y| {\n      \
    \  let x_ones = x.count_ones();\n        let y_ones = y.count_ones();\n      \
    \  if x_ones == y_ones {\n            x.cmp(y)\n        } else {\n           \
    \ x_ones.cmp(&y_ones)\n        }\n    });\n    arr", "    arr.iter()\n       \
    \ .map(|n| {\n            (\n                n.count_ones(),\n               \
    \ if n.is_negative() {\n                    std::isize::MAX\n                }\
    \ else {\n                    n.abs()\n                },\n            )\n   \
    \     })\n        .collect::<Vec<_>>()\n        .sort_by(|a, b| a.cmp(b))\n  \
    \      .iter()\n        .map(|(a, b)| if *b == std::isize::MAX { -*b } else {\
    \ *b })\n        .collect()", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let mut x = *a;\n        let mut y = *b;\n        let mut ones_x\
    \ = 0;\n        let mut ones_y = 0;\n        while x > 0 {\n            ones_x\
    \ += x % 2;\n            x /= 2;\n        }\n        while y > 0 {\n         \
    \   ones_y += y % 2;\n            y /= 2;\n        }\n        ones_x.cmp(&ones_y).then_with(||\
    \ a.cmp(b))\n    });\n    arr", "    let mut arr = arr;\n    arr.sort_by(|a, b|\
    \ {\n        let ones_a = a.abs().count_ones();\n        let ones_b = b.abs().count_ones();\n\
    \        if ones_a == ones_b {\n            a.cmp(b)\n        } else {\n     \
    \       ones_a.cmp(&ones_b)\n        }\n    });\n    arr", "    let mut counter\
    \ = HashMap::new();\n    for i in arr.iter() {\n        let count = count_bits(i);\n\
    \        counter.entry(count).or_insert(Vec::new()).push(*i);\n    }\n    let\
    \ mut res = Vec::new();\n    for i in 0..=count_bits(&arr.iter().max().unwrap())\
    \ {\n        if let Some(v) = counter.get(&i) {\n            res.extend(v);\n\
    \        }\n    }\n    res", "    let mut arr_cpy = arr.clone();\n    arr_cpy.sort_by(|a,\
    \ b| {\n        let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n\
    \        if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n     \
    \       a_ones.cmp(&b_ones)\n        }\n    });\n    arr_cpy", "    let mut arr\
    \ = arr;\n    let mut ones = arr.iter().map(|n| {\n        let mut c = 0;\n  \
    \      let mut n = *n;\n        while n > 0 {\n            c += n & 1;\n     \
    \       n = n >> 1;\n        }\n        c\n    }).collect::<Vec<_>>();\n    arr.sort_by(|a,\
    \ b| {\n        let diff = ones[*a as usize].cmp(&ones[*b as usize]);\n      \
    \  if diff == Ordering::Equal {\n            a.cmp(b)\n        } else {\n    \
    \        diff\n        }\n    });\n    arr", "    use std::collections::HashMap;\n\
    \    let mut map = HashMap::new();\n    for v in arr.iter() {\n        let ones\
    \ = bits(*v);\n        let v = *v;\n        map.entry(ones).or_insert(vec![]).push(v);\n\
    \    }\n    let mut ret = Vec::new();\n    for v in map.values_mut() {\n     \
    \   v.sort();\n        ret.extend(v);\n    }\n    ret", "    let mut zeros = vec![];\n\
    \    let mut ones = vec![];\n    let mut twos = vec![];\n    let mut threes =\
    \ vec![];\n    let mut fours = vec![];\n    let mut fives = vec![];\n    let mut\
    \ sixes = vec![];\n    let mut sevens = vec![];\n    let mut eights = vec![];\n\
    \    let mut nines = vec![];\n    let mut tens = vec![];\n    let mut elevens\
    \ = vec![];\n    let mut twelve = vec![];\n    let mut thirteens = vec![];\n \
    \   let mut fourteens = vec![];\n    let mut fifteens = vec![];\n    let mut sixteens\
    \ = vec![];\n    let mut seventeen = vec![];\n    let mut eighteen = vec![];\n\
    \    let mut nineteen = vec![];\n    let mut twenty = vec![];\n    let mut twenty_one\
    \ = vec![];\n    let mut twenty_two = vec![];\n    let mut twenty_three = vec![];\n\
    \    let mut twenty_four = vec![];\n    let mut twenty_five = vec![];\n    let\
    \ mut twenty_six = vec![];\n    let mut twenty_seven = vec![];\n    let mut twenty_eight\
    \ = vec![];\n    let mut twenty_nine = vec![];\n    let mut thirty = vec![];\n\
    \    let mut thirty_one = vec![];\n    let mut thirty_two = vec![];\n    let mut\
    \ thirty_three = vec![];\n    let mut thirty_four = vec![];\n    let mut thirty_five\
    \ = vec![];\n    let mut thirty_six = vec![];\n    let mut thirty_seven = vec![];\n\
    \    let mut thirty_eight = vec![];\n    let mut thirty_nine = vec![];\n    let\
    \ mut forty = vec![];\n    let mut forty_one = vec![];\n    let mut forty_two\
    \ = vec![];\n    let mut forty_three = vec![];\n    let mut forty_four = vec![",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a = a.to_string();\n\
    \        let b = b.to_string();\n        a.chars().filter(|c| *c == '1').count().cmp(&b.chars().filter(|c|\
    \ *c == '1').count())\n            .then(a.cmp(&b))\n    });\n    arr"]
stop_tokens:
- "\n}"
