name: HumanEval_59_largest_prime_factor
language: rs
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    let f = |n: isize| {\n        let mut n = n;\n        let mut i\
    \ = 2;\n        while i <= n {\n            if n % i == 0 {\n                n\
    \ /= i;\n            } else {\n                i += 1;\n            }\n      \
    \  }\n        i\n    };\n    f(n)", "    let (mut n, mut i) = (n, 2);\n    while\
    \ i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    i", "    let mut biggest_factor = 1;\n\
    \    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n       \
    \     biggest_factor = d;\n            n /= d;\n        } else {\n           \
    \ d += 1;\n        }\n    }\n    if n > 1 {\n        return n;\n    }\n    return\
    \ biggest_factor;", "    let mut f = 2;\n    let mut nn = n;\n    while nn > 1\
    \ {\n        if nn % f == 0 {\n            nn /= f;\n        } else {\n      \
    \      f += 1;\n        }\n    }\n    f", "    let mut p = 2;\n    let mut result\
    \ = 0;\n    while p * p <= n {\n        if n % p == 0 {\n            result =\
    \ p;\n            while n % p == 0 {\n                n /= p;\n            }\n\
    \        }\n        p += 1;\n    }\n    if n > 1 {\n        result = n;\n    }\n\
    \    result", "    let is_factor = |x: isize| -> bool { n % x == 0 };\n    let\
    \ is_prime = |x: isize| -> bool { !(2..(x as f64).sqrt() as isize + 1).any(|i|\
    \ x % i == 0) };\n    (2..n).filter(|x| is_factor(*x)).filter(|x| is_prime(*x)).last().unwrap()",
  "    if n <= 1 {\n        return 0;\n    }\n\n    // find if n is prime\n    let\
    \ mut primes = prime_sieve(1, (n as f64).sqrt() as isize);\n    if let Some(prime)\
    \ = primes.iter().find(|x| **x == n) {\n        return *prime;\n    }\n\n    //\
    \ find max prime factor\n    for p in primes.iter().rev() {\n        if n % p\
    \ == 0 {\n            return *p;\n        }\n    }\n\n    0", "    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    panic!(\"{} is a prime number, do not call me.\", n);", "    let mut\
    \ n = n;\n    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0\
    \ {\n            n /= i;\n        }\n        i += 1;\n    }\n    n", "    for\
    \ i in (2..n).rev() {\n        if n % i == 0 && is_prime(i) {\n            return\
    \ i;\n        }\n    }\n    panic!(\"Expected non-prime\");", "    if is_prime(n)\
    \ {\n        return n;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    n", "    let mut largest_prime = 1;\n\
    \    let mut i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n       \
    \     largest_prime = i;\n            n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    if n > 1 {\n        largest_prime = n;\n    }\n\
    \    largest_prime", "    let mut largest_factor = 1;\n    let mut i = 2;\n  \
    \  while i <= n {\n        if n % i == 0 {\n            n /= i;\n            largest_factor\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    largest_factor",
  "    let mut res = n;\n    let mut i = 2;\n    while i * i <= res {\n        if\
    \ res % i == 0 {\n            res /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    res", "    let (mut remainder, mut factor) = (n, 2);\n\
    \    while factor < remainder {\n        if remainder % factor == 0 {\n      \
    \      remainder /= factor;\n        } else {\n            factor += 1;\n    \
    \    }\n    }\n    factor", "    let mut m = n;\n    let mut result = 1;\n   \
    \ for prime in primes::new() {\n        if prime >= m {\n            break;\n\
    \        }\n        while m % prime == 0 {\n            result = prime;\n    \
    \        m /= prime;\n        }\n    }\n    result", "    let mut factor = 2;\n\
    \    let mut largest_factor = 0;\n    let mut remaining = n;\n    while remaining\
    \ > 1 {\n        if remaining % factor == 0 {\n            largest_factor = factor;\n\
    \            remaining /= factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    largest_factor", "    // TODO implement\n    return 0;",
  "    let mut max_factor = 2;\n    let mut factor = 2;\n    let mut n = n;\n    while\
    \ n > 1 {\n        while n % factor == 0 {\n            n /= factor;\n       \
    \     max_factor = factor;\n        }\n        factor += 1;\n    }\n    max_factor",
  "    if is_prime(n) {\n        return n;\n    }\n\n    let mut n = n;\n    let mut\
    \ largest_factor = 2;\n    while n != 1 {\n        if n % largest_factor == 0\
    \ {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    largest_factor"]
stop_tokens:
- "\n}"
