name: HumanEval_59_largest_prime_factor
language: rs
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    let f = |n: isize| {\n        let mut n = n;\n        let mut i\
    \ = 2;\n        while i <= n {\n            if n % i == 0 {\n                n\
    \ /= i;\n            } else {\n                i += 1;\n            }\n      \
    \  }\n        i\n    };\n    f(n)", "    let (mut n, mut i) = (n, 2);\n    while\
    \ i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n    i", "    let mut biggest_factor = 1;\n\
    \    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n       \
    \     biggest_factor = d;\n            n /= d;\n        } else {\n           \
    \ d += 1;\n        }\n    }\n    if n > 1 {\n        return n;\n    }\n    return\
    \ biggest_factor;", "    let mut f = 2;\n    let mut nn = n;\n    while nn > 1\
    \ {\n        if nn % f == 0 {\n            nn /= f;\n        } else {\n      \
    \      f += 1;\n        }\n    }\n    f", "    let mut p = 2;\n    let mut result\
    \ = 0;\n    while p * p <= n {\n        if n % p == 0 {\n            result =\
    \ p;\n            while n % p == 0 {\n                n /= p;\n            }\n\
    \        }\n        p += 1;\n    }\n    if n > 1 {\n        result = n;\n    }\n\
    \    result", "    let is_factor = |x: isize| -> bool { n % x == 0 };\n    let\
    \ is_prime = |x: isize| -> bool { !(2..(x as f64).sqrt() as isize + 1).any(|i|\
    \ x % i == 0) };\n    (2..n).filter(|x| is_factor(*x)).filter(|x| is_prime(*x)).last().unwrap()",
  "    if n <= 1 {\n        return 0;\n    }\n\n    // find if n is prime\n    let\
    \ mut primes = prime_sieve(1, (n as f64).sqrt() as isize);\n    if let Some(prime)\
    \ = primes.iter().find(|x| **x == n) {\n        return *prime;\n    }\n\n    //\
    \ find max prime factor\n    for p in primes.iter().rev() {\n        if n % p\
    \ == 0 {\n            return *p;\n        }\n    }\n\n    0", "    for i in (2..=n).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    panic!(\"{} is a prime number, do not call me.\", n);", "    let mut\
    \ n = n;\n    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0\
    \ {\n            n /= i;\n        }\n        i += 1;\n    }\n    n", "    for\
    \ i in (2..n).rev() {\n        if n % i == 0 && is_prime(i) {\n            return\
    \ i;\n        }\n    }\n    panic!(\"Expected non-prime\");", "    if is_prime(n)\
    \ {\n        return n;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    n", "    let mut largest_prime = 1;\n\
    \    let mut i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n       \
    \     largest_prime = i;\n            n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    if n > 1 {\n        largest_prime = n;\n    }\n\
    \    largest_prime", "    let mut largest_factor = 1;\n    let mut i = 2;\n  \
    \  while i <= n {\n        if n % i == 0 {\n            n /= i;\n            largest_factor\
    \ = i;\n        } else {\n            i += 1;\n        }\n    }\n    largest_factor",
  "    let mut res = n;\n    let mut i = 2;\n    while i * i <= res {\n        if\
    \ res % i == 0 {\n            res /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    res", "    let (mut remainder, mut factor) = (n, 2);\n\
    \    while factor < remainder {\n        if remainder % factor == 0 {\n      \
    \      remainder /= factor;\n        } else {\n            factor += 1;\n    \
    \    }\n    }\n    factor", "    let mut m = n;\n    let mut result = 1;\n   \
    \ for prime in primes::new() {\n        if prime >= m {\n            break;\n\
    \        }\n        while m % prime == 0 {\n            result = prime;\n    \
    \        m /= prime;\n        }\n    }\n    result", "    let mut factor = 2;\n\
    \    let mut largest_factor = 0;\n    let mut remaining = n;\n    while remaining\
    \ > 1 {\n        if remaining % factor == 0 {\n            largest_factor = factor;\n\
    \            remaining /= factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    largest_factor", "    // TODO implement\n    return 0;",
  "    let mut max_factor = 2;\n    let mut factor = 2;\n    let mut n = n;\n    while\
    \ n > 1 {\n        while n % factor == 0 {\n            n /= factor;\n       \
    \     max_factor = factor;\n        }\n        factor += 1;\n    }\n    max_factor",
  "    if is_prime(n) {\n        return n;\n    }\n\n    let mut n = n;\n    let mut\
    \ largest_factor = 2;\n    while n != 1 {\n        if n % largest_factor == 0\
    \ {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    largest_factor", "    for factor in (2..).take_while(|&factor|\
    \ factor * factor <= n) {\n        if n % factor == 0 {\n            return largest_prime_factor(n\
    \ / factor);\n        }\n    }\n    n", "    for i in (2..=n).rev() {\n      \
    \  if n % i == 0 && is_prime(i) {\n            return i;\n        }\n    }\n \
    \   n", "    let mut factor = 2;\n    let mut result = 1;\n    while n > 1 {\n\
    \        while n % factor == 0 {\n            result = factor;\n            n\
    \ /= factor;\n        }\n        factor += 1;\n    }\n    result", "    let mut\
    \ q = n;\n    let mut d = 2;\n    while q > 1 {\n        while q % d == 0 {\n\
    \            q /= d;\n        }\n        d += 1;\n    }\n    d - 1", "    let\
    \ mut result = 2;\n    let mut tmp = n;\n    while tmp > 1 {\n        while tmp\
    \ % result == 0 {\n            tmp /= result;\n        }\n        result += 1;\n\
    \    }\n    result - 1", "    assert!(n > 1);\n    let largest_prime_factor =\
    \ 2;\n\n    // TODO: replace this with your implementation\n    largest_prime_factor",
  "    // Check 2, 3 and 5\n    if n % 2 == 0 {\n        return 2;\n    }\n    if\
    \ n % 3 == 0 {\n        return 3;\n    }\n    if n % 5 == 0 {\n        return\
    \ 5;\n    }\n\n    let mut i = 7;\n    let mut factor = 2;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            factor = i;\n        }\n        i\
    \ += 4;\n        if n % i == 0 {\n            factor = i;\n        }\n       \
    \ i += 2;\n        if n % i == 0 {\n            factor = i;\n        }\n     \
    \   i += 4;\n        if n % i == 0 {\n            factor = i;\n        }\n   \
    \     i += 2;\n        if n % i == 0 {\n            factor = i;\n        }\n \
    \       i += 4;\n        if n % i == 0 {\n            factor = i;\n        }\n\
    \        i += 6;\n        if n % i == 0 {\n            factor = i;\n        }\n\
    \        i += 2;\n        if n % i == 0 {\n            factor = i;\n        }\n\
    \        i += 6;\n    }\n    factor", "    let mut prime_factor = 2;\n    let\
    \ mut number = n;\n    while prime_factor <= number {\n        if number % prime_factor\
    \ == 0 {\n            number /= prime_factor;\n        } else {\n            prime_factor\
    \ += 1;\n        }\n    }\n    return prime_factor;", "    if is_prime(n) {\n\
    \        return n;\n    }\n    let mut factor = n;\n    while !is_prime(factor)\
    \ {\n        for i in (2..factor + 1).rev() {\n            if factor % i == 0\
    \ {\n                factor = i;\n                break;\n            }\n    \
    \    }\n    }\n    factor", '    (2..).take_while(|&x| x * x <= n).find(|&x| n
    % x == 0).unwrap()', "    let mut k = n;\n    let mut i = 2;\n    while i * i\
    \ <= k {\n        if k % i == 0 {\n            k /= i;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    k", "    if n < 2 {\n        panic!(\"\
    Invalid input: {}\", n);\n    }\n    for d in (2..).take_while(|&d| d * d <= n)\
    \ {\n        if n % d == 0 {\n            return largest_prime_factor(n / d);\n\
    \        }\n    }\n    n", "    let mut largest_factor = 2;\n    let mut num =\
    \ n;\n    while num % 2 == 0 {\n        num /= 2;\n    }\n    let mut divisor\
    \ = 3;\n    while num > 1 {\n        while num % divisor == 0 {\n            num\
    \ /= divisor;\n            largest_factor = divisor;\n        }\n        divisor\
    \ += 2;\n    }\n    largest_factor", "    let mut result = 1;\n    let mut prime\
    \ = 2;\n    let mut n = n;\n    while n > 1 {\n        while n % prime == 0 {\n\
    \            result = prime;\n            n /= prime;\n        }\n        prime\
    \ += 1;\n    }\n    result", "    // TODO: Your code here!\n    unimplemented!()",
  "    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return i;", "    let mut n = n;\n    let mut prime = 2;\n    while\
    \ n > 1 {\n        if n % prime == 0 {\n            n /= prime;\n        } else\
    \ {\n            prime += 1;\n        }\n    }\n    prime", "    // TODO: fix\
    \ code here.\n    let mut n = n;\n    let mut max = n;\n    let mut i = 2;\n \
    \   while i < n {\n        if n % i == 0 {\n            n /= i;\n            max\
    \ = i;\n        }\n        i += 1;\n    }\n    max", "    if n == 2 {\n      \
    \  return 2;\n    }\n    if n % 2 == 0 {\n        return largest_prime_factor(n\
    \ / 2);\n    }\n    let sq = (n as f64).sqrt() as isize;\n    for i in (3..sq\
    \ + 1).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;", "    let mut prime_factor = 1;\n  \
    \  let mut remainder = n;\n    let mut factor = 2;\n    while remainder > 1 {\n\
    \        if remainder % factor == 0 {\n            remainder /= factor;\n    \
    \        prime_factor = factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    prime_factor", '    1', "    let mut n = n;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n            n /=\
    \ i;\n        }\n        i += 1;\n    }\n    n", "    let mut f = 2;\n    let\
    \ mut _n = n;\n    while _n > 1 {\n        if _n % f == 0 {\n            _n /=\
    \ f;\n        } else {\n            f += 1;\n        }\n    }\n    f", "    if\
    \ n % 2 == 0 {\n        return largest_prime_factor(n / 2);\n    }\n\n    let\
    \ mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n\n        i += 2;\n    }\n\n    n",
  '    largest_prime_factor_helper(n, 2)', "    let mut result = 0;\n    let mut i\
    \ = 2;\n    while i <= n {\n        if n % i == 0 {\n            result = i;\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    result", "    let mut x = n;\n    let mut i = 2;\n    let mut factors = Vec::new();\n\
    \    while i * i <= x {\n        if x % i == 0 {\n            factors.push(i);\n\
    \            x /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    if x > 1 {\n        factors.push(x);\n    }\n    factors.sort();\n    factors.last().unwrap().clone()",
  "    let mut factor = 2;\n    let mut i = n;\n    let mut largest_factor = 1;\n\
    \    while i > 1 {\n        while i % factor == 0 {\n            largest_factor\
    \ = factor;\n            i /= factor;\n        }\n        factor += 1;\n    }\n\
    \    largest_factor", "    let mut n = n;\n    let mut prime = 2;\n    while n\
    \ % prime == 0 {\n        n /= prime;\n    }\n    while n != 1 {\n        prime\
    \ += 1;\n        while is_prime(prime) == false {\n            prime += 1;\n \
    \       }\n        while n % prime == 0 {\n            n /= prime;\n        }\n\
    \    }\n    prime", "    let mut n = n;\n    let mut largest_prime = 1;\n    let\
    \ mut p = 2;\n    while p * p <= n {\n        if n % p == 0 {\n            n /=\
    \ p;\n            largest_prime = p;\n        } else {\n            p += 1;\n\
    \        }\n    }\n    if n > largest_prime {\n        n\n    } else {\n     \
    \   largest_prime\n    }", "    let mut primes = Primes::new();\n    let mut largest\
    \ = 1;\n    while let Some(prime) = primes.next() {\n        if n % prime == 0\
    \ {\n            largest = prime;\n        }\n        if prime * prime > n {\n\
    \            break;\n        }\n    }\n    largest", "    if is_prime(n) {\n \
    \       return n;\n    }\n\n    let mut prime_factor: isize = n;\n    let mut\
    \ k: isize = 2;\n    let mut limit: isize = n;\n\n    while k <= limit {\n   \
    \     while prime_factor % k == 0 {\n            prime_factor = prime_factor /\
    \ k;\n            limit = prime_factor;\n        }\n        k += 1;\n    }\n\n\
    \    prime_factor", "    // 1 is not prime\n    if n == 1 {\n        return 0;\n\
    \    }\n\n    // 2 is the only even prime\n    if n % 2 == 0 {\n        return\
    \ largest_prime_factor(n / 2);\n    }\n\n    // Now n is odd and n > 1, so it\
    \ is not prime\n    // Find the largest odd prime factor, p, of n\n    let mut\
    \ p = 0;\n    let mut i = 3;\n    let mut quotient = n;\n    while i * i <= n\
    \ {\n        if quotient % i == 0 {\n            quotient /= i;\n            p\
    \ = i;\n        } else {\n            i += 2;\n        }\n    }\n\n    if quotient\
    \ > 1 {\n        p = quotient;\n    }\n\n    p", "    let mut largest_factor =\
    \ 1;\n    let mut d = 2;\n    while n > 1 {\n        while n % d == 0 {\n    \
    \        largest_factor = d;\n            n /= d;\n        }\n        d += 1;\n\
    \    }\n    largest_factor", "    let factors = prime_factors(n);\n    *factors.iter().max().unwrap()",
  "    let mut m = n;\n    let mut i = 2;\n    while i <= m {\n        if m % i ==\
    \ 0 {\n            m /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return i;", "    let mut largest_factor = 1;\n    let mut n = n;\n\
    \    for divisor in 2..(n / 2 + 1) {\n        if n % divisor == 0 {\n        \
    \    n /= divisor;\n            largest_factor = divisor;\n        }\n    }\n\
    \    largest_factor", "    let mut p = 2;\n    let mut k = n;\n    while k > p\
    \ {\n        if k % p == 0 {\n            k /= p;\n        } else {\n        \
    \    p += 1;\n        }\n    }\n    p", "    let mut factor: isize = n;\n    let\
    \ mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            factor = i;\n            n /= i;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    if n > 1 {\n        factor = n;\n    }\n\
    \    factor", "    let mut d = 2;\n    let mut m = n;\n    while d * d <= m {\n\
    \        if m % d == 0 {\n            m /= d;\n        } else {\n            d\
    \ += 1;\n        }\n    }\n    m", "    let mut m = n;\n    let mut i = 2;\n \
    \   let mut p = 0;\n    while i < n {\n        if m % i == 0 {\n            p\
    \ = i;\n            m = m / i;\n        } else {\n            i += 1;\n      \
    \  }\n    }\n    p", "    let mut divisor = 2;\n    let mut factor = n;\n    while\
    \ divisor * divisor <= factor {\n        if factor % divisor == 0 {\n        \
    \    factor /= divisor;\n        } else {\n            divisor += 1;\n       \
    \ }\n    }\n    factor", '    unimplemented!()', "    let mut divisor = 2;\n \
    \   let mut max_divisor = 1;\n    while n > 1 {\n        while n % divisor ==\
    \ 0 {\n            max_divisor = divisor;\n            n /= divisor;\n       \
    \ }\n        divisor += 1;\n    }\n    max_divisor", "    let limit = (n as f64).sqrt()\
    \ as isize;\n    let mut factor = 2;\n    while factor <= limit {\n        if\
    \ n % factor == 0 {\n            return largest_prime_factor(n / factor);\n  \
    \      }\n        factor += 1;\n    }\n    return n;", "    fn helper(n: isize,\
    \ divisor: isize) -> isize {\n        if n <= divisor {\n            n\n     \
    \   } else if n % divisor == 0 {\n            helper(n / divisor, divisor)\n \
    \       } else {\n            helper(n, divisor + 1)\n        }\n    }\n    helper(n,\
    \ 2)", "    match n {\n        _ if is_prime(n) => n,\n        _ => {\n      \
    \      let mut divisor = 2;\n            let mut largest_prime_factor = 1;\n \
    \           let mut temp = n;\n            while temp > 1 {\n                if\
    \ temp % divisor == 0 {\n                    largest_prime_factor = divisor;\n\
    \                    temp /= divisor;\n                } else {\n            \
    \        divisor += 1;\n                }\n            }\n            largest_prime_factor\n\
    \        }\n    }", "    let mut factor: isize = 2;\n    let mut n = n;\n    while\
    \ n != 1 {\n        if n % factor == 0 {\n            n /= factor;\n        }\
    \ else {\n            factor += 1;\n        }\n    }\n    factor", "    let factors\
    \ = prime_factors(n);\n    return factors[factors.len() - 1];", "    let mut divisor\
    \ = 2;\n    let mut quotient = n;\n    while divisor <= quotient {\n        if\
    \ is_prime(divisor) && quotient % divisor == 0 {\n            quotient /= divisor;\n\
    \        } else {\n            divisor += 1;\n        }\n    }\n    divisor",
  "    let mut factors = Vec::new();\n    let mut current = n;\n    let mut primes\
    \ = PrimeIterator::new();\n    while current > 1 {\n        match prime_factors(current)\
    \ {\n            Ok(vec) => {\n                for factor in vec {\n         \
    \           factors.push(factor);\n                }\n                break;\n\
    \            }\n            Err(i) => {\n                current = i;\n      \
    \          let prime = primes.next().unwrap();\n                factors.push(prime);\n\
    \            }\n        }\n    }\n    let mut largest = 0;\n    for i in factors\
    \ {\n        if i > largest {\n            largest = i;\n        }\n    }\n  \
    \  largest", "    let mut n = n;\n    let mut largest_factor = 1;\n    while n\
    \ % 2 == 0 {\n        largest_factor = 2;\n        n /= 2;\n    }\n    let mut\
    \ factor = 3;\n    while n > 1 {\n        while n % factor == 0 {\n          \
    \  largest_factor = factor;\n            n /= factor;\n        }\n        factor\
    \ += 2;\n    }\n    largest_factor", "    let mut largest = 1;\n    let mut factor\
    \ = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % factor == 0 {\n\
    \            n /= factor;\n            largest = factor;\n        } else {\n \
    \           factor += 1;\n        }\n    }\n    largest", "    let mut factors\
    \ = vec![];\n    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n    \
    \    if n % i == 0 {\n            factors.push(i);\n            n /= i;\n    \
    \    } else {\n            i += 1;\n        }\n    }\n    factors.pop().unwrap()",
  "    let mut largest_prime_factor = 2;\n    let mut new_n = n;\n    for i in 2..n\
    \ {\n        if new_n % i == 0 {\n            if is_prime(i) {\n             \
    \   largest_prime_factor = i;\n            }\n            new_n = new_n / i;\n\
    \        }\n    }\n    largest_prime_factor", "    let mut factors = vec![];\n\
    \    factors.push(n);\n    factors.append(&mut prime_factors(n));\n    factors.sort();\n\
    \    factors.pop().unwrap()", "    let mut ret = 0;\n    let mut divisor = 2;\n\
    \    let mut remainder = n;\n    while remainder > 1 {\n        if remainder %\
    \ divisor == 0 {\n            ret = divisor;\n            remainder /= divisor;\n\
    \        } else {\n            divisor += 1;\n        }\n    }\n    ret", "  \
    \  match n {\n        1 => 1,\n        2 => 2,\n        _ => {\n            for\
    \ x in (2..n).rev() {\n                if is_prime(x) && n % x == 0 {\n      \
    \              return x;\n                }\n            }\n            1\n  \
    \      }\n    }", "    if n % 2 == 0 {\n        largest_prime_factor(n / 2)\n\
    \    } else {\n        // Find the next prime factor (other than 2) of n.\n  \
    \      let mut i = 3;\n        while n % i != 0 {\n            i += 2;\n     \
    \   }\n        // Largest prime factor is the larger of i and the largest prime\
    \ factor of n / i.\n        let other_prime_factor = largest_prime_factor(n /\
    \ i);\n        if i > other_prime_factor {\n            i\n        } else {\n\
    \            other_prime_factor\n        }\n    }", "    if n < 2 {\n        return\
    \ 1;\n    }\n    let mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    n", "    let mut largest_factor = 1;\n    let mut\
    \ remaining = n;\n    let mut factor = 2;\n    while remaining > 1 {\n       \
    \ if remaining % factor == 0 {\n            largest_factor = factor;\n       \
    \     remaining /= factor;\n            while remaining % factor == 0 {\n    \
    \            remaining /= factor;\n            }\n        }\n        factor +=\
    \ 1;\n    }\n    largest_factor", "    // Fill this in.\n    let mut factor =\
    \ 2;\n    let mut max_factor = 1;\n    while factor <= n {\n        if n % factor\
    \ == 0 {\n            max_factor = factor;\n            n /= factor;\n       \
    \ } else {\n            factor += 1;\n        }\n    }\n    max_factor", "   \
    \ if n <= 1 {\n        panic!(\"n must be greater than 1\")\n    }\n    let mut\
    \ prime_factors = Vec::new();\n    let mut n_mut = n;\n    for i in 2..n {\n \
    \       if n_mut % i == 0 {\n            n_mut /= i;\n            prime_factors.push(i);\n\
    \        }\n    }\n    *prime_factors.last().unwrap()", "    let mut largest_factor\
    \ = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            largest_factor = i;\n            n /= i;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    largest_factor", "    // A prime number\
    \ is any number greater than 1 whose only factors are 1 and itself.\n    // `is_prime`\
    \ is declared in `lib.rs`.\n    let mut result = 0;\n    let mut i = 2;\n    while\
    \ i * i <= n {\n        if n % i == 0 && is_prime(i) {\n            result = i;\n\
    \        }\n        i += 1;\n    }\n    result", "    let prime_factors = prime_factors(n);\n\
    \    *prime_factors.iter().max().unwrap()", '    return primes_less_than(n).iter().rev().next().unwrap();',
  "    let mut n = n;\n    let mut i = 2;\n    while i * i <= n {\n        while n\
    \ % i == 0 {\n            n /= i;\n        }\n        i += 1;\n    }\n    n",
  "    let mut num = n;\n    let mut max_prime = 2;\n    let mut p = 2;\n    while\
    \ p * p <= num {\n        if num % p == 0 {\n            max_prime = p;\n    \
    \        num /= p;\n        } else {\n            p += 1;\n        }\n    }\n\
    \    if num > max_prime {\n        num\n    } else {\n        max_prime\n    }",
  "    let mut m = n;\n    let mut i = 2;\n    while i <= m {\n        if m % i ==\
    \ 0 {\n            m /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return i;", "    let mut p = 2;\n    let mut q = n;\n    while q >\
    \ p {\n        if q % p == 0 {\n            q /= p;\n        } else {\n      \
    \      p += 1;\n        }\n    }\n    p", "    let mut candidate = 2;\n    let\
    \ mut biggest = 1;\n    while candidate <= n {\n        if n % candidate == 0\
    \ {\n            biggest = candidate;\n            while n % candidate == 0 {\n\
    \                n /= candidate;\n            }\n        }\n        candidate\
    \ += 1;\n    }\n    biggest", "    for i in 2.. {\n        if n % i == 0 {\n \
    \           return largest_prime_factor(n / i);\n        }\n    }\n    n", " \
    \   let mut n = n;\n    let mut i = 2;\n    let mut max = 1;\n    while i <= n\
    \ / i {\n        while n % i == 0 {\n            max = i;\n            n = n /\
    \ i;\n        }\n        i += 1;\n    }\n    if n > 1 {\n        max = n;\n  \
    \  }\n    max", "    let mut prime_factors = Vec::new();\n    let mut check =\
    \ n;\n    let mut primes = prime_gen(n);\n    while check > 1 {\n        let p\
    \ = primes.next().unwrap();\n        while check % p == 0 {\n            prime_factors.push(p);\n\
    \            check /= p;\n        }\n    }\n    *prime_factors.iter().max().unwrap()",
  "    // A simple trial division algorithm, optimized for n by stopping at sqrt(n).\n\
    \    // If n has a prime factor of p, then either n = p or n/p is not a prime\
    \ number.\n    let mut f = 2;\n    let mut n = n;\n    while n > 1 {\n       \
    \ if n % f == 0 {\n            n /= f;\n        } else {\n            f += 1;\n\
    \        }\n    }\n    f", "    let mut m = n;\n    let mut i = 2;\n    while\
    \ i * i <= m {\n        if m % i == 0 {\n            m /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    m", "    let mut n = n;\n    let mut\
    \ largest_factor = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            largest_factor = i;\n            n /= i;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    if n > 1 {\n        largest_factor\
    \ = n;\n    }\n    largest_factor", "    let mut n = n;\n    for x in 2..n / 2\
    \ {\n        if n % x == 0 {\n            n /= x;\n        }\n    }\n    n", " \
    \   for i in (2..n).rev() {\n        if n % i == 0 && is_prime(i) {\n        \
    \    return i;\n        }\n    }\n    0", "    let mut factor: isize = 2;\n  \
    \  let mut n_modified = n;\n    while factor <= n_modified {\n        if n_modified\
    \ % factor == 0 {\n            n_modified /= factor;\n        } else {\n     \
    \       factor += 1;\n        }\n    }\n    return factor;", "    if n < 1 {\n\
    \        panic!(\"n must be > 1. Found: {}\", n);\n    }\n    if is_prime(n) {\n\
    \        return n;\n    }\n    let mut lpf = 1;\n    for p in 2..=n {\n      \
    \  if is_prime(p) && n % p == 0 {\n            lpf = p;\n        }\n    }\n  \
    \  lpf", "    let mut n = n;\n    let mut factor = 2;\n    let mut last_factor\
    \ = 0;\n    while n > 1 {\n        if n % factor == 0 {\n            last_factor\
    \ = factor;\n            n /= factor;\n            while n % factor == 0 {\n \
    \               n /= factor;\n            }\n        }\n        factor += 1;\n\
    \    }\n    last_factor", "    let mut largest_prime = 2;\n    let mut num = n;\n\
    \    while num > 1 {\n        for x in largest_prime.. {\n            if num %\
    \ x == 0 {\n                largest_prime = x;\n                num /= x;\n  \
    \              break;\n            }\n        }\n    }\n    largest_prime", " \
    \   // TODO: Implement\n    0", "    let mut largest_factor = 1;\n    let mut\
    \ i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            largest_factor\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    largest_factor", "    match n {\n        0 => -1,\n        1 => -1,\n\
    \        2 => 2,\n        _ => {\n            let mut prime_factors = Vec::new();\n\
    \            for i in 2..n + 1 {\n                if is_prime(i) && n % i == 0\
    \ {\n                    prime_factors.push(i);\n                }\n         \
    \   }\n            *prime_factors.iter().max().unwrap()\n        }\n    }", " \
    \   let mut largest_prime = 0;\n    let mut n = n;\n    for i in 2..n {\n    \
    \    while n % i == 0 {\n            n /= i;\n            largest_prime = i;\n\
    \        }\n    }\n    largest_prime", "    match is_prime(n) {\n        true\
    \ => n,\n        false => largest_prime_factor(factor(n).1),\n    }", "    let\
    \ mut max_prime = -1;\n    let mut copy = n;\n\n    while copy % 2 == 0 {\n  \
    \      max_prime = 2;\n        copy /= 2;\n    }\n\n    let mut i = 3;\n    while\
    \ i <= (copy as f64).sqrt() as isize {\n        while copy % i == 0 {\n      \
    \      max_prime = i;\n            copy /= i;\n        }\n        i += 2;\n  \
    \  }\n\n    if copy > 2 {\n        max_prime = copy;\n    }\n\n    max_prime",
  "    let mut n = n;\n    let mut last_prime = 2;\n    while n % 2 == 0 {\n     \
    \   n /= 2;\n    }\n    let mut f = 3;\n    while f * f <= n {\n        if n %\
    \ f == 0 {\n            last_prime = f;\n            while n % f == 0 {\n    \
    \            n /= f;\n            }\n        }\n        f += 2;\n    }\n    if\
    \ n > 1 {\n        last_prime = n;\n    }\n    last_prime", "    let mut primes\
    \ = vec![2];\n    let mut num = n;\n    for i in 3..n {\n        if is_prime(i)\
    \ {\n            primes.push(i);\n        }\n    }\n    while !is_prime(num) {\n\
    \        let mut found = false;\n        for p in primes.iter() {\n          \
    \  if num % p == 0 {\n                num = num / p;\n                found =\
    \ true;\n                break;\n            }\n        }\n        if !found {\n\
    \            panic!(\"No prime factors found for {}\", n);\n        }\n    }\n\
    \    num", "    let mut n = n;\n    let mut factor = 2;\n    while n > 1 {\n \
    \       if n % factor == 0 {\n            n /= factor;\n        } else {\n   \
    \         factor += 1;\n        }\n    }\n    factor", "    let mut divisor =\
    \ 2;\n    let mut largest_prime_factor = 0;\n    let mut remaining = n;\n    while\
    \ remaining > 1 {\n        if remaining % divisor == 0 {\n            largest_prime_factor\
    \ = divisor;\n            remaining /= divisor;\n        } else {\n          \
    \  divisor += 1;\n        }\n    }\n    largest_prime_factor", "    let mut result\
    \ = 0;\n    for mut i in 2..=(n / 2) {\n        if i % 2 == 0 {\n            i\
    \ += 1;\n        }\n        if n % i == 0 {\n            result = i;\n       \
    \     while n % i == 0 {\n                n /= i;\n            }\n        }\n\
    \    }\n    if n > 1 {\n        result = n;\n    }\n    result", "    let mut\
    \ n = n;\n    let mut largest_prime = 2;\n    while n > 1 {\n        if is_prime(n)\
    \ {\n            return n;\n        }\n        while n % largest_prime == 0 {\n\
    \            n /= largest_prime;\n        }\n        largest_prime += 1;\n   \
    \ }\n    largest_prime", "    let mut factor = n / 2;\n    while !is_prime(factor)\
    \ {\n        if n % factor == 0 {\n            return factor;\n        }\n   \
    \     factor -= 1;\n    }\n    n", "    let mut i = 2;\n    let mut largest_prime\
    \ = 1;\n    while i <= n / 2 {\n        if is_prime(i) && n % i == 0 {\n     \
    \       largest_prime = i;\n        }\n        i += 1;\n    }\n    largest_prime",
  "    let mut factors = vec![];\n    let mut n = n;\n    let mut m = 2;\n    while\
    \ n > 1 {\n        if n % m == 0 {\n            factors.push(m);\n           \
    \ n /= m;\n        } else {\n            m += 1;\n        }\n    }\n    factors.iter().max().unwrap().clone()",
  "    let mut res = 0;\n    let mut sq = (n as f64).sqrt() as isize;\n    while sq\
    \ > 1 {\n        if n % sq == 0 && is_prime(sq) {\n            res = sq;\n   \
    \         break;\n        }\n        sq -= 1;\n    }\n    res", "    let mut n\
    \ = n;\n    let mut factor = 2;\n    while n % factor != 0 {\n        factor +=\
    \ 1;\n    }\n    n /= factor;\n    if n == 1 {\n        factor\n    } else {\n\
    \        largest_prime_factor(n)\n    }", "    // Prime numbers less than or equal\
    \ to 10\n    let mut pset = vec![2, 3, 5, 7];\n    let mut result = 0;\n    for\
    \ i in 2..(n as f64).sqrt() as isize + 1 {\n        let is_prime = if i <= 10\
    \ {\n            pset.contains(&i)\n        } else {\n            is_prime_number(i)\n\
    \        };\n        if is_prime && n % i == 0 {\n            result = i;\n  \
    \      }\n    }\n    result", "    let mut x = n;\n    let mut i = 2;\n    while\
    \ i * i <= x {\n        if x % i == 0 {\n            x /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    x", "    // We start i at 3 since\
    \ even numbers can be divided by 2 and 1 is not a prime number.\n    for i in\
    \ (3..).step_by(2) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n", "    let mut n = n;\n    let mut d = 2;\n \
    \   while n > 1 {\n        while n % d == 0 {\n            n /= d;\n        }\n\
    \        d += 1;\n    }\n    d - 1", "    let mut n = n;\n    let mut p = 2;\n\
    \    while n != 1 {\n        while n % p == 0 {\n            n /= p;\n       \
    \ }\n        p += 1;\n    }\n    p - 1", '    return 0;', "    let mut i = 2;\n\
    \    let mut largest = 0;\n    while i <= n {\n        if n % i == 0 {\n     \
    \       largest = i;\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    largest", "    let mut k = n;\n    let mut i = 2;\n\
    \    while i * i <= k {\n        if k % i == 0 {\n            k /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    k", "    // The largest\
    \ prime factor of n is no greater than n / 2.\n    for i in (2..=(n / 2)).rev()\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    // In case of n is a prime.\n    return n;", "    // Can I prune the\
    \ search space?\n    // Don't want to waste time searching for numbers that are\
    \ obviously not going to be a\n    // factor of n.\n    //\n    // Could go through\
    \ all factors and keep track of which ones are prime?\n    // Well, just check\
    \ if it's a prime. Probably don't need to store the list of primes.\n    let mut\
    \ largest_prime_factor = 1;\n    for i in 2..(n/2) {\n        if n % i == 0 &&\
    \ is_prime(i) {\n            largest_prime_factor = i;\n        }\n    }\n   \
    \ largest_prime_factor", "    let mut result = 0;\n    let mut x = n;\n    let\
    \ mut i = 2;\n    while i * i <= x {\n        if x % i == 0 {\n            result\
    \ = i;\n            x /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if x > 1 {\n        result = x;\n    }\n    result", "    let mut\
    \ i = 2;\n    let mut max_prime = 2;\n    while i <= n {\n        while n % i\
    \ == 0 {\n            max_prime = i;\n            n /= i;\n        }\n       \
    \ i += 1;\n    }\n    max_prime", "    let mut i = 2;\n    let mut largest_prime\
    \ = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i;\n            while n % i == 0 {\n                n /= i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if n > largest_prime {\n        n\n  \
    \  } else {\n        largest_prime\n    }", "    // TODO: Implement the function\
    \ here\n    let mut new_n = n;\n    let mut largest_factor = 1;\n    while new_n\
    \ != 1 {\n        largest_factor = smallest_factor(new_n);\n        new_n /= largest_factor;\n\
    \    }\n    largest_factor", "    let mut p = 2;\n    let mut l: isize = 0;\n\
    \    let mut m = n;\n    while p * p <= m {\n        if m % p == 0 {\n       \
    \     l = p;\n            m /= p;\n        } else {\n            p += 1;\n   \
    \     }\n    }\n    if m > 1 {\n        l = m;\n    }\n    l", "    let mut result\
    \ = 1;\n    let mut num = n;\n    while num > 1 {\n        let mut factor = 2;\n\
    \        while factor <= num {\n            if num % factor == 0 {\n         \
    \       result = factor;\n                num /= factor;\n                break;\n\
    \            }\n            factor += 1;\n        }\n    }\n    result", "   \
    \ let mut num = n;\n    let mut largest_factor = 2;\n    while num > largest_factor\
    \ {\n        if num % largest_factor == 0 {\n            num /= largest_factor;\n\
    \            largest_factor = 2;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    largest_factor", "    let mut i = 2;\n    let mut\
    \ result = 1;\n    let mut n = n;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            result = i;\n            n /= i;\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    if n > 1 {\n        result = n;\n    }\n\
    \    result", "    let mut n = n;\n    let mut factors = Vec::new();\n    let\
    \ mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            n /= i;\n\
    \            factors.push(i);\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    factors.pop().unwrap()", "    // We define a function to do factorization.\n\
    \    // Note that for efficiency reasons, the code defines a \"helper\" function,\n\
    \    // and we then use a Rust closure to wrap the function and make it capture\n\
    \    // a mutable variable.\n    fn factor(n: isize, largest: &mut isize) {\n\
    \        for i in 2..=(n / 2) {\n            if n % i == 0 {\n               \
    \ *largest = if i > *largest { i } else { *largest };\n                factor(n\
    \ / i, largest);\n                break;\n            }\n        }\n    }\n\n\
    \    let mut largest = 0;\n    factor(n, &mut largest);\n    largest", "    //\
    \ PENDING\n    0", "    let mut k = 2;\n    let mut l: isize = 1;\n    while k\
    \ * k <= n {\n        if n % k == 0 {\n            n /= k;\n            l = k;\n\
    \        } else {\n            k += 1;\n        }\n    }\n    if n > l {\n   \
    \     n\n    } else {\n        l\n    }", "    if is_prime(n) {\n        return\
    \ n;\n    }\n\n    for i in (2..).take_while(|&i| i * i <= n) {\n        if n\
    \ % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n   \
    \ }\n\n    n", "    let mut n = n;\n    let mut largest_prime = 2;\n    while\
    \ n > 1 {\n        largest_prime = next_prime(largest_prime);\n        while n\
    \ % largest_prime == 0 {\n            n /= largest_prime;\n        }\n    }\n\
    \    largest_prime", "    let mut n = n;\n    let mut max = 1;\n    for i in 2..n\
    \ {\n        if n % i == 0 {\n            n /= i;\n            max = i;\n    \
    \    }\n    }\n    max", "    let limit = (n as f64).sqrt() as isize;\n    let\
    \ mut prime_factors = Vec::new();\n    let mut factor = 2;\n    let mut remainder\
    \ = n;\n    while factor <= limit {\n        if remainder % factor == 0 {\n  \
    \          remainder /= factor;\n            prime_factors.push(factor);\n   \
    \     } else {\n            factor += 1;\n        }\n    }\n    if remainder !=\
    \ 1 {\n        prime_factors.push(remainder);\n    }\n    *prime_factors.iter().max().unwrap()",
  "    let mut n = n;\n    let mut p = 1;\n    while p < n {\n        p += 1;\n  \
    \      while n % p == 0 {\n            n /= p;\n        }\n    }\n    p", "  \
    \  let mut largest_factor = 0;\n    for i in 2..n / 2 {\n        if n % i == 0\
    \ && is_prime(i) {\n            largest_factor = i;\n        }\n    }\n    largest_factor",
  "    let mut p = n;\n    for i in 2..n {\n        if n % i == 0 {\n            p\
    \ = largest_prime_factor(n / i);\n            break;\n        }\n    }\n    p",
  "    let mut factor = 2;\n    let mut result = 1;\n    while n > 1 {\n        while\
    \ n % factor == 0 {\n            result = factor;\n            n /= factor;\n\
    \        }\n        factor += 1;\n    }\n    result", "    let mut primes = vec![];\n\
    \    let mut fact = n;\n    for i in 2..n {\n        if fact % i == 0 {\n    \
    \        fact /= i;\n            primes.push(i);\n        }\n    }\n    *primes.last().unwrap()",
  "    let mut largest_prime_factor = 0;\n    let mut lpf = 2;\n    let mut n = n;\n\
    \    while n > 1 {\n        if n % lpf == 0 {\n            largest_prime_factor\
    \ = lpf;\n            n /= lpf;\n        } else {\n            lpf += 1;\n   \
    \     }\n    }\n    largest_prime_factor", "    if n == 1 {\n        return 1;\n\
    \    }\n    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n        if\
    \ n % i == 0 {\n            n /= i;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    i", "    let mut c = n;\n    let mut i = 2;\n    while i\
    \ * i <= c {\n        if c % i == 0 {\n            c /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    return c;", "    let mut factors =\
    \ vec![];\n    let mut factor = 2;\n    let mut n = n;\n    while n != 1 {\n \
    \       if n % factor == 0 {\n            factors.push(factor);\n            n\
    \ /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n \
    \   *factors.last().unwrap()", "    let mut largest_prime_factor = 2;\n    let\
    \ mut n = n;\n    while n > 1 {\n        if n % largest_prime_factor == 0 {\n\
    \            n /= largest_prime_factor;\n        } else {\n            largest_prime_factor\
    \ += 1;\n        }\n    }\n    largest_prime_factor", "    let mut prime_factors\
    \ = vec![];\n    let mut c = n;\n    for i in 2..c {\n        while c % i == 0\
    \ {\n            prime_factors.push(i);\n            c /= i;\n        }\n    }\n\
    \    if c > 1 {\n        prime_factors.push(c);\n    }\n    *prime_factors.iter().max().unwrap()",
  "    let mut n = n;\n    let mut p = 2;\n    while n % p == 0 {\n        n /= p;\n\
    \    }\n    p += 1;\n    while n > 1 {\n        while n % p == 0 {\n         \
    \   n /= p;\n        }\n        p += 2;\n    }\n    p - 2", '    n / 2', "   \
    \ let mut n = n;\n    let mut m = 2;\n    while n > 1 {\n        while n % m ==\
    \ 0 {\n            n /= m;\n        }\n        m += 1;\n    }\n    m - 1", " \
    \   let mut k = n;\n    let mut largest_prime = 1;\n    while k % 2 == 0 {\n \
    \       largest_prime = 2;\n        k /= 2;\n    }\n    let mut i = 3;\n    while\
    \ i <= (k as f64).sqrt() as isize {\n        if k % i == 0 {\n            largest_prime\
    \ = i;\n            k /= i;\n        } else {\n            i += 2;\n        }\n\
    \    }\n    if k > 2 {\n        largest_prime = k;\n    }\n    largest_prime",
  "    let mut largest = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            n /= i;\n            largest = i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if n > largest {\n        largest\
    \ = n;\n    }\n    largest", "    let mut f = 2;\n    let mut n = n;\n    while\
    \ n > 1 {\n        if n % f == 0 {\n            n /= f;\n        } else {\n  \
    \          f += 1;\n        }\n    }\n    f", "    let mut largest = 0;\n    let\
    \ mut n = n;\n    while n % 2 == 0 {\n        largest = 2;\n        n /= 2;\n\
    \    }\n    let mut p = 3;\n    while n > 1 {\n        while n % p == 0 {\n  \
    \          largest = p;\n            n /= p;\n        }\n        p += 2;\n   \
    \ }\n    largest", '    factor_sum(n)', "    let mut n = n;\n    let mut prime\
    \ = 2;\n    let mut largest_prime = prime;\n    while n > 1 {\n        if n %\
    \ prime == 0 {\n            largest_prime = prime;\n            n /= prime;\n\
    \            while n % prime == 0 {\n                n /= prime;\n           \
    \ }\n        }\n        prime += 1;\n    }\n    largest_prime", "    let mut prime_factors\
    \ = get_prime_factors(n);\n    prime_factors.sort();\n    prime_factors.last().unwrap().clone()",
  "    let mut largest_prime_factor = 0;\n    let mut n = n;\n    for prime in sieve_of_eratosthenes(n)\
    \ {\n        while n % prime == 0 {\n            largest_prime_factor = prime;\n\
    \            n /= prime;\n        }\n    }\n    largest_prime_factor", "    let\
    \ mut x = n;\n    let mut i = 2;\n    let mut ret = 0;\n    while i * i <= x {\n\
    \        if x % i == 0 {\n            ret = i;\n            x /= i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    ret", "    for i in (2..).take_while(|&x|\
    \ x * x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n", "    let limit = (n as f64).sqrt() as isize;\n\
    \    let mut m = 2;\n    let mut factors = vec![];\n    while m <= limit {\n \
    \       if n % m == 0 {\n            factors.push(m);\n            n /= m;\n \
    \       } else {\n            m += 1;\n        }\n    }\n    factors.push(n);\n\
    \    *factors.iter().max().unwrap()", "    let mut i = 2;\n    let mut k = n;\n\
    \    while i * i <= k {\n        if k % i == 0 {\n            k /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    k", "    let mut n = n;\n\
    \    let mut max_factor = 1;\n    let mut factor = 2;\n    while n > 1 {\n   \
    \     while n % factor == 0 {\n            max_factor = factor;\n            n\
    \ /= factor;\n        }\n        factor += 1;\n    }\n    max_factor", "    let\
    \ mut n = n;\n    let mut p = 2;\n    while n % p == 0 {\n        n /= p;\n  \
    \  }\n    let mut p = 3;\n    while n > 1 {\n        while n % p == 0 {\n    \
    \        n /= p;\n        }\n        p += 2;\n    }\n    p - 2", "    let mut\
    \ candidate = 2;\n    let mut largest_factor = 1;\n    while candidate <= n {\n\
    \        if n % candidate == 0 {\n            largest_factor = candidate;\n  \
    \          while n % candidate == 0 {\n                n /= candidate;\n     \
    \       }\n        }\n        candidate += 1;\n    }\n    largest_factor", " \
    \   let mut n = n;\n    let mut d = 2;\n    while n > 1 {\n        while n % d\
    \ == 0 {\n            n /= d;\n        }\n        d += 1;\n    }\n    d - 1",
  '    (2..).filter(|&i| n % i == 0).find(|&i| is_prime(i)).unwrap()', "    let mut\
    \ cur = 2;\n    let mut largest = 1;\n    while cur * cur <= n {\n        if n\
    \ % cur == 0 {\n            largest = cur;\n            n /= cur;\n        } else\
    \ {\n            cur += 1;\n        }\n    }\n    if n > 1 {\n        n\n    }\
    \ else {\n        largest\n    }", "    let mut i = 2;\n    let mut largest_prime\
    \ = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            largest_prime\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    largest_prime", "    let (min, max) = (2, (n as f64).sqrt() as isize);\n\
    \    let factors = (min..max).filter(|&x| n % x == 0);\n    let mut primes = factors.filter(|&x|\
    \ is_prime(x));\n    let mut largest = primes.next().unwrap();\n    for p in primes\
    \ {\n        if p > largest {\n            largest = p;\n        }\n    }\n  \
    \  largest", '    primes_iter().take_while(|&i| i <= n).rev().find(|&i| n % i
    == 0).unwrap()', "    let mut remaining = n;\n    let mut i = 2;\n    while i\
    \ * i <= remaining {\n        if remaining % i == 0 {\n            remaining /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    remaining",
  "    let mut factor = 2;\n    let mut result = n;\n    while result > 1 {\n    \
    \    if result % factor == 0 {\n            result /= factor;\n        } else\
    \ {\n            factor += 1;\n        }\n    }\n    factor", "    let mut largest\
    \ = 1;\n    let mut factor = 2;\n    let mut num = n;\n    while num > 1 {\n \
    \       if num % factor == 0 {\n            largest = factor;\n            num\
    \ /= factor;\n            while num % factor == 0 {\n                num /= factor;\n\
    \            }\n        }\n        factor += 1;\n    }\n    largest", "    for\
    \ i in (2..).take_while(|&x| x <= n) {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i);\n        }\n    }\n    n", "    let mut largest_prime_factor\
    \ = 0;\n    for i in 2..=(n / 2) {\n        if n % i == 0 && is_prime(i) {\n \
    \           largest_prime_factor = i;\n        }\n    }\n    largest_prime_factor",
  "    let mut factors = prime_factors(n);\n    *factors.pop().unwrap()", "    if\
    \ is_prime(n) {\n        return n;\n    }\n\n    let max_factor = ((n as f64).sqrt().ceil()\
    \ as isize) + 1;\n    for i in 2..max_factor {\n        if n % i == 0 {\n    \
    \        return largest_prime_factor(n / i);\n        }\n    }\n\n    panic!(\"\
    Should have found a factor.\");", "    let mut n = n;\n    let mut largest_prime\
    \ = 2;\n    while n % 2 == 0 {\n        n /= 2;\n    }\n    let mut factor = 3;\n\
    \    while n > 1 {\n        while n % factor == 0 {\n            n /= factor;\n\
    \            largest_prime = factor;\n        }\n        factor += 2;\n    }\n\
    \    largest_prime", "    let mut n = n;\n    let mut prime = 2;\n    while n\
    \ % prime == 0 {\n        n /= prime;\n    }\n    prime += 1;\n    while n > 1\
    \ {\n        while n % prime == 0 {\n            n /= prime;\n        }\n    \
    \    prime += 2;\n    }\n    prime - 2", "    let mut prime = 1;\n    let mut\
    \ remaining = n;\n    for p in primes() {\n        if p > remaining {\n      \
    \      break;\n        }\n        if remaining % p == 0 {\n            remaining\
    \ /= p;\n            prime = p;\n        }\n    }\n    prime", "    let upper_bound\
    \ = isqrt(n);\n    let mut lpf = n;\n    for p in 2..upper_bound {\n        if\
    \ is_prime(p) && n % p == 0 {\n            lpf = p;\n        }\n    }\n    lpf",
  "    let mut x = n;\n    let mut f = 2;\n    while x != 1 {\n        while x % f\
    \ == 0 {\n            x /= f;\n        }\n        f += 1;\n    }\n    f - 1",
  "    let mut n = n;\n    let mut largest_prime = 2;\n    let mut trial_factor =\
    \ 2;\n    while n > 1 {\n        if n % trial_factor == 0 {\n            largest_prime\
    \ = trial_factor;\n            n /= trial_factor;\n            while n % trial_factor\
    \ == 0 {\n                n /= trial_factor;\n            }\n        }\n     \
    \   trial_factor += 1;\n    }\n    largest_prime", "    // TODO\n    n", "   \
    \ let mut n = n;\n    let mut prime = 2;\n    while n > 1 {\n        if n % prime\
    \ == 0 {\n            n /= prime;\n        } else {\n            prime += 1;\n\
    \        }\n    }\n    prime", "    let mut n = n;\n    for i in 2..n {\n    \
    \    if n % i == 0 {\n            n /= i;\n            while n % i == 0 {\n  \
    \              n /= i;\n            }\n        }\n    }\n    n", "    let (mut\
    \ n, mut factor) = (n, 2);\n    while n > 1 {\n        if n % factor == 0 {\n\
    \            n /= factor;\n        } else {\n            factor += 1;\n      \
    \  }\n    }\n    factor", "    // this function may return 2, 3, 5 or 7 if prime\
    \ number is given.\n    let mut prime = n;\n    while prime % 2 == 0 {\n     \
    \   prime /= 2;\n    }\n    while prime % 3 == 0 {\n        prime /= 3;\n    }\n\
    \    while prime % 5 == 0 {\n        prime /= 5;\n    }\n    while prime % 7 ==\
    \ 0 {\n        prime /= 7;\n    }\n    if prime > 7 {\n        for i in (11..=prime).step_by(2)\
    \ {\n            while prime % i == 0 {\n                prime /= i;\n       \
    \     }\n        }\n    }\n    prime"]
stop_tokens:
- "\n}"
