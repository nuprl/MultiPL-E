name: HumanEval_112_reverse_delete
language: rs
prompt: "/// Task\n/// We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n/// then check if the result\
  \ string is palindrome.\n/// A string is called palindrome if it reads the same\
  \ backward as forward.\n/// You should return a tuple containing the result string\
  \ and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
  abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s:\
  \ String, c: String) -> (String, bool) {\n"
tests: "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
  abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
  dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
  a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
  mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
completions: ['    (s, true)', "    let s: Vec<char> = s.chars().collect();\n    let\
    \ c: Vec<char> = c.chars().collect();\n    let mut result: Vec<char> = Vec::new();\n\
    \    let mut i = 0;\n    while i < s.len() {\n        if !c.contains(&s[i]) {\n\
    \            result.push(s[i]);\n        }\n        i += 1;\n    }\n    let mut\
    \ j = 0;\n    let mut k = result.len() - 1;\n    while j < k {\n        if result[j]\
    \ != result[k] {\n            return (result.into_iter().collect(), false);\n\
    \        }\n        j += 1;\n        k -= 1;\n    }\n    (result.into_iter().collect(),\
    \ true)", "    let s = s.chars().collect::<Vec<char>>();\n    let mut c = c.chars().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut delete = false;\n    for i in\
    \ s {\n        for j in &c {\n            if i == *j {\n                delete\
    \ = true;\n                break;\n            }\n        }\n        if !delete\
    \ {\n            result.push(i);\n        }\n        delete = false;\n    }\n\
    \    (result, is_palindrome(&result))", '    unimplemented!()', "    let mut result\
    \ = String::new();\n    let s_v: Vec<char> = s.chars().collect();\n    let c_v:\
    \ Vec<char> = c.chars().collect();\n    for i in s_v {\n        if !c_v.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    let result_v: Vec<char>\
    \ = result.chars().collect();\n    (result, result_v == result_v.iter().rev().collect())",
  "    let s_rev: String = s.chars().rev().collect();\n    let result = s_rev.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    (result, result == s_rev)", '    unimplemented!()',
  '    unimplemented!()', "    let mut res = String::new();\n    for char in s.chars()\
    \ {\n        if !c.contains(char) {\n            res.push(char);\n        }\n\
    \    }\n    let is_palindrome = res.chars().eq(res.chars().rev());\n    (res,\
    \ is_palindrome)", "    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char>\
    \ = c.chars().collect();\n    let s: String = s.into_iter().filter(|x| !c.contains(x)).collect();\n\
    \    let s: Vec<char> = s.chars().collect();\n    let mut s: Vec<char> = s.into_iter().rev().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    (s.into_iter().collect(), s == s.iter().rev().collect::<Vec<_>>())",
  '    unimplemented!();', "    let mut res = String::new();\n    for ch in s.chars()\
    \ {\n        if !c.contains(ch) {\n            res.push(ch);\n        }\n    }\n\
    \    let reversed: String = res.chars().rev().collect();\n    (res, res == reversed)",
  "    let mut result: String = s;\n    for i in c.chars() {\n        result = result.chars().filter(|&x|\
    \ x != i).collect();\n    }\n    (result, is_palindrome(&result))", '    unimplemented!()',
  "    let mut ret = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            ret.push(ch);\n        }\n    }\n    (ret, ret == ret.chars().rev().collect::<String>())",
  "    let mut new_string = String::new();\n    let mut is_palindrome = true;\n  \
    \  let mut chars_in_c = Vec::new();\n    let mut count_chars_in_c = 0;\n    for\
    \ ch in c.chars() {\n        chars_in_c.push(ch);\n        count_chars_in_c +=\
    \ 1;\n    }\n    for ch in s.chars() {\n        let mut is_in_c = false;\n   \
    \     for index in 0..count_chars_in_c {\n            if ch == chars_in_c[index]\
    \ {\n                is_in_c = true;\n                break;\n            }\n\
    \        }\n        if !is_in_c {\n            new_string.push(ch);\n        }\n\
    \    }\n    for index in 0..new_string.len() {\n        if new_string.chars().nth(index)\
    \ != new_string.chars().rev().nth(index) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (new_string, is_palindrome)", "   \
    \ let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let mut new_s: Vec<char> = Vec::new();\n    for i in s {\n        if !c.contains(&i)\
    \ {\n            new_s.push(i);\n        }\n    }\n    let new_s: String = new_s.into_iter().collect();\n\
    \    let len = new_s.len();\n    let new_s: Vec<char> = new_s.chars().collect();\n\
    \    for i in 0..len {\n        if new_s[i] != new_s[len - i - 1] {\n        \
    \    return (new_s.into_iter().collect(), false);\n        }\n    }\n    (new_s.into_iter().collect(),\
    \ true)", "    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> =\
    \ c.chars().collect();\n    let s = s.into_iter().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())", '    unimplemented!()', " \
    \   let mut result: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)"]
stop_tokens:
- "\n}"
