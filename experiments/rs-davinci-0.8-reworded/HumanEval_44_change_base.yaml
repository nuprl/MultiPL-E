name: HumanEval_44_change_base
language: rs
prompt: "/// Change numerical base of input number x to base.\n/// return string representation\
  \ after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8,\
  \ 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\"\
  )\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize,\
  \ base: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
  \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
  ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
  \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
  1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
  \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
  ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
  \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
  ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
completions: ["    let mut result = String::new();\n    let mut a = x;\n    while\
    \ a > 0 {\n        result.push(((a % base) + 48) as u8 as char);\n        a /=\
    \ base;\n    }\n    result.chars().rev().collect()", "    let mut res = String::new();\n\
    \    let mut num = x;\n    while num > 0 {\n        res.push((num % base + 48)\
    \ as u8 as char);\n        num /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut x = x;\n    let mut str = String::new();\n    while x > 0 {\n     \
    \   str.push_str(&(x % base).to_string());\n        x /= base;\n    }\n    str.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   res.push(((x % base) + 48) as u8 as char);\n        x /= base;\n    }\n  \
    \  res.chars().rev().collect()", "    if x == 0 {\n        return String::from(\"\
    0\");\n    }\n    let mut ans = String::new();\n    let mut x = x;\n    while\
    \ x > 0 {\n        ans = format!(\"{}{}\", x % base, ans);\n        x /= base;\n\
    \    }\n    ans", "    let v = Vec::new();\n    return change_base_helper(x, base,\
    \ v).iter().cloned().collect();", "    let mut result = String::new();\n    let\
    \ mut x = x;\n    while x > 0 {\n        result.push_str(&((x % base) as u8).to_string());\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut s = String::new();\n    while x > 0 {\n        s.push(((x\
    \ % base) + b'0') as char);\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut output = String::new();\n    let mut m = x;\n    while m > 0 {\n  \
    \      let rem = m % base;\n        m = m / base;\n        output.push_str(&rem.to_string());\n\
    \    }\n    output", "    let mut x = x;\n    let mut vec: Vec<char> = Vec::new();\n\
    \    while x > 0 {\n        vec.push((x % base + '0' as isize) as u8 as char);\n\
    \        x /= base;\n    }\n    vec.iter().rev().collect()", "    let mut x =\
    \ x;\n    let mut ans = String::new();\n    while x > 0 {\n        ans.push_str(&((x\
    \ % base) as u8).to_string());\n        x /= base;\n    }\n    ans.chars().rev().collect()",
  "    let mut x = x;\n    let mut output = String::new();\n    while x > 0 {\n  \
    \      output.push(((x % base) + '0' as isize) as u8 as char);\n        x /= base;\n\
    \    }\n    output.chars().rev().collect()", "    let mut result = String::new();\n\
    \    let mut r;\n    let mut tmp = x;\n    while tmp > 0 {\n        r = tmp %\
    \ base;\n        tmp = tmp / base;\n        result.push(r.to_string().chars().next().unwrap());\n\
    \    }\n    result.chars().rev().collect()", "    let mut x = x;\n    let mut\
    \ base_x = String::new();\n    while x > 0 {\n        base_x.push_str(&((x % base).to_string()));\n\
    \        x /= base;\n    }\n    base_x.chars().rev().collect()", "    let mut\
    \ res = String::new();\n    let mut x = x;\n    while x > 0 {\n        res.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    if x < base {\n        return x.to_string();\n    }\n\n    let mut x = x;\n\
    \    let mut s = String::new();\n    while x >= base {\n        s.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    s.push_str(&x.to_string());\n\
    \    s.chars().rev().collect()", "    let mut y = x;\n    let mut output = String::new();\n\
    \    while y > 0 {\n        let y = y % base;\n        let s = std::char::from_digit(y\
    \ as u32, base as u32);\n        output.push(s.unwrap());\n        y /= base;\n\
    \    }\n    output", "    let mut res = String::new();\n    let mut x = x;\n \
    \   while x != 0 {\n        res = format!(\"{}{}\", (x % base), res);\n      \
    \  x /= base;\n    }\n    res", "    let result = String::from(\"\");\n    String::from(\"\
    \")", "    let mut x = x;\n    let mut res = String::new();\n    while x > 0 {\n\
    \        res = format!(\"{}{}\", x % base, res);\n        x /= base;\n    }\n\
    \    res", "    let mut result = String::new();\n    let mut x = x;\n    while\
    \ x != 0 {\n        let remainder = x % base;\n        x = x / base;\n       \
    \ result.push_str(&remainder.to_string());\n    }\n    result", "    let mut x\
    \ = x;\n    let mut stack = Vec::new();\n    let mut result = String::new();\n\
    \    while x != 0 {\n        stack.push(x % base);\n        x /= base;\n    }\n\
    \    while !stack.is_empty() {\n        result.push_str(&stack.pop().unwrap().to_string());\n\
    \    }\n    result", "    let mut x = x;\n    let mut result = String::new();\n\
    \    while x > 0 {\n        let tmp = (x % base) as u8;\n        result.push(char::from(tmp));\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut result = String::new();\n    while x > 0 {\n        let\
    \ y = x % base;\n        x = x / base;\n        result.push(char::from(y + 48));\n\
    \    }\n    result", "    let mut x = x;\n    let mut res = \"\".to_string();\n\
    \    while x > 0 {\n        res = format!(\"{}{}\", x % base, res);\n        x\
    \ /= base;\n    }\n    res", "    let mut res = String::new();\n    let mut x\
    \ = x;\n    while x > 0 {\n        res = format!(\"{}{}\", res, (x % base).to_string());\n\
    \        x /= base;\n    }\n    res", "    let mut result = String::new();\n \
    \   let mut num = x;\n    while num != 0 {\n        let r = num % base;\n    \
    \    result.push_str(&r.to_string());\n        num /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    while x > 0 {\n  \
    \      result.push_str(&(x % base).to_string());\n        x /= base;\n    }\n\
    \    result.chars().rev().collect()", "    let mut result = String::new();\n \
    \   let mut x = x;\n    while x > 0 {\n        result.push_str(&format!(\"{}\"\
    , x % base));\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    if x == 0 {\n        return String::from(\"0\");\n    }\n    let mut result\
    \ = String::new();\n    let mut x = x;\n    while x > 0 {\n        result.push_str(&format!(\"\
    {}\", x % base));\n        x /= base;\n    }\n    result", "    let mut rem: isize\
    \ = x;\n    let mut result: String = String::new();\n    let mut q: isize;\n \
    \   let mut r: isize;\n    let mut s: String;\n    while rem > 0 {\n        q\
    \ = rem / base;\n        r = rem % base;\n        s = r.to_string();\n       \
    \ result.push_str(&s);\n        rem = q;\n    }\n    result", "    let mut result\
    \ = String::new();\n    let mut n = x;\n    while n != 0 {\n        let reminder\
    \ = n % base;\n        result.push(('0' as u8 + reminder as u8) as char);\n  \
    \      n = n / base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut result = String::new();\n    while x > 0 {\n        let\
    \ r = x % base;\n        result.push_str(&r.to_string());\n        x /= base;\n\
    \    }\n    result.chars().rev().collect()", "    if x == 0 {\n        return\
    \ String::from(\"0\");\n    }\n    let mut x = x;\n    let mut result = String::new();\n\
    \    while x > 0 {\n        result.push_str(&(x % base).to_string());\n      \
    \  x /= base;\n    }\n    // Reverse the result\n    result.chars().rev().collect()",
  "    if x < base {\n        return x.to_string();\n    }\n\n    let mut answer =\
    \ change_base(x / base, base);\n    let new_x = x % base;\n    answer.push_str(&new_x.to_string());\n\
    \    answer", "    let mut quo = x;\n    let mut remainder = 0;\n    let mut output\
    \ = String::new();\n    loop {\n        remainder = quo % base;\n        quo =\
    \ quo / base;\n        output.push_str(&remainder.to_string());\n        if quo\
    \ == 0 {\n            break;\n        }\n    }\n    output.chars().rev().collect()",
  "    let mut n = x;\n    let mut res = String::new();\n    while n != 0 {\n    \
    \    res.push((n % base + '0' as isize) as u8 as char);\n        n /= base;\n\
    \    }\n    res.chars().rev().collect()", "    if x / base == 0 {\n        return\
    \ format!(\"{}\", x % base);\n    } else {\n        return format!(\"{}{}\", change_base(x\
    \ / base, base), x % base);\n    }", "    let mut x = x;\n    let mut res = String::new();\n\
    \    while x != 0 {\n        res = format!(\"{}{}\", (x % base), res);\n     \
    \   x /= base;\n    }\n    if res.is_empty() {\n        res = String::from(\"\
    0\");\n    }\n    res", "    let mut result = String::new();\n    let mut x =\
    \ x;\n    while x > 0 {\n        result.push(((x % base) + 48) as u8 as char);\n\
    \        x /= base;\n    }\n    // reverse string\n    result.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x != 0 {\n    \
    \    res.push_str(&format!(\"{}\", x % base));\n        x /= base;\n    }\n  \
    \  res.chars().rev().collect()", "    let digits = std::iter::successors(Some(x),\
    \ |x| {\n        if *x > 0 {\n            Some((*x / base, (*x % base) as usize))\n\
    \        } else {\n            None\n        }\n    })\n        .collect::<Vec<_>>();\n\
    \    let digits_slice = digits.iter().rev().collect::<Vec<_>>();\n    let digits_str:\
    \ Vec<String> = digits_slice.iter().map(|&x| x.to_string()).collect();\n    digits_str.join(\"\
    \")", "    let mut result = String::new();\n    let mut y = x;\n    while y >\
    \ 0 {\n        result.push_str(&format!(\"{}\", y % base));\n        y /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut result = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        result.push_str(&((x % base) as\
    \ u8).to_string());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   res.push_str(&((x % base) as u8 + '0' as u8) as &str);\n        x /= base;\n\
    \    }\n    res.chars().rev().collect()", "    let mut binary = String::new();\n\
    \    let mut number = x;\n    let mut r = 0;\n    while number > 0 {\n       \
    \ r = number % base;\n        binary.push_str(&r.to_string());\n        number\
    \ = number / base;\n    }\n    binary.chars().rev().collect()", "    assert!(base\
    \ < 10);\n    let mut res = String::new();\n    let mut s = x;\n    while s >\
    \ 0 {\n        res.push(((s % base) + b'0') as char);\n        s /= base;\n  \
    \  }\n    res.chars().rev().collect()", "    let mut ans = \"\".to_string();\n\
    \    let mut x = x;\n    while x > 0 {\n        ans = format!(\"{}{}\", ans, x\
    \ % base);\n        x /= base;\n    }\n    ans", "    let mut x = x;\n    let\
    \ mut result = String::new();\n    while x > 0 {\n        let m = x % base;\n\
    \        x = x / base;\n        result.push_str(&format!(\"{}\", m));\n    }\n\
    \    result", "    let mut q = x;\n    let mut result = String::new();\n    let\
    \ mut r = 0;\n    while q != 0 {\n        r = q % base;\n        q = q / base;\n\
    \        let mut s = r.to_string();\n        result.insert_str(0, &s);\n    }\n\
    \    result", "    let mut x = x;\n    let mut ans = \"\".to_string();\n    while\
    \ x > 0 {\n        ans.push_str(&format!(\"{}\", x % base));\n        x /= base;\n\
    \    }\n    ans.chars().rev().collect()", "    if x < 0 {\n        panic!(\"Not\
    \ supported yet\");\n    }\n    let mut x = x;\n    let mut res = String::new();\n\
    \    while x > 0 {\n        res = (x % base).to_string() + &res;\n        x /=\
    \ base;\n    }\n    res", "    let mut result = String::new();\n    let mut y\
    \ = x;\n    while y > 0 {\n        result.push_str(&format!(\"{}\", y % base));\n\
    \        y /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut output: String = String::new();\n    while x > 0 {\n   \
    \     let x_mod = x % base;\n        let x_str = x_mod.to_string();\n        output.push_str(&x_str);\n\
    \        x = x / base;\n    }\n    output", "    if x < base {\n        return\
    \ format!(\"{}\", x);\n    }\n\n    let mut xx = x;\n    let mut result = String::new();\n\
    \    while xx > 0 {\n        let rem = xx % base;\n        xx = xx / base;\n \
    \       result.push_str(&format!(\"{}\", rem));\n    }\n    result.chars().rev().collect()",
  "    let mut y = x;\n    let mut remainder: isize;\n    let mut result = String::new();\n\
    \    while y > 0 {\n        remainder = y % base;\n        y = y / base;\n   \
    \     result.push_str(&remainder.to_string());\n    }\n    let result: String\
    \ = result.chars().rev().collect();\n    result", "    let mut x = x;\n    let\
    \ mut result = \"\".to_string();\n    loop {\n        let r = x % base;\n    \
    \    x = x / base;\n        result = r.to_string() + &result;\n        if x ==\
    \ 0 {\n            break;\n        }\n    }\n    result", "    let mut x = x;\n\
    \    let mut ans = String::new();\n    while x > 0 {\n        ans = ans + &((x\
    \ % base).to_string());\n        x /= base;\n    }\n    let mut result = String::new();\n\
    \    for c in ans.chars().rev() {\n        result.push(c);\n    }\n    result",
  "    let mut ans = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   ans.push_str(&(x % base).to_string());\n        x /= base;\n    }\n    ans.chars().rev().collect()",
  "    let mut ret = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   ret.push(((x % base) + b'0') as char);\n        x /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x > 0 {\n     \
    \   res.push((x % base + b'0') as char);\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut y = x;\n    let mut res = String::new();\n    while y > 0 {\n     \
    \   res.push_str(&((y % base).to_string()));\n        y /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   res.push(((x % base) + b'0') as char);\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    let mut digit = 0;\n\
    \    loop {\n        digit = x % base;\n        x = x / base;\n        res.push_str(&digit.to_string());\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    res.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut i = x;\n    while i > 0 {\n  \
    \      result.push_str(&(i % base).to_string());\n        i /= base;\n    }\n\
    \    result.chars().rev().collect()", "    let mut res = Vec::new();\n    let\
    \ mut num = x;\n    let mut modulo = 0;\n    let mut quotient = 0;\n    loop {\n\
    \        modulo = num % base;\n        quotient = num / base;\n        res.push(std::char::from_digit(modulo\
    \ as u32, base as u32).unwrap());\n        if quotient == 0 {\n            break;\n\
    \        }\n        num = quotient;\n    }\n    let mut res: String = res.into_iter().rev().collect();\n\
    \    res", "    let mut x = x;\n    let mut s = String::new();\n    while x >\
    \ 0 {\n        s.push(((x % base) + '0' as isize) as u8 as char);\n        x /=\
    \ base;\n    }\n    s.chars().rev().collect()", "    let mut x = x;\n    let mut\
    \ string = String::new();\n    while x != 0 {\n        string.push_str(&((x %\
    \ base).to_string()));\n        x /= base;\n    }\n    string.chars().rev().collect()",
  "    let mut x = x;\n    let mut digits = Vec::new();\n    while x > 0 {\n     \
    \   digits.push((x % base) as u8);\n        x /= base;\n    }\n    let answer:\
    \ String = digits.iter().rev().map(|x| (x + '0' as u8) as char).collect();\n \
    \   answer", "    if x == 0 {\n        return String::from(\"0\");\n    }\n  \
    \  let mut s = String::new();\n    let mut xx = x;\n    while xx > 0 {\n     \
    \   s.push(((xx % base) + 48) as u8 as char);\n        xx /= base;\n    }\n  \
    \  s.chars().rev().collect()", "    if x < base {\n        return x.to_string();\n\
    \    }\n    let mut x = x;\n    let mut out: String = String::new();\n    while\
    \ x > 0 {\n        out.push_str(&(x % base).to_string());\n        x /= base;\n\
    \    }\n    out.chars().rev().collect()", "    let mut x = x;\n    let mut ret\
    \ = String::new();\n    while x != 0 {\n        let remain = x % base;\n     \
    \   let remain = std::char::from_digit(remain as u32, base as u32).unwrap();\n\
    \        ret.push(remain);\n        x /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut x = x;\n    let mut str = String::new();\n    while x != 0 {\n    \
    \    let r = x % base;\n        str.push_str(&r.to_string());\n        x /= base;\n\
    \    }\n    str.chars().rev().collect()", "    let mut res = String::new();\n\
    \    let mut tmp = x;\n    let mut digit: isize;\n    let bases = vec!['0', '1',\
    \ '2', '3', '4', '5', '6', '7', '8', '9'];\n    while tmp > 0 {\n        digit\
    \ = tmp % base;\n        res.push(bases[digit as usize]);\n        tmp /= base;\n\
    \    }\n    res.chars().rev().collect()", "    let mut output = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        output.push_str(&((x % base).to_string()));\n\
    \        x /= base;\n    }\n    output.chars().rev().collect()", "    let mut\
    \ res = String::new();\n    let mut x = x;\n    while x > 0 {\n        res.push_str(&((x\
    \ % base) as u8).to_string());\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut x = x;\n    let mut s = String::new();\n    while x > 0 {\n       \
    \ s.push((x % base + 48) as u8 as char);\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x > 0 {\n     \
    \   res.push(((x % base) + 48) as u8 as char);\n        x /= base;\n    }\n  \
    \  res.chars().rev().collect()", "    let mut num: String = String::new();\n \
    \   let mut tmp = x;\n    while tmp != 0 {\n        let y = tmp % base;\n    \
    \    tmp = tmp / base;\n        num.push_str(&y.to_string());\n    }\n    num.chars().rev().collect()",
  "    if x < base {\n        return x.to_string();\n    }\n    let x = x as f64;\n\
    \    let base = base as f64;\n    let (x, y) = (x.floor(), x.fract());\n    format!(\"\
    {}{}\", change_base(x as isize, base as isize), y * base as f64)", "    let mut\
    \ x = x;\n    let mut res = String::new();\n    while x != 0 {\n        res =\
    \ (x % base).to_string() + &res;\n        x /= base;\n    }\n    res", "    //\
    \ TODO\n    \"\".to_string()", '    format!("{:b}", x)', "    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        let r = x % base;\n\
    \        result.push_str(&r.to_string());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut x = x;\n    let mut chars = Vec::new();\n    while x > 0 {\n      \
    \  chars.push(((x % base) + 48) as u8);\n        x /= base;\n    }\n    let s:\
    \ String = chars.iter().rev().map(|&c| c as char).collect();\n    return s;",
  "    let mut x = x;\n    let mut answer = String::new();\n    let mut num = 0;\n\
    \    while x > 0 {\n        num = x % base;\n        answer.push_str(&num.to_string());\n\
    \        x /= base;\n    }\n    answer.chars().rev().collect()", "    let mut\
    \ n = x;\n    let mut result = String::new();\n    while n > 0 {\n        result.push_str(&(n\
    \ % base).to_string());\n        n /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    let mut digit = 0;\n\
    \    loop {\n        digit = x % base;\n        x = x / base;\n        result.push_str(&digit.to_string());\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    result.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut quotient = x;\n    while quotient\
    \ != 0 {\n        let r = quotient % base;\n        quotient = quotient / base;\n\
    \        res.push_str(&r.to_string());\n    }\n    res.chars().rev().collect()",
  "    let mut digit = x % base;\n    let mut output = String::new();\n    let mut\
    \ x = x / base;\n    while x > 0 {\n        output = format!(\"{}{}\", digit,\
    \ output);\n        digit = x % base;\n        x = x / base;\n    }\n    format!(\"\
    {}{}\", digit, output)", "    let mut x = x;\n    let mut result = String::new();\n\
    \    loop {\n        let remainder = x % base;\n        x = x / base;\n      \
    \  result.push_str(&remainder.to_string());\n        if x == 0 {\n           \
    \ break;\n        }\n    }\n    result.chars().rev().collect()", "    let mut\
    \ string = String::new();\n    let mut n = x;\n    while n > 0 {\n        string.push(((n\
    \ % base) + '0' as isize) as u8 as char);\n        n /= base;\n    }\n    string.chars().rev().collect()",
  "    if x == 0 {\n        return String::from(\"0\");\n    }\n    let mut n = x;\n\
    \    let mut s = String::new();\n    while n > 0 {\n        s.push(((n % base)\
    \ + ('0' as isize)) as u8 as char);\n        n /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut num = x;\n    let mut div = base;\n    let mut change_base = String::new();\n\
    \    while num > 0 {\n        change_base.push_str(&((num % div).to_string()));\n\
    \        num /= div;\n    }\n    change_base.chars().rev().collect()", "    if\
    \ x == 0 {\n        return String::from(\"0\");\n    }\n    let mut x = x;\n \
    \   let mut ret = String::new();\n    while x > 0 {\n        ret.push_str(&((x\
    \ % base) as u8).to_string());\n        x /= base;\n    }\n    ret.chars().rev().collect()",
  "    if x == 0 {\n        String::from(\"0\")\n    } else {\n        let mut res\
    \ = String::new();\n        let mut d = x;\n        while d > 0 {\n          \
    \  res.push_str(&((d % base) as u8).to_string());\n            d /= base;\n  \
    \      }\n        res.chars().rev().collect()\n    }", "    let mut x = x;\n \
    \   let mut ans = String::new();\n    let mut d = 0;\n    while x > 0 {\n    \
    \    d = x % base;\n        x /= base;\n        ans.push_str(&d.to_string());\n\
    \    }\n    ans.chars().rev().collect()", "    let mut result = String::new();\n\
    \    let mut r = x;\n    while r > 0 {\n        result.push_str(&((r % base) as\
    \ u8 + b'0' as u8) as &str);\n        r /= base;\n    }\n    result.chars().rev().collect()",
  '    return format!("{:b}", x);', "    let mut ret = String::new();\n    let mut\
    \ x = x;\n    let mut y = base;\n    while x > 0 {\n        let (q, r) = x.div_rem(&y);\n\
    \        ret = format!(\"{}{}\", r, ret);\n        x = q;\n    }\n    ret", " \
    \   let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n    \
    \    res = format!(\"{}{}\", res, x % base);\n        x /= base;\n    }\n    res",
  "    let mut x = x;\n    let mut string = String::new();\n    while x > 0 {\n  \
    \      string.push(((x % base) + 48) as u8 as char);\n        x /= base;\n   \
    \ }\n    let mut string = string.chars().rev().collect::<String>();\n    if string.len()\
    \ == 0 {\n        string.push('0');\n    }\n    string", "    let mut x = x;\n\
    \    let mut ret = String::new();\n    let mut modulo = 0;\n    let mut base =\
    \ base;\n    loop {\n        modulo = x % base;\n        x = x / base;\n     \
    \   ret.push_str(&modulo.to_string());\n        if x == 0 {\n            break;\n\
    \        }\n    }\n    ret", "    let mut x = x;\n    let mut res = String::new();\n\
    \    while x > 0 {\n        res.push_str(&format!(\"{}\", x % base));\n      \
    \  x /= base;\n    }\n    res.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut ans = String::new();\n    while x > 0 {\n        ans = format!(\"\
    {}{}\", x % base, ans);\n        x /= base;\n    }\n    ans", "    let mut res\
    \ = String::new();\n    let mut x = x;\n    while x > 0 {\n        res.push((x\
    \ % base) as u8 + b'0');\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut y = x;\n    let mut res = String::new();\n    let mut digit;\n    while\
    \ y != 0 {\n        digit = y % base;\n        res.push_str(&digit.to_string());\n\
    \        y = y / base;\n    }\n    res.chars().rev().collect()", "    // Reminder:\
    \ The base of a number is determined by the number of symbols\n    // used to\
    \ represent it.\n    // For example, a decimal number can represent 100 different\
    \ values\n    // (from 0 to 99), and thus it has a base of 100.\n    // Numbers\
    \ that are commonly used include binary (base 2), octal (base 8),\n    // decimal\
    \ (base 10) and hexadecimal (base 16).\n    // Implement a function change_base(x,base)\
    \ that returns the string\n    // representation of x in base base.\n\n    //\
    \ divide x by base, append remainder to string representation\n    // stop when\
    \ x reaches 0\n    let mut x = x;\n    let mut new_base = String::new();\n   \
    \ loop {\n        let temp = x % base;\n        let temp_str = temp.to_string();\n\
    \        new_base.push_str(&temp_str);\n        x = x / base;\n        if x ==\
    \ 0 {\n            break;\n        }\n    }\n    new_base", "    let mut ans =\
    \ String::new();\n    let mut n = x;\n    while n != 0 {\n        ans.push_str(&format!(\"\
    {}\", n % base));\n        n /= base;\n    }\n    ans.chars().rev().collect()",
  "    assert!(base > 1 && base < 10);\n    let mut x = x;\n    let mut result = String::new();\n\
    \    while x > 0 {\n        result.push_str(&(x % base).to_string());\n      \
    \  x /= base;\n    }\n    result.chars().rev().collect()", "    let mut str_buf\
    \ = String::new();\n    let mut x = x;\n    while x > 0 {\n        str_buf.push_str(&((x\
    \ % base) as u8).to_string());\n        x /= base;\n    }\n    str_buf.chars().rev().collect()",
  "    assert!(2 <= base && base <= 10);\n    assert!(x >= 0);\n    if x == 0 {\n\
    \        return String::from(\"0\");\n    }\n    let mut ans = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        ans.push(((x % base) + '0' as\
    \ isize) as u8 as char);\n        x /= base;\n    }\n    ans = ans.chars().rev().collect();\n\
    \    ans", "    if x == 0 {\n        String::from(\"0\")\n    } else {\n     \
    \   let mut result = Vec::new();\n        let mut tmp = x;\n        while tmp\
    \ > 0 {\n            result.push((tmp % base) as u8);\n            tmp /= base;\n\
    \        }\n        result.iter().rev().map(|x| (*x as char).to_string()).collect()\n\
    \    }", "    let mut x = x;\n    let mut result = String::new();\n    loop {\n\
    \        if x == 0 {\n            break;\n        }\n        result.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut rest = x;\n    let mut quo = 0;\n\
    \    while rest > 0 {\n        quo = rest / base;\n        rest = rest % base;\n\
    \        res.push_str(&rest.to_string());\n        rest = quo;\n    }\n    res.chars().rev().collect()",
  "    assert!(base < 10);\n    let result: String = x\n        .to_string()\n   \
    \     .chars()\n        .filter_map(|c| match c {\n            '0' => Some('0'),\n\
    \            '1' => Some('1'),\n            '2' => Some('2'),\n            '3'\
    \ => Some('3'),\n            '4' => Some('4'),\n            '5' => Some('5'),\n\
    \            '6' => Some('6'),\n            '7' => Some('7'),\n            '8'\
    \ => Some('8'),\n            '9' => Some('9'),\n            _ => None,\n     \
    \   })\n        .collect();\n    if base == 2 {\n        return result;\n    }\n\
    \    let mut result_vec: Vec<char> = result.chars().collect();\n    for i in 0..result_vec.len()\
    \ {\n        if result_vec[i] == '2' {\n            result_vec[i] = char::from(base\
    \ + '0');\n        }\n    }\n    let mut final_result: String = result_vec.iter().collect();\n\
    \    let flag = false;\n    final_result", "    let mut x = x;\n    let mut res\
    \ = String::new();\n    while x != 0 {\n        res.push(((x % base) + 48) as\
    \ u8 as char);\n        x /= base;\n    }\n    res.chars().rev().collect()", " \
    \   let mut y = x;\n    let mut digits = Vec::new();\n    let mut remainder =\
    \ y % base;\n    digits.push(remainder);\n    y = y / base;\n    while y > 0 {\n\
    \        remainder = y % base;\n        digits.push(remainder);\n        y = y\
    \ / base;\n    }\n    let mut text = String::new();\n    for i in (0..digits.len()).rev()\
    \ {\n        text.push_str(&format!(\"{}\", digits[i]));\n    }\n    text", " \
    \   let mut x = x;\n    let mut result = String::new();\n    while x > 0 {\n \
    \       let remainder = x % base;\n        result.push_str(&remainder.to_string());\n\
    \        x = x / base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ res = String::new();\n    let mut x = x;\n    while x > 0 {\n        res.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut output = String::new();\n    let mut x = x;\n    while x > 0 {\n  \
    \      output.push_str(&(x % base).to_string());\n        x /= base;\n    }\n\
    \    output.chars().rev().collect()", "    let mut x = x;\n    let mut ret = String::new();\n\
    \    let mut tmp = String::new();\n    while x > 0 {\n        tmp = x % base.to_string();\n\
    \        x = x / base;\n        ret.push_str(&tmp);\n    }\n    ret", "    let\
    \ mut buf = String::new();\n    let mut num = x;\n    while num > 0 {\n      \
    \  buf.push_str(&format!(\"{}\", num % base));\n        num /= base;\n    }\n\
    \    buf.chars().rev().collect()", "    // FIXME: Implement change_base function.\n\
    \    let mut s = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   s.push((x % base + '0' as isize) as u8 as char);\n        x /= base;\n   \
    \ }\n    s.chars().rev().collect()", "    // let mut result = String::from(\"\"\
    );\n    // let mut curr = x;\n    // while curr > 0 {\n    //     let curr_digit\
    \ = curr % base;\n    //     result = format!(\"{}{}\", curr_digit, result);\n\
    \    //     curr = curr / base;\n    // }\n    // result\n    let mut result =\
    \ String::from(\"\");\n    let mut curr = x;\n    while curr > 0 {\n        let\
    \ curr_digit = curr % base;\n        result = format!(\"{}{}\", curr_digit, result);\n\
    \        curr = curr / base;\n    }\n    result", "    assert!(base < 10);\n \
    \   x.to_string()", "    let mut x = x;\n    let mut s = String::new();\n    let\
    \ chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    loop {\n  \
    \      if x == 0 {\n            break;\n        }\n        let a = x % base;\n\
    \        s.push(chars[a as usize]);\n        x = x / base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    while x > 0 {\n  \
    \      let m = x % base;\n        result.push(m.to_string().chars().next().unwrap());\n\
    \        x = x / base;\n    }\n    let mut result_chars: Vec<char> = result.chars().collect();\n\
    \    result_chars.reverse();\n    String::from_iter(result_chars)", "    let mut\
    \ s = String::new();\n    let mut x = x;\n    while x > 0 {\n        s.push_str(&format!(\"\
    {}\", x % base));\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    while x != 0 {\n \
    \       result.push(((x % base) + 0x30) as u8 as char);\n        x /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut re_val = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        re_val.push_str(&format!(\"{}\"\
    , x % base));\n        x /= base;\n    }\n    re_val.chars().rev().collect()",
  "    let mut result = Vec::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   result.push((x % base).to_string());\n        x /= base;\n    }\n    result.reverse();\n\
    \    result.join(\"\")", "    let mut res = String::new();\n    let mut x = x;\n\
    \    while x > 0 {\n        res.push(((x % base) + 48) as u8 as char);\n     \
    \   x /= base;\n    }\n    res.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut rem = 0;\n    let mut result = String::new();\n    let mut stack\
    \ = vec![];\n    let vec_num = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9'];\n    while x > 0 {\n        rem = x % base;\n        stack.push(vec_num[rem\
    \ as usize]);\n        x = x / base;\n    }\n    let mut i = stack.len();\n  \
    \  while i > 0 {\n        result.push(stack[i - 1]);\n        i -= 1;\n    }\n\
    \    result", "    let mut x = x;\n    let mut res = String::new();\n    while\
    \ x > 0 {\n        res.push_str(&(x % base).to_string());\n        x /= base;\n\
    \    }\n    res.chars().rev().collect()", "    let mut result = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        result.push(((x % base) + 48)\
    \ as u8 as char);\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   res.push_str(&((x % base) as u8).to_string());\n        x /= base;\n    }\n\
    \    res.chars().rev().collect()", "    let mut x = x;\n    let mut res = String::new();\n\
    \    while x > 0 {\n        res.push_str(&((x % base) as u8).to_string());\n \
    \       x /= base;\n    }\n    res.chars().rev().collect()", "    let mut result\
    \ = String::new();\n    let mut x = x;\n    while x > 0 {\n        result.push(((x\
    \ % base) + 48) as u8 as char);\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut x = x;\n    let mut out = String::new();\n    while x > 0 {\n     \
    \   out.push(((x % base) + b'0') as char);\n        x /= base;\n    }\n    out.chars().rev().collect()",
  "    // TODO\n    let mut ans = String::new();\n    let mut num = x;\n    while\
    \ num > 0 {\n        ans.push_str(&((num % base) as u8 + 48).to_string());\n \
    \       num /= base;\n    }\n    ans.chars().rev().collect()", "    let mut x\
    \ = x;\n    let mut result = String::new();\n    while x > 0 {\n        let digit\
    \ = (x % base) as u8;\n        x /= base;\n        result.push(char::from(digit\
    \ + 48));\n    }\n    result.chars().rev().collect()", "    let mut modulo: isize;\n\
    \    let mut result = String::new();\n    let mut num = x;\n    while num > 0\
    \ {\n        modulo = num % base;\n        num = num / base;\n        result.push_str(&modulo.to_string());\n\
    \    }\n    result", "    if x == 0 {\n        return String::from(\"0\");\n \
    \   }\n    let mut modulo = x;\n    let mut str = String::new();\n    while modulo\
    \ > 0 {\n        let value = modulo % base;\n        modulo = modulo / base;\n\
    \        str.push_str(&value.to_string());\n    }\n    str", "    let mut xx =\
    \ x;\n    let mut s = String::new();\n    while xx > 0 {\n        s.push_str(&format!(\"\
    {}\", xx % base));\n        xx /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x != 0 {\n    \
    \    res = (x % base).to_string() + &res;\n        x /= base;\n    }\n    res",
  "    let mut x_ = x;\n    let mut ans = String::new();\n    while x_ > 0 {\n   \
    \     ans.push(((x_ % base) + 48) as u8 as char);\n        x_ /= base;\n    }\n\
    \    ans.chars().rev().collect()", "    let mut result = String::new();\n    let\
    \ mut x = x;\n    let mut i = 0;\n    let mut d = 0;\n    let mut modulo = 0;\n\
    \    while i < x {\n        d = x / base;\n        modulo = x % base;\n      \
    \  result = format!(\"{}{}\", modulo, result);\n        x = d;\n        i += 1;\n\
    \    }\n    result", "    let mut result = String::new();\n    let mut value =\
    \ x;\n    while value > 0 {\n        let current_bit = value % base;\n       \
    \ value = value / base;\n        result.push_str(&current_bit.to_string());\n\
    \    }\n    result", "    let mut res = String::new();\n    let mut x = x;\n \
    \   while x > 0 {\n        res = format!(\"{}{}\", x % base, res);\n        x\
    \ /= base;\n    }\n    res", "    let mut stack = vec![];\n    let mut n = x;\n\
    \    let mut result = String::new();\n    loop {\n        let mut i = 0;\n   \
    \     loop {\n            if i * base > n {\n                stack.push(i - 1);\n\
    \                n -= (i - 1) * base;\n                break;\n            }\n\
    \            i += 1;\n        }\n        if n <= 0 {\n            break;\n   \
    \     }\n    }\n    while let Some(i) = stack.pop() {\n        result.push_str(&i.to_string());\n\
    \    }\n    result", "    let mut base_rep = String::new();\n    let mut current\
    \ = x;\n    while current != 0 {\n        let digit = current % base;\n      \
    \  current = current / base;\n        base_rep.push_str(&format!(\"{}\", digit));\n\
    \    }\n    base_rep", "    if x == 0 {\n        String::from(\"0\")\n    } else\
    \ {\n        let mut x = x;\n        let mut result = String::new();\n       \
    \ while x > 0 {\n            result.push_str(&(x % base).to_string());\n     \
    \       x /= base;\n        }\n        result.chars().rev().collect()\n    }",
  "    let mut result = String::new();\n    let mut num = x;\n    while num > 0 {\n\
    \        result.push_str(&format!(\"{}\", num % base));\n        num /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut x = x;\n    let mut\
    \ res = String::new();\n    while x > 0 {\n        res = format!(\"{}{}\", (x\
    \ % base), res);\n        x /= base;\n    }\n    res", "    let mut v = x;\n \
    \   let mut r = String::new();\n    while v > 0 {\n        r.push_str(&(v % base).to_string());\n\
    \        v /= base;\n    }\n    r.chars().rev().collect()", "    if x == 0 {\n\
    \        return String::from(\"0\");\n    }\n    let mut base_string = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        base_string.push_str(&format!(\"\
    {}\", x % base));\n        x /= base;\n    }\n    base_string.chars().rev().collect()",
  "    let mut s = String::new();\n    let mut x = x;\n    while x > 0 {\n       \
    \ s.push_str(&((x % base) as u8).to_string());\n        x /= base;\n    }\n  \
    \  s.chars().rev().collect()", "    if x < base {\n        // if x is less than\
    \ base, then return x directly.\n        return x.to_string();\n    }\n    //\
    \ else return recursively.\n    return change_base(x / base, base) + &(x % base).to_string();",
  "    let mut s = String::new();\n    let mut x = x;\n    while x > 0 {\n       \
    \ s.push_str(&(x % base).to_string());\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut xs = String::new();\n    while x > 0 {\n      \
    \  xs.push_str(&((x % base) as u8 + '0' as u8) as &str);\n        x /= base;\n\
    \    }\n    xs.chars().rev().collect()", "    let mut num = x;\n    let mut res\
    \ = String::new();\n    while num > 0 {\n        res.push_str(&((num % base) as\
    \ u8).to_string());\n        num /= base;\n    }\n    res.chars().rev().collect()",
  "    if x == 0 {\n        return String::from(\"0\");\n    }\n    let mut x = x;\n\
    \    let mut ret = String::new();\n    while x > 0 {\n        ret.push(((x % base)\
    \ + 48) as u8 as char);\n        x /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x > 0 {\n     \
    \   res.push(((x % base) + 48) as u8 as char);\n        x /= base;\n    }\n  \
    \  res.chars().rev().collect()", "    if x == 0 {\n        return String::from(\"\
    0\");\n    }\n    let mut result = String::new();\n    let mut x = x;\n    while\
    \ x > 0 {\n        result.push_str(&((x % base).to_string()));\n        x /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut s = String::new();\n\
    \    let mut number = x;\n    while number > 0 {\n        s.push_str(&(number\
    \ % base).to_string());\n        number /= base;\n    }\n    s.chars().rev().collect()",
  "    // TODO\n    String::from(\"\")", "    let mut x = x;\n    let mut output =\
    \ String::new();\n    while x != 0 {\n        let mut r = x % base;\n        x\
    \ = x / base;\n        output.push_str(&r.to_string());\n    }\n    output", " \
    \   let mut x = x;\n    let mut res = String::new();\n    while x != 0 {\n   \
    \     res.push(((x % base) + b'0') as char);\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    while x != 0 {\n \
    \       let digit = x % base;\n        x = x / base;\n        result.push_str(&digit.to_string());\n\
    \    }\n    result", "    let mut result = String::new();\n    let mut remainder:\
    \ isize;\n    let mut n = x;\n    while n != 0 {\n        remainder = n % base;\n\
    \        n = n / base;\n        result.push_str(&remainder.to_string());\n   \
    \ }\n    // reverse the string\n    result.chars().rev().collect()", "    let\
    \ mut result = String::new();\n    let mut x = x;\n    while x > 0 {\n       \
    \ result.push_str(&(x % base).to_string());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut ret = String::new();\n    let mut x = x;\n    if x == 0 {\n       \
    \ ret.push('0');\n        return ret;\n    }\n    while x > 0 {\n        ret.push(((x\
    \ % base) + '0' as isize) as u8 as char);\n        x /= base;\n    }\n    ret\
    \ = ret.chars().rev().collect();\n    ret", "    let mut q = x;\n    let mut r\
    \ = 0;\n    let mut result = String::new();\n    while q > 0 {\n        r = q\
    \ % base;\n        q = q / base;\n        result.push_str(&r.to_string());\n \
    \   }\n    result.chars().rev().collect()", "    let mut digits = Vec::new();\n\
    \    let mut temp = x;\n    while temp > 0 {\n        digits.push(temp % base);\n\
    \        temp /= base;\n    }\n    let mut s = String::new();\n    for d in digits.iter().rev()\
    \ {\n        s.push(char::from_digit(*d as u32, base as u32).unwrap());\n    }\n\
    \    s", "    let mut output = String::new();\n    let mut x = x;\n    while x\
    \ != 0 {\n        output.push_str(format!(\"{}\", x % base).as_str());\n     \
    \   x /= base;\n    }\n    output.chars().rev().collect()", "    if x <= 0 {\n\
    \        return String::from(\"0\");\n    }\n\n    let mut digits = Vec::new();\n\
    \    let mut y = x;\n    while y > 0 {\n        digits.push(y % base);\n     \
    \   y /= base;\n    }\n\n    return digits.iter().rev().map(|x| x.to_string()).collect();",
  "    let mut x = x;\n    let mut result = String::new();\n    while x > 0 {\n  \
    \      let remainder = x % base;\n        result.push_str(&remainder.to_string());\n\
    \        x = x / base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ y = x;\n    let mut s = String::new();\n    while y > 0 {\n        s.push_str(&((y\
    \ % base).to_string()));\n        y /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut x = x;\n    let mut ret = String::new();\n    while x > 0 {\n     \
    \   ret.push_str(&format!(\"{}\", x % base));\n        x /= base;\n    }\n   \
    \ ret.chars().rev().collect()", "    if x == 0 {\n        return String::from(\"\
    0\");\n    }\n    let mut result = String::new();\n    let mut x = x;\n    while\
    \ x > 0 {\n        result.push_str(&format!(\"{}\", x % base));\n        x /=\
    \ base;\n    }\n    result.chars().rev().collect()", "    let mut x = x;\n   \
    \ let mut ret = String::new();\n    while x > 0 {\n        ret = ((x % base) as\
    \ u8 + ('0' as u8)).encode_utf8().collect::<String>() + &ret;\n        x /= base;\n\
    \    }\n    ret", "    assert!(base <= 10);\n    let mut ans = String::new();\n\
    \    let mut num = x;\n    while num > 0 {\n        ans.push_str(&(num % base).to_string());\n\
    \        num /= base;\n    }\n    ans.chars().rev().collect()", "    if x == 0\
    \ {\n        return String::from(\"0\");\n    }\n    let mut x = x;\n    let mut\
    \ res = String::new();\n    while x > 0 {\n        res = format!(\"{}{}\", x %\
    \ base, res);\n        x /= base;\n    }\n    res", "    let mut result = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        result.push_str(format!(\"{}\"\
    , x % base).as_str());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    assert!(base > 1);\n    let mut x = x;\n    let mut s = String::new();\n  \
    \  while x > 0 {\n        s.push(((x % base) + 48) as u8 as char);\n        x\
    \ /= base;\n    }\n    s.chars().rev().collect()", "    let mut num = x;\n   \
    \ let mut result = String::new();\n    while num > 0 {\n        let digit = num\
    \ % base;\n        num = num / base;\n        result.push_str(&digit.to_string());\n\
    \    }\n    result", "    let mut x = x;\n    let mut rs = String::new();\n  \
    \  while x > 0 {\n        let y = x % base;\n        rs.push(y.to_string().chars().next().unwrap());\n\
    \        x = x / base;\n    }\n    return rs.chars().rev().collect();", "    let\
    \ mut x = x;\n    let mut ans = String::new();\n    while x > 0 {\n        ans.push_str(&((x\
    \ % base) as u8).to_string());\n        x /= base;\n    }\n    ans.chars().rev().collect()",
  "    let mut x_i = x;\n    let mut y_str = String::new();\n    let base_str = ['0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    while x_i > 0 {\n       \
    \ let last_digit = x_i % base;\n        x_i = x_i / base;\n        y_str.push(base_str[last_digit\
    \ as usize]);\n    }\n    y_str", "    let mut num = x;\n    let mut output =\
    \ String::new();\n    while num != 0 {\n        let remainder = num % base;\n\
    \        output.push_str(&remainder.to_string());\n        num = num / base;\n\
    \    }\n    let x = output.chars().rev().collect::<String>();\n    x", "    match\
    \ x {\n        0 => String::from(\"0\"),\n        _ => int_to_base(x, base),\n\
    \    }", "    let mut n = x;\n    let mut result = String::new();\n    let mut\
    \ digit;\n    while n > 0 {\n        digit = n % base;\n        n = n / base;\n\
    \        result.push_str(&digit.to_string());\n    }\n    result", "    let mut\
    \ x = x;\n    let mut output = String::new();\n    while x > 0 {\n        let\
    \ digit = x % base;\n        x = x / base;\n        output.push_str(&format!(\"\
    {}\", digit));\n    }\n    output", "    let mut res = String::new();\n    let\
    \ mut number = x;\n    while number > 0 {\n        res.push_str(&format!(\"{}\"\
    , number % base));\n        number /= base;\n    }\n    res.chars().rev().collect()",
  '    format!("{:b}", x)', "    let mut n = x;\n    let mut s = String::new();\n\
    \    let n_max = n as usize;\n    for i in 0..n_max {\n        s.push_str(&format!(\"\
    {}\", n % base));\n        n /= base;\n    }\n    // convert to decimal\n    s",
  "    let mut new_num = String::new();\n    let mut num = x;\n    while num > 0 {\n\
    \        new_num.push_str(&(num % base).to_string());\n        num /= base;\n\
    \    }\n    new_num.chars().rev().collect()", "    let mut x = x;\n    let mut\
    \ converted = String::new();\n    while x != 0 {\n        converted.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    converted", "    let mut\
    \ x = x;\n    let mut res = \"\".to_string();\n    while x > 0 {\n        res\
    \ = (x % base).to_string() + &res;\n        x /= base;\n    }\n    res"]
stop_tokens:
- "\n}"
