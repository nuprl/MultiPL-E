name: HumanEval_118_get_closest_vowel
language: rs
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    let word = word.as_bytes();\n    for\
    \ (i, &c) in word.iter().enumerate().rev() {\n        let c = c as char;\n   \
    \     let next = *word.get(i + 1).unwrap_or(&(b' '));\n        let prev = *word.get(i\
    \ - 1).unwrap_or(&(b' '));\n        if (prev as char).is_ascii_lowercase() &&\
    \ !vowels.contains(&prev as char) &&\n            (next as char).is_ascii_lowercase()\
    \ && !vowels.contains(&next as char) {\n            return c.to_string();\n  \
    \      }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbh170_p1.rs:22:68\n   |\n\
    22 |         if (prev as char).is_ascii_lowercase() && !vowels.contains(&prev\
    \ as char) &&\n   |                                                          \
    \          ^^^^^^^^^^^^^\n   |                                               \
    \                     |\n   |                                                \
    \                    expected `&char`, found `char`\n   |                    \
    \                                                help: consider borrowing here:\
    \ `&(&prev as char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbh170_p1.rs:23:69\n\
    \   |\n23 |             (next as char).is_ascii_lowercase() && !vowels.contains(&next\
    \ as char) {\n   |                                                           \
    \          ^^^^^^^^^^^^^\n   |                                               \
    \                      |\n   |                                               \
    \                      expected `&char`, found `char`\n   |                  \
    \                                                   help: consider borrowing here:\
    \ `&(&next as char)`\n\nerror[E0606]: casting `&u8` as `char` is invalid\n  -->\
    \ /tmp/tmpbh170_p1.rs:22:68\n   |\n22 |         if (prev as char).is_ascii_lowercase()\
    \ && !vowels.contains(&prev as char) &&\n   |                                \
    \                                    -----^^^^^^^^\n   |                     \
    \                                               |\n   |                      \
    \                                              cannot cast `&u8` as `char`\n \
    \  |                                                                    help:\
    \ dereference the expression: `*&prev`\n\nerror[E0606]: casting `&u8` as `char`\
    \ is invalid\n  --> /tmp/tmpbh170_p1.rs:23:69\n   |\n23 |             (next as\
    \ char).is_ascii_lowercase() && !vowels.contains(&next as char) {\n   |      \
    \                                                               -----^^^^^^^^\n\
    \   |                                                                     |\n\
    \   |                                                              "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = ['a', 'e', 'i', 'o', 'u'];\n    let reversed = word.chars().rev().collect::<String>();\n\
    \    for (i, c) in reversed.char_indices() {\n        if vowels.contains(&c) {\n\
    \            if i < word.len() - 1 {\n                return word[(word.len()\
    \ - i - 1)..].chars().take(1).collect();\n            }\n        }\n    }\n  \
    \  String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpv33j7v0f.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut chars = word.chars().rev();\n    let mut found = false;\n    let mut last_consonant\
    \ = '\\0';\n    let mut last_vowel = '\\0';\n    while let Some(c) = chars.next()\
    \ {\n        if !found {\n            if is_vowel(c) {\n                last_vowel\
    \ = c;\n            } else {\n                last_consonant = c;\n          \
    \      found = true;\n            }\n        } else {\n            if is_vowel(c)\
    \ {\n                return last_vowel.to_string();\n            } else {\n  \
    \              last_consonant = c;\n            }\n        }\n    }\n    return\
    \ String::new();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc90zrzzq.rs:22:16\n\
    \   |\n22 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpc90zrzzq.rs:29:16\n   |\n29 |             if is_vowel(c) {\n  \
    \ |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut last_consonant_position\
    \ = 0;\n    let mut first_vowel_position = 0;\n    let mut found_vowel = false;\n\
    \    let mut found_first_vowel = false;\n    let mut found_second_vowel = false;\n\
    \    let mut second_vowel_position = 0;\n    let mut first_vowel_character = \"\
    \";\n    let mut second_vowel_character = \"\";\n    let mut counter = 0;\n  \
    \  let mut closest_vowel = \"\";\n    let characters: Vec<char> = word.chars().collect();\n\
    \    let words_len = characters.len();\n    for character in characters {\n  \
    \      if vowels.contains(&character.to_string().as_str()) {\n            if !found_first_vowel\
    \ {\n                first_vowel_position = counter;\n                first_vowel_character\
    \ = character.to_string().as_str();\n                found_first_vowel = true;\n\
    \            } else if found_first_vowel && !found_second_vowel {\n          \
    \      second_vowel_position = counter;\n                second_vowel_character\
    \ = character.to_string().as_str();\n                found_second_vowel = true;\n\
    \            }\n        } else {\n            if found_first_vowel && !found_second_vowel\
    \ {\n                last_consonant_position = counter;\n            }\n     \
    \   }\n        counter += 1;\n    }\n    if last_consonant_position < words_len\
    \ && first_vowel_position < words_len {\n        found_vowel = true;\n    }\n\
    \    if found_vowel {\n        if found_second_vowel {\n            if (second_vowel_position\
    \ - last_consonant_position) < (first_vowel_position - last_consonant_position)\
    \ {\n                closest_vowel = second_vowel_character;\n            } else\
    \ {\n                closest_vow\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwc3z__ei.rs:73:3\n\
    \   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n50 |     if found_vowel\
    \ {\n   |                    - unclosed delimiter\n51 |         if found_second_vowel\
    \ {\n   |                               - unclosed delimiter\n...\n54 |      \
    \       } else {\n   |                    - this delimiter might not be properly\
    \ closed...\n55 |                 closest_vow\n56 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n73 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `closest_vow` in this scope\n  --> /tmp/tmpwc3z__ei.rs:55:17\n\
    \   |\n55 |                 closest_vow\n   |                 ^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `closest_vowel`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwc3z__ei.rs:51:31\n   |\n51 |           if found_second_vowel\
    \ {\n   |  _______________________________^\n52 | |             if (second_vowel_position\
    \ - last_consonant_position) < (first_vowel_position - last_consonant_position)\
    \ {\n53 | |                 closest_vowel = second_vowel_character;\n54 | |  \
    \           } else {\n...  |\n72 | |     assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n73 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let chars: Vec<char> = word.chars().collect();\n\
    \    let mut result = None;\n    let mut consonant_count = 0;\n    for i in (0..chars.len()).rev()\
    \ {\n        if vowels.contains(&chars[i]) {\n            if consonant_count ==\
    \ 1 {\n                result = Some(chars[i]);\n                break;\n    \
    \        }\n            consonant_count = 0;\n        } else {\n            consonant_count\
    \ += 1;\n        }\n    }\n    match result {\n        Some(vowel) => vowel.to_string(),\n\
    \        None => String::from(\"\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmppzyoo1kz.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word_chars: Vec<char> = word.chars().collect();\n    let rev_word_chars: Vec<char>\
    \ = word_chars.iter().rev().cloned().collect();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n    let mut closest_vowel\
    \ = String::new();\n    for c in rev_word_chars {\n        if vowels.contains(&c)\
    \ {\n            result.push(c);\n        } else {\n            if !result.is_empty()\
    \ {\n                closest_vowel = result.chars().next().unwrap().to_string();\n\
    \                break;\n            }\n        }\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpab1pxf14.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6t2yrjfz.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = String::from(\"aeiouAEIOU\");\n    let mut found = String::from(\"\"\
    );\n    let mut left = 0;\n    let mut right = 0;\n    let mut result = String::from(\"\
    \");\n    let mut to_consonant = 0;\n    for c in word.chars() {\n        if vowels.contains(c)\
    \ {\n            found = c.to_string();\n            left = right;\n         \
    \   to_consonant = 0;\n        } else {\n            if to_consonant == 0 {\n\
    \                result = found.clone();\n            }\n            to_consonant\
    \ += 1;\n        }\n        right += 1;\n    }\n    if to_consonant == 0 {\n \
    \       result = found.clone();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpcy82f2xr.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmputdqafjy.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ unimplemented!()\n    // return empty string if we didn't find vowel\n    let\
    \ mut res = String::from(\"\");\n    // check if word is empty string\n    if\
    \ word.is_empty() {\n        return res;\n    }\n    // list of vowels\n    let\
    \ vowels = String::from(\"AEIOUaeiou\");\n    // list of consonants\n    let consonants\
    \ = String::from(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\");\n    // take\
    \ word len\n    let wlen = word.len();\n    // find first vowel index\n    let\
    \ first_vowel_index = word.find(|c: char| vowels.contains(c));\n    // if there\
    \ is no vowel, return empty string\n    if first_vowel_index == None {\n     \
    \   return res;\n    }\n    // take last vowel index\n    let last_vowel_index\
    \ = word.rfind(|c: char| vowels.contains(c));\n    // if word is vowel, return\
    \ empty string\n    if first_vowel_index == last_vowel_index {\n        return\
    \ res;\n    }\n    // convert first_vowel_index to Option<usize>\n    let first_vowel_index\
    \ = first_vowel_index.unwrap();\n    // iterate from last vowel index to first\
    \ vowel index\n    for (i,c) in word.chars().enumerate().skip(last_vowel_index.unwrap()).take(wlen)\
    \ {\n        // if current char is vowel\n        if vowels.contains(c) {\n  \
    \          // check if previous char is consonant\n            if consonants.contains(word.chars().nth(i-1).unwrap())\
    \ {\n                // set res to current char\n                res = c.to_string();\n\
    \                // break the loop\n                break;\n            }\n  \
    \      }\n    }\n    // return closest vowel\n    res\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpcqnj7hen.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ reverse_word = word.chars().rev().collect::<String>();\n    let vowels = String::from(\"\
    aeiouAEIOU\");\n    let mut result = String::from(\"\");\n    let mut pre_vowel\
    \ = false;\n    for ch in reverse_word.chars() {\n        if vowels.contains(ch)\
    \ {\n            if pre_vowel {\n                return String::from(\"\");\n\
    \            } else {\n                result.push(ch);\n                pre_vowel\
    \ = true;\n            }\n        } else {\n            pre_vowel = false;\n \
    \       }\n    }\n    result.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ou\"`,\n right: `\"u\"`', /tmp/tmpooushrth.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.chars().collect::<Vec<char>>();\n    let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    let mut result = \"\".to_string();\n    let mut i = word.len()\
    \ - 1;\n    let mut j = 0;\n    for _ in 0..word.len() {\n        if !vowels.contains(&word[i])\
    \ {\n            j += 1;\n            i -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if j == word.len() {\n        return result;\n    }\n \
    \   let mut k = word.len() - 1;\n    for _ in j..word.len() {\n        if !vowels.contains(&word[k])\
    \ {\n            result.push(word[k]);\n            k -= 1;\n        } else {\n\
    \            break;\n        }\n    }\n    result.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"rt\"`,\n right: `\"u\"`', /tmp/tmpqvsjnx4a.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P',\
    \ 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'];\n    let vowels = vec!['A', 'E',\
    \ 'I', 'O', 'U'];\n    let mut i = word.len() - 1;\n    let mut result = String::new();\n\
    \    while i > 0 {\n        let mut char_to_compare = word.chars().nth(i).unwrap();\n\
    \        if char_to_compare.is_uppercase() {\n            char_to_compare = char_to_compare.to_lowercase().next().unwrap();\n\
    \        }\n        if consonants.contains(&char_to_compare) {\n            if\
    \ i < word.len() - 1 {\n                let mut next_char = word.chars().nth(i\
    \ + 1).unwrap();\n                if next_char.is_uppercase() {\n            \
    \        next_char = next_char.to_lowercase().next().unwrap();\n             \
    \   }\n                if vowels.contains(&next_char) {\n                    result\
    \ = next_char.to_string();\n                    break;\n                }\n  \
    \          }\n        }\n        i -= 1;\n    }\n    if i == 0 {\n        result\
    \ = String::new();\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp3pawsks_.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let letters: Vec<char> = word.chars().collect();\n\
    \    for i in 0..letters.len() - 1 {\n        let prev = letters[i];\n       \
    \ let next = letters[i + 1];\n        if vowels.contains(&prev) && vowels.contains(&next)\
    \ {\n            return prev.to_string();\n        }\n    }\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpioecv3l9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ We will go through all the characters in the given string.\n    // If we encounter\
    \ a vowel, we will search backwards until we find a consonant.\n    // If the\
    \ consonant is followed by another consonant, then the vowel is a valid one.\n\
    \    let mut found_vowel = false;\n    let mut valid_vowel = String::new();\n\
    \    for character in word.chars() {\n        if !found_vowel {\n            if\
    \ character == 'a' || character == 'e' || character == 'i' || character == 'o'\
    \ || character == 'u' {\n                found_vowel = true;\n               \
    \ valid_vowel = character.to_string();\n            }\n        } else {\n    \
    \        if character != 'a' && character != 'e' && character != 'i' && character\
    \ != 'o' && character != 'u' {\n                return valid_vowel;\n        \
    \    } else {\n                found_vowel = false;\n            }\n        }\n\
    \    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpft1tdwe9.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.chars().collect::<Vec<char>>();\n    for (i, _) in word.iter().enumerate().rev()\
    \ {\n        if i > 0 && i < word.len() - 1 && !is_vowel(word[i - 1]) && !is_vowel(word[i\
    \ + 1]) && is_vowel(word[i]) {\n            return word[i].to_string();\n    \
    \    }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1gh0ki77.rs:18:44\n\
    \   |\n18 |         if i > 0 && i < word.len() - 1 && !is_vowel(word[i - 1]) &&\
    \ !is_vowel(word[i + 1]) && is_vowel(word[i]) {\n   |                        \
    \                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmp1gh0ki77.rs:18:70\n  \
    \ |\n18 |         if i > 0 && i < word.len() - 1 && !is_vowel(word[i - 1]) &&\
    \ !is_vowel(word[i + 1]) && is_vowel(word[i]) {\n   |                        \
    \                                              ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1gh0ki77.rs:18:95\n\
    \   |\n18 |         if i > 0 && i < word.len() - 1 && !is_vowel(word[i - 1]) &&\
    \ !is_vowel(word[i + 1]) && is_vowel(word[i]) {\n   |                        \
    \                                                                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n\tlet\
    \ vowels = String::from(\"AEIOUaeiou\");\n\tlet chars: Vec<char> = word.chars().collect();\n\
    \tlet mut prev = ' ';\n\tlet mut vowel = ' ';\n\tfor i in (0..chars.len()).rev()\
    \ {\n\t\tlet current = chars[i];\n\t\tif vowels.contains(current) {\n\t\t\tvowel\
    \ = current;\n\t\t} else if vowel != ' ' {\n\t\t\treturn vowel.to_string();\n\t\
    \t}\n\t\tprev = current;\n\t}\n\tString::from(\"\")\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp_himljja.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Implement the function here\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpeetsovsa.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut distance = 1000000;\n    let mut closest_vowel = String::from(\"\");\n \
    \   let word_vec: Vec<char> = word.chars().collect();\n    for i in 0..word_vec.len()\
    \ {\n        if is_vowel(word_vec[i]) {\n            for j in (i + 1)..word_vec.len()\
    \ {\n                if is_vowel(word_vec[j]) {\n                    if j - i\
    \ < distance {\n                        distance = j - i;\n                  \
    \      closest_vowel = word_vec[i].to_string();\n                    }\n     \
    \               break;\n                }\n            }\n        }\n    }\n \
    \   closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpy92055hv.rs:20:12\n\
    \   |\n20 |         if is_vowel(word_vec[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpy92055hv.rs:22:20\n   |\n22 |                 if is_vowel(word_vec[j])\
    \ {\n   |                    ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"\
    yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"\
    FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"\
    ))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n\
    /// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let\
    \ mut pos = word.len();\n    let mut found = String::new();\n    while pos > 0\
    \ {\n        let char = word.chars().nth(pos - 1).unwrap();\n        if is_vowel(char)\
    \ {\n            found = char.to_string();\n            break;\n        }\n  \
    \      pos -= 1;\n    }\n    if pos > 0 {\n        let char = word.chars().nth(pos\
    \ - 1).unwrap();\n        if !is_vowel(char) {\n            found\n        } else\
    \ {\n            String::new()\n        }\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmprlp524ps.rs:20:12\n\
    \   |\n20 |         if is_vowel(char) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmprlp524ps.rs:28:13\n   |\n28 |         if !is_vowel(char) {\n  \
    \ |             ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
