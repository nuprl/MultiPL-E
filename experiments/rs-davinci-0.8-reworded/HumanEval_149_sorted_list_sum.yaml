name: HumanEval_149_sorted_list_sum
language: rs
prompt: "/// Write a function that accepts a vector of strings as a parameter,\n///\
  \ deletes the strings that have odd lengths from it,\n/// and returns the resulted\
  \ vector with a sorted order,\n/// The vector is always a vector of strings and\
  \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
  \ of the vector should be ascending by length of each word, and you\n/// should\
  \ return the vector sorted by that rule.\n/// If two words have the same length,\
  \ sort the vector alphabetically.\n/// The function should return a vector of strings\
  \ in sorted order.\n/// You may assume that all words will have the same length.\n\
  /// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"\
  ), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
  ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n/// vec![String::from(\"\
  ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
  aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n\
  \    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"AI\"), String::from(\"\
  asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"), String::from(\"asdf\"\
  ), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"d\"\
  ), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
  \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
  abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
  )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"),\
  \ String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
  au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
  ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
  a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"aaaa\"\
  ), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"\
  cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")]);\n\
  }\n"
completions: ['    unimplemented!();', "    let mut lst: Vec<String> = lst.into_iter().collect();\n\
    \    lst.sort_by(|a, b| {\n        match a.len().cmp(&b.len()) {\n           \
    \ Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ lst", "    lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect::<Vec<String>>()",
  "    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    lst.dedup();\n\
    \    lst", "    let mut result: Vec<String> = vec![];\n    for i in lst {\n  \
    \      if i.len() % 2 == 0 {\n            result.push(i);\n        }\n    }\n\
    \    result.sort();\n    result", "    fn sorted_list_sum_rec(lst: Vec<String>,\
    \ acc: Vec<String>) -> Vec<String> {\n        match lst.len() {\n            0\
    \ => acc,\n            1 => {\n                if lst[0].len() % 2 == 0 {\n  \
    \                  let mut tmp = acc;\n                    tmp.push(lst[0].clone());\n\
    \                    return tmp;\n                }\n                acc\n   \
    \         }\n            _ => {\n                let (fst, rest) = lst.split_at(1);\n\
    \                if fst[0].len() % 2 == 0 {\n                    let mut tmp =\
    \ acc;\n                    tmp.push(fst[0].clone());\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ tmp)\n                } else {\n                    sorted_list_sum_rec(rest.to_vec(),\
    \ acc)\n                }\n            }\n        }\n    }\n    sorted_list_sum_rec(lst,\
    \ vec![])", "    let lst_len = lst.len();\n    let mut new_lst: Vec<String> =\
    \ Vec::new();\n    for i in 0..lst_len {\n        let s = lst[i].clone();\n  \
    \      if s.len() % 2 == 0 {\n            new_lst.push(s);\n        }\n    }\n\
    \    new_lst.sort();\n    new_lst", "    lst.into_iter()\n        .filter(|v|\
    \ v.len() % 2 == 0)\n        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n\
    \        .collect()", "    let mut result = Vec::new();\n    let mut dict = HashMap::new();\n\
    \    for val in lst {\n        let len = val.len();\n        if !dict.contains_key(&len)\
    \ {\n            dict.insert(len, Vec::new());\n        }\n        let mut lst\
    \ = dict.get_mut(&len).unwrap();\n        lst.push(val);\n    }\n    let mut sorted_keys:\
    \ Vec<usize> = dict.keys().cloned().collect();\n    sorted_keys.sort();\n    for\
    \ key in sorted_keys {\n        let mut lst = dict.get_mut(&key).unwrap();\n \
    \       lst.sort();\n        result.append(lst);\n    }\n    result", "    let\
    \ result: Vec<String> = lst\n        .into_iter()\n        .filter(|s| s.len()\
    \ % 2 == 0)\n        .collect();\n    result", "    let mut new_lst: Vec<String>\
    \ = Vec::new();\n    for i in lst {\n        if is_even_length(&i) {\n       \
    \     new_lst.push(i);\n        }\n    }\n    new_lst.sort();\n    new_lst", " \
    \   let mut result: Vec<String> = Vec::new();\n    for s in lst {\n        if\
    \ s.len() % 2 == 0 {\n            result.push(s);\n        }\n    }\n    result.sort();\n\
    \    result", "    let mut lst_mut = lst;\n    let mut lst_even = Vec::new();\n\
    \    let mut lst_odd = Vec::new();\n    for each in lst_mut.iter() {\n       \
    \ if each.len() % 2 == 0 {\n            lst_even.push(each.clone());\n       \
    \ } else {\n            lst_odd.push(each.clone());\n        }\n    }\n    for\
    \ each in lst_odd.iter() {\n        for (index, c) in lst_mut.iter().enumerate()\
    \ {\n            if c == each {\n                lst_mut.remove(index);\n    \
    \            break;\n            }\n        }\n    }\n    lst_mut.sort();\n  \
    \  lst_mut", "    let mut lst = lst;\n    lst.sort_by(|a, b| b.len().cmp(&a.len()));\n\
    \    lst.sort_by(|a, b| a.cmp(&b));\n    lst", "    lst.into_iter()\n        .filter(|x|\
    \ x.len() % 2 == 0)\n        .sorted_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)))\n\
    \        .collect()", "    let mut new_lst: Vec<String> = vec![];\n    for item\
    \ in lst {\n        if item.len() % 2 == 0 {\n            new_lst.push(item);\n\
    \        }\n    }\n    new_lst.sort();\n    new_lst", "    let mut lst = lst;\n\
    \    lst.sort_by(|a, b| {\n        let len_a = a.len();\n        let len_b = b.len();\n\
    \        if len_a == len_b {\n            a.cmp(b)\n        } else {\n       \
    \     len_a.cmp(&len_b)\n        }\n    });\n    let mut output: Vec<String> =\
    \ Vec::new();\n    for item in lst {\n        if item.len() % 2 == 0 {\n     \
    \       output.push(item);\n        }\n    }\n    output", "    let mut lst =\
    \ lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    lst.sort_by(|a, b|\
    \ a.cmp(&b));\n    lst", "    let mut lst = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    let mut res = Vec::new();\n    for s in lst {\n        if s.len() % 2 ==\
    \ 0 {\n            res.push(s);\n        }\n    }\n    res", "    let mut lst\
    \ = lst;\n    lst.sort_by(|a, b| a.len().cmp(&b.len()));\n    let mut odd_len_lst\
    \ = Vec::new();\n    let mut even_len_lst = Vec::new();\n    for string in lst\
    \ {\n        if string.len() % 2 == 0 {\n            even_len_lst.push(string);\n\
    \        } else {\n            odd_len_lst.push(string);\n        }\n    }\n \
    \   lst.sort_by(|a, b| a.cmp(b));\n    lst"]
stop_tokens:
- "\n}"
