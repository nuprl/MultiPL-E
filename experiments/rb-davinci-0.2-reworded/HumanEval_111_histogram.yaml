name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a hash\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# >>> histogram.call(\"a b c\")\n# {\"a\" => 1, \"b\" => 1, \"c\" =>\
  \ 1}\n# >>> histogram.call(\"a b b a\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"\
  a b c a b\")\n# {\"a\" => 2, \"b\" => 2}\n# >>> histogram.call(\"b b b b a\")\n\
  # {\"b\" => 4}\n# >>> histogram.call(\"\")\n# {}\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select\
    \ { |k, v| v == test.split(\" \").group_by { |v| v }.values.map(&:size).max }\n\
    end", "  h = Hash.new(0)\n  test.split.each { |letter| h[letter] += 1 }\n  h.select\
    \ { |k, v| v == h.values.max }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.sort_by { |k,v| v }.reverse.to_h\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max }\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  letters = test.split(\" \")\n\
    \  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts.select\
    \ { |k, v| v == counts.values.max }\nend", "  letters = test.split(\" \")\n  counts\
    \ = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts.select\
    \ { |k, v| v == counts.values.max }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").group_by{|x|\
    \ x}.map{|k,v| [k, v.count]}.to_h\nend", "  histogram = Hash.new(0)\n  test.split.each\
    \ { |letter| histogram[letter] += 1 }\n  histogram\nend", "  test.split(\" \"\
    ).inject(Hash.new(0)) { |hash, word| hash[word] += 1; hash }\nend", "  result\
    \ = Hash.new(0)\n  test.split.each { |word| result[word] += 1 }\n  result\nend",
  "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v|\
    \ v == test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max\
    \ }\nend", "  # TODO: implement this method\n  hash = Hash.new(0)\n  test.split(\"\
    \ \").each do |letter|\n    hash[letter] += 1\n  end\n  hash\nend", "  # TODO:\
    \ implement me\n  hash = Hash.new(0)\n  test.split(\" \").each do |word|\n   \
    \ hash[word] += 1\n  end\n  hash\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  # your code here\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.sort_by { |k,v| v }.reverse.first.first\n\
    end", "  # Your code here\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v|\
    \ h[v] += 1; h }.max_by { |k,v| v }\nend", "  test = test.split(\" \")\n  test.each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  hash = Hash.new(0)\n  test.split(\"\
    \ \").each { |x| hash[x] += 1 }\n  hash.select { |k, v| v == hash.values.max }\n\
    end", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n  letters.each {\
    \ |letter| counts[letter] += 1 }\n  counts\nend", "  test = test.split(\" \")\n\
    \  count = Hash.new(0)\n  test.each { |word| count[word] += 1 }\n  count.select\
    \ { |k, v| v == count.values.max }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }.sort_by { |k, v| v }.last(1).to_h\nend", "  hash = Hash.new(0)\n\
    \  test.split(\" \").each { |x| hash[x] += 1 }\n  hash\nend", "  test.split(\"\
    \ \").each_with_object(Hash.new(0)) { |word,counts| counts[word] += 1 }\nend",
  "  test.split(\" \").each_with_object(Hash.new(0)) { |word,counts| counts[word]\
    \ += 1 }\nend", "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h\
    \ }.select { |k, v| v == test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] +=\
    \ 1; h }.values.max }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  letters = test.split(\" \")\n\
    \  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts\n\
    end", "  histogram = Hash.new(0)\n  test.split.each { |word| histogram[word] +=\
    \ 1 }\n  histogram\nend", "  test.split.each_with_object(Hash.new(0)) { |word,\
    \ counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  # TODO: implement this method\n\
    end", "  test.split(\" \").each_with_object(Hash.new(0)) { |word,counts| counts[word]\
    \ += 1 }\nend", "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h\
    \ }.select { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] +=\
    \ 1; h }.values.max }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  letters = test.split(\" \")\n\
    \  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts\n\
    end", "  test.split(\" \").inject(Hash.new(0)) { |hash, word| hash[word] += 1;\
    \ hash }\nend", "  hash = Hash.new(0)\n  test.split(\" \").each { |letter| hash[letter]\
    \ += 1 }\n  hash\nend", "  result = Hash.new(0)\n  test.split(\" \").each { |x|\
    \ result[x] += 1 }\n  result\nend", "  test.split(\" \").inject(Hash.new(0)) {\
    \ |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  # Your code here\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h,x| h[x] += 1; h }.sort_by { |k,v| v }.reverse.to_h\n\
    end", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n  letters.each {\
    \ |letter| counts[letter] += 1 }\n  counts.select { |k, v| v == counts.values.max\
    \ }\nend", "  test.split(\" \").each_with_object(Hash.new(0)) { |word, counts|\
    \ counts[word] += 1 }\nend", "  hash = Hash.new(0)\n  test.split(\" \").each {\
    \ |word| hash[word] += 1 }\n  hash.select { |k, v| v == hash.values.max }\nend",
  "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word] += 1 }\n\
    end", "  test.split(\" \").inject(Hash.new(0)) { |hash, word| hash[word] += 1;\
    \ hash }\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h\
    \ }.select { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] +=\
    \ 1; h }.values.max }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k,\
    \ v.size]}.to_h\nend", "  # your code here\nend", "  # Your code here\nend", " \
    \ test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v|\
    \ v == test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max\
    \ }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.count]}.to_h\n\
    end", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend",
  "  # your code here\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v]\
    \ += 1; h }.sort_by { |k,v| v }.reverse.to_h\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test = test.split(\" \")\n  test.each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  letters = test.split(\" \")\n\
    \  letter_count = {}\n  letters.each do |letter|\n    if letter_count[letter]\n\
    \      letter_count[letter] += 1\n    else\n      letter_count[letter] = 1\n \
    \   end\n  end\n  letter_count\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.sort_by { |k,v| v }.reverse.to_h\nend", "  result = {}\n\
    \  test.split(\" \").each do |letter|\n    result[letter] = test.split(\" \").count(letter)\n\
    \  end\n  result\nend", "  test.split(\" \").each_with_object(Hash.new(0)) { |word,counts|\
    \ counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v|\
    \ h[v] += 1; h }.select { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v|\
    \ h[v] += 1; h }.values.max }\nend", "  letters = test.split(\" \")\n  letters.each_with_object(Hash.new(0))\
    \ { |letter,counts| counts[letter] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  histogram = Hash.new(0)\n  test.split.each\
    \ { |word| histogram[word] += 1 }\n  max = histogram.values.max\n  histogram.select\
    \ { |k, v| v == max }\nend", "  test.split(\" \").group_by { |x| x }.map { |k,\
    \ v| [k, v.size] }.to_h\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,\
    \ v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  test.split.inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend", "  test.split.inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.sort_by { |k, v| -v }.to_h\nend", "  letters = test.split(\"\
    \ \")\n  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n\
    \  counts.select { |k, v| v == counts.values.max }\nend", "  result = Hash.new(0)\n\
    \  test.split(\" \").each { |x| result[x] += 1 }\n  result\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.count]}.to_h\nend", "  hash = Hash.new(0)\n\
    \  test.split(\" \").each do |letter|\n    hash[letter] += 1\n  end\n  hash\n\
    end", "  hash = Hash.new(0)\n  test.split(\" \").each { |letter| hash[letter]\
    \ += 1 }\n  hash.select { |k, v| v == hash.values.max }\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.count]}.to_h\nend", "  hash = Hash.new(0)\n\
    \  test.split(\" \").each { |letter| hash[letter] += 1 }\n  hash\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max }\nend", "  test\
    \ = test.split(\" \")\n  hash = Hash.new(0)\n  test.each do |x|\n    hash[x] +=\
    \ 1\n  end\n  hash\nend", "  test.split(\" \").each_with_object(Hash.new(0)) {\
    \ |word, counts| counts[word] += 1 }\nend", "  # TODO: implement this method\n\
    \  # 1. split the string into an array of words\n  # 2. create a hash with the\
    \ words as keys and the number of occurrences as values\n  # 3. find the key with\
    \ the highest value\n  # 4. return the hash with the key with the highest value\n\
    \  # 5. if there are several keys with the same value, return all of them\n  #\
    \ 6. if the string is empty, return an empty hash\n  # 7. if the string is nil,\
    \ return an empty hash\n  # 8. if the string is not a string, return an empty\
    \ hash\n  # 9. if the string is not a string, return an empty hash\n  # 10. if\
    \ the string is not a string, return an empty hash\n  # 11. if the string is not\
    \ a string, return an empty hash\n  # 12. if the string is not a string, return\
    \ an empty hash\n  # 13. if the string is not a string, return an empty hash\n\
    \  # 14. if the string is not a string, return an empty hash\n  # 15. if the string\
    \ is not a string, return an empty hash\n  # 16. if the string is not a string,\
    \ return an empty hash\n  # 17. if the string is not a string, return an empty\
    \ hash\n  # 18. if the string is not a string, return an empty hash\n  # 19. if\
    \ the string is not a string, return an empty hash\n  # 20. if the string is not\
    \ a string, return an empty hash\n  # 21. if the string is not a string, return\
    \ an empty hash\n  # 22. if the string is not a string, return an empty hash\n\
    \  # 23. if the string is not a string, return an empty hash\n  # 24. if the string\
    \ is not a string, return an empty hash\n  # 25. if the string is not a string,\
    \ return an empty hash\n  # 26. if the string is not a string, return an empty\
    \ hash\n  # 27. if the string is not a string, return an empty hash\n  # 28. if\
    \ the string is not a string, return an empty hash\n  # 29. if the string is not\
    \ a string, return an empty hash\n  # 30. if the string is not a string, return\
    \ an empty hash\n  #", "  hash = Hash.new(0)\n  test.split(\" \").each { |x| hash[x]\
    \ += 1 }\n  hash\nend", "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v]\
    \ += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  # TODO: implement this\
    \ method\n  hash = Hash.new(0)\n  test.split(\" \").each do |letter|\n    hash[letter]\
    \ += 1\n  end\n  hash\nend", "  test.split.each_with_object(Hash.new(0)) { |word,\
    \ counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  letters = test.split(\" \")\n\
    \  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts\n\
    end", "  test.split.inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v|\
    \ v == test.split.inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max }\nend",
  "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word] += 1 }\n\
    end", "  test.split(\" \").each_with_object(Hash.new(0)) { |word,counts| counts[word]\
    \ += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0)) { |word, counts|\
    \ counts[word] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test.split(\" \").group_by { |x|\
    \ x }.map { |k, v| [k, v.size] }.to_h\nend", "  letters = test.split(\" \")\n\
    \  histogram = Hash.new(0)\n  letters.each do |letter|\n    histogram[letter]\
    \ += 1\n  end\n  histogram\nend", "  test.split(\" \").inject(Hash.new(0)) { |hash,\
    \ word| hash[word] += 1; hash }\nend", "  letters = test.split(\" \")\n  counts\
    \ = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n  counts.keep_if\
    \ { |k, v| v == counts.values.max }\n  counts\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max }\nend", "  test_array\
    \ = test.split(\" \")\n  histogram_hash = Hash.new(0)\n  test_array.each do |letter|\n\
    \    histogram_hash[letter] += 1\n  end\n  histogram_hash\nend", "  letters =\
    \ test.split(\" \")\n  counts = Hash.new(0)\n  letters.each { |letter| counts[letter]\
    \ += 1 }\n  counts.select { |k, v| v == counts.values.max }\nend", "  letters\
    \ = test.split(\" \")\n  letters.each_with_object(Hash.new(0)) { |letter,counts|\
    \ counts[letter] += 1 }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v|\
    \ [k, v.size]}.to_h\nend", "  hash = Hash.new(0)\n  test.split(\" \").each { |x|\
    \ hash[x] += 1 }\n  hash\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.max_by { |k, v| v }.first\nend", "  test.split(\" \"\
    ).each_with_object(Hash.new(0)) { |word,counts| counts[word] += 1 }\nend", " \
    \ test.split(' ').each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  result = Hash.new(0)\n  test.split(\" \").each { |x| result[x]\
    \ += 1 }\n  result.select { |k, v| v == result.values.max }\nend", "  test.split(\"\
    \ \").each_with_object(Hash.new(0)) { |word, counts| counts[word] += 1 }\nend",
  "  result = {}\n  test.split(\" \").each do |x|\n    if result.has_key?(x)\n   \
    \   result[x] += 1\n    else\n      result[x] = 1\n    end\n  end\n  result\n\
    end", "  hash = Hash.new(0)\n  test.split(\" \").each { |letter| hash[letter]\
    \ += 1 }\n  hash\nend", "  # Your code here\nend", "  hash = Hash.new(0)\n  test.split(\"\
    \ \").each { |letter| hash[letter] += 1 }\n  max = hash.values.max\n  hash.select\
    \ { |k, v| v == max }\nend", "  # TODO: implement this method\n  # TODO: implement\
    \ this method\n  hash = Hash.new(0)\n  test.split.each do |letter|\n    hash[letter]\
    \ += 1\n  end\n  hash\nend", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n\
    \  letters.each { |letter| counts[letter] += 1 }\n  counts\nend", "  hash = Hash.new(0)\n\
    \  test.split(\" \").each { |x| hash[x] += 1 }\n  hash.select { |k, v| v == hash.values.max\
    \ }\nend", "  histogram = Hash.new(0)\n  test.split.each do |word|\n    histogram[word]\
    \ += 1\n  end\n  histogram\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v|\
    \ [k, v.count]}.to_h\nend", "  test.split(\" \").group_by { |x| x }.map { |k,\
    \ v| [k, v.size] }.to_h\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v|\
    \ [k, v.size]}.to_h\nend", "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v]\
    \ += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.select { |k,v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.values.max }\nend", "  hash = Hash.new(0)\n  test.split(\"\
    \ \").each { |x| hash[x] += 1 }\n  hash.select { |k, v| v == hash.values.max }\n\
    end", "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  test.split.inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select\
    \ { |k, v| v == test.split.group_by { |x| x }.values.max.size }.keys.join(' ')\n\
    end", "  test.split.each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  # TODO: implement this method\n  hash = Hash.new(0)\n  test.split(\"\
    \ \").each { |letter| hash[letter] += 1 }\n  hash.select { |k, v| v == hash.values.max\
    \ }\nend", "  histogram = Hash.new(0)\n  test.split(\" \").each { |word| histogram[word]\
    \ += 1 }\n  histogram\nend", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n\
    \  letters.each { |letter| counts[letter] += 1 }\n  counts\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |hash, word| hash[word] += 1; hash }\nend", "  hash = Hash.new(0)\n  test.split.each\
    \ do |letter|\n    hash[letter] += 1\n  end\n  hash.select { |k, v| v == hash.values.max\
    \ }\nend", "  test.split(\" \").each_with_object(Hash.new(0)) { |word,counts|\
    \ counts[word] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  result = Hash.new(0)\n  test.split.each\
    \ { |word| result[word] += 1 }\n  result\nend", "  histogram = Hash.new(0)\n \
    \ test.split(\" \").each do |letter|\n    histogram[letter] += 1\n  end\n  histogram\n\
    end", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.max_by {\
    \ |k,v| v }\nend", "  test.split(\" \").inject(Hash.new(0)) { |h, v| h[v] += 1;\
    \ h }.sort_by { |k, v| v }.reverse.to_h\nend", "  test.split(\" \").group_by{|x|\
    \ x}.map{|k,v| [k, v.count]}.to_h\nend", "  # your code here\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.sort_by { |k, v| v }.reverse.to_h\n\
    end", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend",
  "  result = Hash.new(0)\n  test.split(\" \").each do |letter|\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  # TODO: implement this method\n  hash = Hash.new(0)\n\
    \  test.split(\" \").each do |letter|\n    hash[letter] += 1\n  end\n  hash\n\
    end", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.size]}.to_h\nend",
  "  # TODO: implement this method\n  hash = Hash.new(0)\n  test.split.each do |letter|\n\
    \    hash[letter] += 1\n  end\n  hash\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  # TODO: implement me\n  hash =\
    \ Hash.new(0)\n  test.split(\" \").each { |word| hash[word] += 1 }\n  hash.select\
    \ { |k, v| v == hash.values.max }\nend", "  result = Hash.new(0)\n  test.split(\"\
    \ \").each { |x| result[x] += 1 }\n  result\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  result = {}\n  test.split(\"\
    \ \").each do |letter|\n    if result.key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  hash =\
    \ Hash.new(0)\n  test.split(\" \").each { |letter| hash[letter] += 1 }\n  hash.select\
    \ { |letter, count| count == hash.values.max }\nend", "  # TODO: implement me\n\
    \  hash = Hash.new(0)\n  test.split(\" \").each do |letter|\n    hash[letter]\
    \ += 1\n  end\n  hash\nend", "  test.split(\" \").inject(Hash.new(0)) { |h, v|\
    \ h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0)) {\
    \ |h, v| h[v] += 1; h }.values.max }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word,counts| counts[word] += 1 }\nend", "  test.split(\" \").group_by{|x|\
    \ x}.map{|k,v| [k, v.size]}.to_h\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.sort_by { |k, v| v }.reverse.to_h\nend", "  # your code\
    \ here\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.select\
    \ { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.values.max\
    \ }\nend", "  histogram = Hash.new(0)\n  test.split(\" \").each { |letter| histogram[letter]\
    \ += 1 }\n  histogram\nend", "  hash = Hash.new(0)\n  test.split(\" \").each {\
    \ |x| hash[x] += 1 }\n  hash.delete_if { |k, v| v == 1 }\n  hash\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h,v| h[v] += 1; h }.max_by { |k,v| v }.first\nend",
  "  histogram = Hash.new(0)\n  test.split.each { |letter| histogram[letter] += 1\
    \ }\n  histogram\nend", "  letters = test.split(\" \")\n  letters.each_with_object(Hash.new(0))\
    \ { |letter, counts| counts[letter] += 1 }\nend", "  letters = test.split(\" \"\
    )\n  counts = Hash.new(0)\n  letters.each { |letter| counts[letter] += 1 }\n \
    \ counts.select { |k, v| v == counts.values.max }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.select { |k,v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }.values.max }\nend", "  test.split(\" \").each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\" \").inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }.values.max }\nend", "  result = Hash.new(0)\n  test.split(\"\
    \ \").each do |letter|\n    result[letter] += 1\n  end\n  result\nend", "  result\
    \ = Hash.new(0)\n  test.split(\" \").each do |letter|\n    result[letter] += 1\n\
    \  end\n  result\nend", "  letters = test.split(\" \")\n  counts = Hash.new(0)\n\
    \  letters.each { |letter| counts[letter] += 1 }\n  counts\nend", "  test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.select { |k, v| v == test.split(\"\
    \ \").inject(Hash.new(0)) { |h, v| h[v] += 1; h }.values.max }\nend", "  result\
    \ = {}\n  test.split(\" \").each do |x|\n    if result.has_key?(x)\n      result[x]\
    \ += 1\n    else\n      result[x] = 1\n    end\n  end\n  result\nend", "  test.split(\"\
    \ \").group_by{|x| x}.map{|k,v| [k, v.count]}.to_h\nend", "  test.split(\" \"\
    ).each_with_object(Hash.new(0)) { |word, counts| counts[word] += 1 }\nend", " \
    \ test.split(\" \").each_with_object(Hash.new(0)) { |word, counts| counts[word]\
    \ += 1 }\nend", "  test.split(\" \").group_by{|x| x}.map{|k,v| [k, v.count]}.to_h\n\
    end", "  # Your code here\nend", "  letters = test.split(\" \")\n  letters.each_with_object(Hash.new(0))\
    \ { |letter, counts| counts[letter] += 1 }\nend", "  test.split.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\nend", "  # Your code here\nend", "  #\
    \ Your code here\nend", "  test.split(\" \").inject(Hash.new(0)) { |h,v| h[v]\
    \ += 1; h }.select { |k,v| v == test.split(\" \").inject(Hash.new(0)) { |h,v|\
    \ h[v] += 1; h }.values.max }\nend", "  letters = test.split(\" \")\n  letters_hash\
    \ = {}\n  letters.each do |letter|\n    if letters_hash.has_key?(letter)\n   \
    \   letters_hash[letter] += 1\n    else\n      letters_hash[letter] = 1\n    end\n\
    \  end\n  letters_hash\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
