name: HumanEval_6_parse_nested_parens
language: lua
prompt: "-- Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n-- For each of the group, output the deepest\
  \ level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  -- [2, 3, 1, 3]\nlocal function parse_nested_parens(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n \
  \   lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {4})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local idx = 1\n    local paren_group_starts = {}\n    local paren_group_levels\
    \ = {}\n    local paren_level = 0\n    while idx <= #paren_string do\n       \
    \ local c = paren_string:sub(idx, idx)\n        if c == '(' then\n           \
    \ table.insert(paren_group_starts, idx)\n            paren_level = paren_level\
    \ + 1\n        elseif c == ')' then\n            table.insert(paren_group_levels,\
    \ paren_level)\n            paren_level = paren_level - 1\n        end\n     \
    \   idx = idx + 1\n    end\n    return paren_group_levels\nend", "    local max_nest\
    \ = 0\n    local nest_list = {}\n    for _, w in ipairs(paren_string:split(' '))\
    \ do\n        local nest = 0\n        for c in w:gmatch('[()]') do\n         \
    \   if c == '(' then\n                nest = nest + 1\n            else\n    \
    \            nest = nest - 1\n            end\n            max_nest = math.max(max_nest,\
    \ nest)\n        end\n        table.insert(nest_list, nest)\n    end\n    return\
    \ nest_list, max_nest\nend", "    -- ':' represents the boundary\n    local paren_string\
    \ = ':' .. paren_string .. ':'\n    local depth = 0\n    local max_depth = 0\n\
    \    local paren_groups = {}\n    local group_index = 1\n    -- Loop through the\
    \ string, use max_depth to record the deepest level\n    -- of nesting. Use paren_groups\
    \ to record the depth of all groups.\n    for i = 1, #paren_string do\n      \
    \  local char = paren_string:sub(i, i)\n        if char == '(' then\n        \
    \    depth = depth + 1\n            max_depth = math.max(max_depth, depth)\n \
    \       elseif char == ')' then\n            depth = depth - 1\n        elseif\
    \ char == ':' then\n            paren_groups[group_index] = max_depth\n      \
    \      group_index = group_index + 1\n            max_depth = 0\n        end\n\
    \    end\n    return paren_groups\nend", "  local paren_group = stringx.split(paren_string,\
    \ ' ')\n  local paren_depth = {}\n  for i = 1, #paren_group do\n    local depth\
    \ = paren_group[i]:gsub('[^(]', ''):len()\n    paren_depth[i] = depth\n  end\n\
    \  return paren_depth\nend", "  local function get_deepest_nested_parens(sub_string)\n\
    \    local levels = 0\n    local max_level = 0\n    for i = 1,#sub_string do\n\
    \      if sub_string:sub(i,i) == '(' then\n        levels = levels + 1\n     \
    \   if levels > max_level then\n          max_level = levels\n        end\n  \
    \    elseif sub_string:sub(i,i) == ')' then\n        levels = levels - 1\n   \
    \   end\n    end\n    return max_level\n  end\n  local paren_groups = split(paren_string,\
    \ ' ')\n  local deep_levels = {}\n  for i = 1,#paren_groups do\n    table.insert(deep_levels,\
    \ get_deepest_nested_parens(paren_groups[i]))\n  end\n  return deep_levels\nend",
  "    local maximum_levels = {}\n    for _, str in ipairs(paren_string:split()) do\n\
    \        table.insert(maximum_levels, paren_utils.maximum_nesting_in_group(str))\n\
    \    end\n    return maximum_levels\nend", "    if paren_string == '' then\n \
    \       return {}\n    end\n    local paren_groups = {}\n    -- split paren_string\
    \ into separate parenthesis groups\n    for i in string.gmatch(paren_string, '%S+')\
    \ do\n        table.insert(paren_groups, i)\n    end\n    local paren_depth =\
    \ {}\n    -- for each parenthesis group, extract the maximum depth of parens\n\
    \    for i, paren_group in ipairs(paren_groups) do\n        local depth = 0\n\
    \        local max_depth = 0\n        for paren in string.gmatch(paren_group,\
    \ '.') do\n            if paren == '(' then\n                depth = depth + 1\n\
    \            elseif paren == ')' then\n                depth = depth - 1\n   \
    \         end\n            if depth > max_depth then\n                max_depth\
    \ = depth\n            end\n        end\n        table.insert(paren_depth, max_depth)\n\
    \    end\n    return paren_depth\nend", "    local stack = Stack()\n    local\
    \ max_depth = 0\n    local cur_depth = 0\n    local depth_list = {}\n    for i\
    \ = 1, string.len(paren_string) do\n        local cur_char = string.sub(paren_string,\
    \ i, i)\n        if cur_char == '(' then\n            stack:push('(')\n      \
    \      cur_depth = cur_depth + 1\n            if cur_depth > max_depth then\n\
    \                max_depth = cur_depth\n            end\n        elseif cur_char\
    \ == ')' then\n            stack:pop()\n            cur_depth = cur_depth - 1\n\
    \        elseif cur_char == ' ' then\n            table.insert(depth_list, max_depth)\n\
    \            max_depth = 0\n            cur_depth = 0\n        end\n    end\n\
    \    if not stack:is_empty() then\n        return nil\n    end\n    return depth_list\n\
    end", "\tlocal max_depth_table = {}\n\tlocal paren_depth = 0\n\tlocal max_depth\
    \ = 0\n\tfor paren in paren_string:gmatch('[()]') do\n\t\tif paren == '(' then\n\
    \t\t\tparen_depth = paren_depth + 1\n\t\t\tif paren_depth > max_depth then\n\t\
    \t\t\tmax_depth = paren_depth\n\t\t\tend\n\t\telse\n\t\t\ttable.insert(max_depth_table,\
    \ max_depth)\n\t\t\tmax_depth = 0\n\t\t\tparen_depth = 0\n\t\tend\n\tend\n\treturn\
    \ max_depth_table\nend", "  local function parse_parens(paren_string)\n    local\
    \ max_depth = 0\n    local depth = 0\n    for i = 1, #paren_string do\n      local\
    \ char = paren_string:sub(i, i)\n      if char == '(' then\n        depth = depth\
    \ + 1\n        max_depth = math.max(max_depth, depth)\n      elseif char == ')'\
    \ then\n        depth = depth - 1\n      end\n    end\n    return max_depth\n\
    \  end\n  local group_string = paren_string:gsub('%s+', ' ')\n  local group_list\
    \ = group_string:split(' ')\n  local result = {}\n  for _, group in ipairs(group_list)\
    \ do\n    table.insert(result, parse_parens(group))\n  end\n  return result\n\
    end", "    local depths = {}\n    local depth = 0\n    for l in paren_string:gmatch(\"\
    (.)\") do\n        if l == '(' then\n            depth = depth + 1\n        elseif\
    \ l == ')' then\n            depths[#depths + 1] = depth\n            depth =\
    \ depth - 1\n        end\n    end\n    return depths\nend", "    local max_depth\
    \ = 0\n    local depth = 0\n    local paren_list = {}\n    for i = 1, #paren_string\
    \ do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n\
    \            depth = depth + 1\n            if depth > max_depth then\n      \
    \          max_depth = depth\n            end\n        elseif char == ')' then\n\
    \            depth = depth - 1\n        elseif char == ' ' then\n            paren_list[#paren_list\
    \ + 1] = max_depth\n            max_depth = 0\n            depth = 0\n       \
    \ end\n    end\n    paren_list[#paren_list + 1] = max_depth\n    return paren_list\n\
    end", "  assert(type(paren_string) == 'string')\n  local paren_table = {}\n  local\
    \ paren_start, paren_end = string.find(paren_string, '%(')\n  local paren_depth\
    \ = 0\n  local paren_depth_max = 0\n  local i = 0\n  while paren_start do\n  \
    \  if paren_start > paren_end + 1 then\n      paren_table[i] = paren_depth_max\n\
    \      paren_depth_max = 0\n      i = i + 1\n    end\n    paren_depth = paren_depth\
    \ + 1\n    if paren_depth > paren_depth_max then\n      paren_depth_max = paren_depth\n\
    \    end\n    paren_start, paren_end = string.find(paren_string, '%(', paren_end\
    \ + 1)\n    if paren_start then\n      paren_start, paren_end = string.find(paren_string,\
    \ '%)', paren_end + 1)\n      paren_depth = paren_depth - 1\n    end\n  end\n\
    \  paren_table[i] = paren_depth_max\n  return paren_table\nend", "\tlocal result\
    \ = {}\n\tparen_string:gsub('[^ ]+', function(group)\n\t\tlocal depth = 0\n\t\t\
    local max_depth = 0\n\t\tfor paren in group:gmatch('.') do\n\t\t\tif paren ==\
    \ '(' then\n\t\t\t\tdepth = depth + 1\n\t\t\t\tif depth > max_depth then\n\t\t\
    \t\t\tmax_depth = depth\n\t\t\t\tend\n\t\t\telseif paren == ')' then\n\t\t\t\t\
    depth = depth - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(result, max_depth)\n\t\
    end)\n\treturn result\nend", "    local rst = {}\n    for t in stringx.split(paren_string,\
    \ ' ') do\n        local count = 0\n        local max_count = 0\n        for c\
    \ in stringx.split(t, '') do\n            if c == '(' then\n                count\
    \ = count + 1\n                if count > max_count then\n                   \
    \ max_count = count\n                end\n            elseif c == ')' then\n \
    \               count = count - 1\n            end\n        end\n        table.insert(rst,\
    \ max_count)\n    end\n    return rst\nend", "  local result = {}\n  local index\
    \ = 1\n  while index <= #paren_string do\n    local c = paren_string:sub(index,\
    \ index)\n    if c == '(' then\n      local left_index = index\n      local right_index\n\
    \      local paren_stack = 1\n      for i = index + 1, #paren_string do\n    \
    \    c = paren_string:sub(i, i)\n        if c == '(' then\n          paren_stack\
    \ = paren_stack + 1\n        elseif c == ')' then\n          paren_stack = paren_stack\
    \ - 1\n          if paren_stack == 0 then\n            right_index = i\n     \
    \       break\n          end\n        end\n      end\n      if right_index then\n\
    \        result[#result + 1] = parse_nested_parens(paren_string:sub(left_index\
    \ + 1, right_index - 1))\n        index = right_index + 1\n      else\n      \
    \  index = index + 1\n      end\n    elseif c == ' ' then\n      index = index\
    \ + 1\n    else\n      error('Invalid character ' .. c)\n    end\n  end\n  local\
    \ max_level = 0\n  for i = 1, #result do\n    if type(result[i]) == 'number' then\n\
    \      max_level = math.max(max_level, result[i])\n    else\n      for j = 1,\
    \ #result[i] do\n        max_level = math.max(max_level, result[i][j])\n     \
    \ end\n    end\n  end\n  if max_level == 0 then\n    return 1\n  else\n    return\
    \ max_level + 1\n  end\nend", "    local paren_depth = {}\n    local current_depth\
    \ = 0\n    for char in paren_string:gmatch('%S') do\n        if char == '(' then\n\
    \            current_depth = current_depth + 1\n        elseif char == ')' then\n\
    \            table.insert(paren_depth, current_depth)\n            current_depth\
    \ = current_depth - 1\n        end\n    end\n    return paren_depth\nend", "\t\
    local max_levels = {}\n\tfor paren_group in paren_string:gmatch('%s*(%b())%s*')\
    \ do\n\t\tlocal level = 0\n\t\tlocal max_level = 0\n\t\tfor i=1,#paren_group do\n\
    \t\t\tif paren_group:sub(i,i) == '(' then\n\t\t\t\tlevel = level + 1\n\t\t\t\t\
    if level > max_level then\n\t\t\t\t\tmax_level = level\n\t\t\t\tend\n\t\t\telseif\
    \ paren_group:sub(i,i) == ')' then\n\t\t\t\tlevel = level - 1\n\t\t\tend\n\t\t\
    end\n\t\ttable.insert(max_levels, max_level)\n\tend\n\treturn max_levels\nend",
  "    -- Generate a list of (start, end) groups of parentheses\n    local groups\
    \ = {}\n    for s, e in paren_string:gmatch('()()') do\n        if paren_string:sub(s,\
    \ e) == '()' then\n            table.insert(groups, {s, e})\n        end\n   \
    \ end", "\tlocal t = {}\n\tlocal depth = 0\n\tlocal max_depth = 0\n\tfor c in\
    \ paren_string:gmatch('.') do\n\t\tif c == '(' then\n\t\t\tdepth = depth + 1\n\
    \t\t\tif depth > max_depth then\n\t\t\t\tmax_depth = depth\n\t\t\tend\n\t\telseif\
    \ c == ')' then\n\t\t\tdepth = depth - 1\n\t\tend\n\tend\n\ttable.insert(t, max_depth)\n\
    \treturn t\nend", "  local res = {}\n  for paren in paren_string:gmatch('[^%s]+')\
    \ do\n    local max_depth = 0\n    local cur_depth = 0\n    for c in paren:gmatch('.')\
    \ do\n      if c == '(' then\n        cur_depth = cur_depth + 1\n        max_depth\
    \ = math.max(max_depth, cur_depth)\n      elseif c == ')' then\n        cur_depth\
    \ = cur_depth - 1\n      end\n    end\n    table.insert(res, max_depth)\n  end\n\
    \  return res\nend", "    local result = {}\n    for match in string.gmatch(paren_string,\
    \ '[^ ]+') do\n        local level = 0\n        local max_level = 0\n        for\
    \ character in string.gmatch(match, '.') do\n            if character == '(' then\n\
    \                level = level + 1\n            elseif character == ')' then\n\
    \                level = level - 1\n            end\n            max_level = math.max(max_level,\
    \ level)\n        end\n        table.insert(result, max_level)\n    end\n    return\
    \ result\nend", "    local paren_table = Paren.split(paren_string)\n    local\
    \ paren_count = Paren.count(paren_table)\n    return paren_count\nend", "    local\
    \ paren_max = {}\n    for _, paren_group in ipairs(paren_string:split(' ')) do\n\
    \        local depth = 0\n        local max_depth = 0\n        for s in paren_group:gmatch('%b()')\
    \ do\n            depth = depth + 1\n            max_depth = math.max(max_depth,\
    \ depth)\n        end\n        table.insert(paren_max, max_depth)\n    end\n \
    \   return paren_max\nend", "    paren_string = paren_string or \"\"\n    local\
    \ paren_tokens = stringx.split(paren_string)\n    local token_count = #paren_tokens\n\
    \    local paren_levels = torch.IntTensor(token_count)\n    for i = 1, token_count\
    \ do\n        local token = paren_tokens[i]\n        paren_levels[i] = token:match(\"\
    (%(+).*%(+)\") and #token:match(\"(%(+).*%(+)\") or 0\n    end\n    return paren_levels\n\
    end", "  local nested_parens = {}\n  for paren_group in paren_string:gmatch('%s*%(%s*(%b())%s*%)%s*')\
    \ do\n    local n = 0\n    local max_n = 0\n    for _ in paren_group:gmatch('%b()')\
    \ do\n      n = n + 1\n      max_n = math.max(max_n, n)\n    end\n    table.insert(nested_parens,\
    \ max_n)\n  end\n  return nested_parens\nend", "    local nested_groups = {}\n\
    \    for group in paren_string:gmatch('[^%s]+') do\n        local level = 0\n\
    \        local max_level = 0\n        for paren in group:gmatch('.') do\n    \
    \        if paren == '(' then\n                level = level + 1\n           \
    \ elseif paren == ')' then\n                level = level - 1\n            end\n\
    \            max_level = math.max(max_level, level)\n        end\n        table.insert(nested_groups,\
    \ max_level)\n    end\n    return nested_groups\nend", "  local paren_pattern\
    \ = '(%b())'\n  local paren_array = {}\n  for k, v in string.gmatch(paren_string,\
    \ paren_pattern) do\n    table.insert(paren_array, k)\n  end\n  return paren_array\n\
    end", "    local levels = torch.IntTensor(4):zero()\n    -- the levels are at\
    \ most 4\n    local max_level = 0\n    local current_level = 0\n    for i = 1,\
    \ #paren_string do\n        if paren_string:sub(i, i) == '(' then\n          \
    \  current_level = current_level + 1\n            if current_level > max_level\
    \ then\n                max_level = current_level\n            end\n        elseif\
    \ paren_string:sub(i, i) == ')' then\n            levels[current_level] = levels[current_level]\
    \ + 1\n            current_level = current_level - 1\n        end\n    end\n \
    \   return levels:narrow(1, 1, max_level)\nend", "    local nested_parens = {}\n\
    \    for paren_group in paren_string:gmatch('%S+') do\n        local group_nesting\
    \ = 0\n        local max_nesting = 0\n        for _, char in ipairs(paren_group:split(''))\
    \ do\n            if char == '(' then\n                group_nesting = group_nesting\
    \ + 1\n            elseif char == ')' then\n                if group_nesting >\
    \ max_nesting then\n                    max_nesting = group_nesting\n        \
    \        end\n                group_nesting = group_nesting - 1\n            end\n\
    \        end\n        nested_parens[#nested_parens + 1] = max_nesting\n    end\n\
    \    return nested_parens\nend", "  local groups = stringx.split(paren_string,\
    \ ' ')\n  local counts = {}\n  for _, group in ipairs(groups) do\n    local seq\
    \ = stringx.split(group, '')\n    local count = 0\n    local max_count = 0\n \
    \   for _, char in ipairs(seq) do\n      if char == '(' then\n        count =\
    \ count + 1\n      elseif char == ')' then\n        count = count - 1\n      end\n\
    \      max_count = math.max(max_count, count)\n    end\n    table.insert(counts,\
    \ max_count)\n  end\n  return counts\nend", "    local function find_max_depth(paren_string)\n\
    \        -- Helper function that finds the maximum depth of nesting for the given\
    \ group of parentheses\n        local max_depth = 0\n        local depth = 0\n\
    \        for i=1,#paren_string do\n            if paren_string:sub(i,i) == '('\
    \ then\n                depth = depth + 1\n                if depth > max_depth\
    \ then\n                    max_depth = depth\n                end\n         \
    \   elseif paren_string:sub(i,i) == ')' then\n                depth = depth -\
    \ 1\n            end\n        end\n        return max_depth\n    end", "    paren_string\
    \ = ' ' .. paren_string .. ' '\n    local max_nesting = 0\n    local nesting =\
    \ 0\n    local max_nesting_arr = {}\n    local max_nesting_idx = 0\n    for i\
    \ = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n       \
    \ if char == '(' then\n            nesting = nesting + 1\n            if nesting\
    \ > max_nesting then\n                max_nesting = nesting\n            end\n\
    \        elseif char == ')' then\n            if nesting == max_nesting then\n\
    \                max_nesting_idx = max_nesting_idx + 1\n                max_nesting_arr[max_nesting_idx]\
    \ = max_nesting\n                max_nesting = 0\n            end\n          \
    \  nesting = nesting - 1\n        end\n    end\n    return max_nesting_arr\nend",
  "\tlocal max_paren_nest_levels = {}\n\tfor paren_str in paren_string:gmatch(\"[^%s]+\"\
    ) do\n\t\tlocal current_paren_level = 0\n\t\tlocal max_paren_level = 0\n\t\tfor\
    \ paren in paren_str:gmatch(\".\") do\n\t\t\tif paren == \"(\" then\n\t\t\t\t\
    current_paren_level = current_paren_level + 1\n\t\t\t\tif current_paren_level\
    \ > max_paren_level then\n\t\t\t\t\tmax_paren_level = current_paren_level\n\t\t\
    \t\tend\n\t\t\telseif paren == \")\" then\n\t\t\t\tcurrent_paren_level = current_paren_level\
    \ - 1\n\t\t\tend\n\t\tend\n\t\tmax_paren_nest_levels[#max_paren_nest_levels +\
    \ 1] = max_paren_level\n\tend\n\treturn max_paren_nest_levels\nend", "  local\
    \ paren_list = string.split(paren_string, ' ')\n  local nested_list = {}\n  for\
    \ i = 1, #paren_list do\n    local open = 0\n    local closed = 0\n    local paren_count\
    \ = 0\n    for j = 1, #paren_list[i] do\n      if paren_list[i]:sub(j, j) == '('\
    \ then\n        open = open + 1\n      elseif paren_list[i]:sub(j, j) == ')' then\n\
    \        closed = closed + 1\n      end\n      if open == closed then\n      \
    \  paren_count = open\n        break\n      end\n    end\n    nested_list[i] =\
    \ paren_count\n  end\n  return nested_list\nend", "    local max_nest_counts =\
    \ {}\n    for paren_group in paren_string:gmatch('%s*%b()%s*') do\n        local\
    \ nest_count = 0\n        local max_nest_count = 0\n        for paren in paren_group:gmatch('[()]')\
    \ do\n            if paren == '(' then\n                nest_count = nest_count\
    \ + 1\n            else\n                nest_count = nest_count - 1\n       \
    \     end\n            if nest_count > max_nest_count then\n                max_nest_count\
    \ = nest_count\n            end\n        end\n        table.insert(max_nest_counts,\
    \ max_nest_count)\n    end\n    return max_nest_counts\nend", "    local nests\
    \ = {}\n    for group in string.gmatch(paren_string, '%s*%b()%s*') do\n      \
    \  local depth = 0\n        local max_depth = 0\n        for c in string.gmatch(group,\
    \ '%S') do\n            if c == '(' then\n                depth = depth + 1\n\
    \                if depth > max_depth then\n                    max_depth = depth\n\
    \                end\n            elseif c == ')' then\n                depth\
    \ = depth - 1\n            end\n        end\n        nests[#nests + 1] = max_depth\n\
    \    end\n    return nests\nend", "    local paren_groups = split(paren_string,\
    \ '%s+')\n    local paren_nesting = {}\n    for _, paren_group in ipairs(paren_groups)\
    \ do\n        paren_nesting[#paren_nesting + 1] = parse_nested_parens_single(paren_group)\n\
    \    end\n    return paren_nesting\nend", "  local paren_tokens = split(paren_string,\
    \ ' ')\n  local max_levels = {}\n  for _, paren_token in ipairs(paren_tokens)\
    \ do\n    local level = 0\n    local max_level = 0\n    for i = 1, #paren_token\
    \ do\n      if paren_token:sub(i, i) == '(' then\n        level = level + 1\n\
    \        if level > max_level then\n          max_level = level\n        end\n\
    \      elseif paren_token:sub(i, i) == ')' then\n        level = level - 1\n \
    \     end\n    end\n    table.insert(max_levels, max_level)\n  end\n  return max_levels\n\
    end", "    -- Count number of opening parentheses\n    local count = 0\n    local\
    \ max = 0\n    local result = {}\n    for paren in paren_string:gmatch('[()]')\
    \ do\n        if paren == '(' then\n            count = count + 1\n          \
    \  if count > max then\n                max = count\n            end\n       \
    \ elseif paren == ')' then\n            if count > 0 then\n                count\
    \ = count - 1\n            end\n        end\n    end\n    table.insert(result,\
    \ max)\n    -- Don't have to check if count is 0 here because removing the first\
    \ '(' and last ')' in the input string\n    -- only makes the string shorter.\
    \ It won't make it such that the number of '(' doesn't equal the number of ')'.\n\
    \    return result\nend", "  local ret = {}\n  for paren_group in paren_string:gmatch('[^%s]+')\
    \ do\n    local depth = 0\n    local max_depth = 0\n    for char in paren_group:gmatch('.')\
    \ do\n      if char == '(' then\n        depth = depth + 1\n        max_depth\
    \ = math.max(max_depth, depth)\n      elseif char == ')' then\n        depth =\
    \ depth - 1\n      end\n    end\n    table.insert(ret, max_depth)\n  end\n  return\
    \ ret\nend", "    -- Split the string by spaces.\n    local group_tokens = tokenizer.tokenize(paren_string,\
    \ ' ')\n    -- Trim the string of parentheses.\n    local paren_trimmed_tokens\
    \ = {}\n    for _, token in ipairs(group_tokens) do\n        table.insert(paren_trimmed_tokens,\
    \ token:gsub('%(', ''):gsub('%)', ''))\n    end\n    -- Count the maximum number\
    \ of nested parentheses.\n    local max_nested_parens = {}\n    for _, paren_trimmed_token\
    \ in ipairs(paren_trimmed_tokens) do\n        local token_max_nested_parens =\
    \ 0\n        for _, _ in paren_trimmed_token:gmatch('%(') do\n            token_max_nested_parens\
    \ = token_max_nested_parens + 1\n        end\n        table.insert(max_nested_parens,\
    \ token_max_nested_parens)\n    end\n    return max_nested_parens\nend", "   \
    \ local paren_levels = {}\n    local level = 0\n    for i=1, #paren_string do\n\
    \        if paren_string:sub(i, i) == '(' then\n            level = level + 1\n\
    \        elseif paren_string:sub(i, i) == ')' then\n            level = level\
    \ - 1\n        elseif paren_string:sub(i, i) == ' ' then\n            table.insert(paren_levels,\
    \ level)\n            level = 0\n        end\n    end\n    table.insert(paren_levels,\
    \ level)\n    return paren_levels\nend", "    local tab = {}\n    for paren_group\
    \ in paren_string:gmatch('%S+') do\n        local max_depth = 0\n        local\
    \ depth = 0\n        for c in paren_group:gmatch('.') do\n            if c ==\
    \ '(' then\n                depth = depth + 1\n                if depth > max_depth\
    \ then\n                    max_depth = depth\n                end\n         \
    \   elseif c == ')' then\n                depth = depth - 1\n            end\n\
    \        end\n        table.insert(tab, max_depth)\n    end\n    return tab\n\
    end", "  local levels = {}\n  local count = 0\n  for c in paren_string:gmatch('.')\
    \ do\n    if c == '(' then\n      count = count + 1\n    elseif c == ')' then\n\
    \      count = count - 1\n    elseif c == ' ' then\n      table.insert(levels,\
    \ count)\n      count = 0\n    end\n  end\n  return levels\nend", "  local result\
    \ = {}\n  local current_group = {}\n  local paren_stack = {}\n  for c in paren_string:gmatch'.'\
    \ do\n    table.insert(current_group, c)\n    if c == '(' then\n      table.insert(paren_stack,\
    \ c)\n    elseif c == ')' then\n      table.remove(paren_stack)\n    end\n   \
    \ if c == ' ' or c == paren_string:sub(-1) then\n      table.insert(result, #paren_stack)\n\
    \      paren_stack = {}\n      current_group = {}\n    end\n  end\n  return result\n\
    end", "    local group_max_depth = {}\n    for group in paren_string:gmatch(\"\
    %S+\") do\n        local depth = 0\n        local max_depth = 0\n        for paren\
    \ in group:gmatch(\"%S\") do\n            if paren == '(' then\n             \
    \   depth = depth + 1\n            elseif paren == ')' then\n                depth\
    \ = depth - 1\n            end\n            if depth > max_depth then\n      \
    \          max_depth = depth\n            end\n        end\n        table.insert(group_max_depth,\
    \ max_depth)\n    end\n    return group_max_depth\nend", "    local substrings\
    \ = split(paren_string, '%s+')\n    local paren_levels = {}\n    for k,v in pairs(substrings)\
    \ do\n        local level = 1\n        for i=1,#v do\n            if string.byte(v,\
    \ i) == 40 then\n                level = level + 1\n            elseif string.byte(v,\
    \ i) == 41 then\n                level = level - 1\n            end\n        end\n\
    \        paren_levels[k] = level\n    end\n    return paren_levels\nend", "  \
    \  local counter = 0\n    local paren_level = {}\n    for c in paren_string:gmatch('.')\
    \ do\n        if c == '(' then\n            counter = counter + 1\n        elseif\
    \ c == ')' then\n            table.insert(paren_level, counter)\n            counter\
    \ = counter - 1\n        end\n    end\n    return paren_level\nend", "    local\
    \ paren_levels = {}\n    local level = 0\n    for c in paren_string:gmatch('.')\
    \ do\n        if c == '(' then\n            level = level + 1\n        elseif\
    \ c == ')' then\n            level = level - 1\n        end\n        table.insert(paren_levels,\
    \ level)\n    end\n    return paren_levels\nend", "  -- Assuming paren_string\
    \ is a string represented multiple groups for nested parentheses\n  -- separated\
    \ by spaces.\n  -- The function returns the deepest level of nesting of parentheses\
    \ for each group.\n  local max_depth = 0\n  local current_depth = 0\n  local result\
    \ = {}\n  for s in paren_string:gmatch('[^%s]+') do\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        current_depth = current_depth + 1\n    \
    \    if current_depth > max_depth then\n          max_depth = current_depth\n\
    \        end\n      elseif c == ')' then\n        current_depth = current_depth\
    \ - 1\n      end\n    end\n    table.insert(result, max_depth)\n    max_depth\
    \ = 0\n    current_depth = 0\n  end\n  return result\nend", "    local paren_groups\
    \ = stringx.split(paren_string, '%s+')\n    local nested_parens = {}\n    for\
    \ _, group in ipairs(paren_groups) do\n        local stack = {}\n        local\
    \ max_nesting = 0\n        for i = 1, #group do\n            local bracket = group:sub(i,\
    \ i)\n            if bracket == '(' then\n                table.insert(stack,\
    \ bracket)\n            elseif bracket == ')' then\n                table.remove(stack)\n\
    \            end\n            max_nesting = math.max(max_nesting, #stack)\n  \
    \      end\n        table.insert(nested_parens, max_nesting)\n    end\n    return\
    \ nested_parens\nend", "    local paren_nesting = {}\n    for group in string.gmatch(paren_string,\
    \ '%([^)]*%)') do\n        local nesting = 0\n        for _ in string.gmatch(group,\
    \ '%b()') do\n            nesting = nesting + 1\n        end\n        table.insert(paren_nesting,\
    \ nesting)\n    end\n    return paren_nesting\nend", "    local token_begin =\
    \ 1\n    local token_end = 1\n    local level = 0\n    local max_level = 0\n \
    \   local result = {}\n    local current_state = 'START'\n    local i = 1\n  \
    \  while i <= #paren_string do\n        local char = paren_string:sub(i, i)\n\
    \        if current_state == 'START' then\n            if char == '(' then\n \
    \               token_begin = i\n                level = level + 1\n         \
    \       max_level = level\n                current_state = 'NESTED'\n        \
    \    elseif char == ' ' then\n                current_state = 'START'\n      \
    \      else\n                -- error condition\n                return {}\n \
    \           end\n        elseif current_state == 'NESTED' then\n            if\
    \ char == '(' then\n                level = level + 1\n                max_level\
    \ = level\n            elseif char == ')' then\n                level = level\
    \ - 1\n                if level == 0 then\n                    token_end = i\n\
    \                    result[#result + 1] = max_level\n                    max_level\
    \ = 0\n                    current_state = 'END'\n                end\n      \
    \      else\n                -- error condition\n                return {}\n \
    \           end\n        elseif current_state == 'END' then\n            if char\
    \ == ' ' then\n                current_state = 'START'\n            else\n   \
    \             -- error condition\n                return {}\n            end\n\
    \        end\n        i = i + 1\n    end\n    return result\nend", "  -- Find\
    \ the positions of the parentheses\n  local left_parens = {}\n  local right_parens\
    \ = {}\n  for i = 1, #paren_string do\n    if paren_string:sub(i, i) == '(' then\n\
    \      table.insert(left_parens, i)\n    elseif paren_string:sub(i, i) == ')'\
    \ then\n      table.insert(right_parens, i)\n    end\n  end", "    local depth_list\
    \ = {}\n    for paren_group in string.gmatch(paren_string, '[^%s]+') do\n    \
    \    local nest_depth = get_nested_depth(paren_group)\n        table.insert(depth_list,\
    \ nest_depth)\n    end\n    return depth_list\nend", "    local t = {}\n    for\
    \ paren in string.gmatch(paren_string, '%S+') do\n        local depth = 0\n  \
    \      local max_depth = 0\n        for c in paren:gmatch('.') do\n          \
    \  if c == '(' then\n                depth = depth + 1\n                max_depth\
    \ = math.max(max_depth, depth)\n            elseif c == ')' then\n           \
    \     depth = depth - 1\n            end\n        end\n        table.insert(t,\
    \ max_depth)\n    end\n    return t\nend", "    local paren_count = {}\n    local\
    \ max_count = 0\n    local paren_level = 0\n    for paren in paren_string:gmatch(\"\
    ()%((%(%))\") do\n        paren_level = paren_level + 1\n        if paren == paren_level\
    \ then\n            paren_count[paren_level] = paren_count[paren_level] + 1\n\
    \        else\n            paren_count[paren_level] = 0\n        end\n       \
    \ max_count = math.max(max_count, paren_count[paren_level])\n    end\n    return\
    \ paren_count\nend", "    local depth = 0\n    local depth_list = {}\n    for\
    \ match in paren_string:gmatch('%b()') do\n        depth = depth + 1\n       \
    \ local _, count = match:gsub('()', '()')\n        depth_list[depth] = count\n\
    \        depth = depth - 1\n    end\n    return depth_list\nend", "    local level\
    \ = 0\n    local max_level = 0\n    local max_level_list = {}\n    for paren in\
    \ paren_string:gmatch('[()]') do\n        if paren == '(' then\n            level\
    \ = level + 1\n            if level > max_level then\n                max_level\
    \ = level\n            end\n        elseif paren == ')' then\n            max_level_list[#max_level_list\
    \ + 1] = max_level\n            level = level - 1\n        end\n    end\n    return\
    \ max_level_list\nend", "    local paren_max_level = {}\n    -- Output paren_max_level\n\
    \    return paren_max_level\nend", "    if paren_string:match('%(%s*%)%s*$') then\
    \ return {0} end\n    local results = {}\n    local levels = {}\n    local open_paren_pat\
    \ = '%('\n    local close_paren_pat = '%)'\n    local level = 0\n    local last_seen_level\
    \ = 0\n    local i = 1\n    while i <= #paren_string do\n        local char =\
    \ paren_string:sub(i, i)\n        if char:match(open_paren_pat) then\n       \
    \     level = level + 1\n            last_seen_level = last_seen_level + 1\n \
    \           table.insert(levels, last_seen_level)\n        elseif char:match(close_paren_pat)\
    \ then\n            last_seen_level = table.remove(levels)\n        elseif char:match('%s')\
    \ then\n            if level > 0 then\n                table.insert(results, level)\n\
    \            end\n            level = 0\n            last_seen_level = 0\n   \
    \     end\n        i = i + 1\n    end\n    if level > 0 then\n        table.insert(results,\
    \ level)\n    end\n    return results\nend", "    local paren_groups = stringx.split(paren_string,\
    \ '%s+')\n    local paren_levels = {}\n    for i = 1, #paren_groups do\n     \
    \   paren_levels[i] = 0\n        local paren_count = 0\n        for j = 1, string.len(paren_groups[i])\
    \ do\n            if string.sub(paren_groups[i], j, j) == '(' then\n         \
    \       paren_count = paren_count + 1\n            elseif string.sub(paren_groups[i],\
    \ j, j) == ')' then\n                paren_count = paren_count - 1\n         \
    \   end\n            if paren_count > paren_levels[i] then\n                paren_levels[i]\
    \ = paren_count\n            end\n        end\n    end\n    return paren_levels\n\
    end", "    paren_string = string.gsub(paren_string, \" \", \"\")\n    local stack\
    \ = {}\n    local depth = 0\n    local depth_list = {}\n    for c in paren_string:gmatch(\"\
    .\") do\n        if c == \"(\" then\n            table.insert(stack, c)\n    \
    \        depth = depth + 1\n        elseif c == \")\" then\n            table.remove(stack)\n\
    \            table.insert(depth_list, depth)\n            depth = depth - 1\n\
    \        end\n    end\n    return depth_list\nend", "  -- paren_string is a string\
    \ representing multiple groups of nested parentheses separated by spaces.\n  --\
    \ For each of the group, output the deepest level of nesting of parentheses.\n\
    \  -- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \  local paren_groups = stringx.split(paren_string, ' ')\n  local max_nesting\
    \ = {}\n  for i = 1, #paren_groups do\n    -- count the number of times the following\
    \ pattern occurs in the string.\n    local count = select(2, string.gsub(paren_groups[i],\
    \ \"%(\", \"\"))\n    table.insert(max_nesting, count)\n  end\n  return max_nesting\n\
    end", "\tlocal paren_groups = split(paren_string, ' ')\n\tlocal paren_counts =\
    \ {}\n\tfor i = 1, #paren_groups do\n\t\tlocal paren_group = paren_groups[i]\n\
    \t\tlocal count = 1\n\t\tlocal max_count = 1\n\t\tfor j = 1, #paren_group do\n\
    \t\t\tlocal c = paren_group:sub(j, j)\n\t\t\tif c == '(' then\n\t\t\t\tcount =\
    \ count + 1\n\t\t\t\tif count > max_count then\n\t\t\t\t\tmax_count = count\n\t\
    \t\t\tend\n\t\t\telseif c == ')' then\n\t\t\t\tcount = count - 1\n\t\t\tend\n\t\
    \tend\n\t\ttable.insert(paren_counts, max_count)\n\tend\n\treturn paren_counts\n\
    end", "    local groups = {}\n    for group in paren_string:gmatch('%S+') do\n\
    \        local max_level = 0\n        local level = 0\n        for c in group:gmatch('.')\
    \ do\n            if c == '(' then\n                level = level + 1\n      \
    \          max_level = math.max(max_level, level)\n            elseif c == ')'\
    \ then\n                level = level - 1\n            end\n        end\n    \
    \    table.insert(groups, max_level)\n    end\n    return groups\nend", "  local\
    \ nested_levels = {}\n  for paren_group in paren_string:gmatch('%S+') do\n   \
    \ local nesting_level = 0\n    local max_nesting_level = 0\n    for c in paren_group:gmatch('.')\
    \ do\n      if c == '(' then\n        nesting_level = nesting_level + 1\n    \
    \  elseif c == ')' then\n        nesting_level = nesting_level - 1\n      end\n\
    \      max_nesting_level = math.max(max_nesting_level, nesting_level)\n    end\n\
    \    table.insert(nested_levels, max_nesting_level)\n  end\n  return nested_levels\n\
    end", "    local groups = string.split(paren_string, ' ')\n    local max_levels\
    \ = torch.Tensor(#groups)\n    for i, group in ipairs(groups) do\n        local\
    \ levels = 0\n        local max_level = 0\n        for paren in group:gmatch('[()]')\
    \ do\n            if paren == '(' then\n                levels = levels + 1\n\
    \            else\n                levels = levels - 1\n            end\n    \
    \        max_level = math.max(max_level, levels)\n        end\n        max_levels[i]\
    \ = max_level\n    end\n    return max_levels\nend", "  local utils = require\
    \ 'utils'\n  local match = utils.match\n  local split = utils.split", "  local\
    \ deepest_nesting = {}\n  for group in paren_string:gmatch('%b()') do\n    local\
    \ level = parse_parens(group)\n    table.insert(deepest_nesting, level)\n  end\n\
    \  return deepest_nesting\nend", "    local tab = {}\n    for w in paren_string:gmatch('%S+')\
    \ do\n        local count = 0\n        for c in w:gmatch('%b()') do\n        \
    \    count = count + 1\n        end\n        table.insert(tab, count)\n    end\n\
    \    return tab\nend", "    local splitted = torch.split(paren_string, ' ')\n\
    \    local max_depth = 0\n    local depths = {}\n    for _, paren in ipairs(splitted)\
    \ do\n        local depth = 0\n        for c in paren:gmatch'.' do\n         \
    \   if c == '(' then\n                depth = depth + 1\n            elseif c\
    \ == ')' then\n                depth = depth - 1\n            end\n        end\n\
    \        table.insert(depths, depth)\n    end\n    return depths\nend", "\tlocal\
    \ paren_groups = string.split(paren_string, ' ')\n\tlocal max_levels = {}\n\t\
    for i, paren_group in ipairs(paren_groups) do\n\t\tlocal paren_count = 0\n\t\t\
    local max_level = 0\n\t\tfor j = 1, #paren_group do\n\t\t\tlocal c = paren_group:sub(j,\
    \ j)\n\t\t\tif c == '(' then\n\t\t\t\tparen_count = paren_count + 1\n\t\t\t\t\
    if paren_count > max_level then\n\t\t\t\t\tmax_level = paren_count\n\t\t\t\tend\n\
    \t\t\telseif c == ')' then\n\t\t\t\tparen_count = paren_count - 1\n\t\t\tend\n\
    \t\tend\n\t\tmax_levels[i] = max_level\n\tend\n\treturn max_levels\nend", "  local\
    \ paren_levels = {}\n  -- For each group, we first split the input into separate\
    \ groups of parentheses\n  -- We then parse each group, and record the max depth\
    \ of the group\n  -- Note: there is no need to reset the depth counter each time\
    \ a group is parsed.\n  --       The last group will reset it to zero.\n  for\
    \ _, paren_group in pairs(stringx.split(paren_string, ' ')) do\n    for _, paren\
    \ in pairs(stringx.split(paren_group, '')) do\n      if paren == '(' then\n  \
    \      nested_paren_depth = nested_paren_depth + 1\n      elseif paren == ')'\
    \ then\n        nested_paren_depth = nested_paren_depth - 1\n      end\n     \
    \ max_nested_paren_depth = math.max(max_nested_paren_depth, nested_paren_depth)\n\
    \    end\n    table.insert(paren_levels, max_nested_paren_depth)\n  end\n  return\
    \ paren_levels\nend", "    local max_depth = 0\n    local cur_depth = 0\n    local\
    \ depths = {}\n    for c in paren_string:gmatch'.' do\n        if c == '(' then\n\
    \            cur_depth = cur_depth + 1\n            max_depth = math.max(max_depth,\
    \ cur_depth)\n        elseif c == ')' then\n            cur_depth = cur_depth\
    \ - 1\n        elseif c == ' ' then\n            table.insert(depths, max_depth)\n\
    \            max_depth = 0\n            cur_depth = 0\n        end\n    end\n\
    \    return depths\nend", "  local levels = {}\n  local depth = 0\n  for c in\
    \ paren_string:gmatch('.') do\n    if c == '(' then\n      depth = depth + 1\n\
    \    elseif c == ')' then\n      depth = depth - 1\n    end\n    if c == ' ' then\n\
    \      table.insert(levels, depth)\n      depth = 0\n    end\n  end\n  return\
    \ levels\nend", "    local max_depth = 0\n    local ret = {}\n    for paren in\
    \ paren_string:gmatch('%b()') do\n        local depth = 0\n        for c in paren:gmatch('%b()')\
    \ do\n            depth = depth + 1\n        end\n        ret[#ret + 1] = depth\n\
    \    end\n    return ret\nend", "\tlocal result = {}\n\t-- TODO: need to write\n\
    \treturn result\nend", "    local stacks = {}\n    local index = 1\n    local\
    \ current_stack = {}\n    local depth_list = {}\n    for paren in paren_string:gmatch('.')\
    \ do\n        if paren == '(' then\n            table.insert(current_stack, paren)\n\
    \        elseif paren == ')' then\n            if #current_stack == 0 then\n \
    \               table.insert(stacks, current_stack)\n                current_stack\
    \ = {}\n                index = index + 1\n            else\n                table.remove(current_stack)\n\
    \            end\n        elseif paren == ' ' then\n            table.insert(stacks,\
    \ current_stack)\n            current_stack = {}\n            index = index +\
    \ 1\n        end\n    end\n    if #current_stack > 0 then\n        table.insert(stacks,\
    \ current_stack)\n    end\n    for _, v in ipairs(stacks) do\n        table.insert(depth_list,\
    \ #v)\n    end\n    return depth_list\nend", "    local levels = {}\n    local\
    \ function parse_parens(paren_string)\n        local level = 0\n        local\
    \ max_level = 0\n        for c in paren_string:gmatch('.') do\n            if\
    \ c == '(' then\n                level = level + 1\n                max_level\
    \ = math.max(max_level, level)\n            elseif c == ')' then\n           \
    \     level = level - 1\n            end\n        end\n        return max_level\n\
    \    end\n    for paren_group in paren_string:gmatch('%s*%b()%s*') do\n      \
    \  table.insert(levels, parse_parens(paren_group))\n    end\n    return levels\n\
    end", "    local group_depth = {}\n    local n_parens = 0\n    for i, paren in\
    \ utf8.next, paren_string do\n        if paren == '(' then\n            n_parens\
    \ = n_parens + 1\n        elseif paren == ')' then\n            n_parens = n_parens\
    \ - 1\n        elseif paren == ' ' then\n            table.insert(group_depth,\
    \ n_parens)\n            n_parens = 0\n        end\n    end\n    table.insert(group_depth,\
    \ n_parens)\n    return group_depth\nend", "    local res = {}\n    local seg\
    \ = stringx.split(paren_string, ' ')\n    for _, s in ipairs(seg) do\n       \
    \ local paren_stack = {}\n        local depth = 0\n        for i = 1, #s do\n\
    \            local c = s:sub(i, i)\n            if c == '(' then\n           \
    \     depth = depth + 1\n                table.insert(paren_stack, depth)\n  \
    \          elseif c == ')' then\n                table.remove(paren_stack)\n \
    \           end\n        end\n        res[#res + 1] = depth\n    end\n    return\
    \ res\nend", "  local parse_stack = {}\n  local max_nesting = 0\n  local output\
    \ = {}\n  local nesting = 0\n  for char in paren_string:gmatch'.' do\n    if char\
    \ == '(' then\n      table.insert(parse_stack, char)\n      nesting = nesting\
    \ + 1\n      if nesting > max_nesting then\n        max_nesting = nesting\n  \
    \    end\n    elseif char == ')' then\n      table.remove(parse_stack)\n     \
    \ nesting = nesting - 1\n    elseif char == ' ' then\n      table.insert(output,\
    \ max_nesting)\n      max_nesting = 0\n      nesting = 0\n    end\n  end\n  return\
    \ output\nend", "  local lvl_dict = {}\n  local lvl_cnt = 0\n  local lvl_max =\
    \ 0\n  local lvl_list = {}\n  local lvl_idx = 1\n  local char_idx = 1\n  local\
    \ char_cnt = string.len(paren_string)\n  while char_idx <= char_cnt do\n    local\
    \ c = string.sub(paren_string, char_idx, char_idx)\n    if c == '(' then\n   \
    \   lvl_cnt = lvl_cnt + 1\n      if lvl_cnt > lvl_max then\n        lvl_max =\
    \ lvl_cnt\n      end\n    elseif c == ')' then\n      lvl_cnt = lvl_cnt - 1\n\
    \    elseif c == ' ' then\n      if lvl_cnt > 0 then\n        lvl_list[lvl_idx]\
    \ = lvl_max\n        lvl_idx = lvl_idx + 1\n        lvl_max = 0\n      end\n \
    \   end\n    char_idx = char_idx + 1\n  end\n  return lvl_list\nend", "  local\
    \ count_stack = {}\n  local max_count = 0\n  local count = 0\n  local group_counts\
    \ = {}\n  for char in paren_string:gmatch('%S') do\n    if char == '(' then\n\
    \      count = count + 1\n      if count > max_count then\n        max_count =\
    \ count\n      end\n    elseif char == ')' then\n      table.insert(count_stack,\
    \ count)\n      count = count - 1\n    elseif char == ' ' then\n      if count\
    \ ~= 0 then\n        error('Bad paren string!')\n      end\n      table.insert(group_counts,\
    \ table.remove(count_stack))\n    end\n  end\n  return group_counts\nend", " \
    \ local open_paren_stack = {}\n  local count_stack = {}\n  local max_count = 0\n\
    \  local count = 0\n  for i = 1, #paren_string do\n    if paren_string:sub(i,\
    \ i) == '(' then\n      table.insert(open_paren_stack, 1)\n      count = count\
    \ + 1\n      max_count = math.max(max_count, count)\n    elseif paren_string:sub(i,\
    \ i) == ')' then\n      count = count - 1\n      if open_paren_stack[1] == 1 then\n\
    \        table.remove(open_paren_stack, 1)\n        table.insert(count_stack,\
    \ max_count)\n        max_count = 0\n        count = 0\n      end\n    end\n \
    \ end\n  return count_stack\nend", "  local max_levels = {}\n  for group in paren_string:gmatch('%b()')\
    \ do\n    local level = 0\n    for char in group:gmatch('[()]') do\n      if char\
    \ == '(' then\n        level = level + 1\n      else\n        level = level -\
    \ 1\n      end\n    end\n    table.insert(max_levels, level)\n  end\n  return\
    \ max_levels\nend", "    local result = {}\n    local groups = utils.split(paren_string,\
    \ ' ')\n    for i = 1, #groups do\n        local sub_groups = utils.split(groups[i],\
    \ '')\n        local level = 0\n        local max_level = 0\n        for j = 1,\
    \ #sub_groups do\n            local sub_group = sub_groups[j]\n            if\
    \ sub_group == '(' then\n                level = level + 1\n            elseif\
    \ sub_group == ')' then\n                level = level - 1\n            end\n\
    \            if level > max_level then\n                max_level = level\n  \
    \          end\n        end\n        result[i] = max_level\n    end\n    return\
    \ result\nend", "    local groups = {}\n    for group in paren_string:gmatch('%S+')\
    \ do\n        table.insert(groups, parse_parens(group))\n    end\n    return groups\n\
    end", "    -- TODO\n    local t = {}\n    local start = 1\n    local i = 1\n \
    \   while i <= #paren_string do\n        local char = paren_string:sub(i, i)\n\
    \        if char == ' ' then\n            table.insert(t, paren_string:sub(start,\
    \ i - 1))\n            start = i + 1\n        end\n        i = i + 1\n    end\n\
    \    table.insert(t, paren_string:sub(start, i - 1))\n    local res = {}\n   \
    \ for i = 1, #t do\n        local s = t[i]\n        local cnt = 0\n        local\
    \ level = 0\n        for j = 1, #s do\n            local char = s:sub(j, j)\n\
    \            if char == '(' then\n                cnt = cnt + 1\n            \
    \    if cnt > level then\n                    level = cnt\n                end\n\
    \            elseif char == ')' then\n                cnt = cnt - 1\n        \
    \    end\n        end\n        table.insert(res, level)\n    end\n    return res\n\
    end", "\tlocal max_depth = 0\n\tlocal depth = 0\n\tlocal depths = {}\n\tfor i\
    \ = 1, string.len(paren_string) do\n\t\tlocal char = string.sub(paren_string,\
    \ i, i)\n\t\tif char == '(' then\n\t\t\tdepth = depth + 1\n\t\t\tif depth > max_depth\
    \ then\n\t\t\t\tmax_depth = depth\n\t\t\tend\n\t\telseif char == ')' then\n\t\t\
    \ttable.insert(depths, max_depth)\n\t\t\tdepth = 0\n\t\t\tmax_depth = 0\n\t\t\
    end\n\tend\n\treturn depths\nend", "    local paren_groups = {}\n    for paren_group\
    \ in paren_string:gmatch('%s*%(%s*(%b())%s*') do\n        table.insert(paren_groups,\
    \ paren_group)\n    end\n    local depths = {}\n    for i, paren_group in ipairs(paren_groups)\
    \ do\n        local depth = 0\n        local depth_max = 0\n        for c in paren_group:gmatch('.')\
    \ do\n            if c == '(' then\n                depth = depth + 1\n      \
    \      elseif c == ')' then\n                depth = depth - 1\n            end\n\
    \            if depth > depth_max then\n                depth_max = depth\n  \
    \          end\n        end\n        depths[i] = depth_max\n    end\n    return\
    \ depths\nend", "  paren_string = paren_string:gsub(' ', '')\n  local paren_stack\
    \ = {}\n  local level = 0\n  local max_level = 0\n  local groups = {}\n  for c\
    \ in paren_string:gmatch('.') do\n    if c == '(' then\n      level = level +\
    \ 1\n      table.insert(paren_stack, c)\n    elseif c == ')' then\n      level\
    \ = level - 1\n      if level < 0 then\n        -- error\n        return nil\n\
    \      end\n      table.remove(paren_stack)\n    end\n    if #paren_stack == 0\
    \ then\n      table.insert(groups, max_level)\n      max_level = 0\n    else\n\
    \      max_level = math.max(max_level, level)\n    end\n  end\n  return groups\n\
    end", "    local paren_groups = paren_string:split(\"%s+\")\n    local result\
    \ = {}\n    for _, group in ipairs(paren_groups) do\n        local count = 0\n\
    \        local max_count = 0\n        for i = 1, #group do\n            local\
    \ ch = group:sub(i, i)\n            if ch == '(' then\n                count =\
    \ count + 1\n            elseif ch == ')' then\n                if count > max_count\
    \ then\n                    max_count = count\n                end\n         \
    \       count = count - 1\n            end\n        end\n        if count ~= 0\
    \ then\n            return nil\n        end\n        table.insert(result, max_count)\n\
    \    end\n    return result\nend", "    local max_nesting_per_group = {}\n   \
    \ for group in paren_string:gmatch('%S+') do\n        local current_nesting =\
    \ 0\n        local max_nesting = 0\n        for paren in group:gmatch('%(|%)')\
    \ do\n            if paren == '(' then\n                current_nesting = current_nesting\
    \ + 1\n            else\n                current_nesting = current_nesting - 1\n\
    \            end\n            max_nesting = math.max(max_nesting, current_nesting)\n\
    \        end\n        assert(current_nesting == 0, \"Unmatched parentheses in:\
    \ \" .. group)\n        table.insert(max_nesting_per_group, max_nesting)\n   \
    \ end\n    return max_nesting_per_group\nend", "    local n_paren_groups = select(2,\
    \ paren_string:gsub(' ', ' ')) + 1\n    local max_nesting = torch.IntTensor(n_paren_groups)\n\
    \    local cur_group_index = 1\n    local cur_nesting = 0\n    for current_paren,\
    \ closing_paren in paren_string:gmatch('()()') do\n        cur_nesting = cur_nesting\
    \ + (closing_paren - current_paren > 0 and -1 or 1)\n        max_nesting[cur_group_index]\
    \ = math.max(max_nesting[cur_group_index], cur_nesting)\n        if closing_paren\
    \ % 2 == 0 then\n            cur_group_index = cur_group_index + 1\n        end\n\
    \    end\n    return max_nesting\nend", "    local paren_groups = {}\n    for\
    \ group in stringx.split(paren_string, ' ') do\n        local paren_count = 0\n\
    \        local max_paren_count = 0\n        for char in stringx.split(group, '')\
    \ do\n            if char == '(' then\n                paren_count = paren_count\
    \ + 1\n                if paren_count > max_paren_count then\n               \
    \     max_paren_count = paren_count\n                end\n            elseif char\
    \ == ')' then\n                paren_count = paren_count - 1\n            end\n\
    \        end\n        paren_groups[#paren_groups + 1] = max_paren_count\n    end\n\
    \    return paren_groups\nend", "    local depth_list = {}\n    for paren_group\
    \ in paren_string:gmatch('%b()') do\n        local depth = 0\n        local max_depth\
    \ = 0\n        for paren in paren_group:gmatch('%b()') do\n            depth =\
    \ depth + 1\n            max_depth = math.max(max_depth, depth)\n        end\n\
    \        table.insert(depth_list, max_depth)\n    end\n    return depth_list\n\
    end", "\tlocal group_list = utils.split(paren_string, ' ')\n\tlocal output = {}\n\
    \tfor _, group in ipairs(group_list) do\n\t\tlocal count = 0\n\t\tlocal max_count\
    \ = 0\n\t\tfor _, letter in ipairs(group) do\n\t\t\tif letter == '(' then\n\t\t\
    \t\tcount = count + 1\n\t\t\telseif letter == ')' then\n\t\t\t\tcount = count\
    \ - 1\n\t\t\tend\n\t\t\tif count > max_count then\n\t\t\t\tmax_count = count\n\
    \t\t\tend\n\t\tend\n\t\ttable.insert(output, max_count)\n\tend\n\treturn output\n\
    end", "    local counters = {}\n    local stack = Stack()\n    local max = 0\n\
    \    local max_cnt = 0\n    local paren_level = 1\n    for _, c in ipairs(string.split(paren_string,\
    \ ' ')) do\n        max = 0\n        max_cnt = 0\n        paren_level = 1\n  \
    \      stack:clear()\n        for i=1, #c do\n            local ch = c:sub(i,\
    \ i)\n            if ch == '(' then\n                stack:push(paren_level)\n\
    \                paren_level = paren_level + 1\n            elseif ch == ')' then\n\
    \                if #stack == 0 then\n                    paren_level = paren_level\
    \ - 1\n                else\n                    local pop_level = stack:pop()\n\
    \                    counters[pop_level] = (counters[pop_level] or 0) + 1\n  \
    \                  max = math.max(max, pop_level)\n                    max_cnt\
    \ = math.max(max_cnt, counters[pop_level])\n                end\n            end\n\
    \        end\n        print(paren_level)\n        print(max_cnt)\n        print('\\\
    n')\n    end\nend", "  local paren_list = {}\n  local counter = 1\n  for paren\
    \ in paren_string:gmatch('[^%s]+') do\n    local max_level = 0\n    local level\
    \ = 0\n    for p in paren:gmatch('[()]') do\n      if p == '(' then\n        level\
    \ = level + 1\n      else\n        level = level - 1\n      end\n      if level\
    \ > max_level then\n        max_level = level\n      end\n    end\n    paren_list[counter]\
    \ = max_level\n    counter = counter + 1\n  end\n  return paren_list\nend", " \
    \   -- First, for any \"()\" substring, we will remove it from the input string,\n\
    \    -- replacing with a single space. We do this by calling gsub() on paren_string.\n\
    \    -- For each match, we will write a new string with paren_string as the first\
    \ argument,\n    -- \" \" as the second argument, and a function as the third\
    \ argument.\n    -- Inside the function, we will replace each of the matched \"\
    ()\" pairs with a single space.\n    local no_nested_parens = paren_string:gsub(\"\
    %b()\", function(match)\n        return \" \"\n    end)", "    local depth_of_parens\
    \ = {}\n    local max_depth = 0\n    local current_depth = 0\n    local seen_open_paren\
    \ = false\n    local seen_close_paren = false\n    for i = 1, paren_string:len()\
    \ do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n\
    \            seen_open_paren = true\n            current_depth = current_depth\
    \ + 1\n            if current_depth > max_depth then\n                max_depth\
    \ = current_depth\n            end\n        elseif char == ')' then\n        \
    \    seen_close_paren = true\n            current_depth = current_depth - 1\n\
    \        elseif seen_open_paren and seen_close_paren then\n            seen_open_paren\
    \ = false\n            seen_close_paren = false\n            depth_of_parens[#depth_of_parens\
    \ + 1] = max_depth\n            max_depth = 0\n            current_depth = 0\n\
    \        end\n    end\n    return depth_of_parens\nend", "    local groups = {}\n\
    \    local current_group = {}\n    local last_char = ''\n    local paren_levels\
    \ = {}\n    local max_level = 0\n    local level = 0\n    local in_paren = false\n\
    \    for c in paren_string:gmatch'.' do\n        if c == ' ' then\n          \
    \  if in_paren then\n                table.insert(current_group, level)\n    \
    \            table.insert(groups, current_group)\n                current_group\
    \ = {}\n                in_paren = false\n            end\n            level =\
    \ 0\n            max_level = 0\n        elseif c == '(' then\n            level\
    \ = level + 1\n            in_paren = true\n            if level > max_level then\n\
    \                max_level = level\n            end\n        elseif c == ')' then\n\
    \            level = level - 1\n        end\n    end\n    if in_paren then\n \
    \       table.insert(current_group, level)\n        table.insert(groups, current_group)\n\
    \    end\n    for _, v in ipairs(groups) do\n        local l = 0\n        for\
    \ _, lv in ipairs(v) do\n            if lv > l then\n                l = lv\n\
    \            end\n        end\n        table.insert(paren_levels, l)\n    end\n\
    \    return paren_levels\nend", "    local res = {}\n    for _, str in ipairs(stringx.split(paren_string))\
    \ do\n        table.insert(res, utils.deepest_parens(str))\n    end\n    return\
    \ res\nend", "    -- Construct a regex to capture all the groups\n    local regex\
    \ = paren_string:gsub('%(', '(%('):gsub('%)', '%)')", "  local deepest_levels\
    \ = {}\n  for paren_string in paren_string:gmatch('[^%s]+') do\n    local level\
    \ = 0\n    local max_level = 0\n    for c in paren_string:gmatch('.') do\n   \
    \   if c == '(' then\n        level = level + 1\n      elseif c == ')' then\n\
    \        level = level - 1\n      end\n      max_level = math.max(max_level, level)\n\
    \    end\n    table.insert(deepest_levels, max_level)\n  end\n  return deepest_levels\n\
    end", "    local paren_levels = {}\n    for paren_string in string.gmatch(paren_string,\
    \ '%S+') do\n        local levels = {}\n        for c in paren_string:gmatch('.')\
    \ do\n            if c == '(' then\n                table.insert(levels, 1)\n\
    \            elseif c == ')' then\n                table.insert(levels, 0)\n \
    \           end\n        end\n        table.insert(paren_levels, sum(levels))\n\
    \    end\n    return paren_levels\nend", "    -- Corner cases.\n    if paren_string\
    \ == nil then\n        return nil\n    end\n    local results = {}\n    for group\
    \ in paren_string:gmatch('[^%s]+') do\n        if group:len() == 0 then\n    \
    \        results[#results + 1] = 1\n        else\n            local depth = 0\n\
    \            local max_depth = 0\n            for c in group:gmatch('.') do\n\
    \                if c == '(' then\n                    depth = depth + 1\n   \
    \                 if depth > max_depth then\n                        max_depth\
    \ = depth\n                    end\n                elseif c == ')' then\n   \
    \                 depth = depth - 1\n                end\n            end\n  \
    \          results[#results + 1] = max_depth\n        end\n    end\n    return\
    \ results\nend", "    local idx = 1\n    local paren_counts = {}\n    while idx\
    \ <= #paren_string do\n        local cur_count = 0\n        local remaining_parens\
    \ = 1\n        while remaining_parens > 0 do\n            if paren_string:sub(idx,\
    \ idx) == '(' then\n                cur_count = cur_count + 1\n              \
    \  remaining_parens = remaining_parens + 1\n            elseif paren_string:sub(idx,\
    \ idx) == ')' then\n                remaining_parens = remaining_parens - 1\n\
    \            end\n            idx = idx + 1\n        end\n        paren_counts[#paren_counts\
    \ + 1] = cur_count\n    end\n    return paren_counts\nend", "  local result =\
    \ {}\n  local lmax = 0\n  local p = 0\n  for c in paren_string:gmatch'.' do\n\
    \    p = c == '(' and p + 1 or c == ')' and p - 1 or p\n    lmax = math.max(lmax,\
    \ p)\n  end\n  result[#result + 1] = lmax\n  return result\nend", "    local open_parens\
    \ = {}\n    local depths = {}\n    local cur_depth = 0\n    local result = {}\n\
    \    for i = 1, string.len(paren_string) do\n        local current_char = string.sub(paren_string,\
    \ i, i)\n        if current_char == '(' then\n            table.insert(open_parens,\
    \ i)\n            cur_depth = cur_depth + 1\n        elseif current_char == ')'\
    \ then\n            table.remove(open_parens)\n            cur_depth = cur_depth\
    \ - 1\n        elseif current_char == ' ' then\n            depths[#open_parens]\
    \ = cur_depth\n        end\n    end\n    for i = 1, #depths do\n        table.insert(result,\
    \ depths[i])\n    end\n    return result\nend", "    -- Parse the input.\n   \
    \ local tokens = string.split(paren_string, ' ')\n    local paren_groups = {}\n\
    \    for i = 1, #tokens do\n        local token = tokens[i]\n        if token\
    \ ~= '' then\n            table.insert(paren_groups, token)\n        end\n   \
    \ end", "    local max_depth = {}\n    local depth = 0\n    local depth_array\
    \ = {}\n    for i = 1, paren_string:len() do\n        if paren_string:sub(i, i)\
    \ == '(' then\n            depth = depth + 1\n            if not max_depth[depth]\
    \ then\n                max_depth[depth] = true\n            end\n        elseif\
    \ paren_string:sub(i, i) == ')' then\n            depth = depth - 1\n        end\n\
    \        table.insert(depth_array, depth)\n    end\n    return utils.map(function(val)\
    \ return #max_depth - val end, depth_array)\nend", "    local t = {}\n    for\
    \ s in paren_string:gmatch('%S+') do\n        local n = 0\n        local m = 0\n\
    \        for w in s:gmatch('[()]') do\n            if w == '(' then\n        \
    \        n = n + 1\n                m = n > m and n or m\n            else\n \
    \               n = n - 1\n            end\n        end\n        t[#t + 1] = m\n\
    \    end\n    return t\nend", "    local function count_parens(paren_string)\n\
    \        local nesting = 0\n        local max_nesting = 0\n        for c in paren_string:gmatch('%b()')\
    \ do\n            nesting = nesting + 1\n            max_nesting = math.max(max_nesting,\
    \ nesting)\n        end\n        return max_nesting\n    end\n    local ret =\
    \ {}\n    for paren_group in paren_string:gmatch('%b()') do\n        table.insert(ret,\
    \ count_parens(paren_group))\n    end\n    return ret\nend", "  local depth_vec\
    \ = {}\n  local depth = 0\n  local start_index = 1\n  local string_len = #paren_string\n\
    \  while start_index <= string_len do\n    if paren_string:sub(start_index, start_index)\
    \ == '(' then\n      depth = depth + 1\n    elseif paren_string:sub(start_index,\
    \ start_index) == ')' then\n      depth = depth - 1\n    elseif paren_string:sub(start_index,\
    \ start_index) == ' ' then\n      table.insert(depth_vec, depth)\n      depth\
    \ = 0\n    end\n    start_index = start_index + 1\n  end\n  return depth_vec\n\
    end", "    local g_nested_parens = {}\n    -- print(paren_string)\n    local g_paren_string\
    \ = paren_string:split(' ')\n    for i, _v in ipairs(g_paren_string) do\n    \
    \    -- print(_v)\n        local paren_levels = {}\n        local max_level =\
    \ 0\n        for _i, _s in ipairs(_v) do\n            if _s == '(' then\n    \
    \            table.insert(paren_levels, 1)\n                if max_level < 1 then\n\
    \                    max_level = 1\n                end\n            elseif _s\
    \ == ')' then\n                table.remove(paren_levels)\n            end\n \
    \       end\n        table.insert(g_nested_parens, max_level)\n    end\n    return\
    \ g_nested_parens\nend", "  local function parse_nested_parens_helper(paren_string,\
    \ paren_level, paren_map)\n    if paren_string:len() == 0 then\n      return paren_map\n\
    \    end\n    local first_char = paren_string:sub(1, 1)\n    local rest_string\
    \ = paren_string:sub(2)\n    if first_char == '(' then\n      paren_level = paren_level\
    \ + 1\n      if paren_map[paren_level] == nil then\n        paren_map[paren_level]\
    \ = 1\n      else\n        paren_map[paren_level] = paren_map[paren_level] + 1\n\
    \      end\n    elseif first_char == ')' then\n      paren_level = paren_level\
    \ - 1\n    elseif first_char == ' ' then\n      if paren_level ~= 0 then\n   \
    \     error('Space encountered with non-zero paren level. Incorrect input to parse_nested_parens()')\n\
    \      end\n      return paren_map\n    else\n      error('Unknown character type\
    \ encountered. Incorrect input to parse_nested_parens()')\n    end\n    return\
    \ parse_nested_parens_helper(rest_string, paren_level, paren_map)\n  end\n  local\
    \ paren_map = parse_nested_parens_helper(paren_string, 0, {})\n  local max_level\
    \ = 0\n  for k, _ in pairs(paren_map) do\n    if k > max_level then\n      max_level\
    \ = k\n    end\n  end\n  local res = {}\n  for i = 1, max_level do\n    res[i]\
    \ = paren_map[i]\n  end\n  return res\nend", "    local paren_groups = utils.split(paren_string,\
    \ ' ')\n    local depth_level = {}\n    for _, group in ipairs(paren_groups) do\n\
    \        depth_level[#depth_level + 1] = count_nested_parens(group)\n    end\n\
    \    return depth_level\nend", "  local output = {}\n  for s in paren_string:gmatch('[^%s]+')\
    \ do\n    local level = 0\n    local max_level = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        level = level + 1\n        max_level = math.max(max_level,\
    \ level)\n      elseif c == ')' then\n        level = level - 1\n      end\n \
    \   end\n    output[#output + 1] = max_level\n  end\n  return output\nend", " \
    \   local result = {}\n    for group in paren_string:gmatch('[%(%)]+') do\n  \
    \      result[#result + 1] = maximum_nesting_level(group)\n    end\n    return\
    \ result\nend", "\tlocal max_levels = {}\n\tfor _, paren_group in ipairs(re.split(paren_string,\
    \ '%s+')) do\n\t\tlocal paren_group_levels = 0\n\t\tlocal paren_group_max_levels\
    \ = 0\n\t\tfor _, char in ipairs(paren_group) do\n\t\t\tif char == '(' then\n\t\
    \t\t\tparen_group_levels = paren_group_levels + 1\n\t\t\t\tif paren_group_levels\
    \ > paren_group_max_levels then\n\t\t\t\t\tparen_group_max_levels = paren_group_levels\n\
    \t\t\t\tend\n\t\t\telseif char == ')' then\n\t\t\t\tparen_group_levels = paren_group_levels\
    \ - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(max_levels, paren_group_max_levels)\n\
    \tend\n\treturn max_levels\nend", "    local paren_lists = utils.split(paren_string,\
    \ ' ')\n    local group_levels = {}\n    for _, paren_list in ipairs(paren_lists)\
    \ do\n        table.insert(group_levels, get_nested_levels(paren_list))\n    end\n\
    \    return group_levels\nend", "  local levels, level = {}, 0\n  local words\
    \ = stringx.split(paren_string)\n  for _, word in ipairs(words) do\n    if word\
    \ == '(' then\n      level = level + 1\n    elseif word == ')' then\n      level\
    \ = level - 1\n    end\n    table.insert(levels, level)\n  end\n  return levels\n\
    end", "  local deep_level = {}\n  local level = 0\n  for i = 1, #paren_string\
    \ do\n    local ch = paren_string:sub(i, i)\n    if ch == '(' then\n      level\
    \ = level + 1\n    elseif ch == ')' then\n      table.insert(deep_level, level)\n\
    \      level = level - 1\n    end\n  end\n  return deep_level\nend", "  local\
    \ paren_groups = {}\n  for group in paren_string:gmatch('[^%s]+') do\n    local\
    \ t = parse_parens(group)\n    paren_groups[#paren_groups + 1] = t[1]\n  end\n\
    \  return paren_groups\nend", "\tlocal max_level, cur_level, paren_depth = 0,\
    \ 0, {}\n\tfor paren in string.gmatch(paren_string, '[()]') do\n\t\tif paren ==\
    \ '(' then\n\t\t\tcur_level = cur_level + 1\n\t\t\tmax_level = math.max(max_level,\
    \ cur_level)\n\t\telse\n\t\t\tcur_level = cur_level - 1\n\t\tend\n\t\ttable.insert(paren_depth,\
    \ cur_level)\n\tend\n\treturn paren_depth, max_level\nend", "    local groups\
    \ = split(paren_string, ' ')\n    local depths = {}\n    for i = 1, #groups do\n\
    \        depths[i] = depth_of_nested_parens(groups[i])\n    end\n    return depths\n\
    end", "\tlocal paren_list = {}\n\tfor paren_match in paren_string:gmatch('[^%s]+')\
    \ do\n\t\tlocal count_parens = 0\n\t\tlocal max_count_parens = 0\n\t\tfor paren\
    \ in paren_match:gmatch('%b()') do\n\t\t\tcount_parens = count_parens + 1\n\t\t\
    \tif count_parens > max_count_parens then\n\t\t\t\tmax_count_parens = count_parens\n\
    \t\t\tend\n\t\tend\n\t\ttable.insert(paren_list, max_count_parens)\n\tend\n\t\
    return paren_list\nend", "    local result = {}\n    local max_depth = 0\n   \
    \ local current_depth = 0\n    for i = 1, #paren_string do\n        local paren\
    \ = paren_string:sub(i, i)\n        if paren == '(' then\n            current_depth\
    \ = current_depth + 1\n            max_depth = math.max(max_depth, current_depth)\n\
    \        elseif paren == ')' then\n            table.insert(result, max_depth)\n\
    \            current_depth = current_depth - 1\n            max_depth = 0\n  \
    \      end\n    end\n    return result\nend", "  -- Split the string on spaces\
    \ to process each group separately.\n  local paren_groups = utils.split(paren_string,\
    \ ' ')\n  local paren_depths = {}\n  -- For each group, process one character\
    \ at a time.\n  for _, paren_group in ipairs(paren_groups) do\n    local max_depth\
    \ = 0\n    local curr_depth = 0\n    for _, char in ipairs(paren_group) do\n \
    \     if char == '(' then\n        curr_depth = curr_depth + 1\n      elseif char\
    \ == ')' then\n        curr_depth = curr_depth - 1\n      end\n      max_depth\
    \ = math.max(max_depth, curr_depth)\n    end\n    table.insert(paren_depths, max_depth)\n\
    \  end\n  return paren_depths\nend", "    local tokenizer = dp.WordTokenizer()\n\
    \    local paren_tokens = tokenizer:tokenize(paren_string)\n    local num_parens\
    \ = #paren_tokens\n    local max_nesting = torch.IntTensor(num_parens)\n    local\
    \ nesting = 0\n    for i = 1, num_parens do\n        local paren_string = paren_tokens[i]\n\
    \        local num_open = 0\n        local num_close = 0\n        for j = 1, #paren_string\
    \ do\n            local char = paren_string:sub(j, j)\n            if char ==\
    \ '(' then\n                num_open = num_open + 1\n            elseif char ==\
    \ ')' then\n                num_close = num_close + 1\n            end\n     \
    \   end\n        max_nesting[i] = math.max(num_open, num_close)\n    end\n   \
    \ return max_nesting\nend", "    local paren_list = {}\n    local init_idx = 1\n\
    \    while true do\n        local left_idx = string.find(paren_string, '%(', init_idx)\n\
    \        if left_idx == nil then\n            break\n        end\n        init_idx\
    \ = left_idx\n        local right_idx = string.find(paren_string, '%)', init_idx)\n\
    \        local paren_group = string.sub(paren_string, left_idx, right_idx)\n \
    \       init_idx = right_idx + 1\n        -- print(paren_group)\n        local\
    \ left_count = string.gsub(paren_group, '%(', '')\n        local right_count =\
    \ string.gsub(paren_group, '%)', '')\n        if left_count == right_count then\n\
    \            table.insert(paren_list, left_count)\n        end\n    end\n    return\
    \ paren_list\nend", "    local depth = 0\n    local depth_list = {}\n    for ch\
    \ in stringx.chars(paren_string) do\n        if ch == '(' then\n            depth\
    \ = depth + 1\n        elseif ch == ')' then\n            table.insert(depth_list,\
    \ depth)\n            depth = depth - 1\n        end\n    end\n    return depth_list\n\
    end", "    -- O(N) implementation using a stack (LIFO).\n    local paren_table\
    \ = {}\n    local tmp_stack = {}\n    local level = 0\n    for paren in paren_string:gmatch('%S+')\
    \ do\n        paren_table[#paren_table + 1] = paren\n    end\n    for _, paren\
    \ in ipairs(paren_table) do\n        local count = 0\n        for _ in paren:gmatch('%(')\
    \ do\n            tmp_stack[#tmp_stack + 1] = '('\n            count = count +\
    \ 1\n        end\n        for _ in paren:gmatch('%)') do\n            tmp_stack[#tmp_stack]\
    \ = nil\n            count = count + 1\n        end\n        level = math.max(level,\
    \ #tmp_stack)\n        paren_table[_] = count\n    end\n    for _, paren in ipairs(paren_table)\
    \ do\n        if paren == 0 then\n            paren_table[_] = 1\n        else\n\
    \            paren_table[_] = level\n        end\n    end\n    return paren_table\n\
    end", "  local depth = {}\n  local current_depth = 0\n  local max_depth = 0\n\
    \  for i = 1, #paren_string do\n    local c = paren_string:sub(i, i)\n    if c\
    \ == '(' then\n      current_depth = current_depth + 1\n      max_depth = math.max(max_depth,\
    \ current_depth)\n    elseif c == ')' then\n      table.insert(depth, max_depth)\n\
    \      current_depth = 0\n      max_depth = 0\n    end\n  end\n  return depth\n\
    end", "  local max_level = 0\n  local level = 0\n  local res = {}\n  for c in\
    \ paren_string:gmatch('.') do\n    if c == '(' then\n      level = level + 1\n\
    \      max_level = math.max(max_level, level)\n    elseif c == ')' then\n    \
    \  level = level - 1\n    elseif c == ' ' then\n      table.insert(res, max_level)\n\
    \      max_level = 0\n      level = 0\n    end\n  end\n  table.insert(res, max_level)\n\
    \  return res\nend", "    assert(type(paren_string) == 'string')\n    local levels\
    \ = {}\n    for paren_group in paren_string:gmatch('[()]+') do\n        local\
    \ nesting_level = 0\n        local max_nesting_level = 0\n        for _, c in\
    \ ipairs(paren_group:split('')) do\n            if c == '(' then\n           \
    \     nesting_level = nesting_level + 1\n            elseif c == ')' then\n  \
    \              if nesting_level > max_nesting_level then\n                   \
    \ max_nesting_level = nesting_level\n                end\n                nesting_level\
    \ = nesting_level - 1\n            end\n        end\n        table.insert(levels,\
    \ max_nesting_level)\n    end\n    return levels\nend", "\tlocal groups = {}\n\
    \tfor group in paren_string:gmatch(\"%b()\") do\n\t\tlocal max_depth = 0\n\t\t\
    local depth = 0\n\t\tfor c in group:gmatch(\".\") do\n\t\t\tif c == \"(\" then\n\
    \t\t\t\tdepth = depth + 1\n\t\t\t\tif depth > max_depth then\n\t\t\t\t\tmax_depth\
    \ = depth\n\t\t\t\tend\n\t\t\telseif c == \")\" then\n\t\t\t\tdepth = depth -\
    \ 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(groups, max_depth)\n\tend\n\treturn\
    \ groups\nend", "  local depth_list = {}\n  for paren_group in paren_string:gmatch('%(.*?%)')\
    \ do\n    local depth = get_paren_depth(paren_group)\n    table.insert(depth_list,\
    \ depth)\n  end\n  return depth_list\nend", "    local result = {}\n    local\
    \ paren_groups = string.split(paren_string, ' ')\n    for i = 1, #paren_groups\
    \ do\n        local level = 0\n        local max_level = 0\n        for c in paren_groups[i]:gmatch'.'\
    \ do\n            if c == '(' then\n                level = level + 1\n      \
    \      elseif c == ')' then\n                level = level - 1\n            end\n\
    \            max_level = math.max(max_level, level)\n        end\n        result[i]\
    \ = max_level\n    end\n    return result\nend", "  local paren_t = tds.hash()\n\
    \  local index = 1\n  local index2 = 1\n  while index2 <= #paren_string do\n \
    \   local deepest_parens = 0\n    while index2 <= #paren_string and paren_string:sub(index2,\
    \ index2) ~= ' ' do\n      if paren_string:sub(index2, index2) == '(' then\n \
    \       deepest_parens = deepest_parens + 1\n      elseif paren_string:sub(index2,\
    \ index2) == ')' then\n        paren_t[index] = paren_t[index] or 0\n        paren_t[index]\
    \ = math.max(paren_t[index], deepest_parens)\n        deepest_parens = math.max(0,\
    \ deepest_parens - 1)\n      end\n      index2 = index2 + 1\n    end\n    index\
    \ = index + 1\n    index2 = index2 + 1\n  end\n  local res = {}\n  for i = 1,\
    \ #paren_t do\n    res[i] = paren_t[i]\n  end\n  return res\nend", "  local paren_strs\
    \ = stringx.split(paren_string)\n  local paren_levels = torch.Tensor(#paren_strs)\n\
    \  for i = 1, #paren_strs do\n    local level = 0\n    local max_level = 0\n \
    \   for j = 1, #paren_strs[i] do\n      if paren_strs[i]:sub(j, j) == '(' then\n\
    \        level = level + 1\n        max_level = math.max(max_level, level)\n \
    \     elseif paren_strs[i]:sub(j, j) == ')' then\n        level = level - 1\n\
    \      end\n    end\n    paren_levels[i] = max_level\n  end\n  return paren_levels\n\
    end", "    local n_parens_groups = 0\n    local max_depth = 0\n    local cur_depth\
    \ = 0\n    local max_depth_in_each_group = {}\n    for i = 1, #paren_string do\n\
    \        if paren_string:sub(i, i) == '(' then\n            cur_depth = cur_depth\
    \ + 1\n            if cur_depth > max_depth then\n                max_depth =\
    \ cur_depth\n            end\n        elseif paren_string:sub(i, i) == ')' then\n\
    \            cur_depth = cur_depth - 1\n        elseif paren_string:sub(i, i)\
    \ == ' ' then\n            n_parens_groups = n_parens_groups + 1\n           \
    \ max_depth_in_each_group[n_parens_groups] = max_depth\n            max_depth\
    \ = 0\n            cur_depth = 0\n        end\n    end\n    return max_depth_in_each_group\n\
    end", "\tlocal paren_list = {}\n\tlocal tmp_list = stringx.split(paren_string)\n\
    \tlocal count_list = {}\n\tlocal max_depth_list = {}\n\tfor i, w in ipairs(tmp_list)\
    \ do\n\t\tparen_list[i] = stringx.split(w)\n\tend\n\tfor i, _ in ipairs(paren_list)\
    \ do\n\t\tcount_list[i] = 0\n\t\tmax_depth_list[i] = 0\n\t\tfor j, _ in ipairs(paren_list[i])\
    \ do\n\t\t\tif paren_list[i][j] == '(' then\n\t\t\t\tcount_list[i] = count_list[i]\
    \ + 1\n\t\t\t\tif count_list[i] > max_depth_list[i] then\n\t\t\t\t\tmax_depth_list[i]\
    \ = count_list[i]\n\t\t\t\tend\n\t\t\telseif paren_list[i][j] == ')' then\n\t\t\
    \t\tcount_list[i] = count_list[i] - 1\n\t\t\tend\n\t\tend\n\tend\n\treturn max_depth_list\n\
    end", "  local paren_groups = stringx.split(paren_string, ' ')\n  local paren_levels\
    \ = {}\n  for i = 1, #paren_groups do\n    local paren_level = 0\n    local paren_group\
    \ = paren_groups[i]\n    for j = 1, #paren_group do\n      local paren = paren_group:sub(j,\
    \ j)\n      if paren == '(' then\n        paren_level = paren_level + 1\n    \
    \  elseif paren == ')' then\n        paren_level = paren_level - 1\n      end\n\
    \    end\n    table.insert(paren_levels, paren_level)\n  end\n  return paren_levels\n\
    end", "  local max_levels = {}\n  for str in paren_string:gmatch('%S+') do\n \
    \   local level = 0\n    local prev_char\n    for char in str:gmatch('.') do\n\
    \      if char == '(' then\n        level = level + 1\n      elseif char == ')'\
    \ then\n        level = level - 1\n      end\n      prev_char = char\n    end\n\
    \    -- Only allow parentheses that are nested correctly; only one level 0 and\
    \ no negative levels\n    if level == 0 and prev_char == ')' then\n      table.insert(max_levels,\
    \ level)\n    end\n  end\n  return max_levels\nend", "    local idx = 1\n    local\
    \ word = ''\n    local words = {}\n    local max_nesting = 0\n    local nesting\
    \ = 0\n    for i = 1, #paren_string do\n        local letter = paren_string:sub(i,\
    \ i)\n        if letter == ' ' then\n            if #word > 0 then\n         \
    \       words[idx] = word\n                idx = idx + 1\n                word\
    \ = ''\n            end\n        else\n            word = word .. letter\n   \
    \     end\n    end\n    if #word > 0 then\n        words[idx] = word\n    end\n\
    \    local max_levels = {}\n    for i = 1, #words do\n        local word = words[i]\n\
    \        nesting = 0\n        max_nesting = 0\n        for j = 1, #word do\n \
    \           local char = word:sub(j, j)\n            if char == '(' then\n   \
    \             nesting = nesting + 1\n                if nesting > max_nesting\
    \ then\n                    max_nesting = nesting\n                end\n     \
    \       elseif char == ')' then\n                nesting = nesting - 1\n     \
    \       end\n        end\n        max_levels[i] = max_nesting\n    end\n    return\
    \ max_levels\nend", "\tlocal max_depth = 0\n\tlocal depth = 0\n\tlocal res = {}\n\
    \tlocal paren_stack = {}\n\tlocal idx = 1\n\tlocal stack_top = -1\n\tlocal paren_string_len\
    \ = string.len(paren_string)\n\twhile idx <= paren_string_len do\n\t\tlocal c\
    \ = string.sub(paren_string, idx, idx)\n\t\tif c == '(' then\n\t\t\tstack_top\
    \ = stack_top + 1\n\t\t\tparen_stack[stack_top] = idx\n\t\t\tdepth = depth + 1\n\
    \t\t\tif depth > max_depth then\n\t\t\t\tmax_depth = depth\n\t\t\tend\n\t\telseif\
    \ c == ')' then\n\t\t\tdepth = depth - 1\n\t\t\tif stack_top >= 0 then\n\t\t\t\
    \tstack_top = stack_top - 1\n\t\t\tend\n\t\t\tif depth == 0 then\n\t\t\t\tres[#res\
    \ + 1] = max_depth\n\t\t\t\tmax_depth = 0\n\t\t\tend\n\t\telseif c == ' ' then\n\
    \t\t\tif depth > 0 then\n\t\t\t\tres[#res + 1] = depth\n\t\t\t\tdepth = 0\n\t\t\
    \t\tmax_depth = 0\n\t\t\tend\n\t\tend\n\t\tidx = idx + 1\n\tend\n\tif depth >\
    \ 0 then\n\t\tres[#res + 1] = depth\n\tend\n\treturn res\nend", "  local levels\
    \ = {}\n  local max_level = 0\n  local current_level = 0\n  for i = 1, #paren_string\
    \ do\n    local char = paren_string:sub(i, i)\n    if char == '(' then\n     \
    \ current_level = current_level + 1\n      max_level = math.max(max_level, current_level)\n\
    \    elseif char == ')' then\n      table.insert(levels, current_level)\n    \
    \  current_level = current_level - 1\n    end\n  end\n  local max_levels = {}\n\
    \  for i = 1, #levels do\n    table.insert(max_levels, max_level)\n    max_level\
    \ = max_level - 1\n  end\n  return max_levels\nend", "    local paren_depth =\
    \ {}\n    local current_depth = 0\n    local group_start = false\n    for i =\
    \ 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        if\
    \ char == '(' then\n            current_depth = current_depth + 1\n          \
    \  group_start = true\n        elseif char == ')' then\n            if current_depth\
    \ > 0 then\n                current_depth = current_depth - 1\n            end\n\
    \        elseif char == ' ' then\n            if group_start then\n          \
    \      table.insert(paren_depth, current_depth)\n                current_depth\
    \ = 0\n                group_start = false\n            end\n        end\n   \
    \ end\n    return paren_depth\nend", "    local paren_group = split(paren_string,\
    \ \" \")\n    local paren_depth = {}\n    for _, paren in ipairs(paren_group)\
    \ do\n        local depth = 1\n        local max_depth = 1\n        for _, char\
    \ in ipairs(paren) do\n            if char == '(' then\n                depth\
    \ = depth + 1\n            elseif char == ')' then\n                depth = depth\
    \ - 1\n            end\n            if depth > max_depth then\n              \
    \  max_depth = depth\n            end\n        end\n        table.insert(paren_depth,\
    \ max_depth)\n    end\n    return paren_depth\nend", "    local paren_groups =\
    \ stringx.split(paren_string, ' ')\n    local nest_levels = {}\n    for _, paren_group\
    \ in ipairs(paren_groups) do\n        local stack = {}\n        local max_depth\
    \ = 0\n        for i = 1, string.len(paren_group) do\n            local cur_char\
    \ = string.sub(paren_group, i, i)\n            if cur_char == '(' then\n     \
    \           table.insert(stack, cur_char)\n                max_depth = math.max(max_depth,\
    \ #stack)\n            elseif cur_char == ')' then\n                table.remove(stack)\n\
    \            end\n        end\n        table.insert(nest_levels, max_depth)\n\
    \    end\n    return nest_levels\nend", "    local group_stack = {}\n    local\
    \ max_level = 0\n    local level_record = {}\n    for current_level, char in paren_string:gmatch('()(.)')\
    \ do\n        if char == '(' then\n            table.insert(group_stack, current_level)\n\
    \        elseif char == ')' then\n            -- If we encounter a close paren\
    \ without a corresponding open paren before, we ignore it.\n            if #group_stack\
    \ > 0 then\n                table.remove(group_stack)\n            end\n     \
    \   end\n        max_level = #group_stack\n        if level_record[current_level]\
    \ == nil then\n            level_record[current_level] = max_level\n        end\n\
    \    end\n    local result = {}\n    for k, v in pairs(level_record) do\n    \
    \    table.insert(result, v)\n    end\n    return result\nend", "  local res =\
    \ {}\n  local paren_stack = Stack()\n  local paren_lvl = 0\n  for word in paren_string:gmatch('%S+')\
    \ do\n    paren_lvl = 0\n    for c in word:gmatch('.') do\n      if c == '(' then\n\
    \        paren_stack:push(c)\n        paren_lvl = paren_lvl + 1\n      elseif\
    \ c == ')' then\n        paren_stack:pop()\n        paren_lvl = paren_lvl - 1\n\
    \      end\n    end\n    assert(paren_stack:is_empty(), 'Non-empty parentheses\
    \ stack!')\n    table.insert(res, paren_lvl)\n  end\n  return res\nend", "  local\
    \ tokens = stringx.split(paren_string)\n  local counts = {}\n  for i,token in\
    \ ipairs(tokens) do\n    local count = 0\n    for j = 1, #token do\n      if string.sub(token,\
    \ j, j) == '(' then\n        count = count + 1\n      elseif string.sub(token,\
    \ j, j) == ')' then\n        count = count - 1\n      end\n    end\n    table.insert(counts,\
    \ count)\n  end\n  return counts\nend", "  local ret = {}\n  local level = 0\n\
    \  local max_level = 0\n  for token in paren_string:gmatch('.') do\n    if token\
    \ == '(' then\n      level = level + 1\n      max_level = math.max(max_level,\
    \ level)\n    elseif token == ')' then\n      level = level - 1\n    end\n  end\n\
    \  table.insert(ret, max_level)\n  return ret\nend", "    local paren_tokens =\
    \ stringx.split(paren_string)\n    local paren_levels = {}\n    for i, tok in\
    \ ipairs(paren_tokens) do\n        paren_levels[i] = nesting_level(tok)\n    end\n\
    \    return paren_levels\nend", "  -- TODO\nend", "    local num_nested_parens\
    \ = {}\n    for paren_group in string.gmatch(paren_string, '%S+') do\n       \
    \ if string.find(paren_group, '%(') then\n            local current_nesting =\
    \ 0\n            local max_nesting = 0\n            for char in string.gmatch(paren_group,\
    \ '.') do\n                if char == '(' then\n                    current_nesting\
    \ = current_nesting + 1\n                    if current_nesting > max_nesting\
    \ then\n                        max_nesting = current_nesting\n              \
    \      end\n                elseif char == ')' then\n                    current_nesting\
    \ = current_nesting - 1\n                end\n            end\n            num_nested_parens[#num_nested_parens\
    \ + 1] = max_nesting\n        else\n            num_nested_parens[#num_nested_parens\
    \ + 1] = 0\n        end\n    end\n    return num_nested_parens\nend", "  local\
    \ t = {}\n  for w in paren_string:gmatch('[%s()]+') do\n    w = w:gsub('%s', '')\n\
    \    if #w > 0 then\n      local depth = 0\n      local max_depth = 0\n      for\
    \ c in w:gmatch('.') do\n        if c == '(' then\n          depth = depth + 1\n\
    \          if depth > max_depth then\n            max_depth = depth\n        \
    \  end\n        elseif c == ')' then\n          depth = depth - 1\n        end\n\
    \      end\n      table.insert(t, max_depth)\n    end\n  end\n  return t\nend",
  "  local paren_groups = paren_string:split()\n  local nested_parens = {}\n  for\
    \ _, paren_group in ipairs(paren_groups) do\n    local deepest_nesting = 0\n \
    \   local level = 0\n    for _, c in ipairs(paren_group) do\n      if c == '('\
    \ then\n        level = level + 1\n      elseif c == ')' then\n        level =\
    \ level - 1\n      end\n      if level > deepest_nesting then\n        deepest_nesting\
    \ = level\n      end\n    end\n    table.insert(nested_parens, deepest_nesting)\n\
    \  end\n  return nested_parens\nend", "\tlocal paren_count = 0 -- count the number\
    \ of parentheses\n\tlocal max_count = {} -- store the nested level of each groups\n\
    \tfor _, paren in utf8.gmatch(paren_string, '%(%)') do\n\t\tif paren == '()' then\n\
    \t\t\tparen_count = paren_count + 1\n\t\telse\n\t\t\ttable.insert(max_count, paren_count)\n\
    \t\t\tparen_count = 0\n\t\tend\n\tend\n\treturn max_count\nend", "    local stack\
    \ = {}\n    local paren_indices = {}\n    local function push(pos)\n        table.insert(stack,\
    \ pos)\n    end\n    local function pop()\n        table.remove(stack)\n    end\n\
    \    local function add_paren_indices(pos)\n        local i = 0\n        if #stack\
    \ > 0 then\n            i = stack[#stack]\n        end\n        paren_indices[pos]\
    \ = i\n    end\n    for i = 1, #paren_string do\n        local s = paren_string:sub(i,\
    \ i)\n        if s == '(' then\n            push(i)\n        elseif s == ')' then\n\
    \            pop()\n            add_paren_indices(i)\n        end\n    end\n \
    \   local groups = {}\n    local idx = 0\n    for i = 1, #paren_string do\n  \
    \      local s = paren_string:sub(i, i)\n        if s == ' ' then\n          \
    \  table.insert(groups, paren_indices[idx] - paren_indices[i - 1])\n         \
    \   idx = i\n        end\n    end\n    return groups\nend", "\tlocal paren_groups\
    \ = {}\n\tfor paren_group in paren_string:gmatch('[%(%)]+') do\n\t\ttable.insert(paren_groups,\
    \ paren_group)\n\tend\n\tlocal max_levels = {}\n\tfor _, paren_group in ipairs(paren_groups)\
    \ do\n\t\tlocal levels = 0\n\t\tlocal max_level = 0\n\t\tfor char in paren_group:gmatch('.')\
    \ do\n\t\t\tif char == '(' then\n\t\t\t\tlevels = levels + 1\n\t\t\t\tif levels\
    \ > max_level then\n\t\t\t\t\tmax_level = levels\n\t\t\t\tend\n\t\t\telseif char\
    \ == ')' then\n\t\t\t\tlevels = levels - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(max_levels,\
    \ max_level)\n\tend\n\treturn max_levels\nend", "    paren_string = utils.split(paren_string,\
    \ ' ')\n    local result = {}\n    for i = 1, #paren_string do\n        result[i]\
    \ = paren_string[i]:match('^%b()')\n        local level = 0\n        local max_level\
    \ = 0\n        for j = 1, #result[i] do\n            if result[i]:sub(j, j) ==\
    \ '(' then\n                level = level + 1\n            elseif result[i]:sub(j,\
    \ j) == ')' then\n                level = level - 1\n            end\n       \
    \     if level > max_level then\n                max_level = level\n         \
    \   end\n        end\n        result[i] = max_level\n    end\n    return result\n\
    end", "    local pars = {}\n    for p in paren_string:gmatch('(%b())') do\n  \
    \      table.insert(pars, p:match('%b()'):len() - 2)\n    end\n    return pars\n\
    end", "  local paren_groups = stringx.split(paren_string, ' ')\n  local paren_levels\
    \ = {}\n  for i, paren_group in ipairs(paren_groups) do\n    local paren_count\
    \ = 0\n    local max_paren_count = 0\n    for j = 1, #paren_group do\n      local\
    \ paren = paren_group:sub(j, j)\n      if paren == '(' then\n        paren_count\
    \ = paren_count + 1\n      elseif paren == ')' then\n        paren_count = paren_count\
    \ - 1\n      end\n      max_paren_count = math.max(max_paren_count, paren_count)\n\
    \    end\n    table.insert(paren_levels, max_paren_count)\n  end\n  return paren_levels\n\
    end", "  local levels = {}\n  local level = 0\n  local parens = {}\n  for c in\
    \ paren_string:gmatch'.' do\n    if c == '(' then\n      level = level + 1\n \
    \     parens[level] = c\n    elseif c == ')' then\n      if parens[level] == '('\
    \ then\n        table.insert(levels, level)\n        level = 0\n        parens\
    \ = {}\n      else\n        error(\"Too many closing parentheses\")\n      end\n\
    \    end\n  end\n  if level > 0 then\n    error(\"Too many opening parentheses\"\
    )\n  end\n  return levels\nend", "  local max_depth = 0\n  local depths = {}\n\
    \  for i = 1, #paren_string do\n    local c = paren_string:sub(i, i)\n    if c\
    \ == '(' then\n      max_depth = max_depth + 1\n    elseif c == ')' then\n   \
    \   table.insert(depths, max_depth)\n      max_depth = max_depth - 1\n    end\n\
    \  end\n  return depths\nend", "  -- Split on spaces\n  local groups = string.split(paren_string,\
    \ ' ')\n  local max_nesting = {}\n  -- For each group, do\n  for i = 1, #groups\
    \ do\n    local group = groups[i]\n    local nesting = 0\n    local max_nesting_group\
    \ = 0\n    -- Go through each character in the group.\n    for j = 1, #group do\n\
    \      local char = group:sub(j, j)\n      -- Find the corresponding left paren.\n\
    \      if char == '(' then\n        nesting = nesting + 1\n        -- Check if\
    \ current nesting level is higher than\n        -- maximum nesting level seen\
    \ so far.\n        if nesting > max_nesting_group then\n          max_nesting_group\
    \ = nesting\n        end\n      -- If it is a right paren, then reduce the nesting\
    \ level.\n      elseif char == ')' then\n        nesting = nesting - 1\n     \
    \ end\n    end\n    -- Append the max nesting level of each group to a table.\n\
    \    table.insert(max_nesting, max_nesting_group)\n  end\n  return max_nesting\n\
    end", "    local paren_groups = stringx.split(paren_string, ' ')\n    local res\
    \ = {}\n    for i, paren_group in ipairs(paren_groups) do\n        local depth\
    \ = 0\n        local max_depth = 0\n        for j, c in ipairs(paren_group) do\n\
    \            if c == '(' then\n                depth = depth + 1\n           \
    \     max_depth = math.max(max_depth, depth)\n            elseif c == ')' then\n\
    \                depth = depth - 1\n            end\n        end\n        res[i]\
    \ = max_depth\n    end\n    return res\nend", "\tlocal paren_table = {}\n\tlocal\
    \ max_depth = 0\n\tlocal cur_depth = 0\n\tfor paren in paren_string:gmatch('%(+')\
    \ do\n\t\tcur_depth = cur_depth + 1\n\t\tif cur_depth > max_depth then\n\t\t\t\
    max_depth = cur_depth\n\t\tend\n\t\ttable.insert(paren_table, paren)\n\tend\n\t\
    return { max_depth }\nend", "    local count = {}\n    local max_depth = 0\n \
    \   local start_pos = 1\n    local open_paren_idx = 1\n    local paren_lvl = 1\n\
    \    for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n\
    \        if char == '(' then\n            paren_lvl = paren_lvl + 1\n        \
    \    max_depth = math.max(max_depth, paren_lvl)\n        elseif char == ')' then\n\
    \            table.insert(count, paren_lvl)\n            paren_lvl = paren_lvl\
    \ - 1\n        end\n    end\n    return count\nend", "  local N = #paren_string\n\
    \  local output = {}\n  local level = 0\n  local start = 0\n  for i = 1, N do\n\
    \    if paren_string:sub(i, i) == '(' then\n      level = level + 1\n    elseif\
    \ paren_string:sub(i, i) == ')' then\n      level = level - 1\n    elseif paren_string:sub(i,\
    \ i) == ' ' then\n      output[#output + 1] = level\n      level = 0\n    end\n\
    \  end\n  output[#output + 1] = level\n  return output\nend", "  local max_level_counts\
    \ = {}\n  local curr_level = 0\n  local str_length = string.len(paren_string)\n\
    \  for i = 1, str_length do\n    if string.sub(paren_string, i, i) == '(' then\n\
    \      curr_level = curr_level + 1\n    elseif string.sub(paren_string, i, i)\
    \ == ')' then\n      curr_level = curr_level - 1\n    end\n    if i == str_length\
    \ or string.sub(paren_string, i, i) == ' ' then\n      max_level_counts[#max_level_counts\
    \ + 1] = curr_level\n      curr_level = 0\n    end\n  end\n  return max_level_counts\n\
    end", "    -- make a table of each group of parentheses separated by spaces\n\
    \    local paren_table = {}\n    for paren_group in stringx.split(paren_string,\
    \ ' ') do\n        table.insert(paren_table, paren_group)\n    end\n    -- for\
    \ each group, check the number of nested parentheses\n    local max_nesting =\
    \ 0\n    local max_nesting_per_group = {}\n    for _, group in pairs(paren_table)\
    \ do\n        max_nesting = 0\n        local curr_nesting = 0\n        for _,\
    \ token in pairs(stringx.split(group, '')) do\n            if token == '(' then\n\
    \                curr_nesting = curr_nesting + 1\n            elseif token ==\
    \ ')' then\n                curr_nesting = curr_nesting - 1\n            end\n\
    \            if curr_nesting > max_nesting then\n                max_nesting =\
    \ curr_nesting\n            end\n        end\n        table.insert(max_nesting_per_group,\
    \ max_nesting)\n    end\n    return max_nesting_per_group\nend", "  local paren_strings\
    \ = stringx.split(paren_string)\n  local depths = torch.Tensor(#paren_strings)\n\
    \  for i = 1, #paren_strings do\n    depths[i] = parse_single_nested_parens(paren_strings[i])\n\
    \  end\n  return depths\nend", "    local _, count = paren_string:gsub('%b()',\
    \ '')\n    return count\nend", "    local levels = {}\n    local level = 0\n \
    \   for i = 1, paren_string:len() do\n        local char = paren_string:sub(i,\
    \ i)\n        if char == '(' then\n            level = level + 1\n        elseif\
    \ char == ')' then\n            level = level - 1\n        elseif char == ' '\
    \ then\n            levels[#levels + 1] = level\n            level = 0\n     \
    \   end\n    end\n    return levels\nend", "    local levels = {}\n    local current_level\
    \ = 0\n    for word in paren_string:gmatch('%S+') do\n        if word == '(' then\n\
    \            current_level = current_level + 1\n        elseif word == ')' then\n\
    \            current_level = current_level - 1\n        end\n        table.insert(levels,\
    \ current_level)\n    end\n    return levels\nend", "    local i, j, paren_groups\
    \ = 0, #paren_string, {}\n    while i < j do\n        i = i + 1\n        local\
    \ first_parenthesis = paren_string:find('%(', i)\n        if not first_parenthesis\
    \ then break end\n        i = first_parenthesis\n        local depth = 0\n   \
    \     while i < j do\n            local char = paren_string:sub(i, i)\n      \
    \      if char == '(' then\n                depth = depth + 1\n            elseif\
    \ char == ')' then\n                depth = depth - 1\n                if depth\
    \ == 0 then\n                    table.insert(paren_groups, first_parenthesis)\n\
    \                    break\n                end\n            end\n           \
    \ i = i + 1\n        end\n    end\n    local nested_parens = {}\n    for i = 1,\
    \ #paren_groups - 1 do\n        table.insert(nested_parens, paren_groups[i + 1]\
    \ - paren_groups[i])\n    end\n    return nested_parens\nend", "\tlocal tokens\
    \ = tokenize(paren_string)\n\tlocal output = {}\n\tfor i = 1, #tokens do\n\t\t\
    local parens = tokens[i]\n\t\tlocal depth = 0\n\t\tlocal max_depth = 0\n\t\tfor\
    \ j = 1, #parens do\n\t\t\tlocal char = parens:sub(j, j)\n\t\t\tif char == '('\
    \ then\n\t\t\t\tdepth = depth + 1\n\t\t\t\tif depth > max_depth then\n\t\t\t\t\
    \tmax_depth = depth\n\t\t\t\tend\n\t\t\telseif char == ')' then\n\t\t\t\tdepth\
    \ = depth - 1\n\t\t\tend\n\t\tend\n\t\toutput[i] = max_depth\n\tend\n\treturn\
    \ output\nend", "\tlocal tokens = tokenize(paren_string)\n\tlocal max_depth =\
    \ 1\n\tlocal depth = 1\n\tlocal highest_depths = {}\n\tfor i = 1, #tokens do\n\
    \t\tlocal token = tokens[i]\n\t\tif token == '(' then\n\t\t\tdepth = depth + 1\n\
    \t\t\tif depth > max_depth then\n\t\t\t\tmax_depth = depth\n\t\t\tend\n\t\telseif\
    \ token == ')' then\n\t\t\tif depth == max_depth then\n\t\t\t\ttable.insert(highest_depths,\
    \ max_depth)\n\t\t\t\tmax_depth = 1\n\t\t\tend\n\t\t\tdepth = depth - 1\n\t\t\
    end\n\tend\n\treturn highest_depths\nend", "    if paren_string == nil then\n\
    \        return nil\n    end\n    local groups = paren_string:split(' ')\n   \
    \ local result = {}\n    for _, group in ipairs(groups) do\n        local group_length\
    \ = group:len()\n        local group_result = 0\n        local i = 1\n       \
    \ while i <= group_length do\n            local character = group:sub(i, i)\n\
    \            if character == '(' then\n                group_result = group_result\
    \ + 1\n            elseif character == ')' then\n                group_result\
    \ = group_result - 1\n            end\n            i = i + 1\n        end\n  \
    \      result[#result + 1] = group_result\n    end\n    return result\nend", " \
    \ local paren_groups = split(paren_string, ' ')\n  local max_nesting = {}\n  for\
    \ i = 1, #paren_groups do\n    local nest_count = 0\n    local max_nest = 0\n\
    \    for j = 1, #paren_groups[i] do\n      if paren_groups[i]:sub(j, j) == '('\
    \ then\n        nest_count = nest_count + 1\n      elseif paren_groups[i]:sub(j,\
    \ j) == ')' then\n        nest_count = nest_count - 1\n      end\n      if nest_count\
    \ > max_nest then\n        max_nest = nest_count\n      end\n    end\n    max_nesting[i]\
    \ = max_nest\n  end\n  return max_nesting\nend", "    local max_nest_levels =\
    \ {}\n    local nest_level = 0\n    for c in paren_string:gmatch('.') do\n   \
    \     if c == '(' then\n            nest_level = nest_level + 1\n        elseif\
    \ c == ')' then\n            max_nest_levels[#max_nest_levels + 1] = nest_level\n\
    \            nest_level = math.max(nest_level - 1, 0)\n        end\n    end\n\
    \    return max_nest_levels\nend", "\tlocal paren_list = {}\n\tfor paren in paren_string:gmatch('[^%s]+')\
    \ do\n\t\tlocal curr_cnt = 0\n\t\tlocal max_cnt = 0\n\t\tfor ch in paren:gmatch('[()]')\
    \ do\n\t\t\tif ch == '(' then\n\t\t\t\tcurr_cnt = curr_cnt + 1\n\t\t\telse\n\t\
    \t\t\tcurr_cnt = curr_cnt - 1\n\t\t\tend\n\t\t\tmax_cnt = math.max(max_cnt, curr_cnt)\n\
    \t\tend\n\t\ttable.insert(paren_list, max_cnt)\n\tend\n\treturn paren_list\nend",
  "    local max_nest = 0\n    local nest_count = 0\n    local max_list = {}\n   \
    \ for c in paren_string:gmatch('.') do\n        if c == '(' then\n           \
    \ nest_count = nest_count + 1\n            if nest_count > max_nest then\n   \
    \             max_nest = nest_count\n            end\n        elseif c == ')'\
    \ then\n            nest_count = nest_count - 1\n            table.insert(max_list,\
    \ max_nest)\n            max_nest = 0\n        end\n    end\n    return max_list\n\
    end", "    local max_nesting = 0\n    local current_nesting = 0\n    local results\
    \ = {}\n    for c in paren_string:gmatch('.') do\n        if c == '(' then\n \
    \           current_nesting = current_nesting + 1\n            if current_nesting\
    \ > max_nesting then\n                max_nesting = current_nesting\n        \
    \    end\n        elseif c == ')' then\n            current_nesting = current_nesting\
    \ - 1\n        elseif c == ' ' then\n            results[#results + 1] = max_nesting\n\
    \            max_nesting = 0\n            current_nesting = 0\n        end\n \
    \   end\n    results[#results + 1] = max_nesting\n    return results\nend", "\t\
    local Paren = {}\n\tParen.__index = Paren\n\tfunction Paren:new(str)\n\t\tlocal\
    \ obj = {level = 0, nesting = 0, start = false}\n\t\tsetmetatable(obj, Paren)\n\
    \t\tfor i = 1, #str do\n\t\t\tif str:sub(i, i) == '(' then\n\t\t\t\tobj.level\
    \ = obj.level + 1\n\t\t\t\tobj.start = true\n\t\t\telseif str:sub(i, i) == ')'\
    \ then\n\t\t\t\tobj.level = obj.level - 1\n\t\t\t\tif obj.level > obj.nesting\
    \ then\n\t\t\t\t\tobj.nesting = obj.level\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\
    \treturn obj\n\tend\n\tfunction Paren:parse()\n\t\tif self.start then\n\t\t\t\
    return self.nesting\n\t\telse\n\t\t\treturn 1\n\t\tend\n\tend\n\tparen_string\
    \ = paren_string:gsub('%s', '')\n\tlocal paren_list = split(paren_string, '%b()')\n\
    \tlocal result = List.new()\n\tfor _, paren in ipairs(paren_list) do\n\t\tlocal\
    \ nesting = Paren:new(paren):parse()\n\t\tresult:push(nesting)\n\tend\n\treturn\
    \ result\nend", "    local ret_table = {}\n    for group in paren_string:gmatch('%b()')\
    \ do\n        local level = 0\n        local deepest = 0\n        for paren in\
    \ group:gmatch('[()]') do\n            if paren == '(' then\n                level\
    \ = level + 1\n            else\n                level = level - 1\n         \
    \   end\n            if level > deepest then\n                deepest = level\n\
    \            end\n        end\n        table.insert(ret_table, deepest)\n    end\n\
    \    return ret_table\nend", "\t-- Convert string to one with a single space between\
    \ each parens and no leading/trailing spaces.\n\tparen_string = paren_string:gsub('%s*',\
    \ ' '):gsub('%s+', ' '):gsub('^%s+', ''):gsub('%s+$', '')\n\tlocal levels = {}\n\
    \tlocal level = 0\n\tlocal is_in_string = false\n\tfor i=1, #paren_string do\n\
    \t\tlocal cur_char = paren_string:sub(i, i)\n\t\tif cur_char == '(' then\n\t\t\
    \tif not is_in_string then\n\t\t\t\tlevel = level + 1\n\t\t\tend\n\t\telseif cur_char\
    \ == ')' then\n\t\t\tif not is_in_string then\n\t\t\t\ttable.insert(levels, level)\n\
    \t\t\t\tlevel = level - 1\n\t\t\tend\n\t\telseif cur_char == '\"' then\n\t\t\t\
    is_in_string = not is_in_string\n\t\tend\n\tend\n\treturn levels\nend", "    local\
    \ result = {}\n    for paren_group in stringx.split(paren_string, ' ') do\n  \
    \      local max_depth = 0\n        local depth = 0\n        for c in stringx.chars(paren_group)\
    \ do\n            if c == '(' then\n                depth = depth + 1\n      \
    \          max_depth = math.max(max_depth, depth)\n            elseif c == ')'\
    \ then\n                depth = depth - 1\n            end\n        end\n    \
    \    table.insert(result, max_depth)\n    end\n    return result\nend", "    local\
    \ open_parens = 0\n    local max_level = 0\n    local levels = {}\n    for w in\
    \ paren_string:gmatch(\"[()]\") do\n        if w == '(' then\n            open_parens\
    \ = open_parens + 1\n            if open_parens > max_level then\n           \
    \     max_level = open_parens\n            end\n        else\n            if open_parens\
    \ == max_level then\n                table.insert(levels, max_level)\n       \
    \         max_level = 0\n            end\n            open_parens = open_parens\
    \ - 1\n        end\n    end\n    return levels\nend", "  local paren_groups =\
    \ split(paren_string, ' ')\n  local nested_levels = {}\n  for _, group in ipairs(paren_groups)\
    \ do\n    local num_nested = 0\n    for paren in group:gmatch('%b()') do\n   \
    \   num_nested = num_nested + 1\n    end\n    table.insert(nested_levels, num_nested)\n\
    \  end\n  return nested_levels\nend", "  local depth = 0\n  local max_depth =\
    \ 0\n  local paren_levels = {}\n  for i = 1, #paren_string do\n    local paren\
    \ = paren_string:sub(i, i)\n    if paren == '(' then\n      depth = depth + 1\n\
    \      if depth > max_depth then\n        max_depth = depth\n      end\n    elseif\
    \ paren == ')' then\n      depth = depth - 1\n    elseif paren == ' ' then\n \
    \     table.insert(paren_levels, max_depth)\n      max_depth = 0\n    end\n  end\n\
    \  table.insert(paren_levels, max_depth)\n  return paren_levels\nend", "  local\
    \ function highest_level(paren_string)\n    local max_level = 0\n    local paren_level\
    \ = 0\n    local paren_chars = { ['('] = true, [')'] = true }\n    for char in\
    \ paren_string:gmatch('.') do\n      if paren_chars[char] then\n        if char\
    \ == '(' then\n          paren_level = paren_level + 1\n        else\n       \
    \   paren_level = paren_level - 1\n        end\n        max_level = math.max(max_level,\
    \ paren_level)\n      end\n    end\n    return max_level\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
