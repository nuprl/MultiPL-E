name: HumanEval_11_string_xor
language: lua
results:
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string'\
    \ and type(b) == 'string')\n    local result = ''\n    assert(#a == #b)\n    for\
    \ i = 1, #a do\n        assert(a:sub(i, i) == '0' or a:sub(i, i) == '1')\n   \
    \     assert(b:sub(i, i) == '0' or b:sub(i, i) == '1')\n        if a:sub(i, i)\
    \ == b:sub(i, i) then\n            result = result .. '0'\n        else\n    \
    \        result = result .. '1'\n        end\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local z = ''\n  for i =\
    \ 1, #a do\n    z = z .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n\
    \  end\n  return z\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  result = result .. \"0\"\n        else\n            result = result .. \"1\"\
    \n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local a_len = #a\n  \
    \  local b_len = #b\n    local max_len = math.max(a_len, b_len)\n    local out\
    \ = ''\n    for i = 1, max_len do\n        local a_val = a:sub(a_len - i + 1,\
    \ a_len - i + 1)\n        local b_val = b:sub(b_len - i + 1, b_len - i + 1)\n\
    \        local val = a_val ~= b_val and '1' or '0'\n        out = val .. out\n\
    \    end\n    return out\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal ret = ''\n\tfor i\
    \ = 1, #a do\n\t\tlocal bool = a:sub(i, i) == b:sub(i, i)\n\t\tret = ret .. (bool\
    \ and '0' or '1')\n\tend\n\treturn ret\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal res = ''\n\tfor i\
    \ = 1, #a do\n\t\tlocal x = a:sub(i, i) == '1' and b:sub(i, i) == '0'\n\t\tlocal\
    \ y = a:sub(i, i) == '0' and b:sub(i, i) == '1'\n\t\tif x or y then\n\t\t\tres\
    \ = res .. '1'\n\t\telse\n\t\t\tres = res .. '0'\n\t\tend\n\tend\n\treturn res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, #a do\n        result[i] = tostring(bxor(a:sub(i, i), b:sub(i,\
    \ i)))\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpaxa124ye.lua:8:\
    \ attempt to call a nil value (global 'bxor')\nstack traceback:\n\t/tmp/tmpaxa124ye.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpaxa124ye.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local a_int = tonumber(a,\
    \ 2)\n  local b_int = tonumber(b, 2)\n  local xor_result = bit.bxor(a_int, b_int)\n\
    \  return string.format(\"%x\", xor_result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkvwkxbhv.lua:8:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpkvwkxbhv.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpkvwkxbhv.lua:15: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string')\n\
    \    assert(type(b) == 'string')\n    assert(#a == #b)\n    local result = ''\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  result = result .. '0'\n        else\n            result = result .. '1'\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local a_len = a:len()\n\
    \  local b_len = b:len()\n  local out_len = math.max(a_len, b_len)\n  local out\
    \ = {}\n  for i = 1, out_len do\n    local a_bit = a:sub(i, i) == '1'\n    local\
    \ b_bit = b:sub(i, i) == '1'\n    local out_bit = (a_bit and not b_bit) or (not\
    \ a_bit and b_bit)\n    out[i] = out_bit and '1' or '0'\n  end\n  return table.concat(out)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local xor = {}\n  local\
    \ len = math.max(#a, #b)\n  for i = 1, len do\n    local x = a:sub(len - i + 1,\
    \ len - i + 1) == '1'\n    local y = b:sub(len - i + 1, len - i + 1) == '1'\n\
    \    table.insert(xor, 1, (x or y) and not (x and y) and '1' or '0')\n  end\n\
    \  return table.concat(xor)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, math.max(#a, #b) do\n        local a_bit = tonumber(a:sub(i, i))\
    \ or 0\n        local b_bit = tonumber(b:sub(i, i)) or 0\n        local xor_bit\
    \ = ((a_bit + b_bit) % 2)\n        result = result .. tostring(xor_bit)\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return (a:gsub('.', function(x)\n\
    \    if x == '0' then return b:sub(1, 1) else return b:sub(1, 1):gsub('0', '1'):gsub('1',\
    \ '0') end\n    end))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5zug9bk1.lua:14:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmp5zug9bk1.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"binary\
    \ strings must be of equal length\")\n    local r = {}\n    for i = 1, #a do\n\
    \        local ai = a:sub(i, i)\n        local bi = b:sub(i, i)\n        r[i]\
    \ = ai == bi and '0' or '1'\n    end\n    return table.concat(r)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = ''\n  for\
    \ i = 1, #a do\n    result = result .. (tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n  end\n  return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local n, m = #a, #b\n \
    \ local r = '0'\n  for i = 1, n, 1 do\n    r = ('%s%s'):format(r, a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n  end\n  if n < m then\n    r = ('%s%s'):format(r,\
    \ b:sub(n + 1, m))\n  end\n  return r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoxu9lo5m.lua:20:\
    \ expected: \"010010\"\nactual: \"0010010\"\nstack traceback:\n\t/tmp/tmpoxu9lo5m.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return (a:gsub('.', function(x)\n\
    \    return b:sub(x:byte(), x:byte())\n  end))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcb3wztu1.lua:14:\
    \ expected: \"010010\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpcb3wztu1.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string')\n\
    \    assert(type(b) == 'string')\n    assert(#a == #b)\n    local result = ''\n\
    \    for i = 1, #a do\n        result = result .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4kkw1ukc.lua:19:\
    \ expected: \"010010\"\nactual: \"111111\"\nstack traceback:\n\t/tmp/tmp4kkw1ukc.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal maxlen = math.max(#a,\
    \ #b)\n\tlocal result = ''\n\tfor i = 1, maxlen do\n\t\tlocal x = tonumber(a:sub(i,\
    \ i)) or 0\n\t\tlocal y = tonumber(b:sub(i, i)) or 0\n\t\tlocal z = x ~ y\n\t\t\
    result = result .. z\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    return string.char(bit.bxor(string.byte(a),\
    \ string.byte(b)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpm2de0yir.lua:6:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpm2de0yir.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmpm2de0yir.lua:12: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string'\
    \ and type(b) == 'string', 'a and b must be strings')\n    local s = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        local x = 0\n        if a:sub(i, i) == '1'\
    \ then x = x + 1 end\n        if b:sub(i, i) == '1' then x = x + 1 end\n     \
    \   s = s .. (x % 2 == 0 and '0' or '1')\n    end\n    return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal s = ''\n\tlocal i\
    \ = 1\n\tlocal c = #a\n\tif c < #b then\n\t\tc = #b\n\tend\n\twhile i <= c do\n\
    \t\ts = s .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n\t\ti = i + 1\n\t\
    end\n\treturn s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal a_len = #a\n\tlocal\
    \ b_len = #b\n\tlocal c = {}\n\tlocal n = math.max(a_len, b_len)\n\tfor i = 1,\
    \ n do\n\t\tlocal a_bit = a:sub(a_len - i + 1, a_len - i + 1)\n\t\tlocal b_bit\
    \ = b:sub(b_len - i + 1, b_len - i + 1)\n\t\tlocal a_num = tonumber(a_bit)\n\t\
    \tlocal b_num = tonumber(b_bit)\n\t\tlocal xor_bit = 0\n\t\tif a_num ~= b_num\
    \ then\n\t\t\txor_bit = 1\n\t\tend\n\t\ttable.insert(c, 1, xor_bit)\n\tend\n\t\
    return table.concat(c)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local s = {}\n    for\
    \ i = 1, math.max(#a, #b) do\n        local c = tonumber(a:sub(i, i)) or 0\n \
    \       local d = tonumber(b:sub(i, i)) or 0\n        s[i] = c ~ d\n    end\n\
    \    return table.concat(s)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\treturn (a:gsub('.', function(x)\n\
    \t\treturn b:sub(x == '0' and 1 or 2, 2)\n\tend))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprylah6co.lua:14:\
    \ expected: \"010010\"\nactual: \"000101010\"\nstack traceback:\n\t/tmp/tmprylah6co.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local ret = \"\"\n  for\
    \ i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      ret = ret .. \"\
    0\"\n    else\n      ret = ret .. \"1\"\n    end\n  end\n  return ret\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return (a:gsub('.', function(x)\n\
    \           return b:sub(x:byte(), x:byte())\n         end))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmyi9njnq.lua:14:\
    \ expected: \"010010\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpmyi9njnq.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   local length = math.max(a:len(), b:len())\n    local carry = false\n    for\
    \ i = 1, length do\n        local bit_a = a:sub(i, i)\n        local bit_b = b:sub(i,\
    \ i)\n        local bit_xor = bit_a ~= bit_b\n        if carry then\n        \
    \    bit_xor = not bit_xor\n        end\n        result[i] = bit_xor and '1' or\
    \ '0'\n        carry = bit_a == '1' and bit_b == '1'\n    end\n    if carry then\n\
    \        result[length + 1] = '1'\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0nyrlxcc.lua:28:\
    \ expected: \"010010\"\nactual: \"000110\"\nstack traceback:\n\t/tmp/tmp0nyrlxcc.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(type(a) == 'string'\
    \ and type(b) == 'string')\n  assert(#a == #b)\n  local ret = {}\n  for i = 1,\
    \ #a do\n    ret[i] = ((a:sub(i, i) == '1') and (b:sub(i, i) == '0')) or\n   \
    \   ((a:sub(i, i) == '0') and (b:sub(i, i) == '1')) and '1' or '0'\n  end\n  return\
    \ table.concat(ret)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdo6g0wxu.lua:13:\
    \ invalid value (boolean) at index 2 in table for 'concat'\nstack traceback:\n\
    \t/tmp/tmpdo6g0wxu.lua:13: in local 'candidate'\n\t/tmp/tmpdo6g0wxu.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if #a ~= #b then\n    error(\"\
    string_xor: lengths must be equal\")\n  end\n  local result = \"\"\n  for i =\
    \ 1, #a do\n    local bit_a = a:sub(i, i)\n    local bit_b = b:sub(i, i)\n   \
    \ local bit = bit_a == bit_b and \"0\" or \"1\"\n    result = result .. bit\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = \"\"\n  \
    \  for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            res\
    \ = res .. \"0\"\n        else\n            res = res .. \"1\"\n        end\n\
    \    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(#a == #b, \"Can't\
    \ xor two strings of different lengths!\")\n  local result = {}\n  for i = 1,\
    \ #a do\n    result[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n  end\n  return\
    \ table.concat(result)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local x = tonumber(a,\
    \ 2) ~ tonumber(b, 2)\n    return (\"%x\"):format(x)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz6h_aphk.lua:13:\
    \ expected: \"010010\"\nactual: \"12\"\nstack traceback:\n\t/tmp/tmpz6h_aphk.lua:13:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local xored = ''\n  for\
    \ i = 1, math.max(#a, #b) do\n    local ai = a:sub(i, i)\n    local bi = b:sub(i,\
    \ i)\n    if ai == bi then\n      xored = xored .. '0'\n    else\n      xored\
    \ = xored .. '1'\n    end\n  end\n  return xored\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local x = \"\"\n    local\
    \ y = \"\"\n    if #a > #b then\n        x = a\n        y = b\n    else\n    \
    \    x = b\n        y = a\n    end\n    local z = string.rep(\"0\", #x)\n    for\
    \ i = 1, #y do\n        if y:sub(i, i) == x:sub(i, i) then\n            z = z:sub(1,\
    \ i - 1) .. \"0\" .. z:sub(i + 1)\n        else\n            z = z:sub(1, i -\
    \ 1) .. \"1\" .. z:sub(i + 1)\n        end\n    end\n    return z\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal ret = {}\n\tfor i\
    \ = 1, math.max(#a, #b) do\n\t\tret[i] = a:sub(i, i) == b:sub(i, i) and \"0\"\
    \ or \"1\"\n\tend\n\treturn table.concat(ret)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(#a == #b, 'not equal\
    \ lengths')\n  local result = ''\n  for i = 1, #a do\n    result = result .. (a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1')\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local t = {}\n    local\
    \ x = tonumber(a, 2)\n    local y = tonumber(b, 2)\n    local z = x ~ y\n    local\
    \ xor_str = string.format(\"%X\", z)\n    for i=1, #xor_str do\n        local\
    \ c = string.sub(xor_str, i, i)\n        if c == '0' then\n            table.insert(t,\
    \ '0000')\n        elseif c == '1' then\n            table.insert(t, '0001')\n\
    \        elseif c == '2' then\n            table.insert(t, '0010')\n        elseif\
    \ c == '3' then\n            table.insert(t, '0011')\n        elseif c == '4'\
    \ then\n            table.insert(t, '0100')\n        elseif c == '5' then\n  \
    \          table.insert(t, '0101')\n        elseif c == '6' then\n           \
    \ table.insert(t, '0110')\n        elseif c == '7' then\n            table.insert(t,\
    \ '0111')\n        elseif c == '8' then\n            table.insert(t, '1000')\n\
    \        elseif c == '9' then\n            table.insert(t, '1001')\n        elseif\
    \ c == 'A' then\n            table.insert(t, '1010')\n        elseif c == 'B'\
    \ then\n            table.insert(t, '1011')\n        elseif c == 'C' then\n  \
    \          table.insert(t, '1100')\n        elseif c == 'D' then\n           \
    \ table.insert(t, '1101')\n        elseif c == 'E' then\n            table.insert(t,\
    \ '1110')\n        elseif c == 'F' then\n            table.insert(t, '1111')\n\
    \        end\n    end\n    return table.concat(t)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl6_u0wlx.lua:53:\
    \ expected: \"010010\"\nactual: \"00010010\"\nstack traceback:\n\t/tmp/tmpl6_u0wlx.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    return a:gsub('.', {['0']='1',\
    \ ['1']='0'})\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmbcj8b57.lua:12:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmpmbcj8b57.lua:12:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor = string.gsub(a,\
    \ '[^%z]', {['0'] = '1', ['1'] = '0'})\n    return string.gsub(xor, '[^%z]', {['0']\
    \ = '1', ['1'] = '0'})\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmploryfxim.lua:13:\
    \ expected: \"010010\"\nactual: \"111000\"\nstack traceback:\n\t/tmp/tmploryfxim.lua:13:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local ab, ba = {}, {}\n\
    \  local len = math.max(#a, #b)\n  for i = 1, len do\n    local x, y = string.sub(a,\
    \ i, i), string.sub(b, i, i)\n    if x == '1' and y == '0' then\n      table.insert(ab,\
    \ '1')\n      table.insert(ba, '0')\n    elseif x == '0' and y == '1' then\n \
    \     table.insert(ab, '1')\n      table.insert(ba, '0')\n    elseif x == '1'\
    \ and y == '1' then\n      table.insert(ab, '0')\n      table.insert(ba, '1')\n\
    \    elseif x == '0' and y == '0' then\n      table.insert(ab, '0')\n      table.insert(ba,\
    \ '0')\n    end\n  end\n  return table.concat(ab), table.concat(ba)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local xor = {}\n  for i\
    \ = 1, math.max(#a, #b) do\n    local aa = string.sub(a, i, i) or '0'\n    local\
    \ bb = string.sub(b, i, i) or '0'\n    xor[i] = aa == bb and '0' or '1'\n  end\n\
    \  return table.concat(xor)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return string.gsub(a, '.',\
    \ function(x) return (x == '0') and b:sub(1, 1) or b:sub(1, 1):gsub('0', 'A'):gsub('1',\
    \ '0'):gsub('A', '1') end)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkmq11luf.lua:12:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmpkmq11luf.lua:12:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tlocal len\
    \ = math.max(#a, #b)\n\tfor i = 1, len do\n\t\tlocal aa = tonumber(a:sub(i, i))\
    \ or 0\n\t\tlocal bb = tonumber(b:sub(i, i)) or 0\n\t\tr = r .. tostring(aa +\
    \ bb % 2)\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg0xpceul.lua:19:\
    \ expected: \"010010\"\nactual: \"212010\"\nstack traceback:\n\t/tmp/tmpg0xpceul.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s = \"\"\n  for i\
    \ = 1, #a do\n    s = s .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n \
    \ end\n  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local binxor, carry =\
    \ '', ''\n    for i = 1, math.max(#a, #b) do\n        local x, y = a:sub(#a -\
    \ i + 1, #a - i + 1), b:sub(#b - i + 1, #b - i + 1)\n        local bit_a, bit_b\
    \ = tonumber(x), tonumber(y)\n        if not bit_a then bit_a = 0 end\n      \
    \  if not bit_b then bit_b = 0 end\n        local sum = bit_a ~ bit_b\n      \
    \  if carry == '1' then\n            if sum == 0 then sum = 1 else sum = 0 end\n\
    \        end\n        if sum == 0 then carry = '0' else carry = '1' end\n    \
    \    binxor = sum .. binxor\n    end\n    return binxor\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq9soojsz.lua:25:\
    \ expected: \"010010\"\nactual: \"001110\"\nstack traceback:\n\t/tmp/tmpq9soojsz.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal n = (#a > #b) and\
    \ #a or #b\n\tlocal s = ''\n\tfor i = 1, n do\n\t\tlocal x = tonumber(a:sub(i,\
    \ i) or 0)\n\t\tlocal y = tonumber(b:sub(i, i) or 0)\n\t\ts = s .. tostring(bit32.bxor(x,\
    \ y))\n\tend\n\treturn s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = \"\"\n  for\
    \ i = 1,#a do\n    res = res .. ((a:sub(i,i) == b:sub(i,i)) and \"0\" or \"1\"\
    )\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if #a ~= #b then\n    return\
    \ nil\n  end\n  local len = #a\n  local xor = {}\n  for i = 1, len do\n    if\
    \ string.sub(a, i, i) == string.sub(b, i, i) then\n      xor[i] = '0'\n    else\n\
    \      xor[i] = '1'\n    end\n  end\n  return table.concat(xor)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return hex(xor(hex(a),\
    \ hex(b)))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3_ghjw37.lua:6:\
    \ attempt to call a nil value (global 'hex')\nstack traceback:\n\t/tmp/tmp3_ghjw37.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmp3_ghjw37.lua:12: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert(#a == #b, 'Given\
    \ strings must have the same length')\n\tlocal res = {}\n\tfor i = 1, #a do\n\t\
    \tres[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\tend\n\treturn table.concat(res)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local z = ''\n  local x,\
    \ y\n  local lena = a:len()\n  local lenb = b:len()\n  local l = math.max(lena,\
    \ lenb)\n  for i = 1, l do\n    x = a:sub(i, i)\n    y = b:sub(i, i)\n    if not\
    \ (x == y) then\n      z = z .. '1'\n    else\n      z = z .. '0'\n    end\n \
    \ end\n  return z\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local ret = ''\n  for i\
    \ = 1, #a do\n    ret = ret .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n \
    \ end\n  return ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ for i = 1, math.max(#a, #b) do\n    result = result .. (a:sub(i, i) == b:sub(i,\
    \ i) and \"0\" or \"1\")\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = \"\"\n  \
    \  for i = 1, #a do\n        res = res .. tostring(a:sub(i, i) ~= b:sub(i, i))\n\
    \    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpggt1po9a.lua:16:\
    \ expected: \"010010\"\nactual: \"falsetruefalsefalsetruefalse\"\nstack traceback:\n\
    \t/tmp/tmpggt1po9a.lua:16: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(type(a) == 'string'\
    \ and type(b) == 'string')\n  assert(#a == #b)\n  local n = #a\n  local bxor =\
    \ {}\n  for i = 1, n do\n    bxor[i] = bit.bxor(string.byte(a, i) - string.byte('0'),\n\
    \                       string.byte(b, i) - string.byte('0'))\n  end\n  return\
    \ table.concat(bxor)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2qflzkh3.lua:11:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp2qflzkh3.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmp2qflzkh3.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string'\
    \ and type(b) == 'string')\n    assert(a:len() == b:len())\n    local ret = ''\n\
    \    for i = 1, a:len() do\n        ret = ret .. (a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1')\n    end\n    return ret\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local r = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        r = bit32.bxor(\n            bit32.lshift(a:sub(i,\
    \ i) == '1' and 1 or 0, 1),\n            bit32.lshift(b:sub(i, i) == '1' and 1\
    \ or 0, 0)\n        ) .. r\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_lvgotri.lua:19:\
    \ expected: \"010010\"\nactual: \"010323\"\nstack traceback:\n\t/tmp/tmp_lvgotri.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   local max = math.max(#a, #b)\n    local a_ = a:reverse()\n    local b_ = b:reverse()\n\
    \    for i = 1, max do\n        local digit_a = a_:sub(i, i) or '0'\n        local\
    \ digit_b = b_:sub(i, i) or '0'\n        if digit_a == digit_b then\n        \
    \    table.insert(result, '0')\n        else\n            table.insert(result,\
    \ '1')\n        end\n    end\n    return table.concat(result):reverse()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s = ''\n  for i =\
    \ 1, #a do\n    s = s .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n\
    \  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local a_len = #a\n  \
    \  local b_len = #b\n    local length = math.max(a_len, b_len)\n    local result\
    \ = {}\n    for i = 1, length do\n        local a_bit = a:sub(i, i)\n        local\
    \ b_bit = b:sub(i, i)\n        local bit = tonumber(a_bit) ~= tonumber(b_bit)\
    \ and '1' or '0'\n        table.insert(result, bit)\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor_result = \"\
    \"\n    for i = 1, #a do\n        xor_result = xor_result .. tostring(tonumber(a:sub(i,\
    \ i)) ~ tonumber(b:sub(i, i)))\n    end\n    return xor_result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local x = \"\"\n  for i\
    \ = 1, math.max(#a, #b) do\n    x = x .. (a:sub(i, i) == b:sub(i, i) and \"0\"\
    \ or \"1\")\n  end\n  return x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tif #a == #b then\n\t\t\
    local out = ''\n\t\tfor i = 1, #a do\n\t\t\tout = out .. (a:sub(i, i) == b:sub(i,\
    \ i) and '0' or '1')\n\t\tend\n\t\treturn out\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ local len = math.max(#a, #b)\n  for i = 1, len do\n    result = result .. ((a:sub(i,\
    \ i) == b:sub(i, i)) and \"0\" or \"1\")\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"strings\
    \ are not equal length\")\n    local result = {}\n    for i = 1, #a do\n     \
    \   local c = a:sub(i, i)\n        local d = b:sub(i, i)\n        if c == d then\n\
    \            table.insert(result, \"0\")\n        else\n            table.insert(result,\
    \ \"1\")\n        end\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"string_xor:\
    \ lengths must be equal\")\n    local result = \"\"\n    for i = 1, #a do\n  \
    \      local ai = string.sub(a, i, i)\n        local bi = string.sub(b, i, i)\n\
    \        if (ai == bi) then\n            result = result .. \"0\"\n        else\n\
    \            result = result .. \"1\"\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local len = math.max(#a,\
    \ #b)\n    local result = {}\n    local j = 1\n    for i = len, 1, -1 do\n   \
    \     local x, y = a:sub(i, i), b:sub(i, i)\n        local m = tonumber(x) or\
    \ 0\n        local n = tonumber(y) or 0\n        result[j] = m ~ n\n        j\
    \ = j + 1\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcug69s4k.lua:24:\
    \ expected: \"0101\"\nactual: \"1010\"\nstack traceback:\n\t/tmp/tmpcug69s4k.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local rs = \"\"\n  local\
    \ len = math.max(a:len(), b:len())\n  for i = 1, len do\n    local ai = a:sub(i,\
    \ i) or '0'\n    local bi = b:sub(i, i) or '0'\n    if ai ~= bi then\n      rs\
    \ = rs .. '1'\n    else\n      rs = rs .. '0'\n    end\n  end\n  return rs\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s = ''\n  for i =\
    \ 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      s = s .. '0'\n    else\n\
    \      s = s .. '1'\n    end\n  end\n  return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"String\
    \ lengths don't match\")\n    local result = {}\n    for i = 1, #a do\n      \
    \  local a_val = tonumber(a:sub(i, i))\n        local b_val = tonumber(b:sub(i,\
    \ i))\n        if a_val ~= b_val then\n            table.insert(result, 1)\n \
    \       else\n            table.insert(result, 0)\n        end\n    end\n    return\
    \ table.concat(result)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local s = \"\"\n    for\
    \ i = 1, math.max(#a, #b) do\n        s = s .. (string.byte(a, i) == string.byte(b,\
    \ i) and '0' or '1')\n    end\n    return s\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local c = ''\n    local\
    \ bt = { 0, 1 }\n    for i = 1, #a do\n        c = c .. bt[tonumber(a:sub(i, i))\
    \ + tonumber(b:sub(i, i)) + 1]\n    end\n    return c\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7wum3b33.lua:9:\
    \ attempt to concatenate a nil value (field '?')\nstack traceback:\n\t/tmp/tmp7wum3b33.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmp7wum3b33.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if a == nil or b == nil\
    \ then\n        return nil\n    end\n    if #a ~= #b then\n        return nil\n\
    \    end\n    local res = {}\n    for i = 1, #a do\n        res[i] = a:sub(i,\
    \ i) ~= b:sub(i, i) and '1' or '0'\n    end\n    return table.concat(res)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   local short_string, long_string\n    if #a > #b then\n        short_string\
    \ = b\n        long_string = a\n    else\n        short_string = a\n        long_string\
    \ = b\n    end\n    for i = 1, #short_string do\n        result = result .. (char_xor(short_string:sub(i,\
    \ i), long_string:sub(i, i)))\n    end\n    for i = #short_string + 1, #long_string\
    \ do\n        result = result .. long_string:sub(i, i)\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpojwh010p.lua:16:\
    \ attempt to call a nil value (global 'char_xor')\nstack traceback:\n\t/tmp/tmpojwh010p.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpojwh010p.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local a_bin = read_binary(a)\n\
    \  local b_bin = read_binary(b)\n  return to_binary(xor(a_bin, b_bin))\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppoq6q3_r.lua:6:\
    \ attempt to call a nil value (global 'read_binary')\nstack traceback:\n\t/tmp/tmppoq6q3_r.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmppoq6q3_r.lua:14: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal a1, a2, a3 = a:byte(1,3)\n\
    \tlocal b1, b2, b3 = b:byte(1,3)\n\tlocal r1 = bit.bxor(a1, b1)\n\tlocal r2 =\
    \ bit.bxor(a2, b2)\n\tlocal r3 = bit.bxor(a3, b3)\n\treturn string.char(r1, r2,\
    \ r3)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2lka9pzr.lua:8:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp2lka9pzr.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmp2lka9pzr.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = {}\n  for i\
    \ = 1, #a do\n    res[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n  end\n\
    \  return table.concat(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local r = ''\n  for i =\
    \ 1, #a do\n    local x = tonumber(a:sub(i, i))\n    local y = tonumber(b:sub(i,\
    \ i))\n    r = r .. tostring(xor(x, y))\n  end\n  return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr7eioqw9.lua:10:\
    \ attempt to call a nil value (global 'xor')\nstack traceback:\n\t/tmp/tmpr7eioqw9.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpr7eioqw9.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local ret = {}\n    local\
    \ len = math.max(a:len(), b:len())\n    for i = 1, len do\n        local byte_a\
    \ = a:byte(i) or 0\n        local byte_b = b:byte(i) or 0\n        local byte_ret\
    \ = bit.bxor(byte_a, byte_b)\n        table.insert(ret, string.char(byte_ret))\n\
    \    end\n    return table.concat(ret)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5n03n7w2.lua:11:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp5n03n7w2.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmp5n03n7w2.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local aa = a:byte(1)\n\
    \    local bb = b:byte(1)\n    local r = aa ~ bb\n    return string.char(r)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7vpdxd72.lua:15:\
    \ expected: \"010010\"\nactual: \"\0\"\nstack traceback:\n\t/tmp/tmp7vpdxd72.lua:15:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\treturn a:gsub('%d', {['0']\
    \ = {['0'] = '0', ['1'] = '1'}, ['1'] = {['0'] = '1', ['1'] = '0'}})\n\t     \
    \   :gsub('.', b:sub(1, 1):byte())\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9po8irm8.lua:6:\
    \ invalid replacement value (a table)\nstack traceback:\n\t/tmp/tmp9po8irm8.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmp9po8irm8.lua:13: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = {}\n    for\
    \ i = 1, math.max(#a, #b) do\n        res[i] = achar_xor(a:sub(i, i), b:sub(i,\
    \ i))\n    end\n    return table.concat(res)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsuh9sq5j.lua:8:\
    \ attempt to call a nil value (global 'achar_xor')\nstack traceback:\n\t/tmp/tmpsuh9sq5j.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpsuh9sq5j.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\treturn (a:gsub('.', function(x)\n\
    \t\treturn b:sub(x:byte(), x:byte())\n\tend))\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy5zjipr_.lua:14:\
    \ expected: \"010010\"\nactual: \"\"\nstack traceback:\n\t/tmp/tmpy5zjipr_.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, #a do\n        local ai = tonumber(a:sub(i, i))\n        local\
    \ bi = tonumber(b:sub(i, i))\n        table.insert(result, (ai + bi) % 2)\n  \
    \  end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal result = \"\"\n\t\
    for i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\t\t\tresult = result\
    \ .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\tend\n\tend\n\treturn\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert(#a == #b, \"string_xor:\
    \ input strings must be same length\")\n\tlocal result = \"\"\n\tfor i = 1, #a\
    \ do\n\t\tlocal ai = a:sub(i, i)\n\t\tlocal bi = b:sub(i, i)\n\t\tlocal ai_value\
    \ = tonumber(ai)\n\t\tlocal bi_value = tonumber(bi)\n\t\tassert(ai_value == 0\
    \ or ai_value == 1, \"string_xor: input strings must be 0/1\")\n\t\tassert(bi_value\
    \ == 0 or bi_value == 1, \"string_xor: input strings must be 0/1\")\n\t\tresult\
    \ = result .. tostring(ai_value ~ bi_value)\n\tend\n\treturn result\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert(type(a) == 'string',\
    \ 'Argument \"a\" missing or not a string')\n\tassert(type(b) == 'string', 'Argument\
    \ \"b\" missing or not a string')\n\tassert(#a == #b, 'Arguments \"a\" and \"\
    b\" do not have the same length')\n\tlocal result = {}\n\tfor i = 1, #a do\n\t\
    \tresult[i] = ('%x'):format(tonumber(a:sub(i, i), 16) ~ tonumber(b:sub(i, i),\
    \ 16))\n\tend\n\treturn table.concat(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = ''\n  local\
    \ limit = math.min(#a, #b)\n  for i = 1, limit do\n    result = result .. tostring(math.fmod(tonumber(a:sub(i,\
    \ i)) + tonumber(b:sub(i, i)), 2))\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local z = \"\"\n  local\
    \ i = 0\n  while i < #a do\n    z = z .. ((a:sub(i + 1, i + 1) == b:sub(i + 1,\
    \ i + 1)) and \"0\" or \"1\")\n    i = i + 1\n  end\n  return z\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string'\
    \ and type(b) == 'string')\n    local t = { }\n    for i = 1, string.len(a) do\n\
    \        if a:sub(i, i) == b:sub(i, i) then\n            t[i] = '0'\n        else\n\
    \            t[i] = '1'\n        end\n    end\n    return table.concat(t)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result\
    \ .. \"0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tfor i =\
    \ 1, #a do\n\t\tr = r .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\tend\n\t\
    return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, math.max(#a, #b) do\n        result[i] = tonumber(a:sub(i, i))\
    \ ~= tonumber(b:sub(i, i)) and '1' or '0'\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local a_bytes = map(str2num,\
    \ split(a, ''))\n    local b_bytes = map(str2num, split(b, ''))\n    local result\
    \ = {}\n    for i = 1, #a_bytes do\n        result[i] = bxor(a_bytes[i], b_bytes[i])\n\
    \    end\n    return concat(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmzk7_7dk.lua:6:\
    \ attempt to call a nil value (global 'split')\nstack traceback:\n\t/tmp/tmpmzk7_7dk.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmpmzk7_7dk.lua:18: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s = ''\n  for i =\
    \ 1, #a do\n    if not (a:sub(i, i) == b:sub(i, i)) then\n      s = s .. '1'\n\
    \    else\n      s = s .. '0'\n    end\n  end\n  return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor = bit32.bxor\n\
    \    local s = ''\n    for i = 1, #a do\n        s = s .. xor(a:byte(i) - 48,\
    \ b:byte(i) - 48)\n    end\n    return s\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local sb = ''\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            sb = sb\
    \ .. '0'\n        else\n            sb = sb .. '1'\n        end\n    end\n   \
    \ return sb\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local r = \"\"\n    for\
    \ i = 1, #a do\n        r = r .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\
    )\n    end\n    return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal result = ''\n\tfor\
    \ i = 1, #a do\n\t\tresult = result .. (a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1')\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if #a ~= #b then\n  \
    \      error(\"Strings must be of same length!\")\n    end\n    local result =\
    \ {}\n    for i = 1, #a do\n        result[i] = a:sub(i, i) ~= b:sub(i, i) and\
    \ '1' or '0'\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, a:len() do\n        local a_bit = a:sub(i, i)\n        local b_bit\
    \ = b:sub(i, i)\n        if a_bit == b_bit then\n            result = result ..\
    \ '0'\n        else\n            result = result .. '1'\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if #a ~= #b then\n    error(\"\
    strings must be of equal length\")\n  end\n  local result = \"\"\n  for i = 1,\
    \ #a do\n    result = result .. tostring(bit.bxor(tonumber(a:sub(i, i)), tonumber(b:sub(i,\
    \ i))))\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpz03arjqw.lua:11:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpz03arjqw.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpz03arjqw.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(type(a) == 'string'\
    \ and type(b) == 'string', 'Incorrect argument types.')\n  local sl = math.min(#a,\
    \ #b)\n  local s = {}\n  for i = 1, sl do\n    if a:sub(i, i) == b:sub(i, i) then\n\
    \      s[i] = '0'\n    else\n      s[i] = '1'\n    end\n  end\n  return table.concat(s)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local r = ''\n  if #a >\
    \ #b then\n    b = string.rep('0', #a - #b) .. b\n  elseif #b > #a then\n    a\
    \ = string.rep('0', #b - #a) .. a\n  end\n  for i = 1, #a do\n    r = r .. (a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1')\n  end\n  return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n           \
    \ result = result .. '0'\n        else\n            result = result .. '1'\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor = {\n     \
    \   ['0'] = { ['0'] = '0', ['1'] = '1' },\n        ['1'] = { ['0'] = '1', ['1']\
    \ = '0' }\n    }\n    assert(#a == #b, 'inputs must be of equal length')\n   \
    \ local xored = {}\n    for i = 1, #a do\n        xored[i] = xor[a:sub(i, i)][b:sub(i,\
    \ i)]\n    end\n    return table.concat(xored)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal x, y = tonumber(a,\
    \ 2), tonumber(b, 2)\n\treturn (\"%x\"):format(x ~ y)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcn454hlm.lua:13:\
    \ expected: \"010010\"\nactual: \"12\"\nstack traceback:\n\t/tmp/tmpcn454hlm.lua:13:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    return xor_string(a,\
    \ b)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppbkp1hsz.lua:6:\
    \ attempt to call a nil value (global 'xor_string')\nstack traceback:\n\t/tmp/tmppbkp1hsz.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmppbkp1hsz.lua:12: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = {}\n\tlocal l\
    \ = math.max(#a, #b)\n\tfor i = 1, l do\n\t\tlocal x, y = tonumber(a:sub(i, i))\
    \ or 0, tonumber(b:sub(i, i)) or 0\n\t\tr[i] = (x + y) % 2\n\tend\n\treturn table.concat(r)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = \"\"\n  for\
    \ i = 1, a:len() do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and \"0\" or\
    \ \"1\")\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal len, xor = math.min(#a,\
    \ #b), {}\n\tfor i = 1, len do\n\t\txor[i] = a:sub(i, i) ~= b:sub(i, i) and '1'\
    \ or '0'\n\tend\n\treturn table.concat(xor)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal length = a:len()\n\
    \tlocal xored = ''\n\tfor i = 1, length do\n\t\tlocal _, ba = a:byte(i)\n\t\t\
    local _, bb = b:byte(i)\n\t\tlocal xor = ba ~ bb\n\t\txored = xored .. tostring(xor)\n\
    \tend\n\treturn xored\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe9le9wfv.lua:11:\
    \ attempt to perform bitwise operation on a nil value (local 'ba')\nstack traceback:\n\
    \t/tmp/tmpe9le9wfv.lua:11: in local 'candidate'\n\t/tmp/tmpe9le9wfv.lua:20: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert(type(a) == 'string'\
    \ and type(b) == 'string')\n\tlocal s = ''\n\tfor i = 1, math.max(#a, #b) do\n\
    \t\tlocal x = tonumber(a:sub(i, i) or '0')\n\t\tlocal y = tonumber(b:sub(i, i)\
    \ or '0')\n\t\ts = s .. tostring(xor_gate(x, y))\n\tend\n\treturn s\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6uebcc66.lua:11:\
    \ attempt to call a nil value (global 'xor_gate')\nstack traceback:\n\t/tmp/tmp6uebcc66.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmp6uebcc66.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if #a > #b then\n   \
    \     a, b = b, a\n    end\n    local result = {}\n    for i = 1, #a do\n    \
    \    result[i] = bit32.bxor(tonumber(a:sub(i, i)), tonumber(b:sub(i, i)))\n  \
    \  end\n    for i = #a + 1, #b do\n        result[i] = tonumber(b:sub(i, i))\n\
    \    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\treturn a:gsub('.', {['0']='1',\
    \ ['1']='0'})\n\t\t:gsub('.', {['0']='1', ['1']='%0'})\n\t\t:gsub('.', {['0']='0',\
    \ ['1']='%0'})\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpys3hokd8.lua:14:\
    \ expected: \"010010\"\nactual: \"%0%0%0%0%0%0\"\nstack traceback:\n\t/tmp/tmpys3hokd8.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if a == b then\n    return\
    \ string.rep('0', #a)\n  end\n  local temp = 'x'\n  for i = 1, #a do\n    if a:sub(i,\
    \ i) == b:sub(i, i) then\n      temp = temp .. '0'\n    else\n      temp = temp\
    \ .. '1'\n    end\n  end\n  return temp:sub(2)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = {}\n  local\
    \ n = math.max(#a, #b)\n  for i = 1, n do\n    table.insert(res, ((a:sub(i, i)\
    \ == '1') ~= (b:sub(i, i) == '1')) and '1' or '0')\n  end\n  return table.concat(res)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor = {}\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            xor[i]\
    \ = '0'\n        else\n            xor[i] = '1'\n        end\n    end\n    return\
    \ table.concat(xor)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local ax = a:len()\n\
    \    local bx = b:len()\n    local result = \"\"\n    for i = 1, math.max(ax,\
    \ bx) do\n        local x = 0\n        if i <= ax and a:sub(i, i) == \"1\" then\n\
    \            x = x + 1\n        end\n        if i <= bx and b:sub(i, i) == \"\
    1\" then\n            x = x + 1\n        end\n        if x % 2 == 0 then\n   \
    \         result = result .. \"0\"\n        else\n            result = result\
    \ .. \"1\"\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local output = ''\n \
    \   for i = 1, #a do\n        output = output .. (a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1')\n    end\n    return output\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    local ai = 1\n    local bi = 1\n    local max_len = math.max(#a, #b)\n  \
    \  while ai <= max_len and bi <= max_len do\n        local ca = a:sub(ai, ai)\n\
    \        local cb = b:sub(bi, bi)\n        if ca == \"0\" and cb == \"0\" then\n\
    \            result = result .. \"0\"\n        elseif ca == \"1\" and cb == \"\
    1\" then\n            result = result .. \"0\"\n        else\n            result\
    \ = result .. \"1\"\n        end\n        ai = ai + 1\n        bi = bi + 1\n \
    \   end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local buf = {}\n    for\
    \ i = 1, math.max(#a, #b) do\n        buf[i] = (a:sub(i, i) == '1' and b:sub(i,\
    \ i) ~= '1')\n                or (a:sub(i, i) ~= '1' and b:sub(i, i) == '1')\n\
    \                and '1' or '0'\n    end\n    return table.concat(buf)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprh4wyawv.lua:12:\
    \ invalid value (boolean) at index 2 in table for 'concat'\nstack traceback:\n\
    \t/tmp/tmprh4wyawv.lua:12: in local 'candidate'\n\t/tmp/tmprh4wyawv.lua:18: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return a:gsub('.', { ['0']\
    \ = function (c) return b:sub(1,1) end, ['1'] = function (c) return b:sub(1,1)\
    \ == '0' and '1' or '0' end })\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpu2bs05sz.lua:6:\
    \ invalid replacement value (a function)\nstack traceback:\n\t/tmp/tmpu2bs05sz.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmpu2bs05sz.lua:12: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if #a > #b then\n   \
    \     b = string.rep('0', #a - #b) .. b\n    elseif #b > #a then\n        a =\
    \ string.rep('0', #b - #a) .. a\n    end\n    local result = {}\n    for i = 1,\
    \ #a do\n        local s = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n       \
    \ table.insert(result, s)\n    end\n    return table.concat(result)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local str = ''\n  for i\
    \ = 1, #a do\n    str = str .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n \
    \ end\n  return str\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local ret = {}\n  local\
    \ k = 0\n  for i = 1, #a do\n    local x = a:sub(i, i)\n    local y = b:sub(i,\
    \ i)\n    k = k + 1\n    ret[k] = xor_num[x][y]\n  end\n  return table.concat(ret)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmnyvvlku.lua:12:\
    \ attempt to index a nil value (global 'xor_num')\nstack traceback:\n\t/tmp/tmpmnyvvlku.lua:12:\
    \ in local 'candidate'\n\t/tmp/tmpmnyvvlku.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    local len = string.len(a)\n    for i = 1, len do\n        local a_bit = string.sub(a,\
    \ i, i)\n        local b_bit = string.sub(b, i, i)\n        local xor_bit = string_xor_bit(a_bit,\
    \ b_bit)\n        result = result .. xor_bit\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0b_7o3iy.lua:11:\
    \ attempt to call a nil value (global 'string_xor_bit')\nstack traceback:\n\t\
    /tmp/tmp0b_7o3iy.lua:11: in local 'candidate'\n\t/tmp/tmp0b_7o3iy.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local x, y = tonumber(a,\
    \ 2), tonumber(b, 2)\n  return string.format(\"%03d\", x ~ y):gsub(\"^0+\", \"\
    \")\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpohvagtmx.lua:13:\
    \ expected: \"010010\"\nactual: \"18\"\nstack traceback:\n\t/tmp/tmpohvagtmx.lua:13:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal res = \"\"\n\tlocal\
    \ ta = type(a)\n\tlocal tb = type(b)\n\tif ta ~= \"string\" or tb ~= \"string\"\
    \ then\n\t\terror(\"Parameters a and b must be strings.\", 2)\n\tend\n\t-- build\
    \ res string\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal ea = a:sub(i, i) or\
    \ \"0\"\n\t\tlocal eb = b:sub(i, i) or \"0\"\n\t\tif ea ~= eb then\n\t\t\tres\
    \ = res .. \"1\"\n\t\telse\n\t\t\tres = res .. \"0\"\n\t\tend\n\tend\n\treturn\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    local index = 1\n    while index <= #a or index <= #b do\n        local x\
    \ = 0\n        local y = 0\n        if index <= #a then\n            x = tonumber(a:sub(index,\
    \ index))\n        end\n        if index <= #b then\n            y = tonumber(b:sub(index,\
    \ index))\n        end\n        result = result .. tostring(bit32.bxor(x, y))\n\
    \        index = index + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local len = math.max(#a,\
    \ #b)\n    local result = ''\n    for i = 1, len do\n        local x = a:sub(i,\
    \ i) == '1' and 1 or 0\n        local y = b:sub(i, i) == '1' and 1 or 0\n    \
    \    if (x + y) % 2 == 0 then\n            result = result .. '0'\n        else\n\
    \            result = result .. '1'\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local function a_binary_table()\n\
    \    local ret = {}\n    for i = 1, #a do\n      table.insert(ret, tonumber(a:sub(i,\
    \ i)))\n    end\n    return ret\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpzjp_4knr.lua:22: 'end' expected (to close 'function' at line\
    \ 5) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert_string(1, a)\n\t\
    assert_string(2, b)\n\tlocal n = math.max(#a, #b)\n\ta = a:sub(1, n)\n\tb = b:sub(1,\
    \ n)\n\tlocal r = {}\n\tfor i = 1, n do\n\t\tr[i] = (a:sub(i, i) == b:sub(i, i))\
    \ and '0' or '1'\n\tend\n\treturn table.concat(r)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphdm9aeiv.lua:6:\
    \ attempt to call a nil value (global 'assert_string')\nstack traceback:\n\t/tmp/tmphdm9aeiv.lua:6:\
    \ in local 'candidate'\n\t/tmp/tmphdm9aeiv.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return (a:gsub('.', function(x)\n\
    \    return b:sub(x == '0' and 1 or 2, x == '0' and 1 or 2)\n  end))\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8tvexbco.lua:14:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmp8tvexbco.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = {}\n  local\
    \ max = math.max(#a, #b)\n  for i = 1, max do\n    local ai = i <= #a and a:sub(i,\
    \ i) or '0'\n    local bi = i <= #b and b:sub(i, i) or '0'\n    result[i] = ai\
    \ == bi and '0' or '1'\n  end\n  return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"inputs\
    \ must be of equal length\")\n    local result = ''\n    for i = 1, #a do\n  \
    \      result = result .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s = ''\n  for i =\
    \ 1, #a do\n    s = s .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n\
    \  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    return a:gsub('.', function(x)\n\
    \        return b:sub(x == '0' and 1 or 2, x == '0' and 1 or 2)\n    end)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxij3u5cn.lua:14:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmpxij3u5cn.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n           \
    \ result = result .. '0'\n        else\n            result = result .. '1'\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tfor i =\
    \ 1, math.max(#a, #b) do\n\t\tr = r .. ((a:sub(i, i) == b:sub(i, i)) and '0' or\
    \ '1')\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local xor = 0\n  local\
    \ a, b = tonumber(a, 2), tonumber(b, 2)\n  for _ = 0, 31 do\n    local da, db\
    \ = a % 2 == 1, b % 2 == 1\n    if da ~= db then xor = xor + 2^_ end\n    a, b\
    \ = (a - da) / 2, (b - db) / 2\n  end\n  return string.format(\"%032d\", xor):gsub(\"\
    0*$\", \"\")\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8qtdrles.lua:11:\
    \ attempt to perform arithmetic on a boolean value (local 'da')\nstack traceback:\n\
    \t/tmp/tmp8qtdrles.lua:11: in local 'candidate'\n\t/tmp/tmp8qtdrles.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, \"input\
    \ strings are not of equal length\")\n    local r = \"\"\n    for i = 1, #a do\n\
    \        r = r .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)) and '1' or '0')\n\
    \    end\n    return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc9jr1vqp.lua:17:\
    \ expected: \"010010\"\nactual: \"111111\"\nstack traceback:\n\t/tmp/tmpc9jr1vqp.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if #a ~= #b then\n  \
    \      return nil\n    end\n    local out = {}\n    for i = 1, #a do\n       \
    \ local x = tonumber(a:sub(i, i))\n        local y = tonumber(b:sub(i, i))\n \
    \       if not x or not y then\n            return nil\n        end\n        local\
    \ z = x ~ y\n        out[i] = tostring(z)\n    end\n    return table.concat(out)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = ''\n  for i\
    \ = 1, #a do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n \
    \ end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  result = result .. \"0\"\n        else\n            result = result .. \"1\"\
    \n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tfor i =\
    \ 1, #a do\n\t\tr = r .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\tend\n\t\
    return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = {}\n    for\
    \ i = 1, #a do\n        res[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\
    \n    end\n    return table.concat(res)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local r = ''\n    for\
    \ i = 1, #a do\n        r = r .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n\
    \    return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq4lvhafv.lua:16:\
    \ expected: \"010010\"\nactual: \"falsetruefalsefalsetruefalse\"\nstack traceback:\n\
    \t/tmp/tmpq4lvhafv.lua:16: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(type(a) == 'string'\
    \ and type(b) == 'string', 'expected string arguments')\n  assert(#a == #b, 'string\
    \ arguments must be the same length')\n  local out = ''\n  for i = 1, #a do\n\
    \    if a:sub(i, i) == b:sub(i, i) then\n      out = out .. '0'\n    else\n  \
    \    out = out .. '1'\n    end\n  end\n  return out\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local out = ''\n  for i\
    \ = 1, #a do\n    local bit_a = a:sub(i, i)\n    local bit_b = b:sub(i, i)\n \
    \   local xor_bit = bit_a == bit_b and '0' or '1'\n    out = out .. xor_bit\n\
    \  end\n  return out\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(#a == #b, 'string_xor:\
    \ arguments must be same length')\n  local c = {}\n  for i = 1, #a do\n    c[i]\
    \ = b2i(a:sub(i, i)) ~ b2i(b:sub(i, i))\n  end\n  return table.concat(c)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjce8718b.lua:9:\
    \ attempt to call a nil value (global 'b2i')\nstack traceback:\n\t/tmp/tmpjce8718b.lua:9:\
    \ in local 'candidate'\n\t/tmp/tmpjce8718b.lua:17: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tif a:len() ~= b:len() then\n\
    \t\terror(\"string_xor() arguments have different lengths!\")\n\tend\n\tlocal\
    \ r = ''\n\tfor i = 1, a:len() do\n\t\tr = r .. (a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1')\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal ret = ''\n\tfor i\
    \ = 1, #a do\n\t\tret = ret .. bit32.bxor(a:sub(i, i):byte(), b:sub(i, i):byte())\n\
    \tend\n\treturn ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local ret = {}\n    for\
    \ i = 1, #a do\n        ret[i] = (a:sub(i, i) == b:sub(i, i)) and \"0\" or \"\
    1\"\n    end\n    return table.concat(ret)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local retval = \"\"\n\
    \    for i = 1, #a do\n        retval = retval .. tostring(a:sub(i, i) ~= b:sub(i,\
    \ i))\n    end\n    return retval\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_dci1uo9.lua:16:\
    \ expected: \"010010\"\nactual: \"falsetruefalsefalsetruefalse\"\nstack traceback:\n\
    \t/tmp/tmp_dci1uo9.lua:16: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  assert(#a == #b, \"strings\
    \ not same length\")\n  local result = {}\n  for i = 1, #a do\n    result[i] =\
    \ a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n  end\n  return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ local longest = math.max(a:len(), b:len())\n  for i = 1, longest do\n    local\
    \ n1 = tonumber(a:sub(i, i)) or 0\n    local n2 = tonumber(b:sub(i, i)) or 0\n\
    \    result = result .. tostring(n1 ~ n2)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if string.len(a) > string.len(b)\
    \ then\n    b = string.rep('0', string.len(a) - string.len(b)) .. b\n  elseif\
    \ string.len(a) < string.len(b) then\n    a = string.rep('0', string.len(b) -\
    \ string.len(a)) .. a\n  end\n  local r = ''\n  for i = 1, string.len(a) do\n\
    \    if a:sub(i, i) == b:sub(i, i) then\n      r = r .. '0'\n    else\n      r\
    \ = r .. '1'\n    end\n  end\n  return r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = ''\n  for\
    \ i = 1, math.max(#a, #b) do\n    result = result .. (((a:sub(i, i) == '1') ~=\
    \ (b:sub(i, i) == '1')) and '1' or '0')\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local r = {}\n  local bits\
    \ = #a > #b and #a or #b\n  for i = 1, bits do\n    local b1 = a:sub(i, i)\n \
    \   local b2 = b:sub(i, i)\n    local sum = (b1 == '1' and 1 or 0) + (b2 == '1'\
    \ and 1 or 0)\n    if sum == 2 then\n      r[i] = '0'\n    elseif sum == 1 then\n\
    \      r[i] = '1'\n    else\n      r[i] = '0'\n    end\n  end\n  return table.concat(r)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = \"\"\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  result = result .. \"0\"\n        else\n            result = result .. \"1\"\
    \n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = ''\n    local\
    \ i = 1\n    while i <= #a do\n        res = res .. (tonumber(a:sub(i, i)) ~=\
    \ tonumber(b:sub(i, i)) and '1' or '0')\n        i = i + 1\n    end\n    return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(#a == #b, 'Length\
    \ mismatch')\n    local out = {}\n    for i = 1, #a do\n        out[i] = a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1'\n    end\n    return table.concat(out)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if #a ~= #b then\n    error('In\
    \ order to perform XOR operation on ' .. a .. ' and ' .. b .. ', both strings\
    \ should have the same length')\n  end\n  return a:gsub('.', function(a)\n   \
    \ return b:sub(1, 1):gsub('.', function(b)\n      return a == b and '0' or '1'\n\
    \    end)\n  end)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw7_owvz2.lua:19:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmpw7_owvz2.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local _bits = require\
    \ \"bits\"\n    local r = \"\"\n    local l = math.max(a:len(), b:len())\n   \
    \ for i = 1, l do\n        local x = _bits.bxor(a:byte(i), b:byte(i))\n      \
    \  if x then\n            r = r .. string.char(x)\n        end\n    end\n    return\
    \ r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwikasvto.lua:10:\
    \ attempt to call a nil value (field 'bxor')\nstack traceback:\n\t/tmp/tmpwikasvto.lua:10:\
    \ in local 'candidate'\n\t/tmp/tmpwikasvto.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local ret = ''\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            ret =\
    \ ret .. '0'\n        else\n            ret = ret .. '1'\n        end\n    end\n\
    \    return ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local res = ''\n  for i\
    \ = 1, #a do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n \
    \ end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = ''\n    for\
    \ i = 1, #a do\n        res = res .. (tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal c = {}\n\tfor i =\
    \ 1, math.max(#a, #b) do\n\t\tc[i] = ((a:sub(i, i) == b:sub(i, i)) and '0') or\
    \ '1'\n\tend\n\treturn table.concat(c)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tfor i =\
    \ 1, #a do\n\t\tr = r .. b:sub(i, i):char_xor(a:sub(i, i))\n\tend\n\treturn r\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnl475up4.lua:8:\
    \ attempt to call a nil value (method 'char_xor')\nstack traceback:\n\t/tmp/tmpnl475up4.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmpnl475up4.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal r = ''\n\tfor i =\
    \ 1, #a do\n\t\tr = r .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n\tend\n\
    \treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ for i = 1, #a do\n    local bita = a:sub(i, i)\n    local bitb = b:sub(i, i)\n\
    \    if bita ~= bitb then\n      result = result .. \"1\"\n    else\n      result\
    \ = result .. \"0\"\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if not (type(a) == 'string'\
    \ and type(b) == 'string') then\n        return nil\n    end\n    if #a ~= #b\
    \ then\n        return nil\n    end\n    local chars = {}\n    for i = 1, #a do\n\
    \        local val = a:sub(i, i) ~= b:sub(i, i) and '1' or '0'\n        table.insert(chars,\
    \ val)\n    end\n    return table.concat(chars)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  return (a:gsub('.', function(x)\n\
    \           return b:sub(x, x) == '1' and '0' or '1'\n         end))\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfpx4fng0.lua:14:\
    \ expected: \"010010\"\nactual: \"000111\"\nstack traceback:\n\t/tmp/tmpfpx4fng0.lua:14:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, math.max(#a, #b) do\n        result = result .. (a:sub(i, i) ==\
    \ b:sub(i, i) and '0' or '1')\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor = {}\n    if\
    \ #a == #b then\n        for i = 1, #a do\n            if a:sub(i, i) == b:sub(i,\
    \ i) then\n                xor[i] = '0'\n            else\n                xor[i]\
    \ = '1'\n            end\n        end\n    end\n    return table.concat(xor)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal pad = math.abs(#a\
    \ - #b)\n\tif #a > #b then\n\t\tb = string.rep('0', pad) .. b\n\telse\n\t\ta =\
    \ string.rep('0', pad) .. a\n\tend\n\tlocal out = ''\n\tfor i = 1, #a do\n\t\t\
    out = out .. (bit.band(a:byte(i) - 48, b:byte(i) - 48) == 0 and '1' or '0')\n\t\
    end\n\treturn out\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp2g_76jkh.lua:14:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp2g_76jkh.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp2g_76jkh.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local len = a:len()\n\
    \    if b:len() ~= len then\n        error(\"String length mismatch\")\n    end\n\
    \    local res = ''\n    for i = 1, len do\n        res = res .. (a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, math.max(#a, #b) do\n        local a_int = tonumber(a:sub(i, i))\
    \ or 0\n        local b_int = tonumber(b:sub(i, i)) or 0\n        result[i] =\
    \ (a_int ~ b_int)\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tassert(type(a) == 'string'\
    \ and type(b) == 'string')\n\tassert(#a == #b)\n\tlocal result = ''\n\tfor i =\
    \ 1, #a do\n\t\tresult = result .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlc50ckg.lua:18:\
    \ expected: \"010010\"\nactual: \"111111\"\nstack traceback:\n\t/tmp/tmpxlc50ckg.lua:18:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local r = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        r = r .. (bit.bxor(tonumber(a:sub(i, i)\
    \ or 0), tonumber(b:sub(i, i) or 0)) % 2)\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8812lh__.lua:8:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp8812lh__.lua:8:\
    \ in local 'candidate'\n\t/tmp/tmp8812lh__.lua:16: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal a_len = a:len()\n\
    \tlocal b_len = b:len()\n\tif a_len < b_len then\n\t\ta = a .. string.rep('0',\
    \ b_len - a_len)\n\telseif b_len < a_len then\n\t\tb = b .. string.rep('0', a_len\
    \ - b_len)\n\tend\n\tlocal b_xor = {}\n\tfor i = 1, a:len() do\n\t\tlocal a_sub\
    \ = a:sub(i, i)\n\t\tlocal b_sub = b:sub(i, i)\n\t\tif a_sub == b_sub then\n\t\
    \t\tb_xor[i] = '0'\n\t\telse\n\t\t\tb_xor[i] = '1'\n\t\tend\n\tend\n\treturn table.concat(b_xor)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local xor_vals = {}\n\
    \    for i = 1, a:len() do\n        local xor_val = tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i))\n        table.insert(xor_vals, xor_val and '1' or '0')\n    end\n    return\
    \ table.concat(xor_vals)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = {}\n  local\
    \ i\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result[i]\
    \ = '0'\n    else\n      result[i] = '1'\n    end\n  end\n  return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = \"\"\n  \
    \  local i = 0\n    while i < #a and i < #b do\n        local char_a = a:sub(i\
    \ + 1, i + 1)\n        local char_b = b:sub(i + 1, i + 1)\n        if char_a ==\
    \ char_b then\n            res = res .. \"0\"\n        else\n            res =\
    \ res .. \"1\"\n        end\n        i = i + 1\n    end\n    return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  if #a ~= #b then\n    error(\"\
    strings are of different lengths\")\n  end\n  local res = {}\n  for i = 1, #a\
    \ do\n    res[i] = string.char(bit.bxor(string.byte(a, i), string.byte(b, i)))\n\
    \  end\n  return table.concat(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjpd0lp9q.lua:11:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpjpd0lp9q.lua:11:\
    \ in local 'candidate'\n\t/tmp/tmpjpd0lp9q.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n \
    \   for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n           \
    \ result = result .. '0'\n        else\n            result = result .. '1'\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal result = {}\n\tfor\
    \ i = 1, #a do\n\t\tresult[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\t\
    end\n\treturn table.concat(result)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    assert(type(a) == 'string'\
    \ and type(b) == 'string')\n    local length = math.max(#a, #b)\n    a = string.rep('0',\
    \ length - #a) .. a\n    b = string.rep('0', length - #b) .. b\n    local result\
    \ = {}\n    for i = 1, length do\n        local xor = string.byte(a, i) ~ string.byte(b,\
    \ i)\n        table.insert(result, string.char(xor))\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj75fufov.lua:21:\
    \ expected: \"010010\"\nactual: \"\0\x01\0\0\x01\0\"\nstack traceback:\n\t/tmp/tmpj75fufov.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n\tlocal ret = {}\n\tlocal\
    \ a_len = #a\n\tlocal b_len = #b\n\tlocal big_len = math.max(a_len, b_len)\n\t\
    local i = 0\n\twhile i < big_len do\n\t\tlocal a_i = a:sub(i + 1, i + 1)\n\t\t\
    local b_i = b:sub(i + 1, i + 1)\n\t\tif a_i == b_i then\n\t\t\tret[i + 1] = '0'\n\
    \t\telse\n\t\t\tret[i + 1] = '1'\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn table.concat(ret)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local s = \"\"\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            s = s\
    \ .. \"0\"\n        else\n            s = s .. \"1\"\n        end\n    end\n \
    \   return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, #a do\n        local char_a = a:sub(i, i)\n        local char_b\
    \ = b:sub(i, i)\n        local result_chr = string_xor_char(char_a, char_b)\n\
    \        table.insert(result, result_chr)\n    end\n    return table.concat(result)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
    \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
    \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\n\
    os.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph5pkyaq_.lua:10:\
    \ attempt to call a nil value (global 'string_xor_char')\nstack traceback:\n\t\
    /tmp/tmph5pkyaq_.lua:10: in local 'candidate'\n\t/tmp/tmph5pkyaq_.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = {}\n \
    \   for i = 1, #a do\n        result[i] = a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1'\n    end\n    return table.concat(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    if #a ~= #b then\n  \
    \      error('Attempt to xor strings of unequal length')\n    end\n    local result\
    \ = {}\n    for i = 1, #a do\n        local b1 = a:sub(i, i)\n        local b2\
    \ = b:sub(i, i)\n        if b1 ~= b2 then\n            table.insert(result, '1')\n\
    \        else\n            table.insert(result, '0')\n        end\n    end\n \
    \   return table.concat(result)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local s, i, j, m, n, byte,\
    \ byte_a, byte_b, byte_c\n  if #a < #b then\n    s, i, j, m, n = b, #b, #a, -1,\
    \ -1\n  else\n    s, i, j, m, n = a, #a, #b, 1, 1\n  end\n  byte_a = string.byte(a,\
    \ i)\n  byte_b = string.byte(b, j)\n  byte_c = byte_a ~ byte_b\n  while byte_c\
    \ ~= 0 do\n    byte = byte_c % 2\n    byte_c = (byte_c - byte) / 2\n    s = string.char(string.byte(s,\
    \ i) + byte) .. s\n    i = i + m\n    j = j + n\n    byte_a = string.byte(a, i)\n\
    \    byte_b = string.byte(b, j)\n    byte_c = byte_c + byte_a + byte_b\n  end\n\
    \  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwvvowa2y.lua:31:\
    \ expected: \"010010\"\nactual: \"111000\"\nstack traceback:\n\t/tmp/tmpwvvowa2y.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local x = ''\n  for i =\
    \ 1, #a do\n    x = x .. tostring(a:sub(i, i) ~= b:sub(i, i))\n  end\n  return\
    \ x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp15z64lju.lua:16:\
    \ expected: \"010010\"\nactual: \"falsetruefalsefalsetruefalse\"\nstack traceback:\n\
    \t/tmp/tmp15z64lju.lua:16: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n  local result = \"\"\n \
    \ local len = math.max(a:len(), b:len())\n  for i = 1, len do\n    local s = \"\
    \"\n    local x = tonumber(a:sub(i, i))\n    local y = tonumber(b:sub(i, i))\n\
    \    if x and y then\n      s = (x + y) % 2\n    elseif x then\n      s = x\n\
    \    elseif y then\n      s = y\n    end\n    result = result .. s\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = string_xor\n    lu.assertEquals(candidate('111000', '101010'), '010010')\n\
    \    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local n = math.max(#a,\
    \ #b)\n    local xor = ''\n    for i = 1, n do\n        xor = xor .. ((a:sub(i,\
    \ i) == b:sub(i, i)) and '0' or '1')\n    end\n    return xor\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = string_xor\n    lu.assertEquals(candidate('111000',\
    \ '101010'), '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
    \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
    \ '110')\n-- '100'\nlocal function string_xor(a, b)\n    local res = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        local num1 = tonumber(a:sub(i, i)) or 0\n\
    \        local num2 = tonumber(b:sub(i, i)) or 0\n        res = res .. tostring(num1\
    \ ~ num2)\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = string_xor\n    lu.assertEquals(candidate('111000', '101010'),\
    \ '010010')\n    lu.assertEquals(candidate('1', '1'), '0')\n    lu.assertEquals(candidate('0101',\
    \ '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
