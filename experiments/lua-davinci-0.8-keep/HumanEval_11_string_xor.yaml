name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
  \ '110')\n-- '100'\nlocal function string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    assert(type(a) == 'string' and type(b) == 'string')\n    local\
    \ result = ''\n    assert(#a == #b)\n    for i = 1, #a do\n        assert(a:sub(i,\
    \ i) == '0' or a:sub(i, i) == '1')\n        assert(b:sub(i, i) == '0' or b:sub(i,\
    \ i) == '1')\n        if a:sub(i, i) == b:sub(i, i) then\n            result =\
    \ result .. '0'\n        else\n            result = result .. '1'\n        end\n\
    \    end\n    return result\nend", "  local z = ''\n  for i = 1, #a do\n    z\
    \ = z .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n  end\n  return\
    \ z\nend", "    local result = \"\"\n    for i = 1, #a do\n        if a:sub(i,\
    \ i) == b:sub(i, i) then\n            result = result .. \"0\"\n        else\n\
    \            result = result .. \"1\"\n        end\n    end\n    return result\n\
    end", "    local a_len = #a\n    local b_len = #b\n    local max_len = math.max(a_len,\
    \ b_len)\n    local out = ''\n    for i = 1, max_len do\n        local a_val =\
    \ a:sub(a_len - i + 1, a_len - i + 1)\n        local b_val = b:sub(b_len - i +\
    \ 1, b_len - i + 1)\n        local val = a_val ~= b_val and '1' or '0'\n     \
    \   out = val .. out\n    end\n    return out\nend", "\tlocal ret = ''\n\tfor\
    \ i = 1, #a do\n\t\tlocal bool = a:sub(i, i) == b:sub(i, i)\n\t\tret = ret ..\
    \ (bool and '0' or '1')\n\tend\n\treturn ret\nend", "\tlocal res = ''\n\tfor i\
    \ = 1, #a do\n\t\tlocal x = a:sub(i, i) == '1' and b:sub(i, i) == '0'\n\t\tlocal\
    \ y = a:sub(i, i) == '0' and b:sub(i, i) == '1'\n\t\tif x or y then\n\t\t\tres\
    \ = res .. '1'\n\t\telse\n\t\t\tres = res .. '0'\n\t\tend\n\tend\n\treturn res\n\
    end", "    local result = {}\n    for i = 1, #a do\n        result[i] = tostring(bxor(a:sub(i,\
    \ i), b:sub(i, i)))\n    end\n    return table.concat(result)\nend", "  local\
    \ a_int = tonumber(a, 2)\n  local b_int = tonumber(b, 2)\n  local xor_result =\
    \ bit.bxor(a_int, b_int)\n  return string.format(\"%x\", xor_result)\nend", " \
    \   assert(type(a) == 'string')\n    assert(type(b) == 'string')\n    assert(#a\
    \ == #b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i)\
    \ == b:sub(i, i) then\n            result = result .. '0'\n        else\n    \
    \        result = result .. '1'\n        end\n    end\n    return result\nend",
  "  local a_len = a:len()\n  local b_len = b:len()\n  local out_len = math.max(a_len,\
    \ b_len)\n  local out = {}\n  for i = 1, out_len do\n    local a_bit = a:sub(i,\
    \ i) == '1'\n    local b_bit = b:sub(i, i) == '1'\n    local out_bit = (a_bit\
    \ and not b_bit) or (not a_bit and b_bit)\n    out[i] = out_bit and '1' or '0'\n\
    \  end\n  return table.concat(out)\nend", "  local xor = {}\n  local len = math.max(#a,\
    \ #b)\n  for i = 1, len do\n    local x = a:sub(len - i + 1, len - i + 1) == '1'\n\
    \    local y = b:sub(len - i + 1, len - i + 1) == '1'\n    table.insert(xor, 1,\
    \ (x or y) and not (x and y) and '1' or '0')\n  end\n  return table.concat(xor)\n\
    end", "    local result = ''\n    for i = 1, math.max(#a, #b) do\n        local\
    \ a_bit = tonumber(a:sub(i, i)) or 0\n        local b_bit = tonumber(b:sub(i,\
    \ i)) or 0\n        local xor_bit = ((a_bit + b_bit) % 2)\n        result = result\
    \ .. tostring(xor_bit)\n    end\n    return result\nend", "  return (a:gsub('.',\
    \ function(x)\n    if x == '0' then return b:sub(1, 1) else return b:sub(1, 1):gsub('0',\
    \ '1'):gsub('1', '0') end\n    end))\nend", "    assert(#a == #b, \"binary strings\
    \ must be of equal length\")\n    local r = {}\n    for i = 1, #a do\n       \
    \ local ai = a:sub(i, i)\n        local bi = b:sub(i, i)\n        r[i] = ai ==\
    \ bi and '0' or '1'\n    end\n    return table.concat(r)\nend", "  local result\
    \ = ''\n  for i = 1, #a do\n    result = result .. (tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n  end\n  return result\nend", "  local n, m = #a, #b\n\
    \  local r = '0'\n  for i = 1, n, 1 do\n    r = ('%s%s'):format(r, a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n  end\n  if n < m then\n    r = ('%s%s'):format(r,\
    \ b:sub(n + 1, m))\n  end\n  return r\nend", "  return (a:gsub('.', function(x)\n\
    \    return b:sub(x:byte(), x:byte())\n  end))\nend", "    assert(type(a) == 'string')\n\
    \    assert(type(b) == 'string')\n    assert(#a == #b)\n    local result = ''\n\
    \    for i = 1, #a do\n        result = result .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n    end\n    return result\nend", "\tlocal maxlen = math.max(#a,\
    \ #b)\n\tlocal result = ''\n\tfor i = 1, maxlen do\n\t\tlocal x = tonumber(a:sub(i,\
    \ i)) or 0\n\t\tlocal y = tonumber(b:sub(i, i)) or 0\n\t\tlocal z = x ~ y\n\t\t\
    result = result .. z\n\tend\n\treturn result\nend", "    return string.char(bit.bxor(string.byte(a),\
    \ string.byte(b)))\nend", "    assert(type(a) == 'string' and type(b) == 'string',\
    \ 'a and b must be strings')\n    local s = ''\n    for i = 1, math.max(#a, #b)\
    \ do\n        local x = 0\n        if a:sub(i, i) == '1' then x = x + 1 end\n\
    \        if b:sub(i, i) == '1' then x = x + 1 end\n        s = s .. (x % 2 ==\
    \ 0 and '0' or '1')\n    end\n    return s\nend", "\tlocal s = ''\n\tlocal i =\
    \ 1\n\tlocal c = #a\n\tif c < #b then\n\t\tc = #b\n\tend\n\twhile i <= c do\n\t\
    \ts = s .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n\t\ti = i + 1\n\tend\n\
    \treturn s\nend", "\tlocal a_len = #a\n\tlocal b_len = #b\n\tlocal c = {}\n\t\
    local n = math.max(a_len, b_len)\n\tfor i = 1, n do\n\t\tlocal a_bit = a:sub(a_len\
    \ - i + 1, a_len - i + 1)\n\t\tlocal b_bit = b:sub(b_len - i + 1, b_len - i +\
    \ 1)\n\t\tlocal a_num = tonumber(a_bit)\n\t\tlocal b_num = tonumber(b_bit)\n\t\
    \tlocal xor_bit = 0\n\t\tif a_num ~= b_num then\n\t\t\txor_bit = 1\n\t\tend\n\t\
    \ttable.insert(c, 1, xor_bit)\n\tend\n\treturn table.concat(c)\nend", "    local\
    \ s = {}\n    for i = 1, math.max(#a, #b) do\n        local c = tonumber(a:sub(i,\
    \ i)) or 0\n        local d = tonumber(b:sub(i, i)) or 0\n        s[i] = c ~ d\n\
    \    end\n    return table.concat(s)\nend", "\treturn (a:gsub('.', function(x)\n\
    \t\treturn b:sub(x == '0' and 1 or 2, 2)\n\tend))\nend", "  local ret = \"\"\n\
    \  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      ret = ret ..\
    \ \"0\"\n    else\n      ret = ret .. \"1\"\n    end\n  end\n  return ret\nend",
  "  return (a:gsub('.', function(x)\n           return b:sub(x:byte(), x:byte())\n\
    \         end))\nend", "    local result = {}\n    local length = math.max(a:len(),\
    \ b:len())\n    local carry = false\n    for i = 1, length do\n        local bit_a\
    \ = a:sub(i, i)\n        local bit_b = b:sub(i, i)\n        local bit_xor = bit_a\
    \ ~= bit_b\n        if carry then\n            bit_xor = not bit_xor\n       \
    \ end\n        result[i] = bit_xor and '1' or '0'\n        carry = bit_a == '1'\
    \ and bit_b == '1'\n    end\n    if carry then\n        result[length + 1] = '1'\n\
    \    end\n    return table.concat(result)\nend", "  assert(type(a) == 'string'\
    \ and type(b) == 'string')\n  assert(#a == #b)\n  local ret = {}\n  for i = 1,\
    \ #a do\n    ret[i] = ((a:sub(i, i) == '1') and (b:sub(i, i) == '0')) or\n   \
    \   ((a:sub(i, i) == '0') and (b:sub(i, i) == '1')) and '1' or '0'\n  end\n  return\
    \ table.concat(ret)\nend", "  if #a ~= #b then\n    error(\"string_xor: lengths\
    \ must be equal\")\n  end\n  local result = \"\"\n  for i = 1, #a do\n    local\
    \ bit_a = a:sub(i, i)\n    local bit_b = b:sub(i, i)\n    local bit = bit_a ==\
    \ bit_b and \"0\" or \"1\"\n    result = result .. bit\n  end\n  return result\n\
    end", "    local res = \"\"\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i,\
    \ i) then\n            res = res .. \"0\"\n        else\n            res = res\
    \ .. \"1\"\n        end\n    end\n    return res\nend", "  assert(#a == #b, \"\
    Can't xor two strings of different lengths!\")\n  local result = {}\n  for i =\
    \ 1, #a do\n    result[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n  end\n\
    \  return table.concat(result)\nend", "    local x = tonumber(a, 2) ~ tonumber(b,\
    \ 2)\n    return (\"%x\"):format(x)\nend", "  local xored = ''\n  for i = 1, math.max(#a,\
    \ #b) do\n    local ai = a:sub(i, i)\n    local bi = b:sub(i, i)\n    if ai ==\
    \ bi then\n      xored = xored .. '0'\n    else\n      xored = xored .. '1'\n\
    \    end\n  end\n  return xored\nend", "    local x = \"\"\n    local y = \"\"\
    \n    if #a > #b then\n        x = a\n        y = b\n    else\n        x = b\n\
    \        y = a\n    end\n    local z = string.rep(\"0\", #x)\n    for i = 1, #y\
    \ do\n        if y:sub(i, i) == x:sub(i, i) then\n            z = z:sub(1, i -\
    \ 1) .. \"0\" .. z:sub(i + 1)\n        else\n            z = z:sub(1, i - 1) ..\
    \ \"1\" .. z:sub(i + 1)\n        end\n    end\n    return z\nend", "\tlocal ret\
    \ = {}\n\tfor i = 1, math.max(#a, #b) do\n\t\tret[i] = a:sub(i, i) == b:sub(i,\
    \ i) and \"0\" or \"1\"\n\tend\n\treturn table.concat(ret)\nend", "  assert(#a\
    \ == #b, 'not equal lengths')\n  local result = ''\n  for i = 1, #a do\n    result\
    \ = result .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n  return result\n\
    end", "    local t = {}\n    local x = tonumber(a, 2)\n    local y = tonumber(b,\
    \ 2)\n    local z = x ~ y\n    local xor_str = string.format(\"%X\", z)\n    for\
    \ i=1, #xor_str do\n        local c = string.sub(xor_str, i, i)\n        if c\
    \ == '0' then\n            table.insert(t, '0000')\n        elseif c == '1' then\n\
    \            table.insert(t, '0001')\n        elseif c == '2' then\n         \
    \   table.insert(t, '0010')\n        elseif c == '3' then\n            table.insert(t,\
    \ '0011')\n        elseif c == '4' then\n            table.insert(t, '0100')\n\
    \        elseif c == '5' then\n            table.insert(t, '0101')\n        elseif\
    \ c == '6' then\n            table.insert(t, '0110')\n        elseif c == '7'\
    \ then\n            table.insert(t, '0111')\n        elseif c == '8' then\n  \
    \          table.insert(t, '1000')\n        elseif c == '9' then\n           \
    \ table.insert(t, '1001')\n        elseif c == 'A' then\n            table.insert(t,\
    \ '1010')\n        elseif c == 'B' then\n            table.insert(t, '1011')\n\
    \        elseif c == 'C' then\n            table.insert(t, '1100')\n        elseif\
    \ c == 'D' then\n            table.insert(t, '1101')\n        elseif c == 'E'\
    \ then\n            table.insert(t, '1110')\n        elseif c == 'F' then\n  \
    \          table.insert(t, '1111')\n        end\n    end\n    return table.concat(t)\n\
    end", "    return a:gsub('.', {['0']='1', ['1']='0'})\nend", "    local xor =\
    \ string.gsub(a, '[^%z]', {['0'] = '1', ['1'] = '0'})\n    return string.gsub(xor,\
    \ '[^%z]', {['0'] = '1', ['1'] = '0'})\nend", "  local ab, ba = {}, {}\n  local\
    \ len = math.max(#a, #b)\n  for i = 1, len do\n    local x, y = string.sub(a,\
    \ i, i), string.sub(b, i, i)\n    if x == '1' and y == '0' then\n      table.insert(ab,\
    \ '1')\n      table.insert(ba, '0')\n    elseif x == '0' and y == '1' then\n \
    \     table.insert(ab, '1')\n      table.insert(ba, '0')\n    elseif x == '1'\
    \ and y == '1' then\n      table.insert(ab, '0')\n      table.insert(ba, '1')\n\
    \    elseif x == '0' and y == '0' then\n      table.insert(ab, '0')\n      table.insert(ba,\
    \ '0')\n    end\n  end\n  return table.concat(ab), table.concat(ba)\nend", " \
    \ local xor = {}\n  for i = 1, math.max(#a, #b) do\n    local aa = string.sub(a,\
    \ i, i) or '0'\n    local bb = string.sub(b, i, i) or '0'\n    xor[i] = aa ==\
    \ bb and '0' or '1'\n  end\n  return table.concat(xor)\nend", "  return string.gsub(a,\
    \ '.', function(x) return (x == '0') and b:sub(1, 1) or b:sub(1, 1):gsub('0',\
    \ 'A'):gsub('1', '0'):gsub('A', '1') end)\nend", "\tlocal r = ''\n\tlocal len\
    \ = math.max(#a, #b)\n\tfor i = 1, len do\n\t\tlocal aa = tonumber(a:sub(i, i))\
    \ or 0\n\t\tlocal bb = tonumber(b:sub(i, i)) or 0\n\t\tr = r .. tostring(aa +\
    \ bb % 2)\n\tend\n\treturn r\nend", "  local s = \"\"\n  for i = 1, #a do\n  \
    \  s = s .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n  end\n  return s\n\
    end", "    local binxor, carry = '', ''\n    for i = 1, math.max(#a, #b) do\n\
    \        local x, y = a:sub(#a - i + 1, #a - i + 1), b:sub(#b - i + 1, #b - i\
    \ + 1)\n        local bit_a, bit_b = tonumber(x), tonumber(y)\n        if not\
    \ bit_a then bit_a = 0 end\n        if not bit_b then bit_b = 0 end\n        local\
    \ sum = bit_a ~ bit_b\n        if carry == '1' then\n            if sum == 0 then\
    \ sum = 1 else sum = 0 end\n        end\n        if sum == 0 then carry = '0'\
    \ else carry = '1' end\n        binxor = sum .. binxor\n    end\n    return binxor\n\
    end", "\tlocal n = (#a > #b) and #a or #b\n\tlocal s = ''\n\tfor i = 1, n do\n\
    \t\tlocal x = tonumber(a:sub(i, i) or 0)\n\t\tlocal y = tonumber(b:sub(i, i) or\
    \ 0)\n\t\ts = s .. tostring(bit32.bxor(x, y))\n\tend\n\treturn s\nend", "  local\
    \ res = \"\"\n  for i = 1,#a do\n    res = res .. ((a:sub(i,i) == b:sub(i,i))\
    \ and \"0\" or \"1\")\n  end\n  return res\nend", "  if #a ~= #b then\n    return\
    \ nil\n  end\n  local len = #a\n  local xor = {}\n  for i = 1, len do\n    if\
    \ string.sub(a, i, i) == string.sub(b, i, i) then\n      xor[i] = '0'\n    else\n\
    \      xor[i] = '1'\n    end\n  end\n  return table.concat(xor)\nend", "  return\
    \ hex(xor(hex(a), hex(b)))\nend", "\tassert(#a == #b, 'Given strings must have\
    \ the same length')\n\tlocal res = {}\n\tfor i = 1, #a do\n\t\tres[i] = a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1'\n\tend\n\treturn table.concat(res)\nend", " \
    \ local z = ''\n  local x, y\n  local lena = a:len()\n  local lenb = b:len()\n\
    \  local l = math.max(lena, lenb)\n  for i = 1, l do\n    x = a:sub(i, i)\n  \
    \  y = b:sub(i, i)\n    if not (x == y) then\n      z = z .. '1'\n    else\n \
    \     z = z .. '0'\n    end\n  end\n  return z\nend", "  local ret = ''\n  for\
    \ i = 1, #a do\n    ret = ret .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\
    \  end\n  return ret\nend", "  local result = \"\"\n  for i = 1, math.max(#a,\
    \ #b) do\n    result = result .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\
    )\n  end\n  return result\nend", "    local res = \"\"\n    for i = 1, #a do\n\
    \        res = res .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n    return\
    \ res\nend", "  assert(type(a) == 'string' and type(b) == 'string')\n  assert(#a\
    \ == #b)\n  local n = #a\n  local bxor = {}\n  for i = 1, n do\n    bxor[i] =\
    \ bit.bxor(string.byte(a, i) - string.byte('0'),\n                       string.byte(b,\
    \ i) - string.byte('0'))\n  end\n  return table.concat(bxor)\nend", "    assert(type(a)\
    \ == 'string' and type(b) == 'string')\n    assert(a:len() == b:len())\n    local\
    \ ret = ''\n    for i = 1, a:len() do\n        ret = ret .. (a:sub(i, i) == b:sub(i,\
    \ i) and '0' or '1')\n    end\n    return ret\nend", "    local r = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        r = bit32.bxor(\n            bit32.lshift(a:sub(i,\
    \ i) == '1' and 1 or 0, 1),\n            bit32.lshift(b:sub(i, i) == '1' and 1\
    \ or 0, 0)\n        ) .. r\n    end\n    return r\nend", "    local result = {}\n\
    \    local max = math.max(#a, #b)\n    local a_ = a:reverse()\n    local b_ =\
    \ b:reverse()\n    for i = 1, max do\n        local digit_a = a_:sub(i, i) or\
    \ '0'\n        local digit_b = b_:sub(i, i) or '0'\n        if digit_a == digit_b\
    \ then\n            table.insert(result, '0')\n        else\n            table.insert(result,\
    \ '1')\n        end\n    end\n    return table.concat(result):reverse()\nend",
  "  local s = ''\n  for i = 1, #a do\n    s = s .. (a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1')\n  end\n  return s\nend", "    local a_len = #a\n    local b_len\
    \ = #b\n    local length = math.max(a_len, b_len)\n    local result = {}\n   \
    \ for i = 1, length do\n        local a_bit = a:sub(i, i)\n        local b_bit\
    \ = b:sub(i, i)\n        local bit = tonumber(a_bit) ~= tonumber(b_bit) and '1'\
    \ or '0'\n        table.insert(result, bit)\n    end\n    return table.concat(result)\n\
    end", "    local xor_result = \"\"\n    for i = 1, #a do\n        xor_result =\
    \ xor_result .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n    end\n\
    \    return xor_result\nend", "  local x = \"\"\n  for i = 1, math.max(#a, #b)\
    \ do\n    x = x .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n  end\n  return\
    \ x\nend", "\tif #a == #b then\n\t\tlocal out = ''\n\t\tfor i = 1, #a do\n\t\t\
    \tout = out .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\t\tend\n\t\treturn\
    \ out\n\tend\nend", "  local result = \"\"\n  local len = math.max(#a, #b)\n \
    \ for i = 1, len do\n    result = result .. ((a:sub(i, i) == b:sub(i, i)) and\
    \ \"0\" or \"1\")\n  end\n  return result\nend", "    assert(#a == #b, \"strings\
    \ are not equal length\")\n    local result = {}\n    for i = 1, #a do\n     \
    \   local c = a:sub(i, i)\n        local d = b:sub(i, i)\n        if c == d then\n\
    \            table.insert(result, \"0\")\n        else\n            table.insert(result,\
    \ \"1\")\n        end\n    end\n    return table.concat(result)\nend", "    assert(#a\
    \ == #b, \"string_xor: lengths must be equal\")\n    local result = \"\"\n   \
    \ for i = 1, #a do\n        local ai = string.sub(a, i, i)\n        local bi =\
    \ string.sub(b, i, i)\n        if (ai == bi) then\n            result = result\
    \ .. \"0\"\n        else\n            result = result .. \"1\"\n        end\n\
    \    end\n    return result\nend", "    local len = math.max(#a, #b)\n    local\
    \ result = {}\n    local j = 1\n    for i = len, 1, -1 do\n        local x, y\
    \ = a:sub(i, i), b:sub(i, i)\n        local m = tonumber(x) or 0\n        local\
    \ n = tonumber(y) or 0\n        result[j] = m ~ n\n        j = j + 1\n    end\n\
    \    return table.concat(result)\nend", "  local rs = \"\"\n  local len = math.max(a:len(),\
    \ b:len())\n  for i = 1, len do\n    local ai = a:sub(i, i) or '0'\n    local\
    \ bi = b:sub(i, i) or '0'\n    if ai ~= bi then\n      rs = rs .. '1'\n    else\n\
    \      rs = rs .. '0'\n    end\n  end\n  return rs\nend", "  local s = ''\n  for\
    \ i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      s = s .. '0'\n \
    \   else\n      s = s .. '1'\n    end\n  end\n  return s\nend", "    assert(#a\
    \ == #b, \"String lengths don't match\")\n    local result = {}\n    for i = 1,\
    \ #a do\n        local a_val = tonumber(a:sub(i, i))\n        local b_val = tonumber(b:sub(i,\
    \ i))\n        if a_val ~= b_val then\n            table.insert(result, 1)\n \
    \       else\n            table.insert(result, 0)\n        end\n    end\n    return\
    \ table.concat(result)\nend", "    local s = \"\"\n    for i = 1, math.max(#a,\
    \ #b) do\n        s = s .. (string.byte(a, i) == string.byte(b, i) and '0' or\
    \ '1')\n    end\n    return s\nend", "    local c = ''\n    local bt = { 0, 1\
    \ }\n    for i = 1, #a do\n        c = c .. bt[tonumber(a:sub(i, i)) + tonumber(b:sub(i,\
    \ i)) + 1]\n    end\n    return c\nend", "    if a == nil or b == nil then\n \
    \       return nil\n    end\n    if #a ~= #b then\n        return nil\n    end\n\
    \    local res = {}\n    for i = 1, #a do\n        res[i] = a:sub(i, i) ~= b:sub(i,\
    \ i) and '1' or '0'\n    end\n    return table.concat(res)\nend", "    local result\
    \ = ''\n    local short_string, long_string\n    if #a > #b then\n        short_string\
    \ = b\n        long_string = a\n    else\n        short_string = a\n        long_string\
    \ = b\n    end\n    for i = 1, #short_string do\n        result = result .. (char_xor(short_string:sub(i,\
    \ i), long_string:sub(i, i)))\n    end\n    for i = #short_string + 1, #long_string\
    \ do\n        result = result .. long_string:sub(i, i)\n    end\n    return result\n\
    end", "  local a_bin = read_binary(a)\n  local b_bin = read_binary(b)\n  return\
    \ to_binary(xor(a_bin, b_bin))\nend", "\tlocal a1, a2, a3 = a:byte(1,3)\n\tlocal\
    \ b1, b2, b3 = b:byte(1,3)\n\tlocal r1 = bit.bxor(a1, b1)\n\tlocal r2 = bit.bxor(a2,\
    \ b2)\n\tlocal r3 = bit.bxor(a3, b3)\n\treturn string.char(r1, r2, r3)\nend",
  "  local res = {}\n  for i = 1, #a do\n    res[i] = a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1'\n  end\n  return table.concat(res)\nend", "  local r = ''\n  for\
    \ i = 1, #a do\n    local x = tonumber(a:sub(i, i))\n    local y = tonumber(b:sub(i,\
    \ i))\n    r = r .. tostring(xor(x, y))\n  end\n  return r\nend", "    local ret\
    \ = {}\n    local len = math.max(a:len(), b:len())\n    for i = 1, len do\n  \
    \      local byte_a = a:byte(i) or 0\n        local byte_b = b:byte(i) or 0\n\
    \        local byte_ret = bit.bxor(byte_a, byte_b)\n        table.insert(ret,\
    \ string.char(byte_ret))\n    end\n    return table.concat(ret)\nend", "    local\
    \ aa = a:byte(1)\n    local bb = b:byte(1)\n    local r = aa ~ bb\n    return\
    \ string.char(r)\nend", "\treturn a:gsub('%d', {['0'] = {['0'] = '0', ['1'] =\
    \ '1'}, ['1'] = {['0'] = '1', ['1'] = '0'}})\n\t        :gsub('.', b:sub(1, 1):byte())\n\
    end", "    local res = {}\n    for i = 1, math.max(#a, #b) do\n        res[i]\
    \ = achar_xor(a:sub(i, i), b:sub(i, i))\n    end\n    return table.concat(res)\n\
    end", "\treturn (a:gsub('.', function(x)\n\t\treturn b:sub(x:byte(), x:byte())\n\
    \tend))\nend", "    local result = {}\n    for i = 1, #a do\n        local ai\
    \ = tonumber(a:sub(i, i))\n        local bi = tonumber(b:sub(i, i))\n        table.insert(result,\
    \ (ai + bi) % 2)\n    end\n    return table.concat(result)\nend", "\tlocal result\
    \ = \"\"\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\t\t\tresult\
    \ = result .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\tend\n\tend\n\
    \treturn result\nend", "\tassert(#a == #b, \"string_xor: input strings must be\
    \ same length\")\n\tlocal result = \"\"\n\tfor i = 1, #a do\n\t\tlocal ai = a:sub(i,\
    \ i)\n\t\tlocal bi = b:sub(i, i)\n\t\tlocal ai_value = tonumber(ai)\n\t\tlocal\
    \ bi_value = tonumber(bi)\n\t\tassert(ai_value == 0 or ai_value == 1, \"string_xor:\
    \ input strings must be 0/1\")\n\t\tassert(bi_value == 0 or bi_value == 1, \"\
    string_xor: input strings must be 0/1\")\n\t\tresult = result .. tostring(ai_value\
    \ ~ bi_value)\n\tend\n\treturn result\nend", "\tassert(type(a) == 'string', 'Argument\
    \ \"a\" missing or not a string')\n\tassert(type(b) == 'string', 'Argument \"\
    b\" missing or not a string')\n\tassert(#a == #b, 'Arguments \"a\" and \"b\" do\
    \ not have the same length')\n\tlocal result = {}\n\tfor i = 1, #a do\n\t\tresult[i]\
    \ = ('%x'):format(tonumber(a:sub(i, i), 16) ~ tonumber(b:sub(i, i), 16))\n\tend\n\
    \treturn table.concat(result)\nend", "  local result = ''\n  local limit = math.min(#a,\
    \ #b)\n  for i = 1, limit do\n    result = result .. tostring(math.fmod(tonumber(a:sub(i,\
    \ i)) + tonumber(b:sub(i, i)), 2))\n  end\n  return result\nend", "  local z =\
    \ \"\"\n  local i = 0\n  while i < #a do\n    z = z .. ((a:sub(i + 1, i + 1) ==\
    \ b:sub(i + 1, i + 1)) and \"0\" or \"1\")\n    i = i + 1\n  end\n  return z\n\
    end", "    assert(type(a) == 'string' and type(b) == 'string')\n    local t =\
    \ { }\n    for i = 1, string.len(a) do\n        if a:sub(i, i) == b:sub(i, i)\
    \ then\n            t[i] = '0'\n        else\n            t[i] = '1'\n       \
    \ end\n    end\n    return table.concat(t)\nend", "  local result = \"\"\n  for\
    \ i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result\
    \ .. \"0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return\
    \ result\nend", "\tlocal r = ''\n\tfor i = 1, #a do\n\t\tr = r .. (a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n\tend\n\treturn r\nend", "    local result =\
    \ {}\n    for i = 1, math.max(#a, #b) do\n        result[i] = tonumber(a:sub(i,\
    \ i)) ~= tonumber(b:sub(i, i)) and '1' or '0'\n    end\n    return table.concat(result)\n\
    end", "    local a_bytes = map(str2num, split(a, ''))\n    local b_bytes = map(str2num,\
    \ split(b, ''))\n    local result = {}\n    for i = 1, #a_bytes do\n        result[i]\
    \ = bxor(a_bytes[i], b_bytes[i])\n    end\n    return concat(result)\nend", " \
    \ local s = ''\n  for i = 1, #a do\n    if not (a:sub(i, i) == b:sub(i, i)) then\n\
    \      s = s .. '1'\n    else\n      s = s .. '0'\n    end\n  end\n  return s\n\
    end", "    local xor = bit32.bxor\n    local s = ''\n    for i = 1, #a do\n  \
    \      s = s .. xor(a:byte(i) - 48, b:byte(i) - 48)\n    end\n    return s\nend",
  "    local sb = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i)\
    \ then\n            sb = sb .. '0'\n        else\n            sb = sb .. '1'\n\
    \        end\n    end\n    return sb\nend", "    local r = \"\"\n    for i = 1,\
    \ #a do\n        r = r .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n  \
    \  end\n    return r\nend", "\tlocal result = ''\n\tfor i = 1, #a do\n\t\tresult\
    \ = result .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\tend\n\treturn result\n\
    end", "    if #a ~= #b then\n        error(\"Strings must be of same length!\"\
    )\n    end\n    local result = {}\n    for i = 1, #a do\n        result[i] = a:sub(i,\
    \ i) ~= b:sub(i, i) and '1' or '0'\n    end\n    return table.concat(result)\n\
    end", "    local result = ''\n    for i = 1, a:len() do\n        local a_bit =\
    \ a:sub(i, i)\n        local b_bit = b:sub(i, i)\n        if a_bit == b_bit then\n\
    \            result = result .. '0'\n        else\n            result = result\
    \ .. '1'\n        end\n    end\n    return result\nend", "  if #a ~= #b then\n\
    \    error(\"strings must be of equal length\")\n  end\n  local result = \"\"\n\
    \  for i = 1, #a do\n    result = result .. tostring(bit.bxor(tonumber(a:sub(i,\
    \ i)), tonumber(b:sub(i, i))))\n  end\n  return result\nend", "  assert(type(a)\
    \ == 'string' and type(b) == 'string', 'Incorrect argument types.')\n  local sl\
    \ = math.min(#a, #b)\n  local s = {}\n  for i = 1, sl do\n    if a:sub(i, i) ==\
    \ b:sub(i, i) then\n      s[i] = '0'\n    else\n      s[i] = '1'\n    end\n  end\n\
    \  return table.concat(s)\nend", "  local r = ''\n  if #a > #b then\n    b = string.rep('0',\
    \ #a - #b) .. b\n  elseif #b > #a then\n    a = string.rep('0', #b - #a) .. a\n\
    \  end\n  for i = 1, #a do\n    r = r .. (a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1')\n  end\n  return r\nend", "    local result = ''\n    for i = 1, #a do\n\
    \        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n\
    \        else\n            result = result .. '1'\n        end\n    end\n    return\
    \ result\nend", "    local xor = {\n        ['0'] = { ['0'] = '0', ['1'] = '1'\
    \ },\n        ['1'] = { ['0'] = '1', ['1'] = '0' }\n    }\n    assert(#a == #b,\
    \ 'inputs must be of equal length')\n    local xored = {}\n    for i = 1, #a do\n\
    \        xored[i] = xor[a:sub(i, i)][b:sub(i, i)]\n    end\n    return table.concat(xored)\n\
    end", "\tlocal x, y = tonumber(a, 2), tonumber(b, 2)\n\treturn (\"%x\"):format(x\
    \ ~ y)\nend", "    return xor_string(a, b)\nend", "\tlocal r = {}\n\tlocal l =\
    \ math.max(#a, #b)\n\tfor i = 1, l do\n\t\tlocal x, y = tonumber(a:sub(i, i))\
    \ or 0, tonumber(b:sub(i, i)) or 0\n\t\tr[i] = (x + y) % 2\n\tend\n\treturn table.concat(r)\n\
    end", "  local res = \"\"\n  for i = 1, a:len() do\n    res = res .. (a:sub(i,\
    \ i) == b:sub(i, i) and \"0\" or \"1\")\n  end\n  return res\nend", "\tlocal len,\
    \ xor = math.min(#a, #b), {}\n\tfor i = 1, len do\n\t\txor[i] = a:sub(i, i) ~=\
    \ b:sub(i, i) and '1' or '0'\n\tend\n\treturn table.concat(xor)\nend", "\tlocal\
    \ length = a:len()\n\tlocal xored = ''\n\tfor i = 1, length do\n\t\tlocal _, ba\
    \ = a:byte(i)\n\t\tlocal _, bb = b:byte(i)\n\t\tlocal xor = ba ~ bb\n\t\txored\
    \ = xored .. tostring(xor)\n\tend\n\treturn xored\nend", "\tassert(type(a) ==\
    \ 'string' and type(b) == 'string')\n\tlocal s = ''\n\tfor i = 1, math.max(#a,\
    \ #b) do\n\t\tlocal x = tonumber(a:sub(i, i) or '0')\n\t\tlocal y = tonumber(b:sub(i,\
    \ i) or '0')\n\t\ts = s .. tostring(xor_gate(x, y))\n\tend\n\treturn s\nend",
  "    if #a > #b then\n        a, b = b, a\n    end\n    local result = {}\n    for\
    \ i = 1, #a do\n        result[i] = bit32.bxor(tonumber(a:sub(i, i)), tonumber(b:sub(i,\
    \ i)))\n    end\n    for i = #a + 1, #b do\n        result[i] = tonumber(b:sub(i,\
    \ i))\n    end\n    return table.concat(result)\nend", "\treturn a:gsub('.', {['0']='1',\
    \ ['1']='0'})\n\t\t:gsub('.', {['0']='1', ['1']='%0'})\n\t\t:gsub('.', {['0']='0',\
    \ ['1']='%0'})\nend", "  if a == b then\n    return string.rep('0', #a)\n  end\n\
    \  local temp = 'x'\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n\
    \      temp = temp .. '0'\n    else\n      temp = temp .. '1'\n    end\n  end\n\
    \  return temp:sub(2)\nend", "  local res = {}\n  local n = math.max(#a, #b)\n\
    \  for i = 1, n do\n    table.insert(res, ((a:sub(i, i) == '1') ~= (b:sub(i, i)\
    \ == '1')) and '1' or '0')\n  end\n  return table.concat(res)\nend", "    local\
    \ xor = {}\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n\
    \            xor[i] = '0'\n        else\n            xor[i] = '1'\n        end\n\
    \    end\n    return table.concat(xor)\nend", "    local ax = a:len()\n    local\
    \ bx = b:len()\n    local result = \"\"\n    for i = 1, math.max(ax, bx) do\n\
    \        local x = 0\n        if i <= ax and a:sub(i, i) == \"1\" then\n     \
    \       x = x + 1\n        end\n        if i <= bx and b:sub(i, i) == \"1\" then\n\
    \            x = x + 1\n        end\n        if x % 2 == 0 then\n            result\
    \ = result .. \"0\"\n        else\n            result = result .. \"1\"\n    \
    \    end\n    end\n    return result\nend", "    local output = ''\n    for i\
    \ = 1, #a do\n        output = output .. (a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1')\n    end\n    return output\nend", "    local result = \"\"\n    local\
    \ ai = 1\n    local bi = 1\n    local max_len = math.max(#a, #b)\n    while ai\
    \ <= max_len and bi <= max_len do\n        local ca = a:sub(ai, ai)\n        local\
    \ cb = b:sub(bi, bi)\n        if ca == \"0\" and cb == \"0\" then\n          \
    \  result = result .. \"0\"\n        elseif ca == \"1\" and cb == \"1\" then\n\
    \            result = result .. \"0\"\n        else\n            result = result\
    \ .. \"1\"\n        end\n        ai = ai + 1\n        bi = bi + 1\n    end\n \
    \   return result\nend", "    local buf = {}\n    for i = 1, math.max(#a, #b)\
    \ do\n        buf[i] = (a:sub(i, i) == '1' and b:sub(i, i) ~= '1')\n         \
    \       or (a:sub(i, i) ~= '1' and b:sub(i, i) == '1')\n                and '1'\
    \ or '0'\n    end\n    return table.concat(buf)\nend", "  return a:gsub('.', {\
    \ ['0'] = function (c) return b:sub(1,1) end, ['1'] = function (c) return b:sub(1,1)\
    \ == '0' and '1' or '0' end })\nend", "    if #a > #b then\n        b = string.rep('0',\
    \ #a - #b) .. b\n    elseif #b > #a then\n        a = string.rep('0', #b - #a)\
    \ .. a\n    end\n    local result = {}\n    for i = 1, #a do\n        local s\
    \ = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n        table.insert(result, s)\n\
    \    end\n    return table.concat(result)\nend", "  local str = ''\n  for i =\
    \ 1, #a do\n    str = str .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n\
    \  return str\nend", "  local ret = {}\n  local k = 0\n  for i = 1, #a do\n  \
    \  local x = a:sub(i, i)\n    local y = b:sub(i, i)\n    k = k + 1\n    ret[k]\
    \ = xor_num[x][y]\n  end\n  return table.concat(ret)\nend", "    local result\
    \ = \"\"\n    local len = string.len(a)\n    for i = 1, len do\n        local\
    \ a_bit = string.sub(a, i, i)\n        local b_bit = string.sub(b, i, i)\n   \
    \     local xor_bit = string_xor_bit(a_bit, b_bit)\n        result = result ..\
    \ xor_bit\n    end\n    return result\nend", "  local x, y = tonumber(a, 2), tonumber(b,\
    \ 2)\n  return string.format(\"%03d\", x ~ y):gsub(\"^0+\", \"\")\nend", "\tlocal\
    \ res = \"\"\n\tlocal ta = type(a)\n\tlocal tb = type(b)\n\tif ta ~= \"string\"\
    \ or tb ~= \"string\" then\n\t\terror(\"Parameters a and b must be strings.\"\
    , 2)\n\tend\n\t-- build res string\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal\
    \ ea = a:sub(i, i) or \"0\"\n\t\tlocal eb = b:sub(i, i) or \"0\"\n\t\tif ea ~=\
    \ eb then\n\t\t\tres = res .. \"1\"\n\t\telse\n\t\t\tres = res .. \"0\"\n\t\t\
    end\n\tend\n\treturn res\nend", "    local result = \"\"\n    local index = 1\n\
    \    while index <= #a or index <= #b do\n        local x = 0\n        local y\
    \ = 0\n        if index <= #a then\n            x = tonumber(a:sub(index, index))\n\
    \        end\n        if index <= #b then\n            y = tonumber(b:sub(index,\
    \ index))\n        end\n        result = result .. tostring(bit32.bxor(x, y))\n\
    \        index = index + 1\n    end\n    return result\nend", "    local len =\
    \ math.max(#a, #b)\n    local result = ''\n    for i = 1, len do\n        local\
    \ x = a:sub(i, i) == '1' and 1 or 0\n        local y = b:sub(i, i) == '1' and\
    \ 1 or 0\n        if (x + y) % 2 == 0 then\n            result = result .. '0'\n\
    \        else\n            result = result .. '1'\n        end\n    end\n    return\
    \ result\nend", "  local function a_binary_table()\n    local ret = {}\n    for\
    \ i = 1, #a do\n      table.insert(ret, tonumber(a:sub(i, i)))\n    end\n    return\
    \ ret\n  end", "\tassert_string(1, a)\n\tassert_string(2, b)\n\tlocal n = math.max(#a,\
    \ #b)\n\ta = a:sub(1, n)\n\tb = b:sub(1, n)\n\tlocal r = {}\n\tfor i = 1, n do\n\
    \t\tr[i] = (a:sub(i, i) == b:sub(i, i)) and '0' or '1'\n\tend\n\treturn table.concat(r)\n\
    end", "  return (a:gsub('.', function(x)\n    return b:sub(x == '0' and 1 or 2,\
    \ x == '0' and 1 or 2)\n  end))\nend", "  local result = {}\n  local max = math.max(#a,\
    \ #b)\n  for i = 1, max do\n    local ai = i <= #a and a:sub(i, i) or '0'\n  \
    \  local bi = i <= #b and b:sub(i, i) or '0'\n    result[i] = ai == bi and '0'\
    \ or '1'\n  end\n  return table.concat(result)\nend", "    assert(#a == #b, \"\
    inputs must be of equal length\")\n    local result = ''\n    for i = 1, #a do\n\
    \        result = result .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n    end\n\
    \    return result\nend", "  local s = ''\n  for i = 1, #a do\n    s = s .. (a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1')\n  end\n  return s\nend", "    return a:gsub('.',\
    \ function(x)\n        return b:sub(x == '0' and 1 or 2, x == '0' and 1 or 2)\n\
    \    end)\nend", "    local result = ''\n    for i = 1, #a do\n        if a:sub(i,\
    \ i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n \
    \           result = result .. '1'\n        end\n    end\n    return result\n\
    end", "\tlocal r = ''\n\tfor i = 1, math.max(#a, #b) do\n\t\tr = r .. ((a:sub(i,\
    \ i) == b:sub(i, i)) and '0' or '1')\n\tend\n\treturn r\nend", "  local xor =\
    \ 0\n  local a, b = tonumber(a, 2), tonumber(b, 2)\n  for _ = 0, 31 do\n    local\
    \ da, db = a % 2 == 1, b % 2 == 1\n    if da ~= db then xor = xor + 2^_ end\n\
    \    a, b = (a - da) / 2, (b - db) / 2\n  end\n  return string.format(\"%032d\"\
    , xor):gsub(\"0*$\", \"\")\nend", "    assert(#a == #b, \"input strings are not\
    \ of equal length\")\n    local r = \"\"\n    for i = 1, #a do\n        r = r\
    \ .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)) and '1' or '0')\n    end\n\
    \    return r\nend", "    if #a ~= #b then\n        return nil\n    end\n    local\
    \ out = {}\n    for i = 1, #a do\n        local x = tonumber(a:sub(i, i))\n  \
    \      local y = tonumber(b:sub(i, i))\n        if not x or not y then\n     \
    \       return nil\n        end\n        local z = x ~ y\n        out[i] = tostring(z)\n\
    \    end\n    return table.concat(out)\nend", "  local res = ''\n  for i = 1,\
    \ #a do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n\
    \  return res\nend", "    local result = \"\"\n    for i = 1, #a do\n        if\
    \ a:sub(i, i) == b:sub(i, i) then\n            result = result .. \"0\"\n    \
    \    else\n            result = result .. \"1\"\n        end\n    end\n    return\
    \ result\nend", "\tlocal r = ''\n\tfor i = 1, #a do\n\t\tr = r .. (a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n\tend\n\treturn r\nend", "    local res = {}\n\
    \    for i = 1, #a do\n        res[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or\
    \ \"1\"\n    end\n    return table.concat(res)\nend", "    local r = ''\n    for\
    \ i = 1, #a do\n        r = r .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n\
    \    return r\nend", "  assert(type(a) == 'string' and type(b) == 'string', 'expected\
    \ string arguments')\n  assert(#a == #b, 'string arguments must be the same length')\n\
    \  local out = ''\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n\
    \      out = out .. '0'\n    else\n      out = out .. '1'\n    end\n  end\n  return\
    \ out\nend", "  local out = ''\n  for i = 1, #a do\n    local bit_a = a:sub(i,\
    \ i)\n    local bit_b = b:sub(i, i)\n    local xor_bit = bit_a == bit_b and '0'\
    \ or '1'\n    out = out .. xor_bit\n  end\n  return out\nend", "  assert(#a ==\
    \ #b, 'string_xor: arguments must be same length')\n  local c = {}\n  for i =\
    \ 1, #a do\n    c[i] = b2i(a:sub(i, i)) ~ b2i(b:sub(i, i))\n  end\n  return table.concat(c)\n\
    end", "\tif a:len() ~= b:len() then\n\t\terror(\"string_xor() arguments have different\
    \ lengths!\")\n\tend\n\tlocal r = ''\n\tfor i = 1, a:len() do\n\t\tr = r .. (a:sub(i,\
    \ i) == b:sub(i, i) and '0' or '1')\n\tend\n\treturn r\nend", "\tlocal ret = ''\n\
    \tfor i = 1, #a do\n\t\tret = ret .. bit32.bxor(a:sub(i, i):byte(), b:sub(i, i):byte())\n\
    \tend\n\treturn ret\nend", "    local ret = {}\n    for i = 1, #a do\n       \
    \ ret[i] = (a:sub(i, i) == b:sub(i, i)) and \"0\" or \"1\"\n    end\n    return\
    \ table.concat(ret)\nend", "    local retval = \"\"\n    for i = 1, #a do\n  \
    \      retval = retval .. tostring(a:sub(i, i) ~= b:sub(i, i))\n    end\n    return\
    \ retval\nend", "  assert(#a == #b, \"strings not same length\")\n  local result\
    \ = {}\n  for i = 1, #a do\n    result[i] = a:sub(i, i) == b:sub(i, i) and \"\
    0\" or \"1\"\n  end\n  return table.concat(result)\nend", "  local result = \"\
    \"\n  local longest = math.max(a:len(), b:len())\n  for i = 1, longest do\n  \
    \  local n1 = tonumber(a:sub(i, i)) or 0\n    local n2 = tonumber(b:sub(i, i))\
    \ or 0\n    result = result .. tostring(n1 ~ n2)\n  end\n  return result\nend",
  "  if string.len(a) > string.len(b) then\n    b = string.rep('0', string.len(a)\
    \ - string.len(b)) .. b\n  elseif string.len(a) < string.len(b) then\n    a =\
    \ string.rep('0', string.len(b) - string.len(a)) .. a\n  end\n  local r = ''\n\
    \  for i = 1, string.len(a) do\n    if a:sub(i, i) == b:sub(i, i) then\n     \
    \ r = r .. '0'\n    else\n      r = r .. '1'\n    end\n  end\n  return r\nend",
  "  local result = ''\n  for i = 1, math.max(#a, #b) do\n    result = result .. (((a:sub(i,\
    \ i) == '1') ~= (b:sub(i, i) == '1')) and '1' or '0')\n  end\n  return result\n\
    end", "  local r = {}\n  local bits = #a > #b and #a or #b\n  for i = 1, bits\
    \ do\n    local b1 = a:sub(i, i)\n    local b2 = b:sub(i, i)\n    local sum =\
    \ (b1 == '1' and 1 or 0) + (b2 == '1' and 1 or 0)\n    if sum == 2 then\n    \
    \  r[i] = '0'\n    elseif sum == 1 then\n      r[i] = '1'\n    else\n      r[i]\
    \ = '0'\n    end\n  end\n  return table.concat(r)\nend", "    local result = \"\
    \"\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n       \
    \     result = result .. \"0\"\n        else\n            result = result .. \"\
    1\"\n        end\n    end\n    return result\nend", "    local res = ''\n    local\
    \ i = 1\n    while i <= #a do\n        res = res .. (tonumber(a:sub(i, i)) ~=\
    \ tonumber(b:sub(i, i)) and '1' or '0')\n        i = i + 1\n    end\n    return\
    \ res\nend", "    assert(#a == #b, 'Length mismatch')\n    local out = {}\n  \
    \  for i = 1, #a do\n        out[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\
    \    end\n    return table.concat(out)\nend", "  if #a ~= #b then\n    error('In\
    \ order to perform XOR operation on ' .. a .. ' and ' .. b .. ', both strings\
    \ should have the same length')\n  end\n  return a:gsub('.', function(a)\n   \
    \ return b:sub(1, 1):gsub('.', function(b)\n      return a == b and '0' or '1'\n\
    \    end)\n  end)\nend", "    local _bits = require \"bits\"\n    local r = \"\
    \"\n    local l = math.max(a:len(), b:len())\n    for i = 1, l do\n        local\
    \ x = _bits.bxor(a:byte(i), b:byte(i))\n        if x then\n            r = r ..\
    \ string.char(x)\n        end\n    end\n    return r\nend", "    local ret = ''\n\
    \    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n          \
    \  ret = ret .. '0'\n        else\n            ret = ret .. '1'\n        end\n\
    \    end\n    return ret\nend", "  local res = ''\n  for i = 1, #a do\n    res\
    \ = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  end\n  return res\n\
    end", "    local res = ''\n    for i = 1, #a do\n        res = res .. (tonumber(a:sub(i,\
    \ i)) ~= tonumber(b:sub(i, i)) and '1' or '0')\n    end\n    return res\nend",
  "\tlocal c = {}\n\tfor i = 1, math.max(#a, #b) do\n\t\tc[i] = ((a:sub(i, i) == b:sub(i,\
    \ i)) and '0') or '1'\n\tend\n\treturn table.concat(c)\nend", "\tlocal r = ''\n\
    \tfor i = 1, #a do\n\t\tr = r .. b:sub(i, i):char_xor(a:sub(i, i))\n\tend\n\t\
    return r\nend", "\tlocal r = ''\n\tfor i = 1, #a do\n\t\tr = r .. ((a:sub(i, i)\
    \ == b:sub(i, i)) and '0' or '1')\n\tend\n\treturn r\nend", "  local result =\
    \ \"\"\n  for i = 1, #a do\n    local bita = a:sub(i, i)\n    local bitb = b:sub(i,\
    \ i)\n    if bita ~= bitb then\n      result = result .. \"1\"\n    else\n   \
    \   result = result .. \"0\"\n    end\n  end\n  return result\nend", "    if not\
    \ (type(a) == 'string' and type(b) == 'string') then\n        return nil\n   \
    \ end\n    if #a ~= #b then\n        return nil\n    end\n    local chars = {}\n\
    \    for i = 1, #a do\n        local val = a:sub(i, i) ~= b:sub(i, i) and '1'\
    \ or '0'\n        table.insert(chars, val)\n    end\n    return table.concat(chars)\n\
    end", "  return (a:gsub('.', function(x)\n           return b:sub(x, x) == '1'\
    \ and '0' or '1'\n         end))\nend", "    local result = ''\n    for i = 1,\
    \ math.max(#a, #b) do\n        result = result .. (a:sub(i, i) == b:sub(i, i)\
    \ and '0' or '1')\n    end\n    return result\nend", "    local xor = {}\n   \
    \ if #a == #b then\n        for i = 1, #a do\n            if a:sub(i, i) == b:sub(i,\
    \ i) then\n                xor[i] = '0'\n            else\n                xor[i]\
    \ = '1'\n            end\n        end\n    end\n    return table.concat(xor)\n\
    end", "\tlocal pad = math.abs(#a - #b)\n\tif #a > #b then\n\t\tb = string.rep('0',\
    \ pad) .. b\n\telse\n\t\ta = string.rep('0', pad) .. a\n\tend\n\tlocal out = ''\n\
    \tfor i = 1, #a do\n\t\tout = out .. (bit.band(a:byte(i) - 48, b:byte(i) - 48)\
    \ == 0 and '1' or '0')\n\tend\n\treturn out\nend", "    local len = a:len()\n\
    \    if b:len() ~= len then\n        error(\"String length mismatch\")\n    end\n\
    \    local res = ''\n    for i = 1, len do\n        res = res .. (a:sub(i, i)\
    \ == b:sub(i, i) and '0' or '1')\n    end\n    return res\nend", "    local result\
    \ = {}\n    for i = 1, math.max(#a, #b) do\n        local a_int = tonumber(a:sub(i,\
    \ i)) or 0\n        local b_int = tonumber(b:sub(i, i)) or 0\n        result[i]\
    \ = (a_int ~ b_int)\n    end\n    return table.concat(result)\nend", "\tassert(type(a)\
    \ == 'string' and type(b) == 'string')\n\tassert(#a == #b)\n\tlocal result = ''\n\
    \tfor i = 1, #a do\n\t\tresult = result .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i,\
    \ i)) and '1' or '0')\n\tend\n\treturn result\nend", "    local r = ''\n    for\
    \ i = 1, math.max(#a, #b) do\n        r = r .. (bit.bxor(tonumber(a:sub(i, i)\
    \ or 0), tonumber(b:sub(i, i) or 0)) % 2)\n    end\n    return r\nend", "\tlocal\
    \ a_len = a:len()\n\tlocal b_len = b:len()\n\tif a_len < b_len then\n\t\ta = a\
    \ .. string.rep('0', b_len - a_len)\n\telseif b_len < a_len then\n\t\tb = b ..\
    \ string.rep('0', a_len - b_len)\n\tend\n\tlocal b_xor = {}\n\tfor i = 1, a:len()\
    \ do\n\t\tlocal a_sub = a:sub(i, i)\n\t\tlocal b_sub = b:sub(i, i)\n\t\tif a_sub\
    \ == b_sub then\n\t\t\tb_xor[i] = '0'\n\t\telse\n\t\t\tb_xor[i] = '1'\n\t\tend\n\
    \tend\n\treturn table.concat(b_xor)\nend", "    local xor_vals = {}\n    for i\
    \ = 1, a:len() do\n        local xor_val = tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i))\n        table.insert(xor_vals, xor_val and '1' or '0')\n    end\n    return\
    \ table.concat(xor_vals)\nend", "  local result = {}\n  local i\n  for i = 1,\
    \ #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result[i] = '0'\n    else\n\
    \      result[i] = '1'\n    end\n  end\n  return table.concat(result)\nend", " \
    \   local res = \"\"\n    local i = 0\n    while i < #a and i < #b do\n      \
    \  local char_a = a:sub(i + 1, i + 1)\n        local char_b = b:sub(i + 1, i +\
    \ 1)\n        if char_a == char_b then\n            res = res .. \"0\"\n     \
    \   else\n            res = res .. \"1\"\n        end\n        i = i + 1\n   \
    \ end\n    return res\nend", "  if #a ~= #b then\n    error(\"strings are of different\
    \ lengths\")\n  end\n  local res = {}\n  for i = 1, #a do\n    res[i] = string.char(bit.bxor(string.byte(a,\
    \ i), string.byte(b, i)))\n  end\n  return table.concat(res)\nend", "    local\
    \ result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n\
    \            result = result .. '0'\n        else\n            result = result\
    \ .. '1'\n        end\n    end\n    return result\nend", "\tlocal result = {}\n\
    \tfor i = 1, #a do\n\t\tresult[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\
    \tend\n\treturn table.concat(result)\nend", "    assert(type(a) == 'string' and\
    \ type(b) == 'string')\n    local length = math.max(#a, #b)\n    a = string.rep('0',\
    \ length - #a) .. a\n    b = string.rep('0', length - #b) .. b\n    local result\
    \ = {}\n    for i = 1, length do\n        local xor = string.byte(a, i) ~ string.byte(b,\
    \ i)\n        table.insert(result, string.char(xor))\n    end\n    return table.concat(result)\n\
    end", "\tlocal ret = {}\n\tlocal a_len = #a\n\tlocal b_len = #b\n\tlocal big_len\
    \ = math.max(a_len, b_len)\n\tlocal i = 0\n\twhile i < big_len do\n\t\tlocal a_i\
    \ = a:sub(i + 1, i + 1)\n\t\tlocal b_i = b:sub(i + 1, i + 1)\n\t\tif a_i == b_i\
    \ then\n\t\t\tret[i + 1] = '0'\n\t\telse\n\t\t\tret[i + 1] = '1'\n\t\tend\n\t\t\
    i = i + 1\n\tend\n\treturn table.concat(ret)\nend", "    local s = \"\"\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            s = s\
    \ .. \"0\"\n        else\n            s = s .. \"1\"\n        end\n    end\n \
    \   return s\nend", "    local result = {}\n    for i = 1, #a do\n        local\
    \ char_a = a:sub(i, i)\n        local char_b = b:sub(i, i)\n        local result_chr\
    \ = string_xor_char(char_a, char_b)\n        table.insert(result, result_chr)\n\
    \    end\n    return table.concat(result)\nend", "    local result = {}\n    for\
    \ i = 1, #a do\n        result[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\
    \    end\n    return table.concat(result)\nend", "    if #a ~= #b then\n     \
    \   error('Attempt to xor strings of unequal length')\n    end\n    local result\
    \ = {}\n    for i = 1, #a do\n        local b1 = a:sub(i, i)\n        local b2\
    \ = b:sub(i, i)\n        if b1 ~= b2 then\n            table.insert(result, '1')\n\
    \        else\n            table.insert(result, '0')\n        end\n    end\n \
    \   return table.concat(result)\nend", "  local s, i, j, m, n, byte, byte_a, byte_b,\
    \ byte_c\n  if #a < #b then\n    s, i, j, m, n = b, #b, #a, -1, -1\n  else\n \
    \   s, i, j, m, n = a, #a, #b, 1, 1\n  end\n  byte_a = string.byte(a, i)\n  byte_b\
    \ = string.byte(b, j)\n  byte_c = byte_a ~ byte_b\n  while byte_c ~= 0 do\n  \
    \  byte = byte_c % 2\n    byte_c = (byte_c - byte) / 2\n    s = string.char(string.byte(s,\
    \ i) + byte) .. s\n    i = i + m\n    j = j + n\n    byte_a = string.byte(a, i)\n\
    \    byte_b = string.byte(b, j)\n    byte_c = byte_c + byte_a + byte_b\n  end\n\
    \  return s\nend", "  local x = ''\n  for i = 1, #a do\n    x = x .. tostring(a:sub(i,\
    \ i) ~= b:sub(i, i))\n  end\n  return x\nend", "  local result = \"\"\n  local\
    \ len = math.max(a:len(), b:len())\n  for i = 1, len do\n    local s = \"\"\n\
    \    local x = tonumber(a:sub(i, i))\n    local y = tonumber(b:sub(i, i))\n  \
    \  if x and y then\n      s = (x + y) % 2\n    elseif x then\n      s = x\n  \
    \  elseif y then\n      s = y\n    end\n    result = result .. s\n  end\n  return\
    \ result\nend", "    local n = math.max(#a, #b)\n    local xor = ''\n    for i\
    \ = 1, n do\n        xor = xor .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n\
    \    end\n    return xor\nend", "    local res = ''\n    for i = 1, math.max(#a,\
    \ #b) do\n        local num1 = tonumber(a:sub(i, i)) or 0\n        local num2\
    \ = tonumber(b:sub(i, i)) or 0\n        res = res .. tostring(num1 ~ num2)\n \
    \   end\n    return res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
