name: HumanEval_73_smallest_change
language: lua
prompt: "-- Given an array arr of integers, find the minimum number of elements that\n\
  -- need to be changed to make the array palindromic. A palindromic array is an array\
  \ that\n-- is read the same backwards and forwards. In one change, you can change\
  \ one element to any other element.\n-- For example:\n-- smallest_change([1,2,3,5,4,7,9,6])\
  \ == 4\n-- smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n-- smallest_change([1, 2,\
  \ 3, 2, 1]) == 0\nlocal function smallest_change(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = smallest_change\n\
  \    lu.assertEquals(candidate({1, 2, 3, 5, 4, 7, 9, 6}), 4)\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 3, 2, 2}), 1)\n    lu.assertEquals(candidate({1, 4, 2}), 1)\n    lu.assertEquals(candidate({1,\
  \ 4, 4, 2}), 1)\n    lu.assertEquals(candidate({1, 2, 3, 2, 1}), 0)\n    lu.assertEquals(candidate({3,\
  \ 1, 1, 3}), 0)\n    lu.assertEquals(candidate({1}), 0)\n    lu.assertEquals(candidate({0,\
  \ 1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal sum = 0\n\tfor i = 1, #arr/2 do\n\t\tif arr[i] ~= arr[#arr-i+1]\
    \ then\n\t\t\tsum = sum + 1\n\t\tend\n\tend\n\treturn sum\nend", "    -- Write\
    \ your code here\nend", "  -- make a copy of the array and reverse it\n  local\
    \ copy = copy_array(arr)\n  local reversed = reverse_array(copy)\n  -- keep track\
    \ of changes\n  local diff = 0\n  -- compare each element in the array to its\
    \ reversed equivalent\n  for i,v in ipairs(arr) do\n    if arr[i] ~= reversed[i]\
    \ then\n      diff = diff + 1\n    end\n  end\n  return diff\nend", "    local\
    \ len = #arr\n    local min = math.huge\n    for i = 1, len do\n        local\
    \ sum = 0\n        for j = 1, math.floor(len / 2) do\n            local lj = i\
    \ - j\n            local rj = i + j\n            if (len % 2 == 0 and rj > len)\
    \ or (len % 2 == 1 and rj > len - 1) then\n                lj = i - j - 1\n  \
    \          end\n            if lj > 0 and rj <= len then\n                sum\
    \ = sum + math.abs(arr[lj] - arr[rj])\n            end\n        end\n        min\
    \ = math.min(min, sum)\n    end\n    return min\nend", "    local changes = 0\n\
    \    local left = 1\n    local right = #arr\n    while left < right do\n     \
    \   if arr[left] ~= arr[right] then\n            changes = changes + 1\n     \
    \   end\n        left = left + 1\n        right = right - 1\n    end\n    return\
    \ changes\nend", "    local count = 0\n    local last = #arr\n    local first\
    \ = 1\n    while last > first do\n        if arr[last] ~= arr[first] then\n  \
    \          count = count + 1\n        end\n        last = last - 1\n        first\
    \ = first + 1\n    end\n    return count\nend", "  local function is_palindrome(arr)\n\
    \    local half = #arr // 2\n    for i = 1, half do\n      if arr[i] ~= arr[#arr\
    \ - i + 1] then\n        return false\n      end\n    end\n    return true\n \
    \ end", "    -- Fill this in.\n    local len = #arr\n    local count = 0\n   \
    \ for i = 1, math.floor(len / 2) do\n        if arr[i] ~= arr[len - i + 1] then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  local n = #arr\n  local left, right = 1, n\n  local cnt = 0\n  while left < right\
    \ do\n    if arr[left] ~= arr[right] then\n      cnt = cnt + 1\n    end\n    left\
    \ = left + 1\n    right = right - 1\n  end\n  return cnt\nend", "  local len =\
    \ #arr\n  local changes = 0\n  for i = 1, len // 2 do\n    if arr[i] ~= arr[len\
    \ - i + 1] then\n      changes = changes + 1\n    end\n  end\n  return changes\n\
    end", "    local i = 1\n    local j = #arr\n    local changes = 0\n    while i\
    \ < j do\n        if arr[i] ~= arr[j] then\n            changes = changes + 1\n\
    \        end\n        i = i + 1\n        j = j - 1\n    end\n    return changes\n\
    end", "    local n = #arr\n    local dp = {}\n    for i = 0, n do\n        dp[i]\
    \ = {}\n        for j = 0, n do\n            dp[i][j] = 0\n        end\n    end\n\
    \    for i = 0, n - 1 do\n        for j = n - 1, 0, -1 do\n            if i >=\
    \ j then\n                dp[i][j] = 0\n            elseif arr[i + 1] == arr[j\
    \ + 1] then\n                dp[i][j] = dp[i + 1][j - 1]\n            else\n \
    \               dp[i][j] = 1 + math.min(dp[i + 1][j], dp[i][j - 1])\n        \
    \    end\n        end\n    end\n    return dp[0][n - 1]\nend", "    local len\
    \ = #arr\n    local dp = {}\n    for i = 0, len do\n        dp[i] = {}\n     \
    \   for j = 0, len do\n            dp[i][j] = 0\n        end\n    end\n    for\
    \ i = 1, len do\n        for j = 1, len - i + 1 do\n            local last = j\
    \ + i - 1\n            if arr[j] == arr[last] then\n                dp[j][last]\
    \ = dp[j + 1][last - 1]\n            else\n                dp[j][last] = math.min(dp[j\
    \ + 1][last], dp[j][last - 1]) + 1\n            end\n        end\n    end\n  \
    \  return dp[1][len]\nend", "\tlocal function same_but_reversed(a, b)\n\t\tfor\
    \ i = 1, math.floor(#a / 2) do\n\t\t\tif a[i] ~= b[#b - i + 1] then\n\t\t\t\t\
    return false\n\t\t\tend\n\t\tend\n\t\treturn true\n\tend\n\tlocal reverse = {}\n\
    \tfor i = #arr, 1, -1 do\n\t\treverse[#reverse + 1] = arr[i]\n\tend\n\tif same_but_reversed(arr,\
    \ reverse) then\n\t\treturn 0\n\tend\n\tlocal function check(index)\n\t\tlocal\
    \ a = {}\n\t\tfor i = 1, #arr do\n\t\t\ta[i] = arr[i]\n\t\tend\n\t\tfor i = 1,\
    \ index do\n\t\t\ta[i] = arr[#arr - i + 1]\n\t\tend\n\t\tlocal function changes(index)\n\
    \t\t\tlocal changes = 0\n\t\t\tfor i = 1, index do\n\t\t\t\tif a[i] ~= a[#a -\
    \ i + 1] then\n\t\t\t\t\tchanges = changes + 1\n\t\t\t\tend\n\t\t\tend\n\t\t\t\
    return changes\n\t\tend\n\t\tlocal min = changes(index)\n\t\tfor i = 1, index\
    \ do\n\t\t\tlocal last = a[i]\n\t\t\tfor j = 1, #arr do\n\t\t\t\ta[i] = arr[j]\n\
    \t\t\t\tlocal n = changes(index)\n\t\t\t\tif n < min then\n\t\t\t\t\tmin = n\n\
    \t\t\t\tend\n\t\t\tend\n\t\t\ta[i] = last\n\t\tend\n\t\treturn min\n\tend\n\t\
    local min = #arr\n\tfor i = 1, #arr do\n\t\tlocal n = check(i)\n\t\tif n < min\
    \ then\n\t\t\tmin = n\n\t\tend\n\tend\n\treturn min\nend", "  local start, end_,\
    \ change = 1, #arr, 0\n  for i = 1, #arr do\n    if arr[start] ~= arr[end_] then\n\
    \      change = change + 1\n    end\n    start = start + 1\n    end_ = end_ -\
    \ 1\n  end\n  return change\nend", "    local s, e = 1, #arr\n    local n = 0\n\
    \    while s < e do\n        if arr[s] ~= arr[e] then\n            n = n + 1\n\
    \        end\n        s = s + 1\n        e = e - 1\n    end\n    return n\nend",
  "    for i = 1, math.floor(#arr / 2) do\n        if arr[i] ~= arr[#arr - i + 1]\
    \ then\n            return 1\n        end\n    end\n    return 0\nend", "    local\
    \ length = #arr\n    local count = 0\n    for i = 1, length/2 do\n        if arr[i]\
    \ ~= arr[length - i + 1] then\n            count = count + 1\n        end\n  \
    \  end\n    return count\nend", "  local len = #arr\n  local arr2 = util.reverse(arr)\n\
    \  local count = 0\n  for i = 1,len do\n    if arr[i] ~= arr2[i] then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "    if arr == nil then\n\
    \        return 0\n    end\n    local i = 1\n    local j = #arr\n    local diff_count\
    \ = 0\n    while i < j do\n        if arr[i] ~= arr[j] then\n            diff_count\
    \ = diff_count + 1\n        end\n        i = i + 1\n        j = j - 1\n    end\n\
    \    return diff_count\nend", "  local function helper(i, j)\n    if i > j then\
    \ return 0 end\n    if i == j then return 1 end\n    if arr[i] == arr[j] then\n\
    \      return helper(i + 1, j - 1)\n    else\n      return 1 + min(helper(i +\
    \ 1, j), helper(i, j - 1))\n    end\n  end\n  return helper(1, #arr)\nend", " \
    \ return 0\nend", "    local n = #arr\n    local dp = {}\n    for i = 0, n - 1\
    \ do\n        dp[i] = {}\n        for j = 0, n - 1 do\n            dp[i][j] =\
    \ -1\n        end\n    end\n    local function _smallest_change(a, b)\n      \
    \  if dp[a][b] ~= -1 then\n            return dp[a][b]\n        end\n        if\
    \ a >= b then\n            dp[a][b] = 0\n            return 0\n        end\n \
    \       local rv = 0\n        if arr[a] == arr[b] then\n            rv = _smallest_change(a\
    \ + 1, b - 1)\n        else\n            rv = 1 + _smallest_change(a + 1, b -\
    \ 1)\n            rv = math.min(rv, 1 + _smallest_change(a + 1, b))\n        \
    \    rv = math.min(rv, 1 + _smallest_change(a, b - 1))\n        end\n        dp[a][b]\
    \ = rv\n        return rv\n    end\n    return _smallest_change(1, n)\nend", " \
    \ local size = #arr\n  local nchanges = 0\n  for i = 1, math.floor(size / 2) do\n\
    \    local a = arr[i]\n    local b = arr[size - i + 1]\n    if a ~= b then\n \
    \     nchanges = nchanges + 1\n    end\n  end\n  return nchanges\nend", "    return\
    \ 0\nend", "  local l = 1\n  local r = #arr\n  local ans = 0\n  while l < r do\n\
    \    if arr[l] ~= arr[r] then\n      ans = ans + 1\n    end\n    l = l + 1\n \
    \   r = r - 1\n  end\n  return ans\nend", '  local n = #arr', "    local n = #arr\n\
    \    local left, right = 1, n\n    local changes = 0\n    while left < right do\n\
    \        if arr[left] ~= arr[right] then\n            if arr[left] < arr[right]\
    \ then\n                arr[left] = arr[right]\n            else\n           \
    \     arr[right] = arr[left]\n            end\n            changes = changes +\
    \ 1\n        end\n        left = left + 1\n        right = right - 1\n    end\n\
    \    return changes\nend", "    return 0\nend", "  local n = #arr\n  local count\
    \ = 0\n  for i = 1, math.floor(n / 2) do\n    if arr[i] ~= arr[n - i + 1] then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "  local t = {}\n\
    \  local len = #arr\n  local s = len % 2 == 0 and len / 2 or len / 2 + 1\n  local\
    \ e = len / 2\n  for i = 1, s do\n    local v = arr[i]\n    if t[v] then\n   \
    \   t[v] = t[v] + 1\n    else\n      t[v] = 1\n    end\n  end\n  for i = e, 1,\
    \ -1 do\n    local v = arr[i]\n    if t[v] then\n      t[v] = t[v] - 1\n    else\n\
    \      t[v] = 1\n    end\n  end\n  local count = 0\n  for _, v in pairs(t) do\n\
    \    count = count + v\n  end\n  return count\nend", "  for i = 1, #arr do\n \
    \   if arr[i] ~= arr[#arr - i + 1] then\n      -- change at least one of the values\n\
    \      arr[i] = arr[#arr - i + 1]\n      break\n    end\n  end\n  return find_unequal_nums(arr)\n\
    end", "  if (not is_palindrome(arr)) then\n    local left = 0\n    local right\
    \ = #arr - 1\n    local changes = 0\n    while left < right do\n      if arr[left]\
    \ ~= arr[right] then\n        changes = changes + 1\n      end\n      left = left\
    \ + 1\n      right = right - 1\n    end\n    return changes\n  end\n  return 0\n\
    end", "  -- your code here\nend", "    local diffs = {}\n    for i = 1, #arr /\
    \ 2 do\n        diffs[i] = math.abs(arr[i] - arr[#arr - i + 1])\n    end\n   \
    \ return table.reduce(diffs, 0, function(acc, val) return acc + val end)\nend",
  "    -- TODO: Implement function\n    return 0\nend", "  local l = #arr\n  local\
    \ count = 0\n  for i = 1, l / 2 do\n    if arr[i] ~= arr[l - i + 1] then\n   \
    \   count = count + 1\n    end\n  end\n  return count\nend", "    local min =\
    \ {}\n    local len = #arr\n    for i = 1, len do\n        if arr[i] == arr[len\
    \ - i + 1] then\n            min[i] = min[i - 1] or 0\n        else\n        \
    \    min[i] = (min[i - 1] or 0) + 1\n        end\n    end\n    local min_len =\
    \ min[len - 1] or min[len]\n    for i = 2, len do\n        if min[i - 1] < min_len\
    \ then\n            min_len = min[i - 1]\n        end\n    end\n    return min_len\n\
    end", "    if #arr == 0 then\n        return 0\n    end\n    local mid = math.floor(#arr\
    \ / 2)\n    local left = 0\n    local right = #arr - 1\n    local diff = 0\n \
    \   while (left < mid) do\n        if arr[left] ~= arr[right] then\n         \
    \   diff = diff + 1\n        end\n        left = left + 1\n        right = right\
    \ - 1\n    end\n    return diff\nend", "    --[[\n    This function will take\
    \ a array\n    and will return the number of elements\n    we need to change to\
    \ make it palindromic\n    ]]\n    local start = 1\n    local end_index = #arr\n\
    \    local count = 0\n    while start < end_index do\n        if arr[start] ~=\
    \ arr[end_index] then\n            count = count + 1\n        end\n        start\
    \ = start + 1\n        end_index = end_index - 1\n    end\n    return count\n\
    end", end, "  local i, j = 1, #arr\n  local count = 0\n  while i < j do\n    if\
    \ arr[i] ~= arr[j] then\n      count = count + 1\n    end\n    i = i + 1\n   \
    \ j = j - 1\n  end\n  return count\nend", "  local count = 0\n  local length =\
    \ #arr\n  local is_palindrome = true\n  local i = 1\n  while i <= length do\n\
    \    if arr[i] ~= arr[length - i + 1] then\n      is_palindrome = false\n    \
    \  count = count + 1\n    end\n    i = i + 1\n  end\n  if is_palindrome then\n\
    \    return 0\n  end\n  return count\nend", "    local arr2 = arr:slice()\n  \
    \  arr2:reverse()\n    local count = 0\n    for i=1,arr:len() do\n        if arr[i]\
    \ ~= arr2[i] then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", end, "    local min_change = 0\n    for i = 1, #arr do\n      \
    \  if arr[i] ~= arr[#arr - i + 1] then\n            min_change = min_change +\
    \ 1\n        end\n    end\n    return min_change\nend", "    -- Write your code\
    \ here\n    return -1\nend", "    -- your code here\nend", "    -- ...\nend",
  "  local l = #arr\n  local c = 0\n  for i = 1, l / 2 do\n    if arr[i] ~= arr[l\
    \ - i + 1] then\n      c = c + 1\n    end\n  end\n  return c\nend", "    local\
    \ mid = math.floor(#arr / 2)\n    local k = 0\n    for i = 1, mid do\n       \
    \ if arr[i] ~= arr[#arr - i + 1] then\n            k = k + 1\n        end\n  \
    \  end\n    return k\nend", "    return 0\nend", "    local count = 0\n    local\
    \ length = #arr", "    local changes = 0\n    local left = 1\n    local right\
    \ = #arr\n    while left < right do\n        if arr[left] ~= arr[right] then\n\
    \            changes = changes + 1\n        end\n        left = left + 1\n   \
    \     right = right - 1\n    end\n    return changes\nend", "    local changes\
    \ = 0\n    for i = 1, #arr / 2 do\n        if arr[i] ~= arr[#arr - i + 1] then\n\
    \            changes = changes + 1\n        end\n    end\n    return changes\n\
    end", "  local stack = {}\n  local length = #arr\n  local changes = 0\n  for i=1,length/2\
    \ do\n    if arr[i] ~= arr[length-i+1] then\n      changes = changes + 1\n   \
    \   table.insert(stack, arr[i])\n    end\n  end\n  if length % 2 == 1 then\n \
    \   changes = changes + 1\n  end\n  return changes, stack\nend", end, "    local\
    \ swap_count = 0\n    local left = 1\n    local right = #arr\n    while left <\
    \ right do\n        local left_value = arr[left]\n        local right_value =\
    \ arr[right]\n        if left_value ~= right_value then\n            swap_count\
    \ = swap_count + 1\n        end\n        left = left + 1\n        right = right\
    \ - 1\n    end\n    return swap_count\nend", end, "    local res = {}\n    local\
    \ half_len = math.floor(#arr / 2)\n    local non_palindromic_count = 0\n    for\
    \ i = 1, half_len do\n        local rev_index = #arr - i + 1\n        local a\
    \ = arr[i]\n        local b = arr[rev_index]\n        if a ~= b then\n       \
    \     non_palindromic_count = non_palindromic_count + 1\n        end\n    end\n\
    \    return non_palindromic_count\nend", "  local n = #arr\n  local t = {}\n \
    \ for i=1,n do\n    t[i] = {}\n    for j=1,n do\n      t[i][j] = 0\n    end\n\
    \  end\n  for i=1,n do\n    t[i][i] = 0\n  end\n  for i=1,n-1 do\n    if arr[i]\
    \ ~= arr[i+1] then\n      t[i][i+1] = 1\n    end\n  end\n  for s=3,n do\n    for\
    \ i=1,n-s+1 do\n      local j = i+s-1\n      if arr[i] == arr[j] then\n      \
    \  t[i][j] = t[i+1][j-1]\n      else\n        t[i][j] = 1 + math.min(t[i+1][j],\
    \ t[i][j-1])\n      end\n    end\n  end\n  return t[1][n]\nend", "  local n =\
    \ #arr\n  local min_changes = (n + 1) / 2\n  local last_change = 0\n  for i =\
    \ 1, min_changes do\n    if arr[i] ~= arr[n - i + 1] then\n      last_change =\
    \ i\n    end\n  end\n  return last_change\nend", "  local i,j = 1,#arr\n  local\
    \ count = 0\n  while i <= j do\n    if arr[i] ~= arr[j] then\n      count = count\
    \ + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return count\nend", " \
    \   local l, r = 1, #arr\n    local res = 0\n    while l < r do\n        if arr[l]\
    \ ~= arr[r] then\n            if arr[l] == arr[r - 1] then\n                r\
    \ = r - 1\n            elseif arr[l + 1] == arr[r] then\n                l = l\
    \ + 1\n            else\n                l = l + 1\n                r = r - 1\n\
    \            end\n            res = res + 1\n        end\n        l = l + 1\n\
    \        r = r - 1\n    end\n    return res\nend", "    local n = #arr\n    local\
    \ t = {}\n    for i = 1, n do\n        t[i] = {}\n        for j = 1, n do\n  \
    \          t[i][j] = 0\n        end\n    end\n    for length = 1, n do\n     \
    \   for i = 1, n - length + 1 do\n            local j = i + length - 1\n     \
    \       if i == j then\n                t[i][j] = 0\n            elseif arr[i]\
    \ == arr[j] then\n                t[i][j] = t[i + 1][j - 1]\n            else\n\
    \                t[i][j] = math.min(t[i + 1][j - 1], t[i + 1][j], t[i][j - 1])\
    \ + 1\n            end\n        end\n    end\n    return t[1][n]\nend\nprint(\"\
    smallest_change([1,2,3,5,4,7,9,6])\", smallest_change({1, 2, 3, 5, 4, 7, 9, 6}))\n\
    print(\"smallest_change([1, 2, 3, 4, 3, 2, 2])\", smallest_change({1, 2, 3, 4,\
    \ 3, 2, 2}))\nprint(\"smallest_change([1, 2, 3, 2, 1])\", smallest_change({1,\
    \ 2, 3, 2, 1}))", "\tfor n, v in ipairs(arr) do\n\t\ttable.insert(arr, 1, v)\n\
    \tend\n\tlocal a, b = 1, #arr\n\tlocal cost = 0\n\twhile b > a do\n\t\tif arr[a]\
    \ == arr[b] then\n\t\t\tcost = cost + (arr[a] - arr[a+1])\n\t\telse\n\t\t\tcost\
    \ = cost + math.abs(arr[a] - arr[b])\n\t\tend\n\t\ta = a + 1\n\t\tb = b - 1\n\t\
    end\n\treturn cost\nend", "  -- start with two empty lists for the left and right\n\
    \  local left = {}\n  local right = {}\n  -- make a copy of the array\n  local\
    \ arr_ = tablex.copy(arr)\n  -- make the array the same length as the original\n\
    \  while #arr_ < #arr do\n    table.insert(arr_, arr_[#arr_])\n  end\n  -- look\
    \ at the elements at the start and end of the array,\n  -- and move them over\
    \ to the left or right lists\n  while #arr_ > 0 do\n    if arr_[1] == arr_[#arr_]\
    \ then\n      table.insert(left, arr_[1])\n      table.insert(right, arr_[#arr_])\n\
    \    end\n    table.remove(arr_, 1)\n    table.remove(arr_, #arr_)\n  end\n  --\
    \ the change is the sum of lengths of the two lists\n  return #left + #right\n\
    end", "    local n = #arr\n    local dp = {}\n    for i = 1, n do\n        dp[i]\
    \ = {}\n        for j = 1, n do\n            dp[i][j] = math.huge\n        end\n\
    \    end\n    for i = 1, n do\n        dp[i][i] = 0\n    end\n    for i = 2, n\
    \ do\n        for j = 1, n-i+1 do\n            local k = j + i - 1\n         \
    \   if arr[j] == arr[k] then\n                dp[j][k] = dp[j+1][k-1]\n      \
    \      else\n                for p = j, k do\n                    dp[j][k] = math.min(dp[j][k],\
    \ dp[j][p] + dp[p+1][k] + 1)\n                end\n            end\n        end\n\
    \    end\n    return dp[1][n]\nend", "  local count = 0\n  local last = #arr\n\
    \  for i = 1, #arr do\n    if arr[i] ~= arr[last] then\n      count = count +\
    \ 1\n    end\n    last = last - 1\n  end\n  return count\nend", "  local function\
    \ is_palindrome(arr)\n    local function nth(arr, n)\n      return arr[n + 1]\n\
    \    end\n    local function palindrome(arr, i, j)\n      return i > j or (nth(arr,\
    \ i) == nth(arr, j) and palindrome(arr, i + 1, j - 1))\n    end\n    return palindrome(arr,\
    \ 0, #arr - 1)\n  end\n  local function c(arr, i, j)\n    if i > j then\n    \
    \  return 0\n    elseif i == j then\n      return 1\n    elseif nth(arr, i) ==\
    \ nth(arr, j) then\n      return c(arr, i + 1, j - 1)\n    else\n      return\
    \ math.min(c(arr, i + 1, j), c(arr, i, j - 1)) + 1\n    end\n  end\n  return c(arr,\
    \ 0, #arr - 1)\nend", "    local sz = #arr\n    local count = 0\n    for i = 1,\
    \ sz / 2 do\n        if arr[i] ~= arr[sz - i + 1] then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "    local is_palindrome,\
    \ palindrome_arr, check_arr_len = function() end, function() end, function() end\n\
    \    is_palindrome = function(arr)\n        local len = #arr\n        for i =\
    \ 1, len do\n            if arr[i] ~= arr[len - i + 1] then\n                return\
    \ false\n            end\n        end\n        return true\n    end\n    palindrome_arr\
    \ = function(arr)\n        local len = #arr\n        local new_arr = {}\n    \
    \    for i = 1, len do\n            new_arr[i] = arr[len - i + 1]\n        end\n\
    \        return new_arr\n    end\n    check_arr_len = function(arr)\n        local\
    \ len = #arr\n        if len == 0 then\n            return 0\n        elseif len\
    \ == 1 then\n            return 1\n        elseif len == 2 then\n            if\
    \ arr[1] == arr[2] then\n                return 0\n            else\n        \
    \        return 1\n            end\n        else\n            return -1\n    \
    \    end\n    end\n    local arr_len = check_arr_len(arr)\n    if arr_len ~= -1\
    \ then\n        return arr_len\n    end\n    local max_len = #arr\n    local max_count\
    \ = -1\n    for i = 1, max_len do\n        local k = 1\n        local count =\
    \ 0\n        local tmp_arr = {}\n        while i + k <= max_len do\n         \
    \   if i - k < 1 then\n                tmp_arr[k] = arr[i + k]\n            elseif\
    \ i + k > max_len then\n                tmp_arr[k] = arr[i - k]\n            else\n\
    \                tmp_arr[k] = arr[i - k]\n                tmp_arr[max_len - k\
    \ + 1] = arr[i + k]\n            end\n            k = k + 1\n        end\n   \
    \     for j = 1, max_len do\n            if arr[j] ~= tmp_arr[j] then\n      \
    \          count = count + 1\n            end\n        end\n        if max_count\
    \ == -1 or count < max_count then\n            max_count = count", "    local\
    \ function palindrome_len(arr, off, len)\n        local off_end = off + len -\
    \ 1\n        while off < off_end do\n            if arr[off] ~= arr[off_end] then\n\
    \                return off - off_end\n            end\n            off = off\
    \ + 1\n            off_end = off_end - 1\n        end\n        return 0\n    end",
  "  local function is_palindrome(arr)\n    for i = 1, #arr // 2 do\n      if arr[i]\
    \ ~= arr[#arr - i + 1] then\n        return false\n      end\n    end\n    return\
    \ true\n  end", "    local function is_palindrome(arr)\n        local len = #arr\n\
    \        for i = 1, len / 2 do\n            if arr[i] ~= arr[len - i + 1] then\n\
    \                return false\n            end\n        end\n        return true\n\
    \    end", "  local function is_palindrome(arr)\n    local middle = math.floor(#arr\
    \ / 2) + 1\n    for i = 1, middle do\n      if arr[i] ~= arr[#arr - i + 1] then\n\
    \        return false\n      end\n    end\n    return true\n  end", "  local is_pali\
    \ = function(a)\n    for i = 1, #a / 2 do\n      if a[i] ~= a[#a - i + 1] then\n\
    \        return false\n      end\n    end\n    return true\n  end", "    local\
    \ len = #arr\n    local max_change = len - 1", end, "  local len = #arr\n  local\
    \ s = 0\n  for i = 1, len//2 do\n    if arr[i] ~= arr[len-i+1] then\n      s =\
    \ s + 1\n    end\n  end\n  return s\nend", "\t-- TODO\nend", end, "    local out\
    \ = 0\n    for i = 1, #arr do\n        if i <= #arr - i + 1 and arr[i] ~= arr[#arr\
    \ - i + 1] then\n            out = out + 1\n        end\n    end\n    return out\n\
    end", "  local n = #arr\n  local sum = 0\n  for i = 1, math.floor(n / 2) do\n\
    \    if arr[i] ~= arr[n - i + 1] then\n      sum = sum + 1\n    end\n  end\n \
    \ return sum\nend", "\t-- compute the value for the palindrome\n\tlocal left =\
    \ 1\n\tlocal right = #arr\n\tlocal change = 0\n\tlocal left_value = arr[left]\n\
    \tlocal right_value = arr[right]\n\twhile left < right do\n\t\tlocal new_left\
    \ = arr[left + 1]\n\t\tlocal new_right = arr[right - 1]\n\t\tif left_value ==\
    \ right_value then\n\t\t\tleft = left + 1\n\t\t\tright = right - 1\n\t\t\tleft_value\
    \ = new_left\n\t\t\tright_value = new_right\n\t\telseif left_value > right_value\
    \ then\n\t\t\tright = right - 1\n\t\t\tchange = change + 1\n\t\t\tright_value\
    \ = right_value + new_right\n\t\telse\n\t\t\tleft = left + 1\n\t\t\tchange = change\
    \ + 1\n\t\t\tleft_value = left_value + new_left\n\t\tend\n\tend\n\treturn change\n\
    end", "\tlocal front, back = 1, #arr\n\tlocal index = 0\n\twhile front < back\
    \ do\n\t\tif arr[front] == arr[back] then\n\t\t\tfront = front + 1\n\t\t\tback\
    \ = back - 1\n\t\telse\n\t\t\tfront = front + 1\n\t\t\tindex = index + 1\n\t\t\
    end\n\tend\n\treturn index\nend", "    local n = #arr\n    local ans = n\n   \
    \ for i = 1, n do\n        local l = i - 1\n        local r = n - i\n        if\
    \ arr[l] == arr[r] then\n            ans = ans - 1\n        end\n    end\n   \
    \ return ans\nend", end, "    local c = 0\n    local i = 1\n    local j = #arr\n\
    \    while i < j do\n        if arr[i] ~= arr[j] then\n            arr[i] = arr[j]\n\
    \            c = c + 1\n        end\n        i = i + 1\n        j = j - 1\n  \
    \  end\n    return c\nend", "  -- YOUR CODE HERE\nend", "    local size = #arr\n\
    \    local function is_palindrome(size)\n        local start = 1\n        local\
    \ stop = size\n        local cond = true\n        while start < stop do\n    \
    \        if arr[start] ~= arr[stop] then\n                cond = false\n     \
    \           break\n            end\n            start = start + 1\n          \
    \  stop = stop - 1\n        end\n        return cond\n    end\n    local num_changes\
    \ = 0\n    while not is_palindrome(size) do\n        num_changes = num_changes\
    \ + 1\n        size = size - 1\n    end\n    return num_changes\nend", "    --\
    \ make local copy of arr\n    local tmp = {}\n    for i = 1, #arr do\n       \
    \ tmp[i] = arr[i]\n    end", "  local len = #arr\n  local dp = {}\n  for i = 1,\
    \ len do\n    dp[i] = {}\n    for j = 1, len do\n      dp[i][j] = math.huge\n\
    \    end\n  end\n  for i = 1, len do\n    dp[i][i] = 0\n  end\n  for l = 2, len\
    \ do\n    for i = 1, len - l + 1 do\n      local j = i + l - 1\n      if arr[i]\
    \ == arr[j] then\n        dp[i][j] = dp[i + 1][j - 1]\n      else\n        dp[i][j]\
    \ = math.min(dp[i + 1][j], dp[i][j - 1]) + 1\n      end\n    end\n  end\n  return\
    \ dp[1][len]\nend", "  local i = 1\n  local j = #arr\n  local count = 0\n  while\
    \ i < j do\n    if arr[i] ~= arr[j] then\n      count = count + 1\n    end\n \
    \   i = i + 1\n    j = j - 1\n  end\n  return count\nend", "  -- Your code here\n\
    end", "\tlocal len, count = #arr, 0\n\tfor i = 1, len / 2 do\n\t\tif arr[i] ~=\
    \ arr[len - i + 1] then\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\treturn count\n\
    end", "  if #arr == 0 then return 0 end\n  local i, j = 1, #arr\n  local changes\
    \ = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n      changes = changes\
    \ + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return changes\nend", "\t\
    -- TODO: write your code here\n\tlocal currentChanges = 0\n\tlocal maxLength =\
    \ #arr\n\tlocal start = 1\n\tlocal end = maxLength\n\tlocal moveForward = true\n\
    \twhile (start <= end) do\n\t\tif (arr[start] ~= arr[end]) then\n\t\t\tcurrentChanges\
    \ = currentChanges + 1\n\t\tend\n\t\tif (moveForward) then\n\t\t\tstart = start\
    \ + 1\n\t\telse\n\t\t\tend = end - 1\n\t\tend\n\t\tmoveForward = not moveForward\n\
    \tend\n\treturn currentChanges\nend", "  local n = #arr\n  local m = math.floor(n\
    \ / 2)\n  local l, r = 1, n\n  local count = 0\n  while l <= m and r > m do\n\
    \    if arr[l] ~= arr[r] then\n      count = count + 1\n    end\n    l = l + 1\n\
    \    r = r - 1\n  end\n  return count\nend", "  local first_half = arr:slice(1,\
    \ math.floor(#arr / 2))\n  local second_half = arr:slice(math.ceil(#arr / 2),\
    \ #arr)\n  local reverse_second_half = second_half:reverse()\n  local count =\
    \ 0\n  for i = 1, #first_half do\n    if first_half[i] ~= reverse_second_half[i]\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ n = #arr\n  local a, b = {}, {}\n  for i = 1, n do\n    a[i] = {}\n    b[i]\
    \ = {}\n    for j = 1, n do\n      a[i][j] = i == j and 0 or n\n      b[i][j]\
    \ = a[i][j]\n    end\n  end\n  for k = 1, n do\n    for i = 1, n - k do\n    \
    \  local j = i + k\n      if arr[i] == arr[j] then\n        a[i][j] = a[i + 1][j\
    \ - 1]\n      else\n        a[i][j] = 1 + math.min(a[i + 1][j], a[i][j - 1])\n\
    \      end\n      b[i][j] = math.min(b[i][j], a[i][j])\n    end\n  end\n  return\
    \ b[1][n]\nend", "  return 0\nend", "  local reverse_arr = reverse(arr)\n  local\
    \ counter = 0\n  for i = 1, #arr do\n    if arr[i] ~= reverse_arr[i] then\n  \
    \    counter = counter + 1\n    end\n  end\n  return counter\nend", "  local i,\
    \ j = 1, #arr\n  local count = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n\
    \      count = count + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return\
    \ count\nend", "    local count = 0\n    local left, right = 1, #arr\n    while\
    \ left < right do\n        if arr[left] ~= arr[right] then\n            arr[left]\
    \ = arr[right]\n            count = count + 1\n        end\n        left = left\
    \ + 1\n        right = right - 1\n    end\n    return count\nend", "    -- Set\
    \ pointers\n    local left_pointer = 1\n    local right_pointer = #arr", "   \
    \ local changes = 0\n    for i = 1, math.floor(#arr / 2) do\n        local x =\
    \ arr[i]\n        local y = arr[#arr - i + 1]\n        if x ~= y then\n      \
    \      changes = changes + 1\n        end\n    end\n    return changes\nend",
  "  local n = #arr\n  local dp = {}\n  for i = 0, n do\n    dp[i] = {}\n    for j\
    \ = 0, n do\n      dp[i][j] = -1\n    end\n  end\n  local function helper(i, j)\n\
    \    if i >= j then\n      return 0\n    end\n    if dp[i][j] ~= -1 then\n   \
    \   return dp[i][j]\n    end\n    if arr[i] == arr[j] then\n      dp[i][j] = helper(i\
    \ + 1, j - 1)\n    else\n      dp[i][j] = 1 + math.min(helper(i + 1, j), helper(i,\
    \ j - 1))\n    end\n    return dp[i][j]\n  end\n  return helper(1, n)\nend", " \
    \ -- your code here\nend", "  local function get_rev(arr)\n    local new_arr =\
    \ {}\n    for i = #arr, 1, -1 do\n      table.insert(new_arr, arr[i])\n    end\n\
    \    return new_arr\n  end", "  local len = #arr\n  local l, r = 1, len\n  local\
    \ count = 0\n  while l < r do\n    if arr[l] ~= arr[r] then\n      count = count\
    \ + 1\n    end\n    l = l + 1\n    r = r - 1\n  end\n  return count\nend", " \
    \   local len = #arr\n    if len == 0 then\n        return 0\n    end\n    local\
    \ i = 1\n    local j = len\n    local inc = 0\n    while i < j do\n        if\
    \ arr[i] ~= arr[j] then\n            local a = arr[i]\n            local b = arr[j]\n\
    \            if a > b then\n                arr[i] = b\n                inc =\
    \ inc + a - b\n            else\n                arr[j] = a\n                inc\
    \ = inc + b - a\n            end\n        end\n        i = i + 1\n        j =\
    \ j - 1\n    end\n    return inc\nend", "    local n = #arr\n    local count =\
    \ 0\n    for i = 1, math.floor(n / 2) do\n        if arr[i] ~= arr[n - i + 1]\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    local n = #arr\n    local dp = {}\n    local i, j\n    for i = 1, n\
    \ do\n        dp[i] = {}\n        for j = 1, n do\n            dp[i][j] = 0\n\
    \        end\n    end\n    for i = n - 1, 1, -1 do\n        for j = i + 1, n do\n\
    \            dp[i][j] = math.huge\n            for k = i, j - 1 do\n         \
    \       dp[i][j] = math.min(dp[i][j], arr[k] == arr[j] and dp[i][k] or math.huge)\n\
    \            end\n            dp[i][j] = dp[i][j] + 1\n        end\n    end\n\
    \    return dp[1][n] - 1\nend", "  local l = 1\n  local r = #arr\n  local changes\
    \ = 0\n  while (l < r) do\n    if (arr[l] ~= arr[r]) then\n      changes = changes\
    \ + 1\n    end\n    l = l + 1\n    r = r - 1\n  end\n  return changes\nend", " \
    \   local left = 1\n    local right = #arr\n    local changes = 0\n    while left\
    \ < right do\n        if arr[left] ~= arr[right] then\n            changes = changes\
    \ + 1\n        end\n        left = left + 1\n        right = right - 1\n    end\n\
    \    return changes\nend", "    local n = table.getn(arr)\n    local l = 1\n \
    \   local r = n\n    local changes = 0\n    while l < r do\n        if arr[l]\
    \ ~= arr[r] then\n            if arr[l] > arr[r] then\n                arr[l]\
    \ = arr[r]\n            else\n                arr[r] = arr[l]\n            end\n\
    \            changes = changes + 1\n        end\n        l = l + 1\n        r\
    \ = r - 1\n    end\n    return changes\nend", "\tlocal ret = 0\n\tfor i = 1, #arr\
    \ // 2 do\n\t\tret = ret + math.abs(arr[i] - arr[#arr - i + 1])\n\tend\n\treturn\
    \ ret\nend", "\tlocal n = #arr\n\tlocal t, i, j = 0, 1, n\n\twhile i <= j do\n\
    \t\tif arr[i] == arr[j] then\n\t\t\ti = i + 1\n\t\t\tj = j - 1\n\t\telse\n\t\t\
    \tt = t + 1\n\t\t\tif i == j - 1 then\n\t\t\t\ti = i + 1\n\t\t\t\tj = j - 1\n\t\
    \t\telseif arr[i] == arr[j - 1] then\n\t\t\t\tj = j - 1\n\t\t\telseif arr[i +\
    \ 1] == arr[j] then\n\t\t\t\ti = i + 1\n\t\t\telse\n\t\t\t\ti = i + 1\n\t\t\t\t\
    j = j - 1\n\t\t\tend\n\t\tend\n\tend\n\treturn t\nend", "  local function mirror(start,\
    \ finish)\n    local count = 0\n    while start <= finish do\n      if arr[start]\
    \ ~= arr[finish] then\n        count = count + 1\n      end\n      start = start\
    \ + 1\n      finish = finish - 1\n    end\n    return count\n  end\n  local n\
    \ = #arr\n  local i = 1\n  local j = n\n  while i < j do\n    if arr[i] == arr[j]\
    \ then\n      i = i + 1\n      j = j - 1\n    else\n      local m1 = mirror(i,\
    \ j - 1)\n      local m2 = mirror(i + 1, j)\n      return math.min(m1, m2)\n \
    \   end\n  end\n  return 0\nend", "    local len = #arr\n    local di = math.floor(len\
    \ / 2)\n    local max = 0\n    local count = 0\n    for i = 1, di do\n       \
    \ if arr[i] ~= arr[len - i + 1] then\n            count = count + 1\n        \
    \    if arr[i] > arr[len - i + 1] then\n                max = max + arr[i] - arr[len\
    \ - i + 1]\n            else\n                max = max + arr[len - i + 1] - arr[i]\n\
    \            end\n        end\n    end\n    return count, max\nend", "    local\
    \ len = #arr\n    local mid = math.floor(len / 2)\n    local result = 0\n    local\
    \ j = len\n    for i = 1, mid do\n        if arr[i] ~= arr[j] then\n         \
    \   result = result + 1\n        end\n        j = j - 1\n    end\n    return result\n\
    end", "    local n = #arr\n    local dp = {}\n    for i = 1, n do\n        dp[i]\
    \ = {}\n        for j = 1, n do\n            dp[i][j] = math.huge\n        end\n\
    \    end\n    for i = 1, n do\n        dp[i][i] = 0\n    end\n    for i = 1, n\
    \ - 1 do\n        if arr[i] == arr[i + 1] then\n            dp[i][i + 1] = 0\n\
    \        else\n            dp[i][i + 1] = 1\n        end\n    end\n    for l =\
    \ 3, n do\n        for i = 1, n - l + 1 do\n            local j = i + l - 1\n\
    \            if arr[i] == arr[j] then\n                dp[i][j] = dp[i + 1][j\
    \ - 1]\n            else\n                dp[i][j] = math.min(dp[i + 1][j], dp[i][j\
    \ - 1]) + 1\n            end\n        end\n    end\n    return dp[1][n]\nend",
  "\treturn 0\nend", "  -- Your code here\nend", "  return 0\nend", "    local n =\
    \ #arr\n    local function is_palindrome(arr)\n        for i = 1, n/2 do\n   \
    \         if arr[i] ~= arr[n - i + 1] then\n                return false\n   \
    \         end\n        end\n        return true\n    end\n    local function min_changes(i,\
    \ j)\n        if i >= j then\n            return 0\n        end\n        if arr[i]\
    \ == arr[j] then\n            return min_changes(i + 1, j - 1)\n        end\n\
    \        return 1 + math.min(min_changes(i + 1, j), min_changes(i, j - 1))\n \
    \   end\n    if is_palindrome(arr) then\n        return 0\n    end\n    return\
    \ min_changes(1, n)\nend", end, "  local i, j = 1, #arr\n  local count = 0\n \
    \ while i < j do\n    if arr[i] ~= arr[j] then\n      count = count + 1\n    end\n\
    \    i = i + 1\n    j = j - 1\n  end\n  return count\nend", "  local memo = {}\n\
    \  local function steps(arr, start, fin)\n    if start > fin then return 0 end\n\
    \    if start == fin then return 1 end\n    if arr[start] == arr[fin] then\n \
    \     return steps(arr, start + 1, fin - 1)\n    end\n    local k = string.format(\"\
    %d:%d\", start, fin)\n    if memo[k] then return memo[k] end\n    local result\
    \ = math.min(steps(arr, start + 1, fin), steps(arr, start, fin - 1)) + 1\n   \
    \ memo[k] = result\n    return result\n  end\n  return steps(arr, 1, #arr)\nend",
  "  -- YOUR CODE HERE\nend", "    local count = 0\n    local mirror_index = #arr\n\
    \    for i = 1, #arr / 2 do\n        if arr[i] ~= arr[mirror_index] then\n   \
    \         count = count + 1\n        end\n        mirror_index = mirror_index\
    \ - 1\n    end\n    return count\nend", "  -- your code here\nend", "  local function\
    \ change_num(arr, left, right)\n    local result = 0\n    for i = left, right\
    \ do\n      if arr[i] ~= arr[right + left - i] then\n        result = result +\
    \ 1\n      end\n    end\n    return result\n  end", "    local len = #arr\n  \
    \  local changes = 0\n    local back = len\n    local front = 1\n    local max\
    \ = math.max(len-1, 1)\n    for i = 1, max do\n        if arr[back] ~= arr[front]\
    \ then\n            changes = changes + 1\n        end\n        back = back -\
    \ 1\n        front = front + 1\n    end\n    return changes\nend", "    local\
    \ mirror = {}\n    local count = 0\n    local value\n    for i, v in ipairs(arr)\
    \ do\n        local idx = #arr - i + 1\n        mirror[idx] = v\n    end\n   \
    \ for i = 1, #arr do\n        if mirror[i] ~= arr[i] then\n            count =\
    \ count + 1\n        end\n    end\n    return count\nend", "  -- your code here\n\
    end", "  -- your code here\nend", "    if arr == nil then return 0 end\n    local\
    \ len = #arr\n    local left = 1\n    local right = len\n    local count = 0\n\
    \    while left < right do\n        if arr[left] ~= arr[right] then\n        \
    \    if arr[left] == arr[right - 1] then\n                right = right - 1\n\
    \            elseif arr[left + 1] == arr[right] then\n                left = left\
    \ + 1\n            else\n                left = left + 1\n                right\
    \ = right - 1\n            end\n            count = count + 1\n        end\n \
    \       left = left + 1\n        right = right - 1\n    end\n    return count\n\
    end", "  local left, right = 1, #arr\n  local min_changes = 0\n  while left <\
    \ right do\n    if arr[left] ~= arr[right] then\n      min_changes = min_changes\
    \ + 1\n    end\n    left = left + 1\n    right = right - 1\n  end\n  return min_changes\n\
    end", "  return 'todo'\nend", end, "  local function is_palindrome(arr)\n    local\
    \ back, front = 1, #arr\n    while front > back do\n      if arr[back] ~= arr[front]\
    \ then\n        return false\n      end\n      back = back + 1\n      front =\
    \ front - 1\n    end\n    return true\n  end", "    if is_palindrome(arr) then\n\
    \        return 0\n    end\n    local length = #arr\n    local i = 1\n    local\
    \ j = length\n    local changes = 0\n    while i < j do\n        if arr[i] ~=\
    \ arr[j] then\n            changes = changes + 1\n        end\n        i = i +\
    \ 1\n        j = j - 1\n    end\n    return changes\nend", "  local n = #arr\n\
    \  local result = 0\n  for i = 1, n // 2 do\n    result = result + math.abs(arr[i]\
    \ - arr[n - i + 1])\n  end\n  return result\nend", "    -- Your code here\nend",
  "  local len = #arr\n  local beg, end = 1, len\n  local cost = 0\n  while beg <\
    \ end do\n    if arr[beg] ~= arr[end] then\n      cost = cost + 1\n    end\n \
    \   beg = beg + 1\n    end = end - 1\n  end\n  return cost\nend", "  -- TODO:\
    \ your code here\nend", "    local n = #arr\n    local sum = 0\n    for i = 1,\
    \ math.floor(n / 2) do\n        sum = sum + math.abs(arr[i] - arr[n - i + 1])\n\
    \    end\n    return sum\nend", "    local n = #arr\n    local a, b = 1, n\n \
    \   local count = 0\n    while a < b do\n        if arr[a] == arr[b] then\n  \
    \          a = a + 1\n            b = b - 1\n        else\n            count =\
    \ count + 1\n            if arr[a] < arr[b] then\n                arr[a+1] = arr[a+1]\
    \ + arr[a]\n                a = a + 1\n            else\n                arr[b-1]\
    \ = arr[b-1] + arr[b]\n                b = b - 1\n            end\n        end\n\
    \    end\n    return count\nend", "  if #arr == 0 then return 0 end\n  local i,\
    \ j = 1, #arr\n  local count = 0\n  while i < j do\n    if arr[i] ~= arr[j] then\n\
    \      count = count + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return\
    \ count\nend", '  local len = #arr', "    if is_palindrome(arr) then\n       \
    \ return 0\n    end\n    local len = #arr\n    local t = {}\n    for i = 1,len\
    \ do\n        if arr[i] ~= arr[len-i+1] then\n            table.insert(t,i)\n\
    \        end\n    end\n    return #t\nend", "  return -1\nend", "    -- WRITE\
    \ YOUR CODE HERE\nend", "  -- your code here\nend", "  local res = 0\n  local\
    \ i = 1\n  local j = #arr\n  while i < j do\n    if arr[i] ~= arr[j] then\n  \
    \    res = res + 1\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return res\n\
    end", "    local result = 0\n    local len = #arr\n    local half = math.floor(len\
    \ / 2)\n    local left = 1\n    local right = len\n    while left <= half do\n\
    \        if arr[left] ~= arr[right] then\n            result = result + 1\n  \
    \      end\n        left = left + 1\n        right = right - 1\n    end\n    return\
    \ result\nend", "    local fst, arr = arr[1], sub(arr, 2)\n    local rev = reverse(arr)\n\
    \    local count = 0\n    for i = 1, #arr do\n        local f, r = fst[i], rev[i]\n\
    \        if f ~= r then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "  local min_change = 0\n  for i = 1, #arr - 1 do\n \
    \   if arr[i] == arr[#arr - i + 1] then\n      min_change = min_change + 1\n \
    \   end\n  end\n  return min_change\nend", "  local n = #arr\n  local dp = {}\n\
    \  for i = 1, n do\n    dp[i] = {}\n    for j = 1, n do\n      dp[i][j] = 0\n\
    \    end\n  end\n  for i = n - 1, 1, -1 do\n    for j = i + 1, n do\n      if\
    \ arr[i] == arr[j] then\n        dp[i][j] = dp[i + 1][j - 1]\n      else\n   \
    \     dp[i][j] = 1 + math.min(dp[i + 1][j], dp[i][j - 1])\n      end\n    end\n\
    \  end\n  return dp[1][n]\nend", "  return #arr;\nend", "  local len = #arr\n\
    \  if len == 0 then return 0 end\n  local function is_palindrome(arr)\n    for\
    \ i = 1, len do\n      if arr[i] ~= arr[len - i + 1] then return false end\n \
    \   end\n    return true\n  end\n  local memo = {}\n  local function rec(arr,\
    \ l, r)\n    if l >= r then return 0 end\n    local key = 'key-' .. l .. '-' ..\
    \ r\n    if memo[key] then return memo[key] end\n    local curr = arr[l]\n   \
    \ local res = arr[r] ~= curr and 1 or 0\n    res = res + rec(arr, l + 1, r - 1)\n\
    \    memo[key] = res\n    return res\n  end\n  return rec(arr, 1, len)\nend",
  "    -- your code here\nend", "  local copy_arr = {}\n  for i = 1, #arr do\n   \
    \ copy_arr[i] = arr[i]\n  end\n  for i = 1, math.floor(#arr / 2) do\n    if arr[i]\
    \ ~= arr[#arr - i + 1] then\n      if arr[i] < arr[#arr - i + 1] then\n      \
    \  arr[i] = arr[#arr - i + 1]\n      else\n        arr[#arr - i + 1] = arr[i]\n\
    \      end\n    end\n  end\n  local num_changed = 0\n  for i = 1, #arr do\n  \
    \  if arr[i] ~= copy_arr[i] then\n      num_changed = num_changed + 1\n    end\n\
    \  end\n  return num_changed\nend", "    local sum = 0\n    local i = 1\n    local\
    \ j = #arr\n    while i < j do\n        if arr[i] ~= arr[j] then\n           \
    \ sum = sum + 1\n        end\n        i = i + 1\n        j = j - 1\n    end\n\
    \    return sum\nend", "  local sum = 0\n  for i = 1, math.floor(#arr / 2) do\n\
    \    sum = sum + math.abs(arr[i] - arr[#arr - i + 1])\n  end\n  return sum\nend",
  "  local len = #arr\n  local min_change = len\n  for i = 1, len do\n    local change\
    \ = 0\n    for j = 1, len do\n      if arr[j] ~= arr[len - j + 1] then\n     \
    \   change = change + 1\n      end\n    end\n    if change < min_change then\n\
    \      min_change = change\n    end\n    arr[i] = arr[i] + 1\n  end\n  return\
    \ min_change\nend", "  local n = #arr\n  local mid = math.floor(n / 2)\n  local\
    \ i = 1\n  local j = n\n  local count = 0\n  while i <= mid and j > mid do\n \
    \   if arr[i] ~= arr[j] then\n      count = count + 1\n    end\n    i = i + 1\n\
    \    j = j - 1\n  end\n  return count\nend", "    local i, j = 1, #arr\n    local\
    \ changes = 0\n    while i < j do\n        if arr[i] ~= arr[j] then\n        \
    \    changes = changes + 1\n        end\n        i = i + 1\n        j = j - 1\n\
    \    end\n    return changes\nend", "  local n = #arr\n  local left, right = 1,\
    \ n\n  local changes = 0\n  while left < right do\n    if arr[left] ~= arr[right]\
    \ then\n      changes = changes + 1\n    end\n    left = left + 1\n    right =\
    \ right - 1\n  end\n  return changes\nend", "    -- To figure out the answer,\
    \ we first find the longest palindromic subsequence\n    -- using dynamic programming.\
    \ In particular, the answer is n - len(longest)\n    -- where n is the length\
    \ of the array and len(longest) is the length of the\n    -- longest palindromic\
    \ subsequence.\n    local n = #arr\n    local longest = {}\n    -- longest[i][j]\
    \ holds the length of the longest palindromic subsequence\n    -- starting at\
    \ index i, ending at index j. Note that i and j are 0-indexed.\n    for i = 0,\
    \ n do\n        longest[i] = {}\n        for j = 0, n do\n            longest[i][j]\
    \ = 0\n        end\n    end\n    -- Base case 1:\n    -- longest[i][i] = 1 for\
    \ all i.\n    for i = 0, n - 1 do\n        longest[i][i] = 1\n    end\n    --\
    \ Base case 2:\n    -- longest[i][i + 1] = 2 if arr[i] == arr[i + 1], otherwise\
    \ 1.\n    for i = 0, n - 2 do\n        longest[i][i + 1] = 2\n        if arr[i\
    \ + 1] ~= arr[i + 2] then\n            longest[i][i + 1] = 1\n        end\n  \
    \  end\n    -- Recursive case:\n    -- longest[i][j] = longest[i + 1][j - 1] +\
    \ 2 if arr[i] == arr[j], otherwise\n    -- longest[i][j] = max(longest[i + 1][j],\
    \ longest[i][j - 1]).\n    for s = 2, n - 1 do\n        for i = 0, n - s - 1 do\n\
    \            j = i + s\n            longest[i][j] = longest[i + 1][j - 1] + 2\n\
    \            if arr[i + 1] ~= arr[j + 1] then\n                longest[i][j] =\
    \ max(longest[i + 1][j], longest[i][j - 1])\n            end\n        end\n  \
    \  end\n    return n - longest[0][n - 1]\nend", "    return 0\nend", end, "  --\
    \ Your code here\nend", "    -- your code here\nend", "  -- let's assume that\
    \ we have n elements that are not matched at the left side\n  -- and m elements\
    \ that are not matched at the right side\n  -- our goal is to change as few elements\
    \ as possible to make the left matches the right\n  -- in one change we can change\
    \ an element to any other element\n  -- the maximum number of such changes can\
    \ be at most n + m\n  --\n  -- let's assume that there are l elements in the middle\
    \ that are not matched\n  --  1 2 x x x x x 1 2\n  --  ^ ^     ^     ^\n  -- \
    \ l x     ^     x r\n  --  ^       ^     ^\n  --  x       x     x\n  --  ^   \
    \    ^     ^\n  --  n       l     m\n  --  ^       ^     ^\n  --  1 2 x x x x\
    \ x 1 2\n  --\n  --  now let's change these elements x to 1\n  --  1 2 1 1 1 1\
    \ 1 1 2\n  --  ^ ^     ^     ^\n  --  l 1     ^     1 r\n  --  ^       ^     ^\n\
    \  --  1       1     1\n  --  ^       ^     ^\n  --  n       l     m\n  --  ^\
    \       ^     ^\n  --  1 2 1 1 1 1 1 1 2\n  --\n  --  now let's change these elements\
    \ 1 to x\n  --  1 2 x x x x x 1 2\n  --  ^ ^     ^     ^\n  --  l x     ^    \
    \ x r\n  --  ^       ^     ^\n  --  x       x     x\n  --  ^       ^     ^\n \
    \ --  n       l     m\n  --  ^       ^     ^\n  --  1 2 x x x x x 1 2\n  --\n\
    \  --  now let's add it up:\n  --  n + l + m + n + m + l + n = 3n + 3l + 2m\n\
    \  --\n  --  if n = m and l = 0 then\n  --  n + l + m + n + m + l + n = 3n + 3l\
    \ + 2m = 6n + 2m = 6n\n  --\n  --  if", "  -- Write your code here.\nend", "\t\
    local n = #arr\n\tlocal dp = {}\n\tlocal i, j\n\tfor i = 1, n do\n\t\tdp[i] =\
    \ {}\n\t\tfor j = 1, n do\n\t\t\tdp[i][j] = math.maxinteger\n\t\tend\n\tend\n\t\
    for i = 1, n do\n\t\tdp[i][i] = 0\n\tend\n\tfor j = 1, n do\n\t\tfor i = j - 1,\
    \ 1, -1 do\n\t\t\tif arr[i] == arr[j] then\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1]\n\
    \t\t\telse\n\t\t\t\tdp[i][j] = 1 + math.min(dp[i + 1][j], dp[i][j - 1])\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn dp[1][n]\nend", "    local L, R = 1, #arr\n    local\
    \ num_changes = 0\n    while L < R do\n        if arr[L] ~= arr[R] then\n    \
    \        arr[L], arr[R] = arr[R], arr[L]\n            num_changes = num_changes\
    \ + 1\n        end\n        L, R = L + 1, R - 1\n    end\n    return num_changes\n\
    end", "    -- your code here\nend", "  -- get to first non-matching element\n\
    \  local i, j = 1, #arr\n  while arr[i] == arr[j] do\n    i = i + 1\n    j = j\
    \ - 1\n  end\n  -- if we're at the beginning of the array, this is a palindrome\n\
    \  if i > j then\n    return 0\n  end\n  -- keep searching until we get to the\
    \ end\n  local num_changes = 1\n  while i < j do\n    if arr[i] == arr[j - 1]\
    \ then\n      j = j - 1\n    elseif arr[i + 1] == arr[j] then\n      i = i + 1\n\
    \    else\n      i = i + 1\n      j = j - 1\n      num_changes = num_changes +\
    \ 1\n    end\n  end\n  return num_changes\nend", "    local function invert_string(str)\n\
    \        local _, index = str:find('')\n        if not index then\n          \
    \  return str\n        end\n        local inverted = {}\n        for i = index\
    \ - 1, 1, -1 do\n            table.insert(inverted, str:sub(i, i))\n        end\n\
    \        return table.concat(inverted)\n    end", "  local len = #arr\n  local\
    \ total = 0\n  for i = 1, len // 2 do\n    if arr[i] ~= arr[len + 1 - i] then\n\
    \      total = total + 1\n    end\n  end\n  return total\nend", "    local n =\
    \ #arr\n    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n        for\
    \ j = 1, n do\n            dp[i][j] = 0\n        end\n    end\n    for len = 1,\
    \ n do\n        for i = 1, n - len + 1 do\n            local j = i + len - 1\n\
    \            if i == j then\n                dp[i][j] = 0\n            elseif\
    \ arr[i] == arr[j] then\n                dp[i][j] = dp[i + 1][j - 1]\n       \
    \     else\n                dp[i][j] = math.min(dp[i + 1][j], dp[i][j - 1]) +\
    \ 1\n            end\n        end\n    end\n    return dp[1][n]\nend", "  local\
    \ len = #arr\n  local left = 1\n  local right = len\n  local count = 0\n  while\
    \ left < right do\n    if arr[left] ~= arr[right] then\n      count = count +\
    \ 1\n    end\n    left = left + 1\n    right = right - 1\n  end\n  return count\n\
    end", "  -- your code here\nend", "    local changes = 0\n    for i = 1, math.floor(#arr\
    \ / 2) do\n        if arr[i] ~= arr[#arr - i + 1] then\n            changes =\
    \ changes + 1\n        end\n    end\n    return changes\nend", "    local sum\
    \ = 0\n    local len = #arr\n    for i = 1, len / 2 do\n        if arr[i] ~= arr[len\
    \ - i + 1] then\n            sum = sum + 1\n        end\n    end\n    return sum\n\
    end", "    local len = #arr\n    local res = 0\n    local i = 1\n    local j =\
    \ len\n    while i < j do\n        if arr[i] ~= arr[j] then\n            res =\
    \ res + 1\n        end\n        i = i + 1\n        j = j - 1\n    end\n    return\
    \ res\nend", "  --local change = 0\n  -- write your code here\n  --print(arr)\n\
    \  if #arr == 0 then\n    return 0\n  end\n  local a = {}\n  for i = 1,#arr do\n\
    \    a[i] = arr[i]\n  end\n  local t = {}\n  for i = 1,#a do\n    t[i] = {}\n\
    \    for j = 1,#a do\n      t[i][j] = 0\n    end\n  end\n  for i = 1,#a do\n \
    \   t[i][i] = 0\n  end\n  for i = 1,#a do\n    if a[i] ~= a[i+1] then\n      t[i][i+1]\
    \ = 1\n    end\n  end\n  local n = #a\n  local k = 1\n  while k < n do\n    local\
    \ i = 1\n    while i < n - k do\n      local j = i + k\n      local x = t[i+1][j-1]\n\
    \      local y = t[i][j-1]\n      local z = t[i+1][j]\n      if a[i] == a[j] then\n\
    \        t[i][j] = x\n      else\n        t[i][j] = math.min(x+1,y+1,z+1)\n  \
    \    end\n      i = i + 1\n    end\n    k = k + 1\n  end\n  return t[1][n]\nend",
  "  -- your code here\nend", "    local l = #arr\n    local min = l\n    for i =\
    \ 1, l - 1 do\n        local t = l - 1\n        local c = 0\n        local j =\
    \ 1\n        while i + j <= l and j <= t do\n            if arr[i + j] ~= arr[t]\
    \ then\n                c = c + 1\n            end\n            j = j + 1\n  \
    \          t = t - 1\n        end\n        if c < min then\n            min =\
    \ c\n        end\n    end\n    return min\nend", "    local front, back = 0, #arr\n\
    \    local sum = 0\n    while front < back do\n        if arr[front] ~= arr[back]\
    \ then\n            sum = sum + 1\n        end\n        front = front + 1\n  \
    \      back = back - 1\n    end\n    return sum\nend", "  return #arr\nend", " \
    \   local reverse = {};\n    for i = #arr, 1, -1 do\n        reverse[#arr - i\
    \ + 1] = arr[i];\n    end\n    return util.seq.largest_common_subsequence(arr,\
    \ reverse);\nend", "  local palindrome_length = 1\n  while palindrome_length <=\
    \ #arr do\n    local offset = 1\n    local is_pali = true\n    while offset <=\
    \ palindrome_length do\n      if arr[offset] ~= arr[palindrome_length - offset\
    \ + 1] then\n        is_pali = false\n        break\n      end\n      offset =\
    \ offset + 1\n    end\n    if is_pali then\n      return #arr - palindrome_length\n\
    \    end\n    palindrome_length = palindrome_length + 1\n  end\n  return #arr\n\
    end", "  local is_odd = (#arr % 2 == 1)\n  local start_i = 1\n  local end_i =\
    \ #arr\n  local changes = 0\n  while start_i < end_i do\n    if arr[start_i] ~=\
    \ arr[end_i] then\n      changes = changes + 1\n    end\n    start_i = start_i\
    \ + 1\n    end_i = end_i - 1\n  end\n  if is_odd then\n    changes = changes -\
    \ 1\n  end\n  return changes\nend", "    local size = #arr\n    local sum = 0\n\
    \    local i = 1\n    local j = size\n    local endI = size % 2 == 0 and math.floor(size\
    \ / 2) or math.floor(size / 2) + 1\n    while i < endI do\n        if arr[i] ~=\
    \ arr[j] then\n            sum = sum + 1\n        end\n        i = i + 1\n   \
    \     j = j - 1\n    end\n    return sum\nend", "  local n = #arr\n  local sum\
    \ = 0\n  for i = 1, n / 2 do\n    sum = sum + math.abs(arr[i] - arr[n + 1 - i])\n\
    \  end\n  return sum\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
