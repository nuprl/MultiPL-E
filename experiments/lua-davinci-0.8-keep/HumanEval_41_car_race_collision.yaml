name: HumanEval_41_car_race_collision
language: lua
prompt: "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n\
  \ cars are driving left to right;  simultaneously, a different set of n cars\n--\
  \ are driving right to left.   The two sets of cars start out being very far from\n\
  -- each other.  All cars move in the same speed.  Two cars are said to collide\n\
  -- when a car that's moving left to right hits a car that's moving right to left.\n\
  -- However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n-- in their trajectory as if they did not collide.\n-- This function outputs\
  \ the number of such collisions.\nlocal function car_race_collision(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n\
  \    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n  \
  \  lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n  \
  \  lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local res = 0\n  for i = 1,n do\n    for j = 1,n do\n      if i -\
    \ j < 0 then\n        res = res + 1\n      end\n    end\n  end\n  return res\n\
    end", "  assert(type(n) == \"number\")\n  local t = {}\n  for i = 1, n do\n  \
    \  t[i] = \"left\"\n  end\n  for i = n + 1, 2 * n do\n    t[i] = \"right\"\n \
    \ end\n  local result = 0\n  for i = 1, n do\n    for j = n + 1, 2 * n do\n  \
    \    if t[i] == \"left\" and t[j] == \"right\" then\n        result = result +\
    \ 1\n      end\n    end\n  end\n  return result\nend", "  local num_collisions\
    \ = 0\n  local max_collisions = 0\n  for i = 1, n do\n    for j = n, 1, -1 do\n\
    \      if i == j then\n        num_collisions = num_collisions + 1\n      end\n\
    \    end\n    if num_collisions > max_collisions then\n      max_collisions =\
    \ num_collisions\n    end\n  end\n  return max_collisions\nend", "  if n == 0\
    \ then\n    return 0\n  else\n    local res = car_race_collision(n - 1)\n    res\
    \ = res + n - 1\n    return res\n  end\nend", "  -- Write your code here\nend",
  "    if n == 0 then\n        return 0\n    end\n    if n == 1 then\n        return\
    \ 0\n    end\n    local sum = 0\n    for i = 1, n - 1 do\n        sum = sum +\
    \ i\n    end\n    return sum\nend", "  local l2r_cars, r2l_cars = {}, {}\n  local\
    \ collisions = 0\n  local car_number = 0\n  local function add_car(direction)\n\
    \    car_number = car_number + 1\n    if direction == 'r2l' then\n      r2l_cars[car_number]\
    \ = true\n    else\n      l2r_cars[car_number] = true\n    end\n  end\n  for i\
    \ = 1, n do\n    add_car('l2r')\n    add_car('r2l')\n  end\n  local function check_collision(l2r_car_number,\
    \ r2l_car_number)\n    if r2l_cars[r2l_car_number] then\n      collisions = collisions\
    \ + 1\n      r2l_cars[r2l_car_number] = nil\n    end\n  end\n  for l2r_car_number,\
    \ _ in pairs(l2r_cars) do\n    for r2l_car_number = l2r_car_number, car_number\
    \ do\n      check_collision(l2r_car_number, r2l_car_number)\n    end\n  end\n\
    \  return collisions\nend", "  return (n * (n - 1)) / 2\nend", "   if n < 1 then\
    \ return 0 end\n   return n-1\nend", "   -- TODO: replace me by the correct code.\n\
    \   return 0\nend", "    local n = n or (RANDOM_N and RANDOM_N())\n    n = n or\
    \ 3\n    local n2 = n * 2\n    local a = {}\n    for i = 1, n2 do\n        table.insert(a,\
    \ {i, rand.uniform(0, 100)})\n    end\n    table.sort(a, function(aa, bb) return\
    \ aa[2] < bb[2] end)\n    local cnt = 0\n    for i = 1, n2 do\n        for j =\
    \ i + 1, n2 do\n            if i <= n and j > n then\n                cnt = cnt\
    \ + 1\n            end\n        end\n    end\n    return cnt\nend", "  local left_cars\
    \ = n\n  local right_cars = n\n  local total_collisions = 0\n  while left_cars\
    \ > 0 or right_cars > 0 do\n    total_collisions = total_collisions + left_cars\
    \ * right_cars\n    left_cars = left_cars - 1\n    right_cars = right_cars - 1\n\
    \  end\n  return total_collisions\nend", "  if n < 1 then return 0 end\n  local\
    \ left, right = {}, {}\n  for i = 1, n do\n    left[i] = i\n    right[i] = n+1-i\n\
    \  end\n  local count = 0\n  while #left > 0 and #right > 0 do\n    local l =\
    \ left[1]\n    local r = right[1]\n    if l == r then\n      count = count + 1\n\
    \      table.remove(left, 1)\n      table.remove(right, 1)\n    elseif l < r then\n\
    \      table.remove(left, 1)\n    else\n      table.remove(right, 1)\n    end\n\
    \  end\n  return count\nend", "    local left_to_right = {};\n    local right_to_left\
    \ = {};\n    local max_distance = 2 * n;", '    local n_c = n', "  local num_collisions\
    \ = 0\n  local active_cars = {}\n  local i\n  for i = 1,n do\n    active_cars[i]\
    \ = {x = i, inc = 1}\n  end\n  for i = n+1, 2*n do\n    active_cars[i] = {x =\
    \ 2*n - i + 1, inc = -1}\n  end\n  local j\n  local num_active_cars = n*2\n  local\
    \ car_i, car_j\n  local num_collisions = 0\n  for i = 1, num_active_cars do\n\
    \    car_i = active_cars[i]\n    car_i.x = car_i.x + car_i.inc\n    j = i + 1\n\
    \    while j <= num_active_cars do\n      car_j = active_cars[j]\n      if car_i.x\
    \ == car_j.x then\n        num_collisions = num_collisions + 1\n        table.remove(active_cars,\
    \ j)\n        num_active_cars = num_active_cars - 1\n      else\n        j = j\
    \ + 1\n      end\n    end\n  end\n  return num_collisions\nend", "   local function\
    \ f(t)\n      return t\n   end\n   return 0\nend", "    -- TODO: implement\n \
    \   -- Hint: use a stack.\n    local s = Stack:new()\n    for i = 1, n do\n  \
    \      s:push(i)\n    end\n    local collisions = 0\n    for i = 1, n do\n   \
    \     local left = s:pop()\n        local right = s:pop()\n        if left ==\
    \ nil then\n            collisions = collisions + 1\n        elseif right == nil\
    \ then\n            collisions = collisions + 1\n        elseif left < right then\n\
    \            collisions = collisions + 1\n        end\n    end\n    return collisions\n\
    end", "    local count = 0\n    local a = 1\n    local b = n\n    while a <= n\
    \ and b >= 1 do\n        if a < b then\n            count = count + b - a\n  \
    \          a = a + 1\n        else\n            b = b - 1\n        end\n    end\n\
    \    return count\nend", "  return 0\nend", "   return n * (n - 1)\nend", "  \
    \  return n*(n-1)/2\nend", "    -- Input:  n, the number of cars\n    -- Output:\
    \  the number of times cars moving right to left collide with cars moving left\
    \ to right\n    -- Example:  n = 3\n    -- Two sequences of cars come at each\
    \ other:\n    -- 1 2 3\n    -- 3 2 1\n    -- 1 collides with 3\n    -- 2 collides\
    \ with 2\n    -- 3 collides with 1\n    -- Hence, the output is 3.\n    -- Your\
    \ solution here:\n    local count = 0\n    for i = 1, n do\n        if i == n\
    \ then\n            count = count + 1\n        else\n            count = count\
    \ + i\n        end\n    end\n    return count\nend", "   local x1 = (math.random(0,\
    \ 10000000))   -- starting positions\n   local x2 = (math.random(0, 10000000))\n\
    \   local y1 = (math.random(0, 10000000))\n   local y2 = (math.random(0, 10000000))\n\
    \   local v1 = (math.random(1, 50))         -- speeds\n   local v2 = (math.random(1,\
    \ 50))\n   if v1 == v2 then return 0 end", "  local seen = {}\n  local collisions\
    \ = 0\n  local curx = -n\n  for i = 1, n do\n    local x = math.random(curx +\
    \ 1, curx + i)\n    if seen[x] then\n      collisions = collisions + 1\n    end\n\
    \    seen[x] = true\n    curx = x\n  end\n  return collisions\nend", "  local\
    \ function do_row(car)\n    if car >= n then\n      return car - n\n    else\n\
    \      return car\n    end\n  end\n  local count = 0\n  for left_car = 0, n -\
    \ 1 do\n    for right_car = 0, n - 1 do\n      if do_row(left_car) == do_row(right_car)\
    \ then\n        count = count + 1\n      end\n    end\n  end\n  return count\n\
    end", "    local collisions = 0\n    local cars = {}\n    for i = 1, n do\n  \
    \      cars[i] = {x = -100 * i, dir = 1}\n    end\n    for i = 1, n do\n     \
    \   cars[n + i] = {x = 100 * i, dir = -1}\n    end\n    local p = 1\n    local\
    \ r = n + 1\n    while p <= n and r <= 2 * n do\n        if cars[p].x < cars[r].x\
    \ then\n            p = p + 1\n        elseif cars[p].x > cars[r].x then\n   \
    \         r = r + 1\n        else\n            collisions = collisions + 1\n \
    \           p = p + 1\n            r = r + 1\n        end\n    end\n    return\
    \ collisions\nend", "    -- for i=1,n do\n    --     for j=1,n do\n    --    \
    \     if math.abs(i-j) == n then\n    --             return 1\n    --        \
    \ end\n    --     end\n    -- end\n    -- return 0\n    return math.floor(n/2)\n\
    end", "    if n <= 0 then\n        return 0\n    end\n    local left_car_ts =\
    \ {}\n    local right_car_ts = {}\n    for i = 1, n do\n        left_car_ts[i]\
    \ = i\n        right_car_ts[i] = n - i + 1\n    end\n    local collision_counter\
    \ = 0\n    for i = 1, n do\n        for j = 1, n do\n            if left_car_ts[i]\
    \ == right_car_ts[j] then\n                collision_counter = collision_counter\
    \ + 1\n            end\n        end\n    end\n    return collision_counter\nend",
  "   local data = {}\n   local m = {0, 0}\n   for i = 1, n do\n      data[i] = {m[i\
    \ % 2], math.random()}\n   end\n   table.sort(data, function(a, b) return a[2]\
    \ < b[2] end)\n   local collisions = 0\n   for i = 1, n do\n      collisions =\
    \ collisions + m[data[i][1]]\n      m[data[i][1]] = m[data[i][1]] + 1\n   end\n\
    \   return collisions\nend", "    local cur_r = 0\n    local cur_l = n-1\n   \
    \ local step = 0\n    while cur_r <= cur_l do\n        local temp = math.random(0,1)\n\
    \        if temp == 0 then\n            cur_r = cur_r + 1\n        else\n    \
    \        cur_l = cur_l - 1\n        end\n        step = step + 1\n    end\n  \
    \  return step - 1\nend", "    local pos = {}\n    local t = 0\n    local i =\
    \ 1\n    local j = n\n    for k = 1, n * 2 do\n        local wait = math.huge\n\
    \        if i <= n then\n            wait = math.min(wait, pos[i] / i)\n     \
    \   end\n        if j > 0 then\n            wait = math.min(wait, -pos[j] / j)\n\
    \        end\n        t = t + wait\n        if i <= n then\n            pos[i]\
    \ = pos[i] + i * wait\n        end\n        if j > 0 then\n            pos[j]\
    \ = pos[j] - j * wait\n        end\n        if pos[i] == 0 then\n            i\
    \ = i + 1\n        end\n        if pos[j] == 0 then\n            j = j - 1\n \
    \       end\n    end\n    return t, t / n\nend", "    local cnt = 0\n    for i\
    \ = 1, n do\n        for j = n + 1, 2 * n do\n            if i == j - n then\n\
    \                cnt = cnt + 1\n            end\n        end\n    end\n    return\
    \ cnt\nend", '    local a = n; local b = n; local count = 0;', "  local n_collisions\
    \ = 0\n  for i = 1, n do\n    for j = n, 1, -1 do\n      if i == j then\n    \
    \    n_collisions = n_collisions + 1\n      end\n    end\n  end\n  return n_collisions\n\
    end", "   return 0\nend", "  return math.floor(n * (n-1) / 2)\nend", "   if n\
    \ <= 1 then\n      return 0\n   end\n   local left_i = 1\n   local right_i = n\n\
    \   local left_cars = {}\n   local right_cars = {}\n   for i = 1, n do\n     \
    \ left_cars[i] = n - i + 1\n      right_cars[i] = i\n   end\n   local collision_count\
    \ = 0\n   while left_i <= n and right_i >= 1 do\n      if left_cars[left_i] ==\
    \ right_cars[right_i] then\n         collision_count = collision_count + 1\n \
    \        left_i = left_i + 1\n         right_i = right_i - 1\n      elseif left_cars[left_i]\
    \ < right_cars[right_i] then\n         left_i = left_i + 1\n      else\n     \
    \    right_i = right_i - 1\n      end\n   end\n   return collision_count\nend",
  "    return math.floor(n*(n-1)/2)\nend", "   local count = 0\n   for i = 1, n do\n\
    \      count = count + (n-i+1)\n   end\n   return count\nend", "   return n *\
    \ (n - 1) / 2\nend", "    -- TODO: Implement this function\n    return nil\nend",
  "    local num_left = 0\n    local num_right = 0\n    local num_collision = 0\n\
    \    local q = Queue.new()\n    while num_left < n or num_right < n do\n     \
    \   if num_left < n then\n            num_left = num_left + 1\n            q:enqueue(num_left)\n\
    \        end\n        if num_right < n then\n            num_right = num_right\
    \ + 1\n            q:enqueue(-num_right)\n        end\n        local cur = q:dequeue()\n\
    \        if cur < 0 then\n            num_right = num_right - 1\n            while\
    \ cur + q:peek() == 0 do\n                q:dequeue()\n                num_collision\
    \ = num_collision + 1\n            end\n        else\n            num_left = num_left\
    \ - 1\n        end\n    end\n    return num_collision\nend", "  -- TODO\n  return\
    \ nil\nend", "  n = n or math.random(1, 10)\n  local left_to_right_cars = {}\n\
    \  local right_to_left_cars = {}\n  local collision_count = 0\n  for i = 1, n\
    \ do\n    local x = math.random(1, 100)\n    local x_ = -x\n    left_to_right_cars[i]\
    \ = x\n    right_to_left_cars[i] = x_\n  end\n  local i = 1\n  while i <= n do\n\
    \    local j = 1\n    while j <= n do\n      if left_to_right_cars[i] < right_to_left_cars[j]\
    \ then\n        break\n      end\n      if left_to_right_cars[i] == right_to_left_cars[j]\
    \ then\n        collision_count = collision_count + 1\n      end\n      j = j\
    \ + 1\n    end\n    i = i + 1\n  end\n  return collision_count\nend", "  local\
    \ collisions = 0\n  -- Index the cars that are moving from left to right.\n  for\
    \ i=1,n do\n    -- Index the cars that are moving from right to left.\n    for\
    \ j=1,n do\n      -- Does car i intersect with car j at any point?\n      if math.abs(i-j)\
    \ <= n-1 then\n        collisions = collisions + 1\n      end\n    end\n  end\n\
    \  return collisions\nend", "  local num_collisions = 0\n  for i = 1, n do\n \
    \   num_collisions = num_collisions + i\n  end\n  return num_collisions\nend",
  "  -- Note that the time it takes a car to go from the left side to the right\n\
    \  -- side is the same as the time it takes a car to go from the right side to\n\
    \  -- the left side.\n  -- Given that, the car that is at the end of the trip,\
    \ will be the car that\n  -- started the trip at the right side and the car at\
    \ the right side started\n  -- the trip at the left side.\n  -- Since the time\
    \ it takes to travel from the left side to the right side is\n  -- the same as\
    \ it takes to travel from the right side to the left side, it\n  -- follows that\
    \ the cars traveling from the left side will meet the cars\n  -- traveling from\
    \ the right side and vice versa.\n  -- The result is that the left most car will\
    \ meet the right most car, the\n  -- second to left most car will meet the second\
    \ to right most car and so on.\n  -- This leads to n collisions.\n  return n\n\
    end", "  -- Initialize collision detector\n  local detector = Collision_Detector:new{}\n\
    \  for i = 1, n do\n    detector:add_car(Car:new{direction = 'left_to_right'})\n\
    \    detector:add_car(Car:new{direction = 'right_to_left'})\n  end\n  -- Run the\
    \ cars\n  detector:run()\n  -- Return the number of collisions\n  return detector.collision_count\n\
    end", "   -- What would happen if one of the cars driving left-to-right switched\
    \ direction\n   -- and started driving right-to-left?  We would get one more collision.\n\
    \   -- Thus the number of collisions is the same as the number of cars that get\n\
    \   -- in the way of a car driving left-to-right.\n   -- It's an interesting exercise\
    \ to try to do this simulation yourself.\n   -- Assume a car is a square that\
    \ can be represented by its bottom-left corner\n   -- and its height.  Now imagine\
    \ that each car moves at a fixed speed of 1;\n   -- in other words, each car starts\
    \ out with its bottom-left corner at 0, and\n   -- at the end of time 1, its bottom-left\
    \ corner is at 1.\n   -- What are the cars in the way at the end of time 1?  Certainly,\
    \ the n cars\n   -- driving left-to-right are in the way.  Also, there's a car\
    \ that started out\n   -- at the left edge of the road and is driving right-to-left.\
    \  Of the n cars\n   -- driving right-to-left, the car at position i is in the\
    \ way if its height\n   -- is at least n-i.  Thus the answer is n+1 plus the number\
    \ of cars whose height\n   -- is at least n-i.  By the way, this is the same as\
    \ the number of cars whose\n   -- height is at least i, since there are n cars.\
    \  (And recall from\n   -- `frequency_of_heights` that the number of cars whose\
    \ height is at least i\n   -- is n-i+1.)\n   return n+1 + (n-1)\nend", "  local\
    \ function ininterval(x) return 0 <= x and x < n end\n  local function is_right_to_left(x)\
    \ return x < 0 end\n  local function is_left_to_right(x) return x >= 0 end\n \
    \ local function collide(positions)\n    local t={}\n    for i=1,2*n do t[i]=0\
    \ end\n    for i=1,2*n do\n      t[positions[i]]=t[positions[i]]+1\n    end\n\
    \    local collisions=0\n    for i=1,2*n do\n      collisions=collisions+t[i]*(t[i]-1)/2\n\
    \    end\n    return collisions\n  end\n  local function move(positions)\n   \
    \ local new_positions={}\n    for i=1,2*n do\n      if is_right_to_left(positions[i])\
    \ then\n        new_positions[i]=positions[i]+1\n      else\n        new_positions[i]=positions[i]-1\n\
    \      end\n    end\n    return new_positions\n  end\n  local function to_string(positions)\n\
    \    local out=\"\"\n    for i=1,2*n do\n      if is_right_to_left(positions[i])\
    \ then\n        out=out..string.format(\"(%d,%d) \", positions[i], i)\n      else\n\
    \        out=out..string.format(\"%d \", positions[i])\n      end\n    end\n \
    \   return out\n  end\n  local positions={}\n  for i=1,n do\n    positions[i]=-i\n\
    \  end\n  for i=n+1,2*n do\n    positions[i]=i-n\n  end\n  local collisions=0\n\
    \  local step=0\n  while true do\n    positions=move(positions)\n    collisions=collisions+collide(positions)\n\
    \    if positions[1]==1 then break end\n    step=step+1\n  end\n  return collisions\n\
    end", "   local f = function(a,b)\n\t\t local count = 0\n\t\t for i = 1,n do\n\
    \t\t    if a[i] > b[i] then\n\t\t       count = count + 1\n\t\t    end\n\t\t end\n\
    \t\t return count\n\t      end\n   return f\nend", "  -- n is the size of the\
    \ array\n  local seen_nums_set = {} -- Set of all the numbers we've seen so far\n\
    \  local num_collisions = 0 -- Number of collisions\n  for i=1,n do -- i is the\
    \ index into the array\n    local num = tonumber(assert(io.read())) -- Read next\
    \ number from stdin\n    if seen_nums_set[-num] then -- If there's a number at\
    \ -num\n      -- Then we have collision\n      num_collisions = num_collisions\
    \ + 1\n    end\n    seen_nums_set[num] = true -- Mark that we've seen num\n  end\n\
    \  return num_collisions\nend", "  local moving_left_to_right, moving_right_to_left\
    \ = {}, {}\n  for i = 1, n do\n    table.insert(moving_left_to_right, i)\n   \
    \ table.insert(moving_right_to_left, -i)\n  end\n  local result = 0\n  while next(moving_left_to_right)\
    \ and next(moving_right_to_left) do\n    local result_for_one_step = 0\n    local\
    \ head_of_moving_left_to_right = moving_left_to_right[1]\n    local head_of_moving_right_to_left\
    \ = moving_right_to_left[1]\n    if head_of_moving_left_to_right > head_of_moving_right_to_left\
    \ then\n      -- left-to-right car is ahead of right-to-left car, move only left-to-right\
    \ car\n      table.remove(moving_left_to_right, 1)\n    elseif head_of_moving_left_to_right\
    \ < head_of_moving_right_to_left then\n      -- right-to-left car is ahead of\
    \ left-to-right car, move only right-to-left car\n      table.remove(moving_right_to_left,\
    \ 1)\n    else\n      -- both cars move at the same time, and collision happens\n\
    \      table.remove(moving_left_to_right, 1)\n      table.remove(moving_right_to_left,\
    \ 1)\n      result_for_one_step = 1\n    end\n    result = result + result_for_one_step\n\
    \  end\n  return result\nend", "   local result = 0\n   for i = 1, n do\n    \
    \  for j = 1, n do\n         if i > j then\n            result = result + 1\n\
    \         end\n      end\n   end\n   return result\nend", "   -- We represent\
    \ the cars as numbers from 1..n.\n   -- Each car is a ray, or a line segment that\
    \ extends infinitely in both directions.\n   -- So let's start from the original\
    \ data.  Let cars_left be an array of distinct\n   -- numbers from 1..n and cars_right\
    \ be an array of distinct numbers from 1..n.\n   local cars_left = range(1, n)\n\
    \   local cars_right = range(1, n)\n   local collisions = 0\n   while #cars_left\
    \ > 0 and #cars_right > 0 do\n      local car_left = table.remove(cars_left, 1)\n\
    \      local car_right = table.remove(cars_right, 1)\n      if car_left > car_right\
    \ then\n         collisions = collisions + 1\n      else\n         table.insert(cars_left,\
    \ car_left)\n         table.insert(cars_right, car_right)\n      end\n   end\n\
    \   return collisions\nend", "    print(\"car_race_collision: \"..n)\n    local\
    \ num = 1\n    for i = 1, n - 1 do\n        num = num + i\n    end\n    return\
    \ num\nend", "    local left_to_right = {}\n    local right_to_left = {}\n   \
    \ local pos_right = 0\n    local pos_left = n\n    for i = 1, n do\n        left_to_right[i]\
    \ = pos_right\n        right_to_left[i] = pos_left\n        pos_right = pos_right\
    \ + 1\n        pos_left = pos_left - 1\n    end\n    local counter = 0\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            if left_to_right[i] == right_to_left[j]\
    \ then\n                counter = counter + 1\n            end\n        end\n\
    \    end\n    return counter\nend", "    local r2l = {} -- map car ID -> car position\n\
    \    local l2r = {} -- map car ID -> car position\n    local i, j\n    local cnt\
    \ = 0", '    if n==0 then return 0 end', "    local left_cars = {}\n    local\
    \ right_cars = {}\n    local left_counter = 0\n    local right_counter = 0\n \
    \   while left_counter <= n and right_counter <= n do\n        local new_car =\
    \ math.random(0, n)\n        if not left_cars[new_car] then\n            left_cars[new_car]\
    \ = true\n            left_counter = left_counter + 1\n        end\n        local\
    \ new_car = math.random(0, n)\n        if not right_cars[new_car] then\n     \
    \       right_cars[new_car] = true\n            right_counter = right_counter\
    \ + 1\n        end\n    end\n    local collisions = 0\n    for left_car, _ in\
    \ pairs(left_cars) do\n        if right_cars[left_car] then\n            collisions\
    \ = collisions + 1\n        end\n    end\n    return collisions\nend", "    --\
    \ base case\n    if n == 1 then\n        return 0\n    end", '  local numCollisions
    = 0', "  -- write your code here\nend", "    local n = n or 1\n    local ncars\
    \ = 2*n\n    -- table cnt records for every car, the number of cars that eventually\n\
    \    -- catch up with it.\n    local cnt = {}\n    -- initialize the number of\
    \ collisions each car has at 0.\n    for i = 1, ncars do\n        cnt[i] = 0\n\
    \    end\n    -- add the number of cars that car i catches up with, to car i.\n\
    \    for i = 1, ncars do\n        local j = i + 1\n        while j <= ncars do\n\
    \            cnt[i] = cnt[i] + 1\n            j = j + 1\n        end\n    end\n\
    \    -- add the number of cars that car i catches up with, to all cars that\n\
    \    -- catch up with car i.\n    for i = 1, ncars do\n        local j = i + 1\n\
    \        while j <= ncars do\n            cnt[j] = cnt[j] + cnt[i]\n         \
    \   j = j + 1\n        end\n    end\n    -- Now count the number of collisions.\n\
    \    local ans = 0\n    for i = 1, ncars do\n        -- when car i catches up\
    \ with car j, this means that car i has\n        -- collided with j, 1+2+...+cnt[i]\
    \ cars.\n        ans = ans + cnt[i]*(cnt[i]+1)/2\n    end\n    return ans\nend",
  "    local n = n or 0\n    local left = 0\n    local right = n + 1\n    local cnt\
    \ = 0\n    local i = 1\n    while i <= n do\n        if left < right then\n  \
    \          left = left + 1\n            right = right - 1\n            cnt = cnt\
    \ + 1\n        else\n            left = left + 1\n            right = right -\
    \ 1\n        end\n        i = i + 1\n    end\n    return cnt\nend", "   local\
    \ left = make_array_random(n)\n   local right = make_array_random(n)\n   table.sort(left)\n\
    \   table.sort(right)\n   local i = 1\n   local j = 1\n   local collision = 0\n\
    \   while i <= n and j <= n do\n      if left[i] == right[j] then\n         collision\
    \ = collision + 1\n         i = i + 1\n         j = j + 1\n      elseif left[i]\
    \ < right[j] then\n         i = i + 1\n      else\n         j = j + 1\n      end\n\
    \   end\n   return collision\nend", "   local collisions = 0\n   local set1 =\
    \ {}\n   local set2 = {}\n   local i\n   for i = 1, n do\n      set1[i] = i\n\
    \      set2[i] = i + n\n   end\n   while true do\n      local found = false\n\
    \      for i = 1, n do\n         if set1[i] <= set2[i] then\n            collisions\
    \ = collisions + 1\n            set1[i] = set1[i] + n\n            set2[i] = set2[i]\
    \ - n\n            found = true\n         end\n      end\n      if not found then\
    \ break end\n   end\n   return collisions\nend", "    -- record the previous car\
    \ position\n    local prev = {\n        [1] = -math.huge,\n        [2] = math.huge\n\
    \    }\n    -- count the number of collisions\n    local count = 0\n    -- loop\
    \ the car position\n    for i = 1, n do\n        local x1 = math.random(0, 1000000)\n\
    \        local x2 = math.random(0, 1000000)\n        if x1 < prev[1] and x2 >\
    \ prev[2] then\n            count = count + 1\n        end\n        prev[1] =\
    \ x1\n        prev[2] = x2\n    end\n    return count\nend", "    -- Using the\
    \ following definitions:\n    --    each car is defined by its speed (an integer\
    \ of 1) and its position (another integer)\n    --    cars are ordered by position,\
    \ from smallest to largest\n    --    cars to the left move with positive speed,\
    \ cars to the right move with negative speed\n    --\n    -- The algorithm is\
    \ to iterate through the cars on the left, and do a binary search to find\n  \
    \  -- the first car to the right that collides with it.\n    --\n    -- The complexity\
    \ is O(n log n)", "    assert(n >= 0)\n    local sum = 0\n    local range = utils.range(1,\
    \ n)\n    for _, k in ipairs(range) do\n        for _, v in ipairs(range) do\n\
    \            if v > k then\n                sum = sum + 1\n            end\n \
    \       end\n    end\n    return sum\nend", "    local set = {}\n    local i =\
    \ 0\n    while n > 0 do\n        n = n - 1\n        i = i + 1\n        if set[i]\
    \ then\n            return i\n        end\n        set[i] = true\n    end\n  \
    \  return 0\nend", "    local elapsed_time = 0\n    local collisions = 0\n   \
    \ while(elapsed_time < 100) do\n        local right_to_left_car_num = math.random(1,\
    \ n)\n        local left_to_right_car_num = math.random(1, n)\n        if right_to_left_car_num\
    \ == left_to_right_car_num then\n            collisions = collisions + 1\n   \
    \     end\n        elapsed_time = elapsed_time + 1\n    end\n    return collisions\n\
    end", "   n = n or 1\n   local n_collisions = 0\n   -- print('n:', n)\n   for\
    \ i=1,n do\n      local j = n\n      while j >= i do\n         -- print('i,j:',\
    \ i, j)\n         n_collisions = n_collisions + 1\n         j = j - 1\n      end\n\
    \   end\n   return n_collisions\nend", "  if n <= 0 then return 0 end\n  local\
    \ left = {}\n  local right = {}\n  for i = 1, n do\n    left[i] = 0\n    right[i]\
    \ = 0\n  end\n  local answer = 0\n  local last_car = 1\n  for i = 1, n do\n  \
    \  if last_car == 1 then\n      left[i] = i\n      last_car = 2\n    else\n  \
    \    right[i] = i\n      last_car = 1\n    end\n  end\n  local lo = 1\n  local\
    \ hi = n\n  while lo <= hi do\n    if left[lo] == right[hi] then\n      answer\
    \ = answer + 1\n      lo = lo + 1\n      hi = hi - 1\n    elseif left[lo] < right[hi]\
    \ then\n      lo = lo + 1\n    else\n      hi = hi - 1\n    end\n  end\n  return\
    \ answer\nend", "    -- YOUR CODE HERE\n    local collisions = 0\n    local left\
    \ = {}\n    local right = {}\n    for i = 1, n do\n        local newLeft = math.random()\n\
    \        local newRight = math.random()\n        for j = 1, #left do\n       \
    \     if newLeft < left[j] then\n                collisions = collisions + 1\n\
    \            end\n        end\n        for j = 1, #right do\n            if newRight\
    \ > right[j] then\n                collisions = collisions + 1\n            end\n\
    \        end\n        left[#left + 1] = newLeft\n        right[#right + 1] = newRight\n\
    \    end\n    return collisions\nend", "   local car_left = {}\n   local car_right\
    \ = {}\n   for i = 1, n do\n      table.insert(car_left, i)\n      table.insert(car_right,\
    \ n - i + 1)\n   end\n   local count = 0\n   local i = 1\n   local j = 1\n   while\
    \ i <= n and j <= n do\n      local left_car = car_left[i]\n      local right_car\
    \ = car_right[j]\n      if left_car > right_car then\n         count = count +\
    \ 1\n         j = j + 1\n      else\n         i = i + 1\n      end\n   end\n \
    \  return count\nend", "    -- IMPLEMENT THIS FUNCTION\n    return 0\nend", " \
    \   assert(n > 0)\n    return math.ceil(n/2)\nend", "  local num_collisions =\
    \ 0\n  local cars_r2l = {}\n  local cars_l2r = {}\n  local time = 0\n  while time\
    \ < n do\n    time = time + 1\n    if time % 2 == 0 then -- even time\n      if\
    \ #cars_r2l > 0 then\n        local collision_index = cars_r2l[#cars_r2l]\n  \
    \      table.remove(cars_r2l)\n        num_collisions = num_collisions + n - collision_index\n\
    \      end\n      table.insert(cars_l2r, 1, time)\n    else -- odd time\n    \
    \  if #cars_l2r > 0 then\n        local collision_index = cars_l2r[#cars_l2r]\n\
    \        table.remove(cars_l2r)\n        num_collisions = num_collisions + collision_index\
    \ - 1\n      end\n      table.insert(cars_r2l, 1, time)\n    end\n  end\n  return\
    \ num_collisions\nend", "    if n==1 then return 0 end\n    local start_order\
    \ = {}\n    for i=1,n do\n        start_order[i] = i\n    end\n    -- print(\"\
    shuffling: \"..table.concat(start_order,\",\"))\n    table.sort(start_order,function(a,b)\
    \ return math.random()<0.5 end)\n    -- print(\"shuffled: \"..table.concat(start_order,\"\
    ,\"))\n    local collisions = 0\n    for i=1,n do\n        for j=i+1,n do\n  \
    \          if start_order[i]>start_order[j] then\n                collisions =\
    \ collisions + 1\n            end\n        end\n    end\n    return collisions\n\
    end", "    -- how many times each car in the first set has collided\n    local\
    \ t = {}\n    for i = 1, n do\n        t[i] = 0\n    end\n    -- the first set\
    \ of cars is at the positions\n    -- 1, 2, 3, 4, ..., n, n+1, n+2, n+3, n+4,\
    \ ...\n    -- the second set of cars is at the positions\n    -- n, n-1, n-2,\
    \ n-3, ..., 1, 0, -1, -2, -3, ...\n    -- car i in the first set collides with\
    \ car n-i+1 in the second set\n    for i = 1, n do\n        t[i] = t[i] + 1\n\
    \    end\n    -- sum up the number of collisions\n    local sum = 0\n    for i\
    \ = 1, n do\n        sum = sum + t[i]\n    end\n    return sum\nend", "    --\
    \ The following line is necessary in order to compile.  Please remove\n    --\
    \ as soon as you write your own code.\n    return 0\nend", "  local t = unpack(n)\n\
    \  local m = {}\n  for i = 1, n do\n    m[i] = unpack(t[i])\n  end\n  local pairs\
    \ = 0\n  for i = 1, n do\n    for j = i + 1, n do\n      local a = m[i]\n    \
    \  local b = m[j]\n      if a[1] < b[1] and a[2] < b[2] then\n        pairs =\
    \ pairs + 1\n      end\n    end\n  end\n  return pairs\nend", "  local left_to_right\
    \ = {};\n  local right_to_left = {};\n  for i = 1, n do\n    left_to_right[i]\
    \ = i;\n    right_to_left[i] = n + 1 - i;\n  end", "  -- Substitute your code\
    \ here\n  return 1+n\nend", "   local cars = {};\n   local left_to_right = {}\n\
    \   local right_to_left = {}\n   for i = 1, n do\n      local a = random_decimal(0,\
    \ 1000000000000)\n      local b = random_decimal(0, 1000000000000)\n      table.insert(cars,\
    \ { a, b })\n      if a < b then\n         table.insert(left_to_right, { a, b\
    \ })\n      else\n         table.insert(right_to_left, { a, b })\n      end\n\
    \   end\n   for i = 1, n do\n      for j = 1, n do\n         if (left_to_right[i][1]\
    \ < right_to_left[j][2]) and (left_to_right[i][2] > right_to_left[j][1]) then\n\
    \            print(string.format(\"%d -> %d collides with %d -> %d\", left_to_right[i][1],\
    \ left_to_right[i][2], right_to_left[j][1], right_to_left[j][2]))\n         end\n\
    \      end\n   end\nend", "    local collisions = 0\n    local current_time =\
    \ 1", "  local num_collisions = 0\n  -- Each car has an index.\n  -- We'll store\
    \ each car's index in a hash table.\n  -- The index is used to compute the car's\
    \ position and velocity.\n  -- The hash table is used to quickly detect collisions.\n\
    \  local left_to_right_cars = {}\n  local right_to_left_cars = {}\n  for i = 1,\
    \ n do\n    -- Cars moving left to right:\n    left_to_right_cars[i] = i\n   \
    \ -- Cars moving right to left:\n    right_to_left_cars[n - i + 1] = n - i + 1\n\
    \  end\n  -- We'll simulate the movement of cars for 0 < t < n,\n  -- incrementing\
    \ t by 1.\n  for t = 1, n - 1 do\n    -- At time t, we'll check each car moving\
    \ left to right to see if it collided\n    -- with a car moving right to left.\n\
    \    for car_index, _ in pairs(left_to_right_cars) do\n      -- At time t, the\
    \ car moving left to right with index i is at position i + t.\n      -- The car\
    \ moving right to left with index j is at position j - t.\n      -- These two\
    \ cars collide when i + t = j - t,\n      -- which simplifies to i = j.\n    \
    \  if right_to_left_cars[car_index] then\n        num_collisions = num_collisions\
    \ + 1\n      end\n    end\n    -- Now we simulate the movement of cars for time\
    \ t + 1.\n    -- At this time, the car moving left to right with index i has moved\
    \ forward\n    -- to position i + t + 1.\n    for car_index, _ in pairs(left_to_right_cars)\
    \ do\n      if car_index + t + 1 > n then\n        -- This car has moved all the\
    \ way to the end of the road,\n        -- so we no longer need to simulate its\
    \ movement.\n        left_to_right_cars[car_index] = nil\n      end\n    end\n\
    \    -- At this time, the car moving right to left with index j has moved forward\n\
    \    -- to position j - t - 1.\n    for car_index", "    local n_collisions =\
    \ 0\n    local lr_cars = set.new(range(1, n))\n    local rl_cars = set.new(range(1,\
    \ n))\n    while #lr_cars > 0 do\n        n_collisions = n_collisions + 1\n  \
    \      local lr_car = lr_cars:pop()\n        local rl_car = rl_cars:pop()\n  \
    \      if lr_car < rl_car then\n            rl_cars:insert(rl_car)\n        else\n\
    \            lr_cars:insert(lr_car)\n        end\n    end\n    return n_collisions\n\
    end", "    local t = 0\n    for i = 1, n do\n        for j = 1, n do\n       \
    \     if i > j then\n                t = t + 1\n            end\n        end\n\
    \    end\n    return t\nend", "    return n * (n - 1) / 2\nend", "    assert(n>=0)\n\
    \    if n==0 then return 0 end\n    return car_race_collision(n-1) + (n-1)\nend",
  "   local left_right = {}\n   local right_left = {}\n   local left_right_index =\
    \ 1\n   local right_left_index = 1\n   local collisions = 0\n   for k = 1, n do\n\
    \      left_right[k] = 0\n      right_left[k] = n+1\n   end\n   for t = 1, 2*n\
    \ do\n      local left_right_position = left_right[left_right_index]\n      local\
    \ right_left_position = right_left[right_left_index]\n      if left_right_position\
    \ == right_left_position then\n         collisions = collisions + 1\n      end\n\
    \      if left_right_position < right_left_position then\n         left_right_index\
    \ = left_right_index + 1\n      else\n         right_left_index = right_left_index\
    \ + 1\n      end\n   end\n   return collisions\nend", "    local function cars(n,\
    \ d)\n        if n == 0 then\n            return function () return nil end\n\
    \        else\n            return function ()\n                return n, -d, cars(n\
    \ - 1, d)\n            end\n        end\n    end\n    local collisions = 0\n \
    \   local lx, ly, lt = cars(n, -1)\n    local rx, ry, rt = cars(n, 1)\n    while\
    \ lx and rx do\n        if lx < rx then\n            lx, ly, lt = lt()\n     \
    \   elseif rx < lx then\n            rx, ry, rt = rt()\n        else\n       \
    \     collisions = collisions + 1\n            lx, ly, lt = lt()\n           \
    \ rx, ry, rt = rt()\n        end\n    end\n    return collisions\nend", "    local\
    \ function left_to_right_iterator()\n        for i = 1, n do\n            coroutine.yield(i)\n\
    \        end\n    end\n    local function right_to_left_iterator()\n        for\
    \ i = 1, n do\n            coroutine.yield(n - i + 1)\n        end\n    end\n\
    \    local left_to_right_co = coroutine.create(left_to_right_iterator)\n    local\
    \ right_to_left_co = coroutine.create(right_to_left_iterator)\n    local result\
    \ = 0\n    while true do\n        local left_to_right_value = {coroutine.resume(left_to_right_co)}\n\
    \        local right_to_left_value = {coroutine.resume(right_to_left_co)}\n  \
    \      if left_to_right_value[1] and right_to_left_value[1] then\n           \
    \ if left_to_right_value[2] == right_to_left_value[2] then\n                result\
    \ = result + 1\n            end\n        else\n            return result\n   \
    \     end\n    end\nend", "   local left_count = n\n   local right_count = n\n\
    \   local collisio", "   -- Your code here\n   if n == 0 then\n      return 0\n\
    \   else\n      return n + car_race_collision(n-1)\n   end\nend", "    local collisions\
    \ = 0\n    for i = 1, n do\n        for j = 1, n do\n            if (i - j) %\
    \ n == 0 then\n                collisions = collisions + 1\n            end\n\
    \        end\n    end\n    return collisions\nend", "  return math.floor(n*(n-1)/2)\n\
    end", "  local n1 = 0\n  local n2 = 0\n  for i = 1, n do\n    n1 = n1 + i\n  \
    \  n2 = n2 + n + 1 - i\n  end\n  return n1 + n2\nend", "    local x = { }\n  \
    \  for i = 1, n do\n        x[i] = 2 * i\n    end\n    local y = { }\n    for\
    \ i = 1, n do\n        y[i] = 2 * i - 1\n    end\n    local count = 0\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            if x[i] == y[j] then\n   \
    \             count = count + 1\n            end\n        end\n    end\n    return\
    \ count\nend", "  local left = 0\n  local right = 0\n  local coll = 0\n  while\
    \ left < n and right < n do\n    if left == right then\n      coll = coll + 1\n\
    \      left = left + 1\n      right = right + 1\n    elseif left < right then\n\
    \      left = left + 1\n    else\n      right = right + 1\n    end\n  end\n  return\
    \ coll\nend", "  -- in O(n), compute the number of car collisions.\n  local result\
    \ = 0\n  for i = 1, n do\n    result = result + i\n  end\n  return result\nend",
  "  return n * (n - 1) / 2\nend", "   -- Print some error messages if the parameters\
    \ are invalid.\n   if type(n) ~= \"number\" then\n      print(\"Error: car_race_collision(n)\
    \ called with a non-number n.\")\n      return nil\n   end\n   if n < 1 then\n\
    \      print(\"Error: car_race_collision(n) called with a non-positive n.\")\n\
    \      return nil\n   end\n   if math.floor(n) ~= n then\n      print(\"Error:\
    \ car_race_collision(n) called with a non-integer n.\")\n      return nil\n  \
    \ end", "    if n % 2 == 0 then\n        return n / 2\n    else\n        return\
    \ (n - 1) / 2\n    end\nend", "    local n = tonumber(n)\n    assert(n and n >=\
    \ 0)\n    local total = 0\n    for i = 1, n do\n        total = total + n - i\
    \ + 1\n    end\n    return total\nend", "    return math.floor(n * (n - 1) / 2)\n\
    end", "    local ans = 0\n    for i = 1, n do\n        for j = 1, n do\n     \
    \       if i > j then\n                ans = ans + 1\n            end\n      \
    \  end\n    end\n    return ans\nend", "    local count = 0\n    for i = 1, n\
    \ do\n        for j = 1, n do\n            if i ~= j then\n                count\
    \ = count + 1\n            end\n        end\n    end\n    return count\nend",
  "  local i = 1\n  local j = n\n  local count = 0\n  while true do\n    local passed\
    \ = 0\n    if i == j then\n      passed = 1\n    elseif i > j then\n      passed\
    \ = i - j\n    elseif j > i then\n      passed = j - i\n    end\n    count = count\
    \ + passed\n    if i == n and j == 1 then\n      break\n    end\n    i = i + 1\n\
    \    j = j - 1\n  end\n  return count\nend", "  local space_time_diagram = {}\n\
    \  local cur = 1\n  while cur <= n do\n    space_time_diagram[cur] = true\n  \
    \  cur = cur + 1\n  end\n  cur = -n\n  while cur <= -1 do\n    if space_time_diagram[-cur]\
    \ then\n      return n + cur\n    end\n    cur = cur + 1\n  end\n  return 0\n\
    end", "  local n = n or 1000 -- number of cars going to the right\n  local m =\
    \ n or 1000 -- number of cars going to the left\n  local t = 0 -- time elapsed,\
    \ in seconds.  We start at time t=0\n  local x = {i=1,j=1} -- We have n+m cars,\
    \ and we number the cars from 1 to n+m.  We use an index table x to keep track\
    \ of how far each car has progressed, as a function of time t.\n  local function\
    \ update_cars()\n    t = t + 1\n    x.i = x.i + 1\n    x.j = x.j + 1\n  end\n\
    \  local function is_collision()\n    return x.i == x.j\n  end\n  local function\
    \ reset_index_table()\n    x.i = 1\n    x.j = 1\n  end\n  local c = 0 -- c is\
    \ the number of collisions\n  local cars_arrived = 0 -- the number of cars that\
    \ have arrived at the other end\n  while cars_arrived < n+m do\n    update_cars()\n\
    \    if is_collision() then\n      c = c + 1\n      reset_index_table()\n    end\n\
    \    cars_arrived = 0\n    for k,v in pairs(x) do\n      if v > n+m then\n   \
    \     cars_arrived = cars_arrived + 1\n      end\n    end\n  end\n  return c\n\
    end", "    local x1 = 0\n    local x2 = math.huge\n    for i = 0, n - 1 do\n \
    \       local t1 = x1 / (i + 1)\n        local t2 = x2 / (n - i)\n        if t1\
    \ < t2 then\n            return i\n        end\n        x1 = x1 + 1\n        x2\
    \ = x2 - 1\n    end\n    return n\nend", "  -- we will use this to store (as the\
    \ key) the time at which a car started\n  -- moving left to right.  As the value,\
    \ we will store the speed of the car.\n  local left_to_right = {}\n  -- we will\
    \ use this to store (as the key) the time at which a car started\n  -- moving\
    \ right to left.  As the value, we will store the speed of the car.\n  local right_to_left\
    \ = {}\n  -- this is the time at which the first left-to-right car started moving\n\
    \  local left_to_right_start_time = -math.huge\n  -- this is the time at which\
    \ the first right-to-left car started moving\n  local right_to_left_start_time\
    \ = -math.huge\n  -- we will keep a running tally of how many collisions occurred\n\
    \  local collisions = 0\n  -- for 1 to n, we will add a car moving left to right\
    \ to our left_to_right table\n  for i = 1, n do\n    -- we will use the value\
    \ i as the speed of the car.  So, we will store the \n    -- speed of the car\
    \ (i) as the value to the key i, in the left_to_right table.\n    left_to_right[i]\
    \ = i\n    -- now, let's time the time at which this car started moving left to\
    \ right.\n    -- We know that each car will move at the same speed, and since\
    \ it's the\n    -- first car on the road, it will be at the start of the road\
    \ at time 0.\n    -- We will use the value i as the starting time.  So, we will\
    \ store the \n    -- start time of the car (i) as the value to the key i, in the\
    \ left_to_right table.\n    left_to_right[i] = i\n    -- now, let's update the\
    \ value of left_to_right_start_time\n    -- with the earliest time at which any\
    \ car started moving left to right.\n    -- To accomplish this, we simply need\
    \ to get the smallest\n    -- key from the left_to_right table.  Remember, we\
    \ are using the key as the\n    -- starting time of the car, and we are using\
    \ the value as the speed of", "    local cars_left_to_right = {}\n    local cars_right_to_left\
    \ = {}\n    for i = 1, n do\n        cars_left_to_right[i] = math.random() * 100\n\
    \        cars_right_to_left[i] = math.random() * 100\n    end\n    table.sort(cars_left_to_right)\n\
    \    table.sort(cars_right_to_left)\n    local j = 1\n    local collisions = 0\n\
    \    for i = 1, n do\n        local car_left_to_right = cars_left_to_right[i]\n\
    \        while j <= n and cars_right_to_left[j] < car_left_to_right do\n     \
    \       j = j + 1\n        end\n        collisions = collisions + j - 1\n    end\n\
    \    return collisions\nend", "    local n1, n2, n3, n4 = n - 1, n - 2, n - 3,\
    \ n - 4\n    return ((n1 * n2) * (n3 * n4)) / 4\nend", "    if n < 2 then\n  \
    \      return 0\n    end\n    local collisions = 0\n    local flags = {}\n   \
    \ local number_of_cars = n * 2\n    local starting_positions = {}\n    for i =\
    \ 1, number_of_cars do\n        flags[i] = true\n        starting_positions[i]\
    \ = i\n    end\n    local elapsed_time = 0\n    while #starting_positions > 0\
    \ do\n        elapsed_time = elapsed_time + 1\n        local new_positions = {}\n\
    \        for i = 1, #starting_positions do\n            local current_position\
    \ = starting_positions[i]\n            local new_position = current_position +\
    \ elapsed_time\n            local flag = flags[current_position]\n           \
    \ if new_position <= number_of_cars then\n                new_positions[#new_positions\
    \ + 1] = new_position\n                flags[new_position] = flag\n          \
    \  end\n        end\n        starting_positions = new_positions\n        if #starting_positions\
    \ == 0 then\n            break\n        end\n        for i = 1, #starting_positions\
    \ do\n            local current_position = starting_positions[i]\n           \
    \ local flag = flags[current_position]\n            local flag2 = flags[current_position\
    \ - elapsed_time]\n            if flag == flag2 then\n                collisions\
    \ = collisions + 1\n            end\n        end\n    end\n    return collisions\n\
    end", "    local left_to_right = {}\n    local right_to_left = {}\n    for i =\
    \ 1, n do\n        left_to_right[i] = i\n        right_to_left[i] = i\n    end\n\
    \    local i = 1\n    local j = 1\n    local rst = 0\n    while i <= n and j <=\
    \ n do\n        if left_to_right[i] < right_to_left[j] then\n            i = i\
    \ + 1\n        elseif left_to_right[i] > right_to_left[j] then\n            j\
    \ = j + 1\n        else\n            rst = rst + 1\n            i = i + 1\n  \
    \          j = j + 1\n        end\n    end\n    return rst\nend", "   -- We start\
    \ with a car moving to the right.\n   -- This is our first car.  The first car\
    \ has no collision.\n   local collisions = 0\n   -- We will make the following\
    \ fact inductive:\n   --\n   --   Invariant:\n   --      If we are to drive `n`\
    \ cars to the right, and\n   --      if we were to drive the same number of cars\
    \ to the left,\n   --      and if there are no collisions among these cars,\n\
    \   --      then the total number of collisions will be collisions.\n   --\n \
    \  -- The invariant is true for n = 1, because\n   --   If we drive 1 car to the\
    \ right, then there is one car total.\n   --   There are 0 cars to the left.\n\
    \   --   There are 0 collisions among these cars.\n   --   And the total number\
    \ of collisions is collisions = 0.\n   --\n   -- We will prove the invariant by\
    \ induction.\n   -- Assume that the invariant is true for n = k.\n   -- We will\
    \ prove that the invariant is true for n = k + 1.\n   --\n   -- If we are to drive\
    \ k + 1 cars to the right, and\n   --    we were to drive the same number of cars\
    \ to the left,\n   --    and if there are no collisions among these cars,\n  \
    \ --    then the total number of collisions will be collisions.\n   --\n   --\
    \ How can we drive k + 1 cars to the right?\n   --    We can do this by driving\
    \ k cars to the right,\n   --    and then drive 1 more car to the right.\n   --\
    \ This can be done because the invariant is true for n = k.\n   --\n   -- Also,\
    \ how can we drive k + 1 cars to the left?\n   --    We can do this by driving\
    \ k cars to the left,\n   --    and then drive 1 more car to the left.\n   --\
    \ This can be done because the invariant is true for n = k.\n   --\n   -- There\
    \ are no collisions among these cars, because\n   --    We have proved that there\
    \ are no collisions among the k cars\n   --    when we drive the k cars to the\
    \ right,\n   --    and we have proved that there are no collisions among the k\
    \ cars\n  ", "    -- TODO: return the correct number of collisions\n    local\
    \ e = 0\n    for i = 1, n do\n        if i % 2 == 0 then\n            e = e +\
    \ 1\n        end\n    end\n    return e\nend", "  if n <= 0 then\n    return 0\n\
    \  end\n  -- Assume n > 0.\n  local collisions = 0\n  local d = math.floor(n/2)\n\
    \  collisions = collisions + d\n  return collisions\nend", "  return n * (n -\
    \ 1) / 2\nend", '    local collisions = 0', "  print('car_race_collision('..n..')')\n\
    \  local count = 0\n  if n>0 then\n    count = car_race_collision(n-1) + n - 1\n\
    \  end\n  print('car_race_collision('..n..')='..count)\n  return count\nend",
  "  -- Convert all the cars' speeds and positions into a vector of same size\n  --\
    \ Cars that are moving right to left are converted to a negative speed.\n  --\
    \ Cars that are moving left to right are converted to a positive speed.\n  --\
    \ Cars that are moving right to left but at the far left of the road\n  -- are\
    \ converted to cars that are not moving.\n  -- Cars that are moving left to right\
    \ but at the far right of the road\n  -- are converted to cars that are not moving.\n\
    \  -- Cars that are moving left to right but have negative position\n  -- are\
    \ converted to cars that are not moving.\n  -- Cars that are moving right to left\
    \ but have positive position\n  -- are converted to cars that are not moving.\n\
    \  -- [[\n  -- For example, you could convert the input in the following way:\n\
    \  -- input:  2 cars moving left to right, from 0 to 4.5, with speed 2 and speed\
    \ 4\n  -- input:  1 car moving right to left, from 3 to -1, with speed 3\n  --\
    \ input:  1 car moving right to left, from -10 to 0, with speed -1\n  -- input:\
    \  1 car moving left to right, from -4 to -2, with speed -10\n  -- you can convert\
    \ the input to the following vector:\n  -- 0, 0, 2, 0, 4, 0, 0, -3, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,", "   assert(n >= 0)\n\
    \   if n == 0 then\n      return 0\n   else\n      return n + car_race_collision(n-1)\n\
    \   end\nend", "    local n1, n2 = n, n\n    local col = 0", "   local coll =\
    \ 0;\n   if n == 0 then return 0; end\n   if n == 1 then return 0; end\n   for\
    \ i = 1, n-1 do\n      coll = coll + i;\n   end\n   return coll;\nend", "  --\
    \ I'll store the cars in two arrays.\n  -- cars_right_to_left is an array that\
    \ contains the position of the cars\n  -- moving right to left.  car_left_to_right\
    \ is an array that contains the\n  -- position of the cars moving left to right.\
    \  Note: the cars can be thought\n  -- of as integers since the road is a straight\
    \ line.\n  local cars_right_to_left = {}\n  local cars_left_to_right = {}", " \
    \ -- Write your code here.\nend", "   return math.floor(n * (n-1) / 2)\nend",
  "  assert(n > 0, \"n must be a positive integer\")\n  local collision = 0\n  for\
    \ i = 1, n do\n    for j = 1, n do\n      -- Think about it:  the cars start very\
    \ far away.\n      -- By the time the first car reaches the start point of the\
    \ second car,\n      -- the second car has traveled a distance of 1, which is\
    \ greater than the\n      -- distance the first car has traveled.\n      -- So\
    \ how can a collision be possible?\n      collision = collision + 1\n    end\n\
    \  end\n  return collision\nend", "  -- COMPLETE ME\nend", "    if n == 0 then\n\
    \        return 0\n    end\n    return n - 1 + car_race_collision(n - 1)\nend",
  "    local function count(x, y)\n        local function print_list(list)\n     \
    \       print(table.concat(list, \" \"))\n        end\n        local left = {}\n\
    \        local right = {}\n        for i = 1, n do\n            left[i] = x -\
    \ 1\n            right[i] = y + 1\n        end\n        while x <= y do\n    \
    \        print_list(left)\n            print_list(right)\n            print()\n\
    \            x = x + 1\n            y = y - 1\n            for i = 1, n do\n \
    \               if left[i] == x then\n                    left[i] = left[i] +\
    \ 1\n                end\n                if right[i] == y then\n            \
    \        right[i] = right[i] - 1\n                end\n            end\n     \
    \   end\n    end\n    count(1, n)\nend", "   local n = n or 3\n   local function\
    \ count_collisions()\n      local collisions = 0\n      local cars_l2r = {}\n\
    \      local cars_r2l = {}\n      for i = 1, n do\n         cars_l2r[i] = 0\n\
    \         cars_r2l[i] = n\n      end\n      local t = 0\n      while true do\n\
    \         t = t + 1\n         for i = 1, n do\n            cars_l2r[i] = cars_l2r[i]\
    \ + 1\n            cars_r2l[i] = cars_r2l[i] - 1\n            if cars_l2r[i] ==\
    \ cars_r2l[i] then\n               collisions = collisions + 1\n            end\n\
    \         end\n         if cars_l2r[n] == n then\n            break\n        \
    \ end\n      end\n      return collisions\n   end\n   return count_collisions()\n\
    end", "    local left_to_right = {}\n    local right_to_left = {}\n    for i =\
    \ 1, n do\n        -- The cars are moving at speed 1, so the x coordinate is just\
    \ equal to the time\n        left_to_right[i] = i\n        right_to_left[i] =\
    \ -i\n    end\n    local collisions = 0\n    for t = 1, 2 * n - 1 do\n       \
    \ for i = 1, n do\n            if t == left_to_right[i] and t == -right_to_left[i]\
    \ then\n                collisions = collisions + 1\n            end\n       \
    \ end\n    end\n    return collisions\nend", "   -- we're only generating the\
    \ cars that are moving left to right; the cars that\n   -- are moving right to\
    \ left are just an inferior mirror image of these cars.\n   local cars = {}\n\
    \   for i = 1, n do\n      cars[i] = { x = i, speed = math.random(1, 100) }\n\
    \   end\n   local collisions = 0\n   for i = 1, n do\n      local car = cars[i]\n\
    \      for j = i + 1, n do\n         local car2 = cars[j]\n         if car.speed\
    \ > car2.speed then\n            -- car2 and car are moving towards each other;\
    \ we're only interested\n            -- in the situation where car2 and car are\
    \ moving left to right and\n            -- car2 is in front of car.\n        \
    \    local t = (car2.x - car.x) / (car.speed - car2.speed)\n            if t >=\
    \ 0 then\n               -- at time t, car2 and car would collide\n          \
    \     collisions = collisions + 1\n            end\n         end\n      end\n\
    \   end\n   return collisions\nend", "  -- This is a very easy problem if we draw\
    \ the cars like this:\n  --\n  --      <--\n  --     |  |\n  --     |  |\n  --\
    \     |  |   <--\n  --     |  |  |  |\n  --     |  |  |  |\n  --     |  |  | \
    \ |\n  --     v  v  v  v\n  -- The above cars clearly collide two times.\n  --\n\
    \  -- But now consider this layout:\n  --\n  --      <--\n  --      |  |\n  --\
    \      |  |   <--\n  --      |  |  |  |\n  --      |  |  |  |\n  --      |  |\
    \  |  |\n  --      |  |  |  |\n  --      v  v  v  v\n  --\n  -- This is the same\
    \ layout as above!  Yet now the cars do not collide any more.\n  -- Why?  Because\
    \ the cars are infinitely strong;  as a result, when the two cars\n  -- collide,\
    \ they continue moving without changing speed or direction.\n  --\n  -- Now consider\
    \ this layout:\n  --\n  --  <--     <--\n  -- |  |    |  |\n  -- |  |    |  |\n\
    \  -- |  |    |  |\n  -- |  |    |  |\n  -- |  |    |  |\n  -- |  |    |  |\n\
    \  -- |  |    |  |\n  -- v  v    v  v\n  --\n  -- This is not at all like the\
    \ last layout!  Yet the cars clearly collide two times.\n  -- We could keep going\
    \ like this.  The general idea is that we can get a different\n  -- number of\
    \ car collisions by simply shuffling the cars;  and it can be hard to\n  -- predict\
    \ how many collisions there will be by just looking at the initial layout.\n \
    \ --\n  -- Let's try to solve this problem by code.  The first step is to convert\
    \ the\n  -- problem description into a more natural representation for us humans\
    \ to work with.\n  -- Namely, instead of thinking about cars moving on the x-axis,\
    \ let's think about a\n", "    return n*(n-1)/2;\nend", "   assert(type(n) ==\
    \ \"number\")\n   assert(n >= 0)\n   local count = 0\n   for i = 1, n do\n   \
    \   for j = 1, n do\n         if i == j then\n            count = count + 1\n\
    \         end\n      end\n   end\n   return count\nend", "    local a = {}\n \
    \   local b = {}\n    for i = 1, n do\n        a[i] = math.random(n)\n       \
    \ b[i] = math.random(n)\n    end\n    table.sort(a)\n    table.sort(b)\n    local\
    \ c = 0\n    local i = 1\n    local j = 1\n    while i <= n and j <= n do\n  \
    \      if a[i] < b[j] then\n            i = i + 1\n        elseif a[i] > b[j]\
    \ then\n            j = j + 1\n        else\n            c = c + 1\n         \
    \   i = i + 1\n            j = j + 1\n        end\n    end\n    return c\nend",
  "  local left_to_right = range(1, n)\n  local right_to_left = range(1, n)\n  local\
    \ tbl = {}\n  for _, v in ipairs(left_to_right) do\n    if tbl[v] then\n     \
    \ tbl[v] = tbl[v] + 1\n    else\n      tbl[v] = 1\n    end\n  end\n  for _, v\
    \ in ipairs(right_to_left) do\n    if tbl[v] then\n      tbl[v] = tbl[v] + 1\n\
    \    else\n      tbl[v] = 1\n    end\n  end\n  local count = 0\n  for _, v in\
    \ pairs(tbl) do\n    if v == 2 then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "    return math.floor(n*(n-1)/2)\nend", "   local function\
    \ collide_bfs(left_start, right_start)\n      local queue = {}\n      local visited\
    \ = {}\n      for i = 1, n do\n         queue[#queue+1] = {left_start - i, right_start\
    \ + i}\n      end\n      for i = 1, n do\n         queue[#queue+1] = {left_start\
    \ + i, right_start - i}\n      end\n      local num_collisions = 0\n      local\
    \ ctx = 0\n      while #queue > 0 do\n         local curr = table.remove(queue,\
    \ 1)\n         local id = table.concat(curr, '_')\n         if visited[id] then\n\
    \            -- Already visited.\n            goto continue\n         end\n  \
    \       visited[id] = true\n         if curr[1] == curr[2] then\n            --\
    \ Collision.\n            num_collisions = num_collisions + 1\n         end\n\
    \         if curr[1] <= curr[2] then\n            -- Generate right moves.\n \
    \           for i = 1, n do\n               queue[#queue+1] = {curr[1] + i, curr[2]\
    \ - i}\n            end\n         else\n            -- Generate left moves.\n\
    \            for i = 1, n do\n               queue[#queue+1] = {curr[1] - i, curr[2]\
    \ + i}\n            end\n         end\n         ::continue::\n         ctx = ctx\
    \ + 1\n         if ctx % 1000000 == 0 then\n            print(ctx)\n         end\n\
    \      end\n      return num_collisions\n   end\n   return collide_bfs(1, 1)\n\
    end", "    local n_l2r = n\n    local n_r2l = n\n    local collisions = 0\n  \
    \  while n_l2r > 0 or n_r2l > 0 do\n        if n_l2r > 0 then\n            collisions\
    \ = collisions + n_r2l\n            n_l2r = n_l2r - 1\n        end\n        if\
    \ n_r2l > 0 then\n            collisions = collisions + n_l2r\n            n_r2l\
    \ = n_r2l - 1\n        end\n    end\n    return collisions\nend", "  local r =\
    \ math.random\n  -- create a table of n random integers representing the cars'\
    \ indices.\n  local cars = {}\n  for i = 1, n do\n    table.insert(cars, r(1,\
    \ n))\n  end\n  -- print(table.concat(cars, \", \"))", "    local function aux(n,left_going,right_going)\n\
    \        local ret\n        if n == 0 then\n            ret = 0\n        else\n\
    \            local head_left,head_right = left_going[1],right_going[1]\n     \
    \       if head_left < head_right then\n                ret = aux(n-1,left_going[2],right_going)\n\
    \            else\n                ret = 1 + aux(n-1,left_going[2],right_going[2])\n\
    \            end\n        end\n        return ret\n    end\n    local left_going\
    \ = {-n,-n+1,-n+2,-n+3,-n+4,-n+5,-n+6,-n+7,-n+8,-n+9}\n    local right_going =\
    \ {n,n-1,n-2,n-3,n-4,n-5,n-6,n-7,n-8,n-9}\n    local ret = aux(n,left_going,right_going)\n\
    \    return ret\nend", "    -- A car moving left to right is represented by an\
    \ integer that's a\n    -- negative number between -(n-1) and -1.  A car moving\
    \ right to left\n    -- is represented by an integer that's a positive number\
    \ between 1 and (n-1).\n    -- We create the two sets of cars and put them in\
    \ a list with the cars\n    -- ordered by the position of the cars on the road.\
    \  To create a list of\n    -- n cars, we create a list of n numbers, each between\
    \ 1 and n, and\n    -- we permute the list of numbers.\n    -- We now have two\
    \ sets of ordered lists of cars.  We take each set of\n    -- ordered lists of\
    \ cars and we convert it to a set of ordered lists of\n    -- cars with the cars\
    \ ordered by their position on the road.\n    -- An ordered list of cars ordered\
    \ by the position of the cars on the road\n    -- is an ordered tree of cars,\
    \ where each car is placed into the tree based\n    -- on the position of the\
    \ car on the road.\n    -- We then combine the two ordered trees of cars to form\
    \ a single ordered\n    -- tree.  The number of collisions is the number of collisions\
    \ in the\n    -- ordered tree.\n    -- We start by generating a list of n numbers,\
    \ each between 1 and n.\n    local numbers = random_permutation(n)\n    -- We\
    \ make two lists of the numbers, one for the cars moving left to right,\n    --\
    \ and one for the cars moving right to left.\n    local numbers_left = {}\n  \
    \  local numbers_right = {}\n    for i = 1, n do\n        numbers_left[i] = -numbers[i]\n\
    \        numbers_right[i] = numbers[i]\n    end\n    -- We create two ordered\
    \ trees of cars, one for the cars moving left to right,\n    -- and one for the\
    \ cars moving right to left.\n    local ordered_tree_left = ordered_tree.create(numbers_left)\n\
    \    local ordered_tree_right = ordered_tree.create(numbers_right)\n    -- We\
    \ create an ordered tree of cars with cars moving left to right and\n    -- cars\
    \ moving right to left.\n    local ordered_tree = ordered_tree.merge(ordered_tree_",
  "  if n == 0 then\n    return 0\n  else\n    local left_result = car_race_collision(n-1)\n\
    \    local right_result = car_race_collision(n-1)\n    return left_result + right_result\
    \ + 1\n  end\nend", "    assert(n == math.floor(n) and n >= 0)\n    local n =\
    \ n -- n cars on the road\n    if n < 2 then\n        return 0\n    end\n    local\
    \ left = {} -- table of car speeds from left to right\n    local right = {} --\
    \ table of car speeds from right to left\n    local collisions = 0 -- number of\
    \ collisions\n    -- fill left and right tables with random speeds\n    for i\
    \ = 1, n do\n        left[i] = math.random(0, n - 1)\n        right[i] = math.random(0,\
    \ n - 1)\n    end\n    -- counting sort\n    -- the cars are sorted by their speeds\
    \ so we'll know in advance\n    -- how many collisions there would be in each\
    \ pair\n    -- local bucket is the speed => number of cars with this speed\n \
    \   local bucket = {}\n    for i = 0, n - 1 do\n        bucket[i] = 0\n    end\n\
    \    for i = 1, n do\n        bucket[left[i]] = bucket[left[i]] + 1\n    end\n\
    \    local j = 1\n    for i = 0, n - 1 do\n        while bucket[i] > 0 do\n  \
    \          left[j] = i\n            j = j + 1\n            bucket[i] = bucket[i]\
    \ - 1\n        end\n    end\n    for i = 0, n - 1 do\n        bucket[i] = 0\n\
    \    end\n    for i = 1, n do\n        bucket[right[i]] = bucket[right[i]] + 1\n\
    \    end\n    local j = 1\n    for i = 0, n - 1 do\n        while bucket[i] >\
    \ 0 do\n            right[j] = i\n            j = j + 1\n            bucket[i]\
    \ = bucket[i] - 1\n        end\n    end\n    -- count collisions\n    -- local\
    \ i and j are the indices in left and right tables respectively\n    local i =\
    \ 1\n    local j = 1\n    while i <= n and j <= n do\n        if left[i] < right[j]\
    \ then\n            collisions = collisions + n - j + 1\n            i = i + 1\n\
    \        else\n            j = j + 1\n        end\n    end\n    return", "  local\
    \ t = os.clock()\n  local function helper(n, cur, prev)\n    if n == 0 then\n\
    \      return cur\n    else\n      return helper(n - 1, cur + n + prev, cur)\n\
    \    end\n  end\n  local ans = helper(n, 0, 0)\n  print(string.format(\"time to\
    \ run car_race_collision(%d) = %.2f\", n, os.clock() - t))\n  return ans\nend",
  "  local num_collisions = 0\n  local left_to_right_car_starts = {}\n  local right_to_left_car_starts\
    \ = {}\n  for i = 1, n do\n    left_to_right_car_starts[i] = 10 ^ 10 + i\n   \
    \ right_to_left_car_starts[i] = 10 ^ 10 - i\n  end\n  for i = 1, n do\n    for\
    \ j = 1, n do\n      if left_to_right_car_starts[i] >= right_to_left_car_starts[j]\
    \ then\n        num_collisions = num_collisions + 1\n      end\n    end\n  end\n\
    \  return num_collisions\nend", "    return n*(n-1)/2\nend", "    local collisions\
    \ = 0\n    local a = {} -- A location of a car\n    local b = {} -- A location\
    \ of a car\n    for i = 1, n do\n        a[i] = 0\n        b[i] = 100000000\n\
    \    end\n    while true do\n        -- Move all cars\n        for i = 1, n do\n\
    \            a[i] = a[i] + 1\n            b[i] = b[i] - 1\n        end\n     \
    \   -- Check for collisions\n        for i = 1, n do\n            for j = 1, n\
    \ do\n                if (a[i] == b[j]) then\n                    collisions =\
    \ collisions + 1\n                end\n            end\n        end\n        --\
    \ Check for stopping condition\n        if (a[n] > b[n]) then\n            break\n\
    \        end\n    end\n    return collisions\nend", '    local collisions = 0',
  "  return math.floor(n * (n - 1) / 2)\nend", "  local c = 0\n  for i = 1, n do\n\
    \    for j = 1, n do\n      c = c + 1\n    end\n  end\n  return c\nend", "  if\
    \ n == 0 then\n    return 0\n  else\n    return n - 1 + car_race_collision(n -\
    \ 1)\n  end\nend", "  local n = n or 0\n  local collisions = 0\n  local h = math.floor(n/2)\n\
    \  for i = 1, h do\n    collisions = collisions + i\n  end\n  return collisions\n\
    end", "   local cars_going_left = {}\n   local cars_going_right = {}\n   for i\
    \ = 1, n do\n      table.insert(cars_going_left, {0})\n      table.insert(cars_going_right,\
    \ {0})\n   end\n   local counter = 0\n   while #cars_going_left ~= 0 and #cars_going_right\
    \ ~= 0 do\n      if cars_going_left[1][1] == cars_going_right[1][1] then\n   \
    \      counter = counter + 1\n         table.remove(cars_going_left, 1)\n    \
    \     table.remove(cars_going_right, 1)\n      elseif cars_going_left[1][1] <\
    \ cars_going_right[1][1] then\n         table.remove(cars_going_left, 1)\n   \
    \   else\n         table.remove(cars_going_right, 1)\n      end\n   end\n   return\
    \ counter\nend", "  local count = 0\n  local left_cars = {}\n  local right_cars\
    \ = {}\n  for _=1,n do\n    table.insert(left_cars, _*(2*math.random()-1))\n \
    \   table.insert(right_cars, _*(2*math.random()-1))\n  end\n  for _,left_x in\
    \ ipairs(left_cars) do\n    for _,right_x in ipairs(right_cars) do\n      if left_x\
    \ < right_x then\n        count = count + 1\n      end\n    end\n  end\n  return\
    \ count\nend", "   if n == 0 then\n      return 0\n   else\n      return n-1 +\
    \ car_race_collision(n-1)\n   end\nend", "    -- This function determines whether\
    \ the two given points are in the same\n    -- horizontal line.\n    local function\
    \ same_line(x1,y1,x2,y2)\n        return y1 == y2\n    end", "  return 0\nend",
  "  -- return the number of collisions, given the number of cars.\n  -- note: two\
    \ cars can collide at the same time.\n  -- hint: run the program multiple times\
    \ to observe the number of collisions.\n  -- (write a loop to run the program\
    \ many times; count the number of collisions for each run,\n  -- and then you\
    \ get the average number of collisions).\n  -- hint: the number of collisions\
    \ is expected to be less than the average number of collisions.\n  return math.ceil(n^2/4)\n\
    end", "  return math.floor(n * (n - 1) / 2)\nend", "  return n * (n - 1) / 2\n\
    end", "    local collisions = 0\n    for i = 1, n do\n        collisions = collisions\
    \ + i - 1\n    end\n    return collisions\nend", "  local collsion_counter = 0\n\
    \  local l2r_cars = {}\n  local r2l_cars = {}\n  for i = 1, n do\n    l2r_cars[i]\
    \ = 0\n    r2l_cars[i] = n\n  end\n  while l2r_cars[1] < n do\n    -- every time\
    \ a car moves one unit, we compare the positions of\n    --  left-to-right cars\
    \ to right-to-left cars.\n    for i = 1, n do\n      if l2r_cars[i] == r2l_cars[i]\
    \ then\n        collsion_counter = collsion_counter + 1\n      end\n      l2r_cars[i]\
    \ = l2r_cars[i] + 1\n      r2l_cars[i] = r2l_cars[i] - 1\n    end\n  end\n  return\
    \ collsion_counter\nend", "   local n1 = math.random(n)\n   local n2 = math.random(n)\n\
    \   return n1 * n2\nend", "    local n = tonumber(n)\n    local n_half = math.floor(n/2)\n\
    \    local sum = 0\n    for i = 1, n_half do\n        sum = sum + i\n    end\n\
    \    return sum\nend", "  return n*(n-1)/2\nend", "  -- YOUR CODE GOES HERE\n\
    \   return 0\nend", "  local lr_cars = {}  -- cars that move left to right\n \
    \ local rl_cars = {}  -- cars that move right to left\n  for i = 1, n do\n   \
    \ lr_cars[i] = i - 1\n    rl_cars[i] = -(i - 1)\n  end\n  local collisions = 0\n\
    \  for i = 1, n do\n    for j = 1, n do\n      if lr_cars[i] >= rl_cars[j] then\n\
    \        collisions = collisions + 1\n      end\n    end\n  end\n  return collisions\n\
    end", "    if n % 2 == 0 then\n        -- For even number of cars, the number\
    \ of collisions is always equal to\n        -- the number of cars.\n        return\
    \ n\n    else\n        -- For odd number of cars, the number of collisions is\
    \ always equal to\n        -- number of cars - 1.\n        return n - 1\n    end\n\
    end", "  local a, b = {}, {}\n  for i = 1, n do\n    a[i] = math.random()\n  \
    \  b[i] = math.random()\n  end\n  table.sort(a)\n  table.sort(b)\n  local i, j\
    \ = 1, 1\n  local collision = 0\n  while i <= n and j <= n do\n    if a[i] <=\
    \ b[j] then\n      collision = collision + j - 1\n      i = i + 1\n    else\n\
    \      j = j + 1\n    end\n  end\n  return collision\nend", "    -- Write your\
    \ code here.\n    return 0\nend", "  -- BEGIN student's code.\n  local coll_count\
    \ = 0\n  for i = 1,n do\n    for j = n+1, 2*n do\n      if i == j - n then\n \
    \       coll_count = coll_count + 1\n      end\n    end\n  end\n  return coll_count\n\
    \  -- END student's code.\nend", "  -- length of road\n  local road = {0, 100000000000}\n\
    \  -- create two arrays of cars\n  local right_to_left_car = {}\n  local left_to_right_car\
    \ = {}\n  -- now generate the position of cars\n  for i = 1, n do\n    right_to_left_car[i]\
    \ = math.random(road[1], road[2])\n    left_to_right_car[i] = math.random(road[1],\
    \ road[2])\n  end\n  -- now put the cars on their trajectory\n  for i = 1, n do\n\
    \    for j = 1, n do\n      if right_to_left_car[i] > left_to_right_car[j] then\n\
    \        print(string.format(\"Car %d hit by car %d\", i, j))\n      end\n   \
    \ end\n  end\nend", "\treturn (n * (n - 1)) / 2\nend", "\treturn n*(n-1)/2\nend",
  "\tlocal t = {}\n\tfor i = 1,n do\n\t\tt[i] = true\n\tend\n\tlocal counter = 0\n\
    \tfor i = 1,n do\n\t\tif t[i] then\n\t\t\tt[i] = false\n\t\t\tcounter = counter\
    \ + 1\n\t\t\tfor j = i+1,n do\n\t\t\t\tif t[j] then\n\t\t\t\t\tt[j] = false\n\t\
    \t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn counter\nend",
  "    -- total number of cars = 2n, 1/2 of them moving right to left and 1/2 left\
    \ to right\n    local total_cars = 2 * n\n    -- the index of the last car that\
    \ is moving right to left\n    local right_to_left_index = n\n    -- initialize\
    \ a table to store the indices of the cars that are moving right to left\n   \
    \ local right_to_left_indices = {}\n    for i = 1, right_to_left_index do\n  \
    \      table.insert(right_to_left_indices, i)\n    end\n    -- the number of collisions\
    \ so far\n    local collisions = 0\n    -- the index of the last car that is moving\
    \ left to right\n    local left_to_right_index = total_cars\n    -- repeat until\
    \ all cars have been processed\n    while left_to_right_index > 0 do\n       \
    \ -- if the last car that is moving left to right collides with a car that is\
    \ moving right to left\n        if left_to_right_index <= right_to_left_index\
    \ then\n            -- the number of collisions increases by the number of cars\
    \ that are moving right to left\n            collisions = collisions + right_to_left_index\n\
    \            -- there are no more cars that are moving right to left\n       \
    \     right_to_left_index = 0\n        else\n            -- remove the index of\
    \ the last car that is moving right to left\n            table.remove(right_to_left_indices)\n\
    \            -- the new index of the last car that is moving right to left is\
    \ the previous index minus 1\n            right_to_left_index = right_to_left_index\
    \ - 1\n        end\n        -- the new index of the last car that is moving left\
    \ to right is the previous index minus 1\n        left_to_right_index = left_to_right_index\
    \ - 1\n    end\n    -- return the number of collisions\n    return collisions\n\
    end", "    local left_cars_position = {}\n    local right_cars_position = {}\n\
    \    for i = 1, n do\n        left_cars_position[i] = n + i\n        right_cars_position[i]\
    \ = n - i\n    end\n    local collisions = 0\n    while true do\n        local\
    \ left_car_hit = nil\n        local right_car_hit = nil\n        for i = 1, n\
    \ do\n            local position = left_cars_position[i]\n            if position\
    \ <= 0 then\n                left_car_hit = i\n                break\n       \
    \     end\n            left_cars_position[i] = position - 1\n        end\n   \
    \     for i = 1, n do\n            local position = right_cars_position[i]\n \
    \           if position >= 0 then\n                right_car_hit = i\n       \
    \         break\n            end\n            right_cars_position[i] = position\
    \ + 1\n        end\n        if left_car_hit and right_car_hit then\n         \
    \   collisions = collisions + 1\n            left_cars_position[left_car_hit]\
    \ = nil\n            right_cars_position[right_car_hit] = nil\n        else\n\
    \            break\n        end\n    end\n    return collisions\nend", "  local\
    \ car = {}\n  for i = 1, n do\n    car[i] = { position = 0, direction = 1 }\n\
    \  end\n  local collision = 0\n  while true do\n    local any_move = false\n \
    \   for i = 1, n do\n      local c = car[i]\n      c.position = c.position + c.direction\n\
    \      if c.position == 0 then\n        collision = collision + 1\n      end\n\
    \      any_move = any_move or c.position == 0\n    end\n    if not any_move then\n\
    \      break\n    end\n  end\n  return collision\nend", "\tlocal cars = {}\n\t\
    for i = 1, n do\n\t\tcars[i] = {\n\t\t\tpos = 1,\n\t\t\tdir = 1\n\t\t}\n\tend\n\
    \tfor i = n + 1, 2 * n do\n\t\tcars[i] = {\n\t\t\tpos = math.huge,\n\t\t\tdir\
    \ = -1\n\t\t}\n\tend\n\tlocal cnt = 0\n\tfor time = 1, n do\n\t\tfor i = 1, n\
    \ do\n\t\t\tlocal c1 = cars[i]\n\t\t\tfor j = n + 1, 2 * n do\n\t\t\t\tlocal c2\
    \ = cars[j]\n\t\t\t\tif c1.pos == c2.pos then\n\t\t\t\t\tcnt = cnt + 1\n\t\t\t\
    \tend\n\t\t\tend\n\t\tend\n\t\tfor i = 1, 2 * n do\n\t\t\tcars[i].pos = cars[i].pos\
    \ + cars[i].dir\n\t\tend\n\tend\n\treturn cnt\nend", "  -- Solution will be this.\n\
    \  local ans = 0\n  -- List of all cars driving left to right.\n  local ll = {}\n\
    \  -- List of all cars driving right to left.\n  local rl = {}\n  -- A colliding\
    \ pair of cars.\n  local pair = {}\n  -- Initialize the list of cars driving left\
    \ to right.\n  for i = 1, n do\n    ll[i] = {}\n    ll[i].start = i\n    ll[i].end\
    \ = i + n\n  end\n  -- Initialize the list of cars driving right to left.\n  for\
    \ i = 1, n do\n    rl[i] = {}\n    rl[i].start = i + n\n    rl[i].end = i\n  end\n\
    \  -- Iterate through all cars driving left to right.\n  for i = 1, n do\n   \
    \ -- Iterate through all cars driving right to left.\n    for j = 1, n do\n  \
    \    -- Is car[i] colliding with car[j]?\n      if ((rl[j].start >= ll[i].start)\
    \ and (rl[j].start <= ll[i].end)) or\n         ((rl[j].end >= ll[i].start) and\
    \ (rl[j].end <= ll[i].end)) then\n        -- Yes.\n        ans = ans + 1\n   \
    \     pair[#pair + 1] = {i, j}\n      end\n    end\n  end\n  -- Print out all\
    \ pairs.\n  for i = 1, #pair do\n    print(\"Car \" .. pair[i][1] .. \" collides\
    \ with car \" .. pair[i][2])\n  end\n  -- Print out the number of collisions.\n\
    \  print(\"Total number of collisions is \" .. ans)\n  -- Return number of collisions.\n\
    \  return ans\nend", "  local coll = 0\n  -- TODO: fill in the body of this function\n\
    \  return coll\nend", "  local function car_race_collision(n)\n    local i,j,k,m,p,q,r,t,u,v\n\
    \    local a,b,c,d,e,f,g,h\n    k = 0\n    if n < 2 then\n      return k\n   \
    \ end\n    a = { }\n    b = { }\n    for i = 1,n do\n      r = nrand()\n     \
    \ a[i] = r\n      b[i] = 1 - r\n    end\n    table.sort(a)\n    table.sort(b)\n\
    \    c = { }\n    d = { }\n    for i = 1,n do\n      c[i] = a[i]\n      d[i] =\
    \ b[i]\n    end\n    e = 0\n    for i = 1,n do\n      e = e + 1\n      f = c[e]\n\
    \      g = d[e]\n      while g <= f do\n        k = k + 1\n        e = e + 1\n\
    \        g = d[e]\n      end\n    end\n    return k\n  end\n  local function car_race_collision(n)\n\
    \    local i,j,k,m,p,q,r,t,u,v\n    local a,b,c,d,e,f,g,h\n    k = 0\n    if n\
    \ < 2 then\n      return k\n    end\n    a = { }\n    b = { }\n    for i = 1,n\
    \ do\n      r = nrand()\n      a[i] = r\n      b[i] = 1 - r\n    end\n    table.sort(a)\n\
    \    table.sort(b)\n    for i = 1,n do\n      for j = 1,n do\n        if a[i]\
    \ < b[j] then\n          break\n        end\n        k = k + 1\n      end\n  \
    \  end\n    return k\n  end\n  local function car_race_collision(n)\n    local\
    \ i,j,k,m,p,q,r,t,u,v\n    local a,b,c,d,e,f,g,h\n    k", "    assert(n % 2 ==\
    \ 0)\n    return n * n\nend", "\t-- TODO\nend", "    return n * (n - 1) / 2\n\
    end", "    return n*(n-1)/2\nend", "  local right_cars, left_cars = {}, {}\n \
    \ for i = 1, n do\n    left_cars[i] = { x = i, speed = 0 }\n    right_cars[i]\
    \ = { x = i, speed = 0 }\n  end\n  local right_car_x = 0\n  local left_car_x =\
    \ 0\n  local num_collisions = 0\n  while right_car_x <= n and left_car_x <= n\
    \ do\n    right_car_x = right_car_x + 1\n    left_car_x = left_car_x + 1\n   \
    \ if left_car_x == right_car_x then\n      num_collisions = num_collisions + 1\n\
    \    end\n  end\n  return num_collisions\nend", "    local left_cars = {}\n  \
    \  local right_cars = {}\n    local num_collisions = 0\n    for i = 1, n do\n\
    \        table.insert(left_cars, math.random(1, 500))\n        table.insert(right_cars,\
    \ math.random(1, 500))\n    end\n    table.sort(left_cars)\n    table.sort(right_cars)\n\
    \    local i = 1\n    local j = 1\n    while i <= n and j <= n do\n        if\
    \ left_cars[i] == right_cars[j] then\n            num_collisions = num_collisions\
    \ + 1\n            i = i + 1\n            j = j + 1\n        elseif left_cars[i]\
    \ < right_cars[j] then\n            i = i + 1\n        else\n            j = j\
    \ + 1\n        end\n    end\n    return num_collisions\nend", "  -- in the array\
    \ car_state[1..n], car_state[i]==true means that the car moving\n  -- left to\
    \ right is at the position i-1; and car_state[i]==false means that the\n  -- car\
    \ moving right to left is at the position i-1.\n  local car_state = {}\n  local\
    \ num_collisions = 0\n  for i = 1, n do\n    -- if it is a car moving left to\
    \ right, then its position is i-1.\n    if i%2 == 1 then\n      car_state[i] =\
    \ true\n    else\n      car_state[i] = false\n    end\n  end\n  local pos = 0\n\
    \  for _ = 1, n do\n    if car_state[pos + 1] then\n      -- a car moving left\
    \ to right is at position pos\n      pos = pos + 1\n    else\n      -- a car moving\
    \ right to left is at position pos\n      if pos > 0 then\n        num_collisions\
    \ = num_collisions + 1\n      end\n      pos = pos - 1\n    end\n  end\n  return\
    \ num_collisions\nend", "    local num_collisions = 0\n    local cars_left, cars_right\n\
    \    cars_left, cars_right = {}, {}\n    for i = 1, n do\n        cars_left[i]\
    \ = i\n        cars_right[i] = n + 1 - i\n    end\n    while true do\n       \
    \ -- We have n cars moving left to right and n cars moving right to left.\n  \
    \      -- We output a collision if we have a car moving left to right at position\n\
    \        -- i and a car moving right to left at position i.  This is the same\
    \ as\n        -- if we have a car moving left to right at position j and a car\
    \ moving\n        -- right to left at position n + 1 - j.\n        -- So we take\
    \ the two sorted sets of cars, and take the index of the\n        -- smallest\
    \ number in each set, and check if they add up to n + 1.\n        local left_index,\
    \ right_index = 1, 1\n        while cars_left[left_index] == nil do\n        \
    \    left_index = left_index + 1\n        end\n        while cars_right[right_index]\
    \ == nil do\n            right_index = right_index + 1\n        end\n        if\
    \ left_index + right_index == n + 1 then\n            -- We have a collision.\n\
    \            num_collisions = num_collisions + 1\n            cars_left[left_index]\
    \ = nil\n            cars_right[right_index] = nil\n        elseif left_index\
    \ + right_index < n + 1 then\n            -- The left car has not gone as far\
    \ as the right car.\n            -- So we increment the left car.\n          \
    \  cars_left[left_index] = cars_left[left_index] + 1\n        elseif left_index\
    \ + right_index > n + 1 then\n            -- The right car has not gone as far\
    \ as the left car.\n            -- So we increment the right car.\n          \
    \  cars_right[right_index] = cars_right[right_index] - 1\n        end\n      \
    \  if cars_left[left_index] == nil and cars_right[right_index] == nil then\n \
    \           break\n        end\n    end\n    return num_collisions\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
