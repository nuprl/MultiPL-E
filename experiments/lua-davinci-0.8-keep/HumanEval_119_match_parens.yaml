name: HumanEval_119_match_parens
language: lua
prompt: "-- You are given a list of two strings, both strings consist of open\n--\
  \ parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it\
  \ is possible to concatenate the two strings in\n-- some order, that the resulting\
  \ string will be good.\n-- A string S is considered to be good if and only if all\
  \ parentheses in S\n-- are balanced. For example: the string '(())()' is good, while\
  \ the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(', ')'])\
  \ == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
  \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
  \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n  \
  \  lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
  \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n  \
  \  lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
  \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n   \
  \ lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
  \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local count = 0\n  for _, s in ipairs(lst) do\n    for i = 1, #s\
    \ do\n      if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n\
    \        count = count - 1\n      end\n      if count < 0 then\n        return\
    \ 'No'\n      end\n    end\n  end\n  return 'Yes'\nend", "  local cnt = 0\n  for\
    \ _, s in ipairs(lst) do\n    cnt = cnt + count_parens(s)\n  end\n  return cnt\
    \ == 0 and 'Yes' or 'No'\nend", "  local s = table.concat(lst)\n  local count\
    \ = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '(' then\n      count = count\
    \ + 1\n    else\n      count = count - 1\n    end\n    if count < 0 then\n   \
    \   return 'No'\n    end\n  end\n  return count == 0 and 'Yes' or 'No'\nend",
  "  local s1, s2 = table.unpack(lst)\n  local ok = false\n  local function helper(s1,\
    \ s2)\n    if s1 == '' and s2 == '' then\n      ok = true\n      return\n    end\n\
    \    if s1 == '' and s2 ~= '' then\n      return\n    end\n    if s1 ~= '' and\
    \ s2 == '' then\n      local t = {}\n      for c in s1:gmatch('.') do\n      \
    \  table.insert(t, c)\n      end\n      local l, r = 0, 0\n      for _, v in ipairs(t)\
    \ do\n        if v == '(' then\n          l = l + 1\n        else\n          r\
    \ = r + 1\n        end\n        if r > l then\n          return\n        end\n\
    \      end\n      if l == r then\n        ok = true\n        return\n      end\n\
    \    end\n    helper(s1, s2:sub(2))\n    helper(s1:sub(2), s2)\n  end\n  helper(s1,\
    \ s2)\n  return ok and 'Yes' or 'No'\nend", "    local function recur(cnt, str)\n\
    \        if #str == 0 then\n            return cnt == 0\n        end\n       \
    \ if cnt < 0 then\n            return false\n        end\n        if str:sub(1,\
    \ 1) == '(' then\n            return recur(cnt + 1, str:sub(2))\n        else\n\
    \            return recur(cnt - 1, str:sub(2))\n        end\n    end\n    if recur(0,\
    \ lst[1] .. lst[2]) then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "  local stack = {}\n  local wrong = 0\n  for i = 1, #lst do\n\
    \    for c in lst[i]:gmatch\".\" do\n      if c == '(' then\n        table.insert(stack,\
    \ c)\n      else\n        if #stack == 0 then\n          wrong = 1\n        else\n\
    \          table.remove(stack)\n        end\n      end\n    end\n  end\n  return\
    \ (wrong == 0 and #stack == 0) and 'Yes' or 'No'\nend", "  local count = 0\n \
    \ for _, s in ipairs(lst) do\n    for _, c in ipairs(s:gmatch('.')) do\n     \
    \ if c == '(' then\n        count = count + 1\n      else\n        count = count\
    \ - 1\n      end\n      if count < 0 then\n        return 'No'\n      end\n  \
    \  end\n  end\n  return count == 0 and 'Yes' or 'No'\nend", "  local s1, s2 =\
    \ lst[1], lst[2]\n  if #s1 == 0 and #s2 == 0 then\n    return 'Yes'\n  end\n \
    \ if #s1 == 0 then\n    local unclosed_count = 0\n    for i = 1, #s2 do\n    \
    \  if s2:sub(i, i) == ')' then\n        unclosed_count = unclosed_count - 1\n\
    \      else\n        unclosed_count = unclosed_count + 1\n      end\n      if\
    \ unclosed_count < 0 then\n        return 'No'\n      end\n    end\n    return\
    \ 'Yes'\n  end\n  if #s2 == 0 then\n    local unclosed_count = 0\n    for i =\
    \ 1, #s1 do\n      if s1:sub(i, i) == ')' then\n        unclosed_count = unclosed_count\
    \ - 1\n      else\n        unclosed_count = unclosed_count + 1\n      end\n  \
    \    if unclosed_count < 0 then\n        return 'No'\n      end\n    end\n   \
    \ return 'Yes'\n  end\n  local s_concat = s1 .. s2\n  local unclosed_count = 0\n\
    \  for i = 1, #s_concat do\n    if s_concat:sub(i, i) == ')' then\n      unclosed_count\
    \ = unclosed_count - 1\n    else\n      unclosed_count = unclosed_count + 1\n\
    \    end\n    if unclosed_count < 0 then\n      return 'No'\n    end\n  end\n\
    \  return 'Yes'\nend", "\tlocal open, close = 0, 0\n\tfor _, s in ipairs(lst)\
    \ do\n\t\tlocal inc = 0\n\t\tfor i = 1, #s do\n\t\t\tif s:sub(i, i) == '(' then\n\
    \t\t\t\tinc = inc + 1\n\t\t\telse\n\t\t\t\tinc = inc - 1\n\t\t\tend\n\t\tend\n\
    \t\tif inc > 0 then\n\t\t\topen = open + inc\n\t\telse\n\t\t\tclose = close -\
    \ inc\n\t\tend\n\tend\n\treturn open >= close and 'Yes' or 'No'\nend", "    if\
    \ #lst ~= 2 then\n        return nil\n    end\n    local brackets = {'(', ')'}\n\
    \    local balance = 0\n    for _, item in ipairs(lst) do\n        for _, bracket\
    \ in ipairs(brackets) do\n            if bracket == '(' then\n               \
    \ balance = balance + 1\n            else\n                balance = balance -\
    \ 1\n            end\n            if balance < 0 then\n                return\
    \ 'No'\n            end\n        end\n    end\n    if balance == 0 then\n    \
    \    return 'Yes'\n    else\n        return 'No'\n    end\nend", "  local left,\
    \ right = 0, 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i) == '(' then\n\
    \      left = left + 1\n    else\n      right = right + 1\n    end\n  end\n  for\
    \ i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n      left = left +\
    \ 1\n    else\n      right = right + 1\n    end\n  end\n  if left == right then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  local S = lst[1] ..\
    \ lst[2]\n  local cnt = 0\n  for i = 1, #S do\n    if S:sub(i, i) == '(' then\n\
    \      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n\
    \      return 'No'\n    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\nend",
  "    local open, close = lst[1], lst[2]\n    local balance = #open - #close\n  \
    \  if balance < 0 then\n        return 'No'\n    end\n    if balance == 0 then\n\
    \        return 'Yes'\n    end\n    if open[1] == '(' then\n        return match_parens({open:sub(2),\
    \ close})\n    end\n    if close[#close] == ')' then\n        return match_parens({open,\
    \ close:sub(1, #close - 1)})\n    end\n    return 'No'\nend", "    local function\
    \ aux(l, r)\n        if l == 0 and r == 0 then\n            return true\n    \
    \    elseif l == 0 and r > 0 then\n            return false\n        elseif l\
    \ > 0 and r == 0 then\n            return aux(l - 1, r + 1)\n        else\n  \
    \          return aux(l - 1, r + 1) or aux(l, r - 1)\n        end\n    end\n \
    \   local l, r = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i)\
    \ == '(' then\n            l = l + 1\n        else\n            r = r + 1\n  \
    \      end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) ==\
    \ '(' then\n            l = l + 1\n        else\n            r = r + 1\n     \
    \   end\n    end\n    return aux(l, r) and 'Yes' or 'No'\nend", "    local l,\
    \ r = lst[1], lst[2]\n    local x = 0\n    for i = 1, #l do\n        if l:sub(i,\
    \ i) == '(' then\n            x = x + 1\n        else\n            x = x - 1\n\
    \        end\n    end\n    for i = 1, #r do\n        if r:sub(i, i) == '(' then\n\
    \            x = x + 1\n        else\n            x = x - 1\n        end\n   \
    \ end\n    return x == 0 and 'Yes' or 'No'\nend", "\tlocal closing = 0\n\tlocal\
    \ opening = 0\n\tfor i, x in ipairs(lst) do\n\t\tfor _, c in utf8.codes(x) do\n\
    \t\t\tif c == 40 then\n\t\t\t\topening = opening + 1\n\t\t\telseif c == 41 then\n\
    \t\t\t\tclosing = closing + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn opening ==\
    \ closing and 'Yes' or 'No'\nend", "    local function count_open(s)\n       \
    \ return s:gsub('%(', ''):len()\n    end\n    local function count_close(s)\n\
    \        return s:gsub('%)', ''):len()\n    end\n    if lst[1] == '' and lst[2]\
    \ == '' then\n        return 'Yes'\n    elseif count_open(lst[1]) > count_close(lst[2])\
    \ then\n        return 'No'\n    elseif count_open(lst[2]) > count_close(lst[1])\
    \ then\n        return 'No'\n    else\n        return 'Yes'\n    end\nend", " \
    \   local topen, tclose = 0, 0\n    for _, s in ipairs(lst) do\n        topen,\
    \ tclose = topen + s:gsub('%(', ''), tclose + s:gsub('%)', '')\n    end\n    return\
    \ topen == tclose and 'Yes' or 'No'\nend", "    local function is_good(s)\n  \
    \      local cnt = 0\n        for i = 1, #s do\n            local ch = s:sub(i,\
    \ i)\n            if ch == '(' then\n                cnt = cnt + 1\n         \
    \   else\n                cnt = cnt - 1\n                if cnt < 0 then\n   \
    \                 return false\n                end\n            end\n       \
    \ end\n        return cnt == 0\n    end\n    local s1, s2 = table.unpack(lst)\n\
    \    return (is_good(s1 .. s2) or is_good(s2 .. s1)) and 'Yes' or 'No'\nend",
  "    -- your code goes here\nend", "    local open, close = 0, 0\n    for _, s in\
    \ ipairs(lst) do\n        for c in s:gmatch('%(') do open = open + 1 end\n   \
    \     for c in s:gmatch('%)') do close = close + 1 end\n    end\n    return open\
    \ == close and 'Yes' or 'No'\nend", "  local left_parens = 0\n  local right_parens\
    \ = 0\n  for i = 1, #lst do\n    for j = 1, #lst[i] do\n      if lst[i]:sub(j,\
    \ j) == '(' then\n        left_parens = left_parens + 1\n      else\n        right_parens\
    \ = right_parens + 1\n      end\n    end\n  end\n  return left_parens == right_parens\
    \ and 'Yes' or 'No'\nend", "  local s = table.concat(lst)\n  local function check_balance(s)\n\
    \    local bal = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n \
    \       bal = bal + 1\n      else\n        bal = bal - 1\n      end\n      if\
    \ bal < 0 then\n        return false\n      end\n    end\n    return bal == 0\n\
    \  end\n  return (check_balance(s) and 'Yes') or 'No'\nend", "  local str1, str2\
    \ = lst[1], lst[2]\n  local func = function(str)\n    local bal = 0\n    for i\
    \ = 1, #str do\n      local ch = str:sub(i, i)\n      if ch == '(' then\n    \
    \    bal = bal + 1\n      else\n        bal = bal - 1\n      end\n      if bal\
    \ < 0 then\n        return false\n      end\n    end\n    return bal == 0\n  end\n\
    \  return func(str1) and func(str2) and 'Yes' or 'No'\nend", "    for i, _ in\
    \ ipairs(lst) do\n        if string.match(lst[i], '%(%(%))') then\n          \
    \  return 'Yes'\n        end\n    end\n    return 'No'\nend", "  local count =\
    \ 0\n  for _, v in ipairs(lst) do\n    for ch in v:gmatch('%(') do\n      count\
    \ = count + 1\n    end\n    for ch in v:gmatch('%)') do\n      count = count -\
    \ 1\n    end\n    if count < 0 then\n      return 'No'\n    end\n  end\n  return\
    \ count == 0 and 'Yes' or 'No'\nend", "  local function count_open(s)\n    return\
    \ #s:gsub('%(', '')\n  end\n  local function count_close(s)\n    return #s:gsub('%)',\
    \ '')\n  end\n  local function is_good(s)\n    local c = count_open(s) - count_close(s)\n\
    \    if c < 0 then return false end\n    if c == 0 then return true end\n    return\
    \ is_good(s:sub(c + 1))\n  end\n  return (count_open(lst[1]) - count_close(lst[1])\
    \ ==\n    count_open(lst[2]) - count_close(lst[2])) and\n    is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend", "  local seq = ''\n  local dict = {\n    ['(']\
    \ = ')',\n    [')'] = '('\n  }\n  for i = 1, #lst do\n    seq = seq .. lst[i]\n\
    \  end\n  while #seq > 0 do\n    local seq0 = seq\n    seq = seq:gsub('%(%)',\
    \ '')\n    if seq == seq0 then\n      return 'No'\n    end\n  end\n  return 'Yes'\n\
    end", "    local left = 0\n    local right = 0\n    for i = 1, #lst[1] do\n  \
    \      if lst[1]:sub(i, i) == '(' then\n            left = left + 1\n        else\n\
    \            right = right + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            left = left + 1\n      \
    \  else\n            right = right + 1\n        end\n    end\n    if left == right\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend", " \
    \   local parens = {}\n    for _, str in ipairs(lst) do\n        for c in str:gmatch('%(')\
    \ do\n            table.insert(parens, c)\n        end\n        for c in str:gmatch('%)')\
    \ do\n            if table.remove(parens) ~= '(' then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return 'Yes'\nend", "  local\
    \ unmatched = 0\n  for i = 1, #lst do\n    for j = 1, #lst[i] do\n      local\
    \ c = lst[i]:sub(j, j)\n      if c == '(' then\n        unmatched = unmatched\
    \ + 1\n      else\n        unmatched = unmatched - 1\n      end\n      if unmatched\
    \ < 0 then\n        return 'No'\n      end\n    end\n  end\n  return unmatched\
    \ == 0 and 'Yes' or 'No'\nend", "    if #lst ~= 2 then\n        return 'Yes'\n\
    \    end\n    local str1, str2 = lst[1], lst[2]\n    local balance1, balance2\
    \ = 0, 0\n    for i = 1, #str1 do\n        if str1:sub(i, i) == '(' then\n   \
    \         balance1 = balance1 + 1\n        else\n            balance1 = balance1\
    \ - 1\n        end\n    end\n    for i = 1, #str2 do\n        if str2:sub(i, i)\
    \ == '(' then\n            balance2 = balance2 + 1\n        else\n           \
    \ balance2 = balance2 - 1\n        end\n    end\n    return (balance1 + balance2\
    \ == 0) and 'Yes' or 'No'\nend", "   -- Your code here\nend", "  -- Construct\
    \ a regular expression that matches strings with balanced parentheses.\n  local\
    \ left, right = string.match(table.concat(lst), \"^(.*%))(.*)$\")\n  return (left\
    \ or right) and\n    (left and left:match\"^()$\" or right and right:match\"^()$\"\
    ) and\n    \"Yes\" or \"No\"\nend", "  -- your code here\nend", "    -- TODO:\
    \ implement\nend", "  local f = {}\n  for _, p in ipairs(lst) do\n    for c in\
    \ p:gmatch('.') do\n      f[c] = (f[c] or 0) + (c == '(' and 1 or -1)\n    end\n\
    \  end\n  return (f['('] or 0) == (f[')'] or 0) and 'Yes' or 'No'\nend", "  local\
    \ opp = lst[1]\n  local clp = lst[2]\n  local open, closed = 0, 0\n  for i = 1,\
    \ #opp do\n    if opp:sub(i, i) == '(' then\n      open = open + 1\n    else\n\
    \      closed = closed + 1\n    end\n  end\n  for i = 1, #clp do\n    if clp:sub(i,\
    \ i) == '(' then\n      open = open + 1\n    else\n      closed = closed + 1\n\
    \    end\n  end\n  if open == closed then\n    return 'Yes'\n  else\n    return\
    \ 'No'\n  end\nend", "    -- get the directions\n    local lhs = {}\n    local\
    \ rhs = {}\n    for i, v in ipairs(lst) do\n        if i == 1 then\n         \
    \   for _, vv in ipairs(v) do\n                if vv == '(' then\n           \
    \         table.insert(lhs, 'L')\n                else\n                    table.insert(lhs,\
    \ 'R')\n                end\n            end\n        else\n            for _,\
    \ vv in ipairs(v) do\n                if vv == '(' then\n                    table.insert(rhs,\
    \ 'L')\n                else\n                    table.insert(rhs, 'R')\n   \
    \             end\n            end\n        end\n    end\n    -- print(unpack(lhs))\n\
    \    -- print(unpack(rhs))\n    -- build a graph, a parenthesis is a node with\
    \ two edges,\n    -- one for every direction\n    local graph = {}\n    for i,v\
    \ in ipairs(lhs) do\n        graph[i] = {}\n        if v == 'L' then\n       \
    \     graph[i]['L'] = i + 1\n        else\n            graph[i]['R'] = i - 1\n\
    \        end\n    end\n    local start = #lhs + 1\n    for i,v in ipairs(rhs)\
    \ do\n        graph[start + i] = {}\n        if v == 'L' then\n            graph[start\
    \ + i]['L'] = start + i + 1\n        else\n            graph[start + i]['R'] =\
    \ start + i - 1\n        end\n    end\n    -- print_graph(graph)\n    -- merge\
    \ the graphs\n    for i = #lhs, 1, -1 do\n        if lhs[i] == 'R' then\n    \
    \        graph[i]['R'] = start\n            graph[start]['L'] = i\n          \
    \  break\n        end\n    end\n    for i = 1, #rhs do\n        if rhs[i] == 'L'\
    \ then\n            graph[start + i]['L'] = 1\n            graph[1]['R'] = start\
    \ + i\n            break\n        end\n    end\n    -- print_graph(graph)\n  \
    \  -- the trick", "    local function count_parens(s)\n        local cnt = 0\n\
    \        for c in s:gmatch('.') do\n            if c == '(' then\n           \
    \     cnt = cnt + 1\n            else\n                cnt = cnt - 1\n       \
    \     end\n        end\n        return cnt\n    end\n    local cnt0 = count_parens(lst[1])\n\
    \    local cnt1 = count_parens(lst[2])\n    return cnt0 == cnt1 and 'Yes' or 'No'\n\
    end", "  local s = table.concat(lst)\n  local a, b = 0, 0\n  for i = 1, #s do\n\
    \    local c = s:sub(i, i)\n    if c == '(' then\n      a = a + 1\n    else\n\
    \      b = b + 1\n    end\n    if b > a then\n      return 'No'\n    end\n  end\n\
    \  return a == b and 'Yes' or 'No'\nend", "    local a, b = lst[1], lst[2]\n \
    \   -- check for empty string\n    if a == '' and b == '' then\n        return\
    \ 'Yes'\n    end\n    -- check for only one non-empty string\n    if a == '' or\
    \ b == '' then\n        if a == '' then\n            return check_parens(b)\n\
    \        else\n            return check_parens(a)\n        end\n    end\n    --\
    \ more than one character\n    -- generate all possible concatenations\n    local\
    \ lst = gen_combinations(a, b)\n    -- check them all\n    for _, s in ipairs(lst)\
    \ do\n        if check_parens(s) then\n            return 'Yes'\n        end\n\
    \    end\n    return 'No'\nend", "  local open, close = 0, 0\n  for _, s in ipairs(lst)\
    \ do\n    for _, c in ipairs(s:split(\"\")) do\n      if c == \"(\" then\n   \
    \     open = open + 1\n      else\n        close = close + 1\n      end\n    end\n\
    \  end\n  return close <= open and \"Yes\" or \"No\"\nend", "    local count =\
    \ 0\n    for _, str in ipairs(lst) do\n        for _, c in utf8.codes(str) do\n\
    \            if c == 40 then\n                count = count + 1\n            else\n\
    \                count = count - 1\n            end\n            if count < 0\
    \ then\n                return 'No'\n            end\n        end\n    end\n \
    \   return count == 0 and 'Yes' or 'No'\nend", "    local match = {\n        ['(']\
    \ = ')',\n        [')'] = '('\n    }\n    local check = {}\n    for _, s in ipairs(lst)\
    \ do\n        for c in s:gmatch '.' do\n            if #check == 0 then\n    \
    \            table.insert(check, c)\n            elseif match[check[#check]] ==\
    \ c then\n                table.remove(check)\n            else\n            \
    \    table.insert(check, c)\n            end\n        end\n    end\n    return\
    \ #check == 0 and 'Yes' or 'No'\nend", "   local lst1, lst2 = lst[1], lst[2]\n\
    \   for i = 1, #lst1 do\n      for j = 1, #lst2 do\n         if lst1:sub(i, i)\
    \ == '(' and lst2:sub(j, j) == ')' then\n            return 'Yes'\n         end\n\
    \      end\n   end\n   return 'No'\nend", "    local str1, str2 = table.unpack(lst)\n\
    \    if str1:match('%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%",
  "  local left_num = 0\n  local right_num = 0\n  for k, v in ipairs(lst) do\n   \
    \ for i=1, #v do\n      if v:sub(i, i) == '(' then\n        left_num = left_num\
    \ + 1\n      else\n        right_num = right_num + 1\n      end\n    end\n  end\n\
    \  if left_num == right_num then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend", "    -- YOUR CODE HERE\n    if lst[1] == \")\" or lst[2] == \"(\"\
    \ then\n        return \"No\"\n    end\n    local a = lst[1] .. lst[2]\n    local\
    \ b = lst[2] .. lst[1]\n    -- print(a)\n    -- print(b)\n    if (isGood(a) or\
    \ isGood(b)) then\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend", "   -- your code here\nend", "  for i = 1, #lst do\n    lst[i]\
    \ = lst[i]:gsub('[^%(%)]', '')\n  end\n  local function is_good(s)\n    local\
    \ cnt = 0\n    for c in s:gmatch('[%(%)]') do\n      if c == '(' then\n      \
    \  cnt = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if cnt <\
    \ 0 then\n        return false\n      end\n    end\n    return cnt == 0\n  end\n\
    \  local function join(lst)\n    return table.concat(lst)\n  end\n  return is_good(join(lst))\
    \ and 'Yes' or 'No'\nend", "  -- your code here\nend", "    local function index(p)\n\
    \        for i, x in ipairs(lst) do\n            if x == p then\n            \
    \    return i\n            end\n        end\n        return nil\n    end\n   \
    \ local function sublists(lst)\n        local function sublist(i, j)\n       \
    \     local res = {}\n            for k = i, j do\n                res[#res +\
    \ 1] = lst[k]\n            end\n            return res\n        end\n        local\
    \ res = {}\n        for i = 1, #lst do\n            for j = i, #lst do\n     \
    \           res[#res + 1] = sublist(i, j)\n            end\n        end\n    \
    \    return res\n    end\n    local function good(lst)\n        local n = 0\n\
    \        for _, x in ipairs(lst) do\n            if x == '(' then\n          \
    \      n = n + 1\n            else\n                n = n - 1\n            end\n\
    \            if n < 0 then\n                return false\n            end\n  \
    \      end\n        return n == 0\n    end\n    local i = index(')')\n    if i\
    \ == nil then\n        return good(lst) and 'Yes' or 'No'\n    end\n    local\
    \ res = 'No'\n    for _, sub in ipairs(sublists(lst)) do\n        if good(sub)\
    \ then\n            res = 'Yes'\n            break\n        end\n    end\n   \
    \ return res\nend", "  -- your code here\nend", "  local left, right = 0, 0\n\
    \  for _, s in ipairs(lst) do\n    for i = 1, #s do\n      if s:sub(i, i) == '('\
    \ then\n        left = left + 1\n      else\n        right = right + 1\n     \
    \ end\n    end\n  end\n  return (left == right) and 'Yes' or 'No'\nend", "  local\
    \ function count_parens(s)\n    local open, close = 0, 0\n    for _, c in ipairs(s)\
    \ do\n      if c == '(' then\n        open = open + 1\n      else\n        close\
    \ = close + 1\n      end\n    end\n    return open, close\n  end\n  local open_1,\
    \ close_1 = count_parens(lst[1])\n  local open_2, close_2 = count_parens(lst[2])\n\
    \  if open_1 == close_1 and open_2 == close_2 then\n    return 'Yes'\n  elseif\
    \ open_1 > close_1 and open_2 == close_2 then\n    return 'Yes'\n  elseif open_1\
    \ == close_1 and open_2 < close_2 then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend", "    local s = table.concat(lst)\n    local score = 0\n    for i\
    \ = 1, #s do\n        if s:sub(i, i) == '(' then\n            score = score +\
    \ 1\n        else\n            score = score - 1\n        end\n        if score\
    \ < 0 then\n            return 'No'\n        end\n    end\n    return score ==\
    \ 0 and 'Yes' or 'No'\nend", "   local n = 0\n   for _, s in ipairs(lst) do\n\
    \      for i = 1, #s do\n         if s:sub(i, i) == '(' then\n            n =\
    \ n + 1\n         else\n            n = n - 1\n         end\n         if n < 0\
    \ then\n            return 'No'\n         end\n      end\n   end\n   return n\
    \ == 0 and 'Yes' or 'No'\nend", "  local balance = 0\n  for _, s in ipairs(lst)\
    \ do\n    for c in s:gmatch('%(') do balance = balance + 1 end\n    for c in s:gmatch('%)')\
    \ do balance = balance - 1 end\n    if balance < 0 then return 'No' end\n  end\n\
    \  return balance == 0 and 'Yes' or 'No'\nend", "    local s = lst[1] .. lst[2]\n\
    \    local c = 0\n    for i = 1, #s do\n        local ch = s:sub(i, i)\n     \
    \   if ch == '(' then\n            c = c + 1\n        else\n            c = c\
    \ - 1\n        end\n        if c < 0 then\n            return 'No'\n        end\n\
    \    end\n    return c == 0 and 'Yes' or 'No'\nend", "    local m = {\n      \
    \  ['('] = ')',\n        [')'] = '('\n    }\n    local result = 0\n    for _,\
    \ v in ipairs(lst) do\n        for _, c in ipairs(v) do\n            if result\
    \ < 0 then return 'No' end\n            result = result + (m[c] == '(' and 1 or\
    \ -1)\n        end\n    end\n    return result == 0 and 'Yes' or 'No'\nend", " \
    \ local s = table.concat(lst)\n  local bal = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      bal = bal + 1\n    else\n      bal = bal - 1\n    end\n\
    \    if bal < 0 then\n      return 'No'\n    end\n  end\n  return bal == 0 and\
    \ 'Yes' or 'No'\nend", "  local result = {}\n  for _, string in ipairs(lst) do\n\
    \    for i = 1, #string do\n      local c = string:sub(i, i)\n      if c == '('\
    \ then\n        table.insert(result, '(')\n      else\n        if #result == 0\
    \ then\n          return 'No'\n        end\n        table.remove(result)\n   \
    \   end\n    end\n  end\n  return #result == 0 and 'Yes' or 'No'\nend", "    local\
    \ s = table.concat(lst)\n    local counter = 0\n    for i = 1, #s do\n       \
    \ local c = s:sub(i, i)\n        if c == '(' then\n            counter = counter\
    \ + 1\n        else\n            counter = counter - 1\n        end\n        if\
    \ counter < 0 then\n            return 'No'\n        end\n    end\n    return\
    \ counter == 0 and 'Yes' or 'No'\nend", "    local f, s = lst[1], lst[2]\n   \
    \ local t = f:gsub('%(', '')\n    if t == '' then\n        if #f < #s then\n \
    \           return 'Yes'\n        else\n            return 'No'\n        end\n\
    \    end\n    t = s:gsub('%)', '')\n    if t == '' then\n        if #s < #f then\n\
    \            return 'Yes'\n        else\n            return 'No'\n        end\n\
    \    end\n    if #s < #f then\n        f, s = s, f\n    end\n    local start =\
    \ f:sub(1, 1)\n    local last = s:sub(-1)\n    if start == '(' and last == ')'\
    \ then\n        return 'Yes'\n    end\n    return 'No'\nend", "    local function\
    \ aux(l, r)\n        if l > r then\n            return true\n        elseif l\
    \ < 0 or r < 0 then\n            return false\n        else\n            return\
    \ aux(l - 1, r) or aux(l, r - 1)\n        end\n    end\n    local open, close\
    \ = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n\
    \            open = open + 1\n        else\n            close = close + 1\n  \
    \      end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) ==\
    \ '(' then\n            open = open + 1\n        else\n            close = close\
    \ + 1\n        end\n    end\n    return aux(open, close) and 'Yes' or 'No'\nend",
  "  local count = 0\n  for _, str in ipairs(lst) do\n    for p in str:gmatch('%(')\
    \ do count = count + 1 end\n    for p in str:gmatch('%)') do count = count - 1\
    \ end\n    if count < 0 then return 'No' end\n  end\n  return count == 0 and 'Yes'\
    \ or 'No'\nend", "  return 'Yes'\nend", "  local open_stack = 0\n  local closed_stack\
    \ = 0\n  for _, v in ipairs(lst) do\n    for _, c in ipairs(v:split('')) do\n\
    \      if c == '(' then\n        open_stack = open_stack + 1\n      else\n   \
    \     if open_stack == 0 then\n          closed_stack = closed_stack + 1\n   \
    \     else\n          open_stack = open_stack - 1\n        end\n      end\n  \
    \  end\n  end\n  if open_stack == 0 and closed_stack == 0 then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "\tlocal s = lst[1] .. lst[2]\n\tlocal\
    \ stack = {}\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i, i)\n\t\tif c == '(' then\n\
    \t\t\ttable.insert(stack, c)\n\t\telse\n\t\t\tif #stack == 0 then\n\t\t\t\treturn\
    \ 'No'\n\t\t\tend\n\t\t\ttable.remove(stack)\n\t\tend\n\tend\n\treturn #stack\
    \ == 0 and 'Yes' or 'No'\nend", "    local function is_balanced(s)\n        local\
    \ function count(s, c)\n            local i = 0\n            for ch in s:gmatch(c)\
    \ do\n                i = i + 1\n            end\n            return i\n     \
    \   end\n        local cnt_open = count(s, '%(')\n        local cnt_close = count(s,\
    \ '%)')\n        return cnt_open == cnt_close\n    end\n    return is_balanced(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "  local x, y = lst[1], lst[2]\n  local\
    \ good = function(p)\n    local count = 0\n    for i = 1, #p do\n      if p:sub(i,\
    \ i) == '(' then\n        count = count + 1\n      else\n        count = count\
    \ - 1\n      end\n      if count < 0 then\n        return false\n      end\n \
    \   end\n    return count == 0\n  end\n  return good(x .. y) or good(y .. x) and\
    \ 'Yes' or 'No'\nend", "    local function check(s)\n        local cnt = 0\n \
    \       for i = 1, #s do\n            if s:sub(i, i) == '(' then\n           \
    \     cnt = cnt + 1\n            else\n                cnt = cnt - 1\n       \
    \     end\n            if cnt < 0 then\n                return false\n       \
    \     end\n        end\n        return cnt == 0\n    end\n    if check(lst[1])\
    \ then\n        return 'Yes'\n    end\n    local res = { 'Yes', 'No' }\n    for\
    \ i = 1, #lst[1] do\n        for j = 1, #lst[2] do\n            if check(lst[1]:sub(1,\
    \ i) .. lst[2]:sub(1, j)) or\n               check(lst[2]:sub(1, j) .. lst[1]:sub(1,\
    \ i)) then\n                return res[1]\n            end\n        end\n    end\n\
    \    return res[2]\nend", "  local c = 0\n  for _, s in ipairs(lst) do\n    for\
    \ _, b in ipairs(s:gmatch('.')) do\n      if b == '(' then\n        c = c + 1\n\
    \      else\n        c = c - 1\n      end\n      if c < 0 then\n        return\
    \ 'No'\n      end\n    end\n  end\n  return c == 0 and 'Yes' or 'No'\nend", " \
    \ local function to_set(s)\n    local set = {}\n    for i = 1, #s do\n      set[s:sub(i,\
    \ i)] = true\n    end\n    return set\n  end\n  local function is_good(s)\n  \
    \  local open = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n  \
    \      open = open + 1\n      else\n        open = open - 1\n      end\n     \
    \ if open < 0 then\n        return false\n      end\n    end\n    return open\
    \ == 0\n  end\n  local set1, set2 = to_set(lst[1]), to_set(lst[2])\n  for _, s\
    \ in ipairs{lst[1] .. lst[2], lst[2] .. lst[1]} do\n    if is_good(s) then\n \
    \     return 'Yes'\n    end\n  end\n  if set1['('] and set2[')'] or set1[')']\
    \ and set2['('] then\n    return 'Yes'\n  end\n  return 'No'\nend", "\tlocal def\
    \ = 1\n\tfor _,v in ipairs(lst) do\n\t\tdef = def + (v == '(' and 1 or -1)\n\t\
    \tif def < 0 then return 'No' end\n\tend\n\treturn def == 0 and 'Yes' or 'No'\n\
    end", "    local s1, s2 = lst[1], lst[2]\n    local cnt1, cnt2 = 0, 0\n    for\
    \ i = 1, #s1 do\n        cnt1 = cnt1 + (s1:sub(i, i) == '(' and 1 or -1)\n   \
    \ end\n    for i = 1, #s2 do\n        cnt2 = cnt2 + (s2:sub(i, i) == '(' and 1\
    \ or -1)\n    end\n    return cnt1 + cnt2 == 0 and 'Yes' or 'No'\nend\nassert(match_parens({'()(',\
    \ ')'}) == 'Yes')\nassert(match_parens({')', ')'}) == 'No')", "   local src =\
    \ table.concat(lst)\n   for i = 1, #src - 1 do\n      for j = i + 1, #src do\n\
    \         local s = src:sub(1, i - 1) .. src:sub(j, j) .. src:sub(i, i) .. src:sub(j\
    \ + 1)\n         if parens_balanced(s) then\n            return 'Yes'\n      \
    \   end\n      end\n   end\n   return 'No'\nend", "    local s = lst[1] .. lst[2]\n\
    \    local cnt = 0\n    for c in s:gmatch\".\" do\n        if c == '(' then\n\
    \            cnt = cnt + 1\n        else\n            cnt = cnt - 1\n        \
    \    if cnt < 0 then\n                return 'No'\n            end\n        end\n\
    \    end\n    return cnt == 0 and 'Yes' or 'No'\nend", "    local open_cnt = 0\n\
    \    local close_cnt = 0\n    for _, str in ipairs(lst) do\n        for ch in\
    \ str:gmatch('%(') do\n            open_cnt = open_cnt + 1\n        end\n    \
    \    for ch in str:gmatch('%)') do\n            close_cnt = close_cnt + 1\n  \
    \      end\n    end\n    if open_cnt == close_cnt then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend", "    local s = table.concat(lst)\n\
    \    local a, b = '', ''\n    local function is_paren(c)\n        return c ==\
    \ '(' or c == ')'\n    end\n    for i = 1, #s do\n        local c = s:sub(i, i)\n\
    \        if is_paren(c) then\n            if c == '(' then\n                a\
    \ = a .. c\n            else\n                if a:sub(-1) == '(' then\n     \
    \               a = a:sub(1, -2)\n                else\n                    b\
    \ = b .. c\n                end\n            end\n        end\n    end\n    if\
    \ #a == 0 and #b == 0 then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend", "  local function count_open(s)\n    return select(2, s:gsub('%(',\
    \ ''))\n  end\n  local function count_close(s)\n    return select(2, s:gsub('%)',\
    \ ''))\n  end\n  local s1, s2 = lst[1], lst[2]\n  local sum_open = count_open(s1)\
    \ + count_open(s2)\n  local sum_close = count_close(s1) + count_close(s2)\n  return\
    \ (sum_open == sum_close) and 'Yes' or 'No'\nend", "    local _match_parens =\
    \ function(s1, s2)\n        if s1 == '' then\n            if s2 == '' then\n \
    \               return true\n            else\n                return _match_parens('',\
    \ s2:sub(2))\n            end\n        elseif s2 == '' then\n            if s1\
    \ == '' then\n                return true\n            else\n                return\
    \ _match_parens(s1:sub(2), '')\n            end\n        elseif s1:sub(1, 1) ==\
    \ '(' then\n            if s2:sub(1, 1) == ')' then\n                return _match_parens(s1:sub(2),\
    \ s2:sub(2))\n            else\n                return _match_parens(s1:sub(2),\
    \ s2)\n            end\n        elseif s1:sub(1, 1) == ')' then\n            if\
    \ s2:sub(1, 1) == '(' then\n                return _match_parens(s1:sub(2), s2:sub(2))\n\
    \            else\n                return _match_parens(s1:sub(2), s2)\n     \
    \       end\n        end\n    end\n    if _match_parens(lst[1], lst[2]) then\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend", "  local\
    \ function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if s:sub(i,\
    \ i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n \
    \     end\n      if cnt < 0 then\n        return false\n      end\n    end\n \
    \   return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2])) and\
    \ 'Yes' or 'No'\nend", "  local function count_parens(s)\n    local t = 0\n  \
    \  for i=1,#s do\n      if s:sub(i,i) == '(' then\n        t = t + 1\n      else\n\
    \        t = t - 1\n      end\n      if t < 0 then\n        return nil\n     \
    \ end\n    end\n    return t\n  end\n  return (count_parens(lst[1]) == count_parens(lst[2]))\
    \ and 'Yes' or 'No'\nend", "  local l, r = 0, 0\n  for i = 1, #lst[1] do\n   \
    \ l = l + lst[1]:sub(i, i) == '(' and 1 or -1\n  end\n  for i = 1, #lst[2] do\n\
    \    r = r + lst[2]:sub(i, i) == '(' and 1 or -1\n  end\n  return (l == 0 and\
    \ r == 0) or (l * r >= 0) and 'Yes' or 'No'\nend", "  local cnt = 0\n  for _,\
    \ s in ipairs(lst) do\n    for _, c in utf8.codes(s) do\n      if c == utf8.byte('(')\
    \ then\n        cnt = cnt + 1\n      elseif c == utf8.byte(')') then\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return 'No'\n     \
    \ end\n    end\n  end\n  return (cnt == 0) and 'Yes' or 'No'\nend", "    local\
    \ function is_good(s)\n        local count = 0\n        for c in s:gmatch('%b()')\
    \ do\n            count = count + 1\n        end\n        return count % 2 ==\
    \ 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    if is_good(s1) and is_good(s2)\
    \ then\n        return 'Yes'\n    end\n    local index = #s1\n    for i = 1, index\
    \ - 1 do\n        local t1, t2 = s1:sub(1, i), s1:sub(i + 1)\n        if is_good(t1)\
    \ and is_good(t2) then\n            return 'Yes'\n        end\n    end\n    return\
    \ 'No'\nend", "  local left, right = unpack(lst)\n  local left_count, right_count\
    \ = 0, 0\n  for _, char in ipairs(left) do\n    if char == '(' then\n      left_count\
    \ = left_count + 1\n    else\n      left_count = left_count - 1\n    end\n  end\n\
    \  for _, char in ipairs(right) do\n    if char == '(' then\n      right_count\
    \ = right_count + 1\n    else\n      right_count = right_count - 1\n    end\n\
    \  end\n  if left_count == 0 and right_count == 0 then\n    return 'Yes'\n  elseif\
    \ left_count == 0 or right_count == 0 then\n    return 'No'\n  elseif left_count\
    \ == -right_count then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend",
  "  local open = 0\n  local close = 0\n  for i = 1, #lst do\n    for j = 1, #lst[i]\
    \ do\n      if lst[i]:sub(j, j) == '(' then\n        open = open + 1\n      else\n\
    \        close = close + 1\n      end\n    end\n  end\n  return (open == close)\
    \ and 'Yes' or 'No'\nend", "  local function is_good(s)\n    local cnt = 0\n \
    \   for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        cnt = cnt + 1\n\
    \      else\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n       \
    \ return false\n      end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend", "    local yes_no = {\n        [0] = 'Yes',\n\
    \        [1] = 'No',\n    }\n    local balance = 0\n    for _, s in ipairs(lst)\
    \ do\n        for _, c in ipairs{s:byte(1, -1)} do\n            if c == 40 then\n\
    \                balance = balance + 1\n            else\n                balance\
    \ = balance - 1\n            end\n            if balance < 0 then\n          \
    \      return yes_no[1]\n            end\n        end\n    end\n    return yes_no[balance\
    \ % 2]\nend", "    local n1, n2 = #lst[1], #lst[2]\n    local p1, p2 = 0, 0\n\
    \    for i = 1, n1 do\n        if lst[1]:sub(i, i) == '(' then\n            p1\
    \ = p1 + 1\n        else\n            p1 = p1 - 1\n        end\n    end\n    for\
    \ i = 1, n2 do\n        if lst[2]:sub(i, i) == '(' then\n            p2 = p2 +\
    \ 1\n        else\n            p2 = p2 - 1\n        end\n    end\n    if p1 <\
    \ 0 or p2 < 0 then\n        return 'No'\n    end\n    if p1 == 0 then\n      \
    \  if p2 % 2 == 0 then\n            return 'Yes'\n        else\n            return\
    \ 'No'\n        end\n    end\n    if p2 == 0 then\n        if p1 % 2 == 0 then\n\
    \            return 'Yes'\n        else\n            return 'No'\n        end\n\
    \    end\n    return 'Yes'\nend", "    local count = 0\n    for _, v in ipairs(lst)\
    \ do\n        for c in v:gmatch('%(') do\n            count = count + 1\n    \
    \    end\n        for c in v:gmatch('%)') do\n            count = count - 1\n\
    \        end\n        if count < 0 then\n            return 'No'\n        end\n\
    \    end\n    return 'Yes'\nend", "    local left = 0\n    local right = 0\n \
    \   for _, s in ipairs(lst) do\n        for c in s:gmatch('.') do\n          \
    \  if c == '(' then\n                left = left + 1\n            else\n     \
    \           right = right + 1\n            end\n        end\n    end\n    if left\
    \ == right then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end", "  local s = lst[1] .. lst[2]\n  local c = 0\n  for i = 1, #s do\n    if\
    \ s:sub(i, i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n    end\n\
    \    if c < 0 then\n      return 'No'\n    end\n  end\n  return 'Yes'\nend", " \
    \   local bal = 0\n    for i = 1, #lst do\n        local a = lst[i]\n        for\
    \ j = 1, #a do\n            local b = a:sub(j, j)\n            if b == '(' then\n\
    \                bal = bal + 1\n            else\n                bal = bal -\
    \ 1\n            end\n            if bal < 0 then\n                return 'No'\n\
    \            end\n        end\n    end\n    return bal == 0 and 'Yes' or 'No'\n\
    end", "    local upar = 0\n    local dpar = 0\n    for i = 1, #lst[1] do\n   \
    \     if lst[1]:sub(i, i) == '(' then\n            upar = upar + 1\n        else\n\
    \            dpar = dpar + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            upar = upar + 1\n      \
    \  else\n            dpar = dpar + 1\n        end\n    end\n    if upar == dpar\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend", " \
    \   local stack = {}\n    for _, s in ipairs(lst) do\n        for i = 1, #s do\n\
    \            local p = s:sub(i, i)\n            if p == '(' then\n           \
    \     table.insert(stack, p)\n            else\n                if #stack == 0\
    \ then\n                    return 'No'\n                end\n               \
    \ table.remove(stack)\n            end\n        end\n    end\n    return #stack\
    \ == 0 and 'Yes' or 'No'\nend", "\tlocal s0, s1 = lst[1], lst[2]\n\tif #s0 ==\
    \ 0 then\n\t\tif s1:find('%(') then\n\t\t\treturn 'No'\n\t\telse\n\t\t\treturn\
    \ 'Yes'\n\t\tend\n\tend\n\tlocal p = s0:find('%(')\n\tif not p then\n\t\treturn\
    \ 'No'\n\tend\n\ts0 = s0:sub(p)\n\ts1 = s1:sub(p)\n\tlocal stack = {}\n\tfor i\
    \ = 1, #s0 do\n\t\tlocal c = s0:sub(i, i)\n\t\tif c == '(' then\n\t\t\ttable.insert(stack,\
    \ c)\n\t\telse\n\t\t\tif #stack == 0 then\n\t\t\t\treturn 'No'\n\t\t\tend\n\t\t\
    \ttable.remove(stack)\n\t\tend\n\tend\n\tfor i = 1, #s1 do\n\t\tlocal c = s1:sub(i,\
    \ i)\n\t\tif c == '(' then\n\t\t\ttable.insert(stack, c)\n\t\telse\n\t\t\tif #stack\
    \ == 0 then\n\t\t\t\treturn 'No'\n\t\t\tend\n\t\t\ttable.remove(stack)\n\t\tend\n\
    \tend\n\tif #stack == 0 then\n\t\treturn 'Yes'\n\telse\n\t\treturn 'No'\n\tend\n\
    end", "   local bad = false\n   local stack = 0\n   for _, str in ipairs(lst)\
    \ do\n      for i = 1, #str do\n         if str:sub(i, i) == '(' then\n      \
    \      stack = stack + 1\n         else\n            stack = stack - 1\n     \
    \       if stack < 0 then\n               bad = true\n               break\n \
    \           end\n         end\n      end\n   end\n   if bad or stack ~= 0 then\n\
    \      return 'No'\n   else\n      return 'Yes'\n   end\nend", "    -- check the\
    \ number of open and close parentheses\n    -- if it's possible to make a good\
    \ string, return 'Yes'\n    -- otherwise, return 'No'\n    local function count_parens(parens)\n\
    \        local open, close = 0, 0\n        for i=1,#parens do\n            if\
    \ parens:sub(i,i) == '(' then\n                open = open + 1\n            else\n\
    \                close = close + 1\n            end\n        end\n        return\
    \ open, close\n    end\n    local parens1, parens2 = lst[1], lst[2]\n    local\
    \ op1, cl1 = count_parens(parens1)\n    local op2, cl2 = count_parens(parens2)\n\
    \    if op1 > cl1 and op2 > cl2 then\n        return 'Yes'\n    elseif op1 > cl1\
    \ then\n        local op, cl = count_parens(parens1 .. parens2)\n        if op\
    \ > cl then\n            return 'Yes'\n        end\n    elseif op2 > cl2 then\n\
    \        local op, cl = count_parens(parens2 .. parens1)\n        if op > cl then\n\
    \            return 'Yes'\n        end\n    end\n    return 'No'\nend", "  local\
    \ lst1, lst2 = lst[1], lst[2]\n  local cnt1, cnt2 = 0, 0\n  for i = 1, #lst1 do\n\
    \    if lst1:sub(i, i) == '(' then\n      cnt1 = cnt1 + 1\n    else\n      cnt1\
    \ = cnt1 - 1\n    end\n  end\n  for i = 1, #lst2 do\n    if lst2:sub(i, i) ==\
    \ '(' then\n      cnt2 = cnt2 + 1\n    else\n      cnt2 = cnt2 - 1\n    end\n\
    \  end\n  if cnt1 == cnt2 and cnt1 >= 0 then\n    return 'Yes'\n  else\n    return\
    \ 'No'\n  end\nend", "   local n = (#lst[1] + #lst[2])\n   local o = 0\n   local\
    \ c = 0\n   for i = 1, n do\n      local c = lst[1]:sub(i, i) or lst[2]:sub(i,\
    \ i)\n      if c == '(' then\n         o = o + 1\n      else\n         if o ==\
    \ 0 then\n            return 'No'\n         end\n         o = o - 1\n      end\n\
    \   end\n   return 'Yes'\nend", "  local s = table.concat(lst)\n  local i = 0\n\
    \  for c in s:gmatch('.') do\n    if c == '(' then\n      i = i + 1\n    else\n\
    \      i = i - 1\n    end\n    if i < 0 then\n      return 'No'\n    end\n  end\n\
    \  return i == 0 and 'Yes' or 'No'\nend", "  local function helper(str)\n    local\
    \ open, close = 0, 0\n    for c in str:gmatch\".\" do\n      if c == '(' then\n\
    \        open = open + 1\n      else\n        if open == 0 then\n          return\
    \ false\n        end\n        open = open - 1\n      end\n    end\n    return\
    \ open == 0\n  end\n  local s = table.concat(lst)\n  local a, b = helper(s), helper(s:reverse())\n\
    \  return a and b and 'Yes' or 'No'\nend", "    local function is_open(c)\n  \
    \      return c == '('\n    end\n    local function is_close(c)\n        return\
    \ c == ')'\n    end\n    local left = lst[1]\n    local right = lst[2]\n    local\
    \ opens = 0\n    local closes = 0\n    for i = 1, #left do\n        if is_open(left:sub(i,\
    \ i)) then\n            opens = opens + 1\n        else\n            closes =\
    \ closes + 1\n        end\n    end\n    for i = 1, #right do\n        if is_open(right:sub(i,\
    \ i)) then\n            opens = opens + 1\n        else\n            closes =\
    \ closes + 1\n        end\n    end\n    if closes > opens then\n        return\
    \ 'No'\n    end\n    if opens % 2 == 0 and closes % 2 == 0 then\n        return\
    \ 'Yes'\n    end\n    return 'No'\nend", "    local open, close = 0, 0\n    for\
    \ i, v in ipairs(lst) do\n        for _, c in ipairs(v) do\n            if c ==\
    \ '(' then\n                open = open + 1\n            else\n              \
    \  close = close + 1\n            end\n        end\n    end\n    return (open\
    \ > close) and 'Yes' or 'No'\nend", "  local s1, s2 = lst[1], lst[2]\n  local\
    \ balance = #s1 - #s2\n  if balance % 2 ~= 0 then\n    return 'No'\n  end\n  local\
    \ s = s1 .. s2\n  for _, s in ipairs({s1, s2, s}) do\n    local cnt = 0\n    for\
    \ i = 1, #s do\n      local c = s:sub(i, i)\n      if c == '(' then\n        cnt\
    \ = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n\
    \        return 'No'\n      end\n    end\n  end\n  return 'Yes'\nend", "    local\
    \ left_cnt = 0\n    local right_cnt = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            left_cnt = left_cnt + 1\n        else\n\
    \            right_cnt = right_cnt + 1\n        end\n    end\n    for i = 1, #lst[2]\
    \ do\n        if lst[2]:sub(i, i) == '(' then\n            left_cnt = left_cnt\
    \ + 1\n        else\n            right_cnt = right_cnt + 1\n        end\n    end\n\
    \    if left_cnt == right_cnt then\n        return 'Yes'\n    else\n        return\
    \ 'No'\n    end\nend", "    if #lst ~= 2 then\n        return nil\n    end\n \
    \   local s = table.concat(lst)\n    local cnt = 0\n    for i = 1, #s do\n   \
    \     if s:sub(i, i) == '(' then\n            cnt = cnt + 1\n        else\n  \
    \          cnt = cnt - 1\n        end\n        if cnt < 0 then\n            return\
    \ 'No'\n        end\n    end\n    return cnt == 0 and 'Yes' or 'No'\nend", " \
    \ -- your code here\nend", "  local t = { [0] = 0 }\n  for _, str in ipairs(lst)\
    \ do\n    for c in str:gmatch\".\" do\n      t[#t] = t[#t] + (c == '(' and 1 or\
    \ -1)\n      if t[#t] < 0 then return 'No' end\n    end\n  end\n  if t[#t] ==\
    \ 0 then return 'Yes' end\n  return 'No'\nend", "  for _, s in ipairs(lst) do\n\
    \    local cnt = 0\n    for _, c in s:gmatch'.' do\n      if c == '(' then\n \
    \       cnt = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n      if\
    \ cnt < 0 then\n        return 'No'\n      end\n    end\n  end\n  return 'Yes'\n\
    end", "    -- your code here\nend", "  local s = table.concat(lst)\n  local open,\
    \ close = s:match'^%(+()%)+$'\n  return open == nil and 'No' or 'Yes'\nend", " \
    \   local function go(s1, s2, n)\n        if n == 0 then\n            return s1\
    \ .. s2\n        elseif s1:sub(1, 1) == '(' then\n            return go(s1:sub(2),\
    \ s2, n - 1)\n        elseif s2:sub(-1) == ')' then\n            return go(s1,\
    \ s2:sub(1, -2), n - 1)\n        else\n            return false\n        end\n\
    \    end\n    local s1, s2 = lst[1], lst[2]\n    local s = go(s1, s2, #s1 + #s2)\n\
    \    if s then\n        local i = 1\n        for c in s:gmatch('()') do\n    \
    \        if s:sub(c, c) == '(' then\n                i = i + 1\n            else\n\
    \                i = i - 1\n            end\n            if i < 0 then\n     \
    \           return 'No'\n            end\n        end\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend", "  local function is_good(str)\n\
    \    local sum = 0\n    for i = 1, #str do\n      if str:sub(i, i) == '(' then\n\
    \        sum = sum + 1\n      else\n        sum = sum - 1\n      end\n      if\
    \ sum < 0 then\n        return false\n      end\n    end\n    return sum == 0\n\
    \  end\n  return is_good(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", "  local open\
    \ = lst[1]:gsub('%(', 'O')\n  local close = lst[2]:gsub('%)', 'C')\n  return open:match('O+')\
    \ and close:match('C+') and 'Yes' or 'No'\nend", "    -- \"lst\" is a list of\
    \ two strings, both strings\n    -- consist of open parentheses '(' or close parentheses\
    \ ')' only.\n    local s1, s2 = lst[1], lst[2]\n    local l1, l2 = s1:len(), s2:len()\n\
    \    local s3 = s1 .. s2\n    local s4 = s2 .. s1\n    if parent_ok(s3) then\n\
    \        return 'Yes'\n    elseif parent_ok(s4) then\n        return 'Yes'\n \
    \   else\n        return 'No'\n    end\nend", "    local left_count = 0\n    local\
    \ right_count = 0\n    for i, v in ipairs(lst) do\n        for _, p in ipairs(v)\
    \ do\n            if p == '(' then\n                left_count = left_count +\
    \ 1\n            else\n                right_count = right_count + 1\n       \
    \     end\n        end\n    end\n    if left_count == right_count then\n     \
    \   return 'Yes'\n    else\n        return 'No'\n    end\nend", "  local s = lst[1]\
    \ .. lst[2]\n  local balance = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '('\
    \ then\n      balance = balance + 1\n    else\n      balance = balance - 1\n \
    \   end\n    if balance < 0 then\n      return 'No'\n    end\n  end\n  return\
    \ balance == 0 and 'Yes' or 'No'\nend", "    local bracket_stack = {}\n    for\
    \ _, s in ipairs(lst) do\n        for i = 1, #s do\n            local b = s:sub(i,\
    \ i)\n            if b == '(' then\n                table.insert(bracket_stack,\
    \ b)\n            else\n                if #bracket_stack == 0 then\n        \
    \            return 'No'\n                end\n                table.remove(bracket_stack)\n\
    \            end\n        end\n    end\n    return (#bracket_stack == 0) and 'Yes'\
    \ or 'No'\nend", "   local counts = {0, 0}\n   for i = 1, 2 do\n      local s\
    \ = lst[i]\n      for j = 1, #s do\n         local c = s:sub(j, j)\n         if\
    \ c == '(' then\n            counts[i] = counts[i] + 1\n         else\n      \
    \      counts[i] = counts[i] - 1\n         end\n         if counts[i] < 0 then\n\
    \            return 'No'\n         end\n      end\n   end\n   if counts[1] ==\
    \ counts[2] then\n      return 'Yes'\n   else\n      return 'No'\n   end\nend",
  "    for _, s in ipairs(lst) do\n        if s:find('%(%)') then\n            return\
    \ 'Yes'\n        end\n    end\n    return 'No'\nend", "    local parens_stack\
    \ = {};\n    local opening_parens = {'(', '{', '['};\n    local closing_parens\
    \ = {')', '}', ']'};\n    local matches = {\n        ['('] = ')',\n        ['{']\
    \ = '}',\n        ['['] = ']'\n    };\n    local function is_empty()\n       \
    \ return not parens_stack[1];\n    end\n    local function top()\n        return\
    \ parens_stack[#parens_stack];\n    end\n    local function pop()\n        table.remove(parens_stack,\
    \ #parens_stack);\n    end\n    local function push(char)\n        table.insert(parens_stack,\
    \ char);\n    end\n    local function is_pair(c)\n        return matches[top()]\
    \ == c;\n    end\n    local function is_opening(c)\n        for _, p in ipairs(opening_parens)\
    \ do\n            if p == c then\n                return true;\n            end\n\
    \        end\n        return false;\n    end\n    local function is_closing(c)\n\
    \        for _, p in ipairs(closing_parens) do\n            if p == c then\n \
    \               return true;\n            end\n        end\n        return false;\n\
    \    end\n    for _, word in ipairs(lst) do\n        for i = 1, #word do\n   \
    \         local c = word:sub(i, i);\n            if is_opening(c) then\n     \
    \           push(c);\n            elseif is_closing(c) then\n                if\
    \ is_empty() or not is_pair(c) then\n                    return 'No';\n      \
    \          else\n                    pop();\n                end\n           \
    \ end\n        end\n    end\n    return is_empty() and 'Yes' or 'No';\nend", " \
    \   local str1, str2 = lst[1], lst[2]\n    -- <YOUR CODE HERE>\n    -- key idea:\
    \ make the strings into valid parens\n    -- then a valid parens just need to\
    \ be checked\n    local temp = str1..str2\n    local sum = 0\n    for i = 1, #temp\
    \ do\n        if temp:sub(i, i) == '(' then\n            sum = sum + 1\n     \
    \   else\n            sum = sum - 1\n        end\n        if sum < 0 then\n  \
    \          return 'No'\n        end\n    end\n    if sum == 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "    local n = 0\n    for\
    \ _, s in ipairs(lst) do\n        for _ in s:gmatch'()' do\n            n = n\
    \ + 1\n        end\n    end\n    return n % 2 == 0 and 'Yes' or 'No'\nend", " \
    \   local function is_good(s)\n        local n = 0\n        for c in s:gmatch('%(%)')\
    \ do\n            if c == '(' then\n                n = n + 1\n            else\n\
    \                n = n - 1\n            end\n            if n < 0 then\n     \
    \           return false\n            end\n        end\n        return n == 0\n\
    \    end\n    return (is_good(lst[1]) and is_good(lst[2])) and 'Yes' or 'No'\n\
    end", "    -- TODO\nend", "    local str = ''\n    for i = 1, #lst do\n      \
    \  str = str .. lst[i]\n    end\n    local count = 0\n    for i = 1, #str do\n\
    \        if str:sub(i, i) == '(' then\n            count = count + 1\n       \
    \ else\n            count = count - 1\n        end\n        if count < 0 then\n\
    \            return 'No'\n        end\n    end\n    if count == 0 then\n     \
    \   return 'Yes'\n    else\n        return 'No'\n    end\nend", "   local function\
    \ split(s)\n      local res = {}\n      for c in s:gmatch(\".\") do\n        \
    \ table.insert(res, c)\n      end\n      return res\n   end\n   local function\
    \ index_first_close(lst)\n      for i = 1, #lst do\n         if lst[i] == ')'\
    \ then\n            return i\n         end\n      end\n      return -1\n   end\n\
    \   local function split_parens(lst)\n      local first_close = index_first_close(lst)\n\
    \      if first_close == -1 then\n         return {}\n      end\n      local res\
    \ = {}\n      local curr = {}\n      for i = 1, #lst do\n         if i < first_close\
    \ then\n            table.insert(curr, lst[i])\n         elseif i == first_close\
    \ then\n            table.insert(res, curr)\n            curr = {}\n         else\n\
    \            table.insert(curr, lst[i])\n         end\n      end\n      if #curr\
    \ > 0 then\n         table.insert(res, curr)\n      end\n      return res\n  \
    \ end\n   local function str_find(sub, s)\n      for i = 1, #s - #sub + 1 do\n\
    \         local ok = true\n         for j = 1, #sub do\n            if sub[j]\
    \ ~= s[i + j - 1] then\n               ok = false\n               break\n    \
    \        end\n         end\n         if ok then\n            return i\n      \
    \   end\n      end\n      return -1\n   end\n   local function join(lst)\n   \
    \   local res = {}\n      for _, v in ipairs(lst) do\n         for _, c in ipairs(v)\
    \ do\n            table.insert(res, c)\n         end\n      end\n      return\
    \ res\n   end\n   local function pop_parens(lst)\n      local res = {}\n     \
    \ local curr = {}\n      for i = 1, #lst do\n         if lst[i] == '(' then\n\
    \            table.insert(curr, lst[i])\n         else\n            table.insert(res,\
    \ curr)\n", "  -- your code here\n  return nil\nend", "  local open, close = lst[1],\
    \ lst[2]\n  if open == close then\n    return 'Yes'\n  end\n  return 'No'\nend",
  "  local function process(open, closed)\n    if open > closed then\n      return\
    \ 'No'\n    elseif open == closed then\n      return 'Yes'\n    else\n      return\
    \ process(open + 1, closed - 1)\n    end\n  end\n  local open = 0\n  local closed\
    \ = 0\n  for i = 1, #lst do\n    local str = lst[i]\n    for j = 1, #str do\n\
    \      local c = str:sub(j, j)\n      if c == '(' then\n        open = open +\
    \ 1\n      else\n        closed = closed + 1\n      end\n    end\n  end\n  return\
    \ process(open, closed)\nend", "\tlocal stack = {}\n\tfor _, str in ipairs(lst)\
    \ do\n\t\tfor ch in str:gmatch('.') do\n\t\t\tif ch == '(' then\n\t\t\t\ttable.insert(stack,\
    \ ch)\n\t\t\telse\n\t\t\t\tif #stack > 0 then\n\t\t\t\t\ttable.remove(stack)\n\
    \t\t\t\telse\n\t\t\t\t\treturn 'No'\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\
    return #stack == 0 and 'Yes' or 'No'\nend", "  -- your code goes here\nend", " \
    \ -- your code here\nend", "  local cnt1, cnt2 = 0, 0\n  for i = 1, #lst[1] do\n\
    \    cnt1 = cnt1 + (lst[1]:sub(i, i) == '(' and 1 or -1)\n  end\n  for i = 1,\
    \ #lst[2] do\n    cnt2 = cnt2 + (lst[2]:sub(i, i) == '(' and 1 or -1)\n  end\n\
    \  return (cnt1 + cnt2) >= 0 and 'Yes' or 'No'\nend", "  local cnt = 0\n  for\
    \ _, p in ipairs(lst) do\n    for char in p:gmatch('%(') do\n      cnt = cnt +\
    \ 1\n    end\n    for char in p:gmatch('%)') do\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend", "    local s = table.concat(lst)\n    local tmp = {}\n\
    \    for i = 1, #s do\n        local char = s:sub(i, i)\n        if char == '('\
    \ then\n            table.insert(tmp, char)\n        else\n            if #tmp\
    \ > 0 then\n                table.remove(tmp)\n            else\n            \
    \    return 'No'\n            end\n        end\n    end\n    return #tmp == 0\
    \ and 'Yes' or 'No'\nend", "  local ok = true\n  local cnt = 0\n  for i = 1, #lst\
    \ do\n    local s = lst[i]\n    for j = 1, #s do\n      if s:sub(j, j) == '('\
    \ then\n        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n\
    \      if cnt < 0 then\n        ok = false\n        break\n      end\n    end\n\
    \  end\n  return ok and cnt == 0 and 'Yes' or 'No'\nend", "  local left, right\
    \ = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('.') do\n      if\
    \ c == '(' then\n        left = left + 1\n      else\n        right = right +\
    \ 1\n      end\n    end\n  end\n  return left == right and 'Yes' or 'No'\nend",
  "  local function balance(str)\n    local bal = 0\n    for i = 1, #str do\n    \
    \  if str:sub(i, i) == '(' then\n        bal = bal + 1\n      else\n        bal\
    \ = bal - 1\n      end\n      if bal < 0 then\n        return false\n      end\n\
    \    end\n    return bal == 0\n  end\n  local s1, s2 = table.unpack(lst)\n  return\
    \ balance(s1 .. s2) and 'Yes' or 'No'\nend", "  local stack = {}\n  local function\
    \ push(x)\n    stack[#stack + 1] = x\n  end\n  local function pop()\n    stack[#stack]\
    \ = nil\n  end\n  local function top()\n    return stack[#stack]\n  end\n  local\
    \ function parenthesis_balance(s)\n    for i = 1, #s do\n      local c = s:sub(i,\
    \ i)\n      if c == '(' then\n        push(c)\n      elseif c == ')' then\n  \
    \      if top() == '(' then\n          pop()\n        else\n          return false\n\
    \        end\n      end\n    end\n    return #stack == 0\n  end\n  local function\
    \ next_combination(lst)\n    local n = #lst\n    local i = n\n    while i > 0\
    \ and lst[i] == ')' do\n      i = i - 1\n    end\n    if i <= 0 then\n      return\
    \ nil\n    end\n    lst[i] = ')'\n    for j = i + 1, n do\n      lst[j] = '('\n\
    \    end\n    return lst\n  end\n  local function next_permutation(lst)\n    local\
    \ n = #lst\n    local i = n - 1\n    while i > 0 and lst[i] >= lst[i + 1] do\n\
    \      i = i - 1\n    end\n    if i <= 0 then\n      return nil\n    end\n   \
    \ local j = n\n    while lst[j] <= lst[i] do\n      j = j - 1\n    end\n    lst[i],\
    \ lst[j] = lst[j], lst[i]\n    local k = i + 1\n    local l = n\n    while k <\
    \ l do\n      lst[k], lst[l] = lst[l], lst[k]\n      k = k + 1\n      l = l -\
    \ 1\n    end\n    return lst\n  end\n  while true do\n    if parenthesis_balance(table.concat(lst))\
    \ then\n      return 'Yes'\n    end\n    lst = next_permutation(lst)\n    if not\
    \ l", "  -- Get the two strings\n  local a, b = lst[1], lst[2]\n  -- Check if\
    \ both strings are good.\n  local function check(a, b)\n    local function count(str)\n\
    \      local n = 0\n      for c in str:gmatch'()' do\n        if c == '(' then\
    \ n = n + 1 else n = n - 1 end\n        if n < 0 then return false end\n     \
    \ end\n      return n == 0\n    end\n    return count(a) and count(b)\n  end\n\
    \  -- Recursively check the possible combinations\n  local function go(a, b)\n\
    \    if a == '' then return check(b, '') end\n    if b == '' then return check(a,\
    \ '') end\n    return go(a:sub(2), b) or go(a, b:sub(2))\n  end\n  -- Return the\
    \ result as 'Yes' or 'No'\n  return (go(a, b) and 'Yes' or 'No')\nend", "  local\
    \ s = table.concat(lst)\n  if s:match\"^%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%",
  "   local function check(s)\n      local bal = 0\n      for c in s:gmatch(\".\"\
    ) do\n         if c == \"(\" then\n            bal = bal + 1\n         else\n\
    \            bal = bal - 1\n         end\n         if bal < 0 then\n         \
    \   return false\n         end\n      end\n      return bal == 0\n   end\n   if\
    \ #lst[1] == 0 then\n      return check(lst[2]) and \"Yes\" or \"No\"\n   elseif\
    \ #lst[2] == 0 then\n      return check(lst[1]) and \"Yes\" or \"No\"\n   else\n\
    \      return (check(lst[1] .. lst[2]) or check(lst[2] .. lst[1])) and \"Yes\"\
    \ or \"No\"\n   end\nend", "\tlocal a, b = lst[1], lst[2]\n\tlocal pa, pb = 0,\
    \ 0\n\tfor i = 1, #a do\n\t\tif a:sub(i, i) == '(' then\n\t\t\tpa = pa + 1\n\t\
    \telse\n\t\t\tpa = pa - 1\n\t\tend\n\tend\n\tfor i = 1, #b do\n\t\tif b:sub(i,\
    \ i) == '(' then\n\t\t\tpb = pb + 1\n\t\telse\n\t\t\tpb = pb - 1\n\t\tend\n\t\
    end\n\tif pa < 0 or pb < 0 then\n\t\treturn 'No'\n\tend\n\treturn 'Yes'\nend",
  "  local str1, str2 = lst[1], lst[2]\n  local cnt1, cnt2 = 0, 0\n  for i = 1, #str1\
    \ do\n    if str1:sub(i, i) == '(' then\n      cnt1 = cnt1 + 1\n    else\n   \
    \   cnt1 = cnt1 - 1\n    end\n  end\n  for i = 1, #str2 do\n    if str2:sub(i,\
    \ i) == '(' then\n      cnt2 = cnt2 + 1\n    else\n      cnt2 = cnt2 - 1\n   \
    \ end\n  end\n  if (cnt1 + cnt2) % 2 == 0 then\n    return 'Yes'\n  else\n   \
    \ return 'No'\n  end\nend", "    local function balanced(s)\n        local level\
    \ = 0\n        for c in s:gmatch\".\" do\n            if c == \"(\" then\n   \
    \             level = level + 1\n            else\n                level = level\
    \ - 1\n            end\n            if level < 0 then\n                return\
    \ false\n            end\n        end\n        return level == 0\n    end\n  \
    \  return balanced(lst[1] .. lst[2]) and \"Yes\" or \"No\"\nend", "    local s\
    \ = table.concat(lst)\n    if s:match(\"^()$\") or s:match(\"^()%(.*%)$\") or\
    \ s:match(\"^.*%(.*%)()$\") or s:match(\"^%(.*%)()%(.*%)$\") then\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend", "  local extra = 0\n\
    \  for _, s in ipairs(lst) do\n    for c in s:gmatch(\".\") do\n      if c ==\
    \ '(' then\n        extra = extra + 1\n      else\n        extra = extra - 1\n\
    \      end\n      if extra < 0 then\n        return 'No'\n      end\n    end\n\
    \  end\n  return extra == 0 and 'Yes' or 'No'\nend", "  local s = 'Yes'\n  local\
    \ c = 0\n  for i = 1, #lst do\n    c = c + (lst[i]:sub(1, 1) == '(' and 1 or -1)\n\
    \    if c < 0 then\n      s = 'No'\n      break\n    end\n  end\n  return s\n\
    end", "  local function count_parens(str)\n    local _, cnt = str:gsub('%(', '%(')\n\
    \    local _, cnt_ = str:gsub('%)', '%)')\n    return cnt, cnt_\n  end\n  local\
    \ function concat_parens(lst)\n    local str = ''\n    for _, val in ipairs(lst)\
    \ do\n      str = str .. val\n    end\n    return str\n  end\n  local counts =\
    \ {}\n  for _, str in ipairs(lst) do\n    local cnt, cnt_ = count_parens(str)\n\
    \    if cnt == cnt_ then\n      table.insert(counts, 0)\n    else\n      table.insert(counts,\
    \ cnt - cnt_)\n    end\n  end\n  local strs = {}\n  for _, cnt in ipairs(counts)\
    \ do\n    if cnt > 0 then\n      strs[1] = strs[1] or '('\n      if cnt == 1 then\n\
    \        strs[1] = strs[1] .. ')'\n      else\n        strs[1] = strs[1] .. ('('):rep(cnt\
    \ - 1) .. ')'\n      end\n    elseif cnt < 0 then\n      strs[2] = strs[2] or\
    \ ')'\n      if cnt == -1 then\n        strs[2] = strs[2] .. '('\n      else\n\
    \        strs[2] = strs[2] .. (')'):rep(-cnt - 1) .. '('\n      end\n    end\n\
    \  end\n  local str = concat_parens(strs)\n  local _, cnt = str:gsub('%(%(', '%(')\n\
    \  local _, cnt_ = str:gsub('%)%)', '%)')\n  if cnt == cnt_ then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "  local function balance(str)\n    local\
    \ counter = 0\n    for c in str:gmatch(\".\") do\n      if c == '(' then\n   \
    \     counter = counter + 1\n      else\n        counter = counter - 1\n     \
    \ end\n      if counter < 0 then\n        return false\n      end\n    end\n \
    \   return counter == 0\n  end\n  local str = table.concat(lst)\n  return balance(str)\
    \ and 'Yes' or 'No'\nend", "    local x, y = lst[1], lst[2]\n    local xm, ym\
    \ = 0, 0\n    for i = 1, #x do\n        xm = xm + (x:sub(i, i) == '(' and 1 or\
    \ -1)\n    end\n    for i = 1, #y do\n        ym = ym + (y:sub(i, i) == '(' and\
    \ 1 or -1)\n    end\n    if xm == 0 and ym == 0 then\n        return 'Yes'\n \
    \   elseif xm < 0 and ym < 0 then\n        return 'No'\n    elseif xm > 0 and\
    \ ym > 0 then\n        return 'No'\n    elseif xm + ym > 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "  local function good(s)\n\
    \    local c = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n   \
    \     c = c + 1\n      else\n        c = c - 1\n      end\n      if c < 0 then\n\
    \        return false\n      end\n    end\n    return c == 0\n  end\n  return\
    \ (good(lst[1]) and good(lst[2])) and 'Yes' or 'No'\nend", "  local left, right\
    \ = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch(\"%(\") do left\
    \ = left + 1 end\n    for c in s:gmatch(\"%)\") do right = right + 1 end\n  end\n\
    \  return left == right and \"Yes\" or \"No\"\nend", "  local a = lst[1]\n  local\
    \ b = lst[2]\n  local open = 0\n  local close = 0\n  for _, c in ipairs(a) do\n\
    \    if c == '(' then\n      open = open + 1\n    else\n      close = close +\
    \ 1\n    end\n  end\n  for _, c in ipairs(b) do\n    if c == '(' then\n      open\
    \ = open + 1\n    else\n      close = close + 1\n    end\n  end\n  if open ~=\
    \ close then\n    return 'No'\n  end\n  local s = ''\n  while #a > 0 or #b > 0\
    \ do\n    local ca = a:sub(1, 1)\n    local cb = b:sub(1, 1)\n    if ca == '('\
    \ then\n      s = s .. ca\n      a = a:sub(2)\n    elseif cb == '(' then\n   \
    \   s = s .. cb\n      b = b:sub(2)\n    elseif ca == ')' then\n      s = s ..\
    \ ca\n      a = a:sub(2)\n    elseif cb == ')' then\n      s = s .. cb\n     \
    \ b = b:sub(2)\n    end\n  end\n  open = 0\n  close = 0\n  for _, c in ipairs(s)\
    \ do\n    if c == '(' then\n      open = open + 1\n    else\n      close = close\
    \ + 1\n    end\n    if close > open then\n      return 'No'\n    end\n  end\n\
    \  return 'Yes'\nend", "  local good, bad = 0, 0\n  for _, s in ipairs(lst) do\n\
    \    for _, c in ipairs(s:gmatch('.')) do\n      if c == '(' then\n        good\
    \ = good + 1\n      else\n        if good == 0 then\n          bad = bad + 1\n\
    \        else\n          good = good - 1\n        end\n      end\n    end\n  end\n\
    \  return good == 0 and bad == 0 and 'Yes' or 'No'\nend", "    local a, b = lst[1],\
    \ lst[2]\n    local c = {\n        ['()'] = true,\n        [')('] = true,\n  \
    \      ['(('] = true,\n        ['))'] = true,\n    }\n    return (c[a .. b] and\
    \ 'Yes') or 'No'\nend", "  local balance = 0\n  for _, paren in ipairs(lst) do\n\
    \    for c in paren:gmatch(\".\") do\n      if c == '(' then\n        balance\
    \ = balance + 1\n      else\n        balance = balance - 1\n      end\n      if\
    \ balance < 0 then\n        return 'No'\n      end\n    end\n  end\n  return balance\
    \ == 0 and 'Yes' or 'No'\nend", "    local open = 0\n    local close = 0\n   \
    \ for i = 1, #lst[1] do\n        if lst[1]:sub(i, i) == '(' then\n           \
    \ open = open + 1\n        else\n            close = close + 1\n        end\n\
    \    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n\
    \            open = open + 1\n        else\n            close = close + 1\n  \
    \      end\n    end\n    if open > close then\n        return 'Yes'\n    else\n\
    \        return 'No'\n    end\nend", "  if not lst[1] then return 'Yes' end\n\
    \  local l, r = lst[1]:gsub('%(', ''), lst[2]:gsub('%)', '')\n  if l == '' and\
    \ r == '' then return 'Yes' end\n  if l ~= '' and r ~= '' then return 'No' end\n\
    \  if l == '' then return match_parens{'', lst[2]:gsub('%)', '', 1)} end\n  return\
    \ match_parens{lst[1]:gsub('%(', '', 1), ''}\nend", "  local function helper(s)\n\
    \    local cnt = 0\n    for i = 1, #s do\n      local ch = s:sub(i, i)\n     \
    \ if ch == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n\
    \      end\n      if cnt < 0 then\n        return false\n      end\n    end\n\
    \    return cnt == 0\n  end\n  local s1, s2 = table.unpack(lst)\n  return helper(s1)\
    \ and helper(s2) and (helper(s1 .. s2) or helper(s2 .. s1))\nend", "    local\
    \ r = {\"Yes\"}\n    for i = 1, #lst do\n        for c in lst[i]:gmatch(\"%S\"\
    ) do\n            if c == \"(\" then\n                r[#r + 1] = c\n        \
    \    else\n                r[#r] = nil\n                if #r == 0 then\n    \
    \                return \"No\"\n                end\n            end\n       \
    \ end\n    end\n    return table.concat(r)\nend", "   local function count_parens(str)\n\
    \      local cnt, bal = 0, 0\n      for _, c in ipairs(str) do\n         if c\
    \ == '(' then\n            bal = bal + 1\n         else\n            bal = bal\
    \ - 1\n         end\n         if bal < 0 then\n            cnt = cnt + 1\n   \
    \      end\n      end\n      return cnt, bal\n   end\n   local cnt1, bal1 = count_parens(lst[1])\n\
    \   local cnt2, bal2 = count_parens(lst[2])\n   if cnt1 > cnt2 then\n      return\
    \ 'No'\n   end\n   if bal1 < 0 and bal2 > 0 then\n      return 'No'\n   end\n\
    \   return 'Yes'\nend", "    local is_good = function(s)\n        local stack\
    \ = {}\n        for c in s:gmatch('.') do\n            if c == '(' then\n    \
    \            table.insert(stack, c)\n            else\n                if #stack\
    \ == 0 then\n                    return false\n                end\n         \
    \       table.remove(stack)\n            end\n        end\n        return #stack\
    \ == 0\n    end\n    if is_good(lst[1]) and is_good(lst[2]) then\n        return\
    \ 'Yes'\n    end\n    if is_good(lst[1] .. lst[2]) then\n        return 'Yes'\n\
    \    end\n    if is_good(lst[2] .. lst[1]) then\n        return 'Yes'\n    end\n\
    \    return 'No'\nend", "  local open = {}\n  local close = {}\n  for _, s in\
    \ ipairs(lst) do\n    if s == '(' then\n      table.insert(open, s)\n    else\n\
    \      table.insert(close, s)\n    end\n  end\n  local good = true\n  for _, c\
    \ in ipairs(close) do\n    if #open == 0 then\n      good = false\n      break\n\
    \    end\n    table.remove(open)\n  end\n  if #open == 0 and good then\n    return\
    \ 'Yes'\n  else\n    return 'No'\n  end\nend", "    local function extract_parens(s)\n\
    \        local parens = {}\n        for i = 1, #s do\n            local c = s:sub(i,\
    \ i)\n            if c == '(' then\n                table.insert(parens, 1, c)\n\
    \            else\n                if #parens > 0 then\n                    table.remove(parens,\
    \ 1)\n                else\n                    return false\n               \
    \ end\n            end\n        end\n        return true\n    end\n    local s1,\
    \ s2 = lst[1], lst[2]\n    local s1_good = extract_parens(s1)\n    local s2_good\
    \ = extract_parens(s2)\n    if s1_good then\n        return s2_good and 'Yes'\
    \ or 'No'\n    else\n        return s2_good and 'No' or 'Yes'\n    end\nend",
  "  local t = { ['('] = 1, [')'] = -1 }\n  local s = 0\n  for _,v in ipairs(lst)\
    \ do\n    for i = 1, #v do\n      s = s + t[v:sub(i,i)]\n      if s < 0 then return\
    \ 'No' end\n    end\n  end\n  return (s == 0) and 'Yes' or 'No'\nend", "  local\
    \ num_open = 0\n  local num_close = 0\n  for i = 1, #lst do\n    local str = lst[i]\n\
    \    for j = 1, #str do\n      local c = str:sub(j, j)\n      if c == '(' then\n\
    \        num_open = num_open + 1\n      else\n        num_close = num_close +\
    \ 1\n      end\n    end\n  end\n  if num_open == num_close then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend", "  -- your code here\nend", "  -- your\
    \ code here\n  local function parens_str(str)\n    local t = {}\n    for i=1,\
    \ #str do\n      if str:sub(i,i) == '(' then table.insert(t, '(') end\n      if\
    \ str:sub(i,i) == ')' then table.insert(t, ')') end\n    end\n    return t\n \
    \ end\n  if not lst[1] then return 'Yes' end\n  if not lst[2] then return 'Yes'\
    \ end\n  if #lst[1] == 1 and #lst[2] == 1 then\n    return 'No'\n  end\n  local\
    \ str1 = parens_str(lst[1])\n  local str2 = parens_str(lst[2])\n  if #str1 ==\
    \ 0 and #str2 == 0 then return 'Yes' end\n  if #str1 == 0 and #str2 > 0 then return\
    \ 'No' end\n  if #str1 > 0 and #str2 == 0 then return 'No' end\n  if #str1 ==\
    \ #str2 then return 'Yes' end\n  local t = {}\n  for i=1, #str1 do\n    table.insert(t,\
    \ str1[i])\n  end\n  for i=1, #str2 do\n    table.insert(t, str2[i])\n  end\n\
    \  local stack = {}\n  for i=1, #t do\n    if t[i] == '(' then\n      table.insert(stack,\
    \ t[i])\n    else\n      if #stack == 0 then return 'No' end\n      if stack[#stack]\
    \ == '(' then\n        table.remove(stack)\n      else\n        return 'No'\n\
    \      end\n    end\n  end\n  if #stack == 0 then return 'Yes' end\n  return 'No'\n\
    end", "    -- your code here\nend", "  local l1, l2 = lst[1], lst[2]\n  local\
    \ s1, s2 = string.match(l1, \"^(%(*)()\"), string.match(l2, \"^(%(*)()\")\n  if\
    \ s1 and s2 then\n    return s1 == s2 and \"Yes\" or \"No\"\n  elseif (s1 and\
    \ not s2) or (not s1 and s2) then\n    return \"No\"\n  else\n    return match_parens({string.sub(l1,\
    \ 2), string.sub(l2, 2)})\n  end\nend", "    local s = {}\n    for _, v in ipairs(lst)\
    \ do\n        for i = 1, #v do\n            local c = v:sub(i, i)\n          \
    \  if c == '(' then\n                table.insert(s, c)\n            else\n  \
    \              if #s == 0 then\n                    return 'No'\n            \
    \    end\n                table.remove(s)\n            end\n        end\n    end\n\
    \    return #s == 0 and 'Yes' or 'No'\nend", "    local counter = 0\n    for _,\
    \ v in ipairs(lst) do\n        for i = 1, #v do\n            if v:sub(i, i) ==\
    \ '(' then\n                counter = counter + 1\n            else\n        \
    \        counter = counter - 1\n            end\n            if counter < 0 then\n\
    \                return 'No'\n            end\n        end\n    end\n    return\
    \ counter == 0 and 'Yes' or 'No'\nend", "  local a = lst[1]\n  local b = lst[2]\n\
    \  local function count(s)\n    local c = 0\n    for i = 1, #s do\n      local\
    \ ch = s:sub(i, i)\n      if ch == '(' then\n        c = c + 1\n      else\n \
    \       c = c - 1\n      end\n      if c < 0 then\n        return -1\n      end\n\
    \    end\n    return c\n  end\n  local ca = count(a)\n  local cb = count(b)\n\
    \  if ca == 0 and cb == 0 then\n    return 'Yes'\n  elseif ca == -1 or cb == -1\
    \ then\n    return 'No'\n  elseif (ca > 0 and cb > 0) or (ca < 0 and cb < 0) then\n\
    \    return 'No'\n  else\n    local s = a .. b\n    if count(s) == 0 then\n  \
    \    return 'Yes'\n    else\n      return 'No'\n    end\n  end\nend", "    local\
    \ function helper(lst, cnt)\n        for _, v in ipairs(lst) do\n            if\
    \ cnt < 0 then return false end\n            if v == '(' then cnt = cnt + 1\n\
    \            else cnt = cnt - 1 end\n        end\n        return cnt == 0\n  \
    \  end\n    return helper(lst[1], 0) and helper(lst[2], 0) and 'Yes' or 'No'\n\
    end", "    local open = 0\n    local close = 0\n    for i = 1, #lst[1] do\n  \
    \      if lst[1]:sub(i, i) == '(' then\n            open = open + 1\n        else\n\
    \            close = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            open = open + 1\n      \
    \  else\n            close = close + 1\n        end\n    end\n    if open == close\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend", " \
    \ local good_count, bad_count = 0, 0\n  for _, s in ipairs(lst) do\n    for p\
    \ in s:gmatch('%(') do good_count = good_count + 1 end\n    for p in s:gmatch('%)')\
    \ do\n      if good_count == 0 then bad_count = bad_count + 1\n      else good_count\
    \ = good_count - 1 end\n    end\n  end\n  return (good_count == 0 and bad_count\
    \ == 0) and 'Yes' or 'No'\nend", "    local count = 0\n    for i, s in ipairs(lst)\
    \ do\n        for c in s:gmatch('[()]') do\n            if c == '(' then\n   \
    \             count = count + 1\n            else\n                count = count\
    \ - 1\n            end\n            if count < 0 then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return count == 0 and 'Yes'\
    \ or 'No'\nend", "    local left_parens, right_parens = 0, 0\n    for _, c in\
    \ ipairs(lst[1]) do\n        if c == '(' then\n            left_parens = left_parens\
    \ + 1\n        else\n            left_parens = left_parens - 1\n        end\n\
    \    end\n    for _, c in ipairs(lst[2]) do\n        if c == ')' then\n      \
    \      right_parens = right_parens + 1\n        else\n            right_parens\
    \ = right_parens - 1\n        end\n    end\n    if left_parens >= 0 and right_parens\
    \ >= 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "    local str = table.concat(lst)\n    local level = 0\n    for i = 1, #str do\n\
    \        if str:sub(i, i) == '(' then\n            level = level + 1\n       \
    \ else\n            level = level - 1\n        end\n        if level < 0 then\n\
    \            return 'No'\n        end\n    end\n    return level == 0 and 'Yes'\
    \ or 'No'\nend", "    local u, v = lst[1], lst[2]\n    local s = 0\n    for i\
    \ = 1, #u do\n        if u:sub(i, i) == '(' then\n            s = s + 1\n    \
    \    else\n            s = s - 1\n        end\n    end\n    for i = 1, #v do\n\
    \        if v:sub(i, i) == '(' then\n            s = s + 1\n        else\n   \
    \         s = s - 1\n        end\n    end\n    if s == 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend", "  local cnt = 0\n  for\
    \ _,s in ipairs(lst) do\n    for i=1,#s do\n      local c = s:sub(i,i)\n     \
    \ if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt - 1\n\
    \      end\n      if cnt < 0 then\n        return 'No'\n      end\n    end\n \
    \ end\n  return cnt == 0 and 'Yes' or 'No'\nend", "   -- your code goes here\n\
    \   local function balance(str)\n      local count = 0\n      for i=1,#str do\n\
    \         if str:sub(i,i) == '(' then\n            count = count + 1\n       \
    \  else\n            count = count - 1\n         end\n         if count < 0 then\n\
    \            return false\n         end\n      end\n      return count == 0\n\
    \   end\n   return balance(lst[1]..lst[2]) and 'Yes' or 'No'\nend", "  -- your\
    \ code here!\nend", "  local s = lst[1] .. lst[2]\n  local tmp = 0\n  for i =\
    \ 1, #s do\n    local c = s:sub(i, i)\n    if c == '(' then\n      tmp = tmp +\
    \ 1\n    else\n      tmp = tmp - 1\n    end\n    if tmp < 0 then\n      return\
    \ 'No'\n    end\n  end\n  return tmp == 0 and 'Yes' or 'No'\nend", "    local\
    \ balance = 0\n    for _, s in ipairs(lst) do\n        for i = 1, #s do\n    \
    \        local c = s:sub(i, i)\n            if c == '(' then\n               \
    \ balance = balance + 1\n            else\n                balance = balance -\
    \ 1\n            end\n            if balance < 0 then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return balance == 0 and 'Yes'\
    \ or 'No'\nend", "    local function balance(parens)\n        local len = #parens\n\
    \        local sum = 0\n        for i = 1, len do\n            if parens:sub(i,\
    \ i) == '(' then\n                sum = sum + 1\n            else\n          \
    \      sum = sum - 1\n            end\n            if sum < 0 then\n         \
    \       return false\n            end\n        end\n        return sum == 0\n\
    \    end\n    local s1, s2 = lst[1], lst[2]\n    return balance(s1 .. s2) or balance(s2\
    \ .. s1) and 'Yes' or 'No'\nend\n_G.match_parens = match_parens", "    local d\
    \ = {[0] = 1}\n    for i, v in ipairs(lst) do\n        for c in v:gmatch'.' do\n\
    \            d[i] = (d[i - 1] or 0) + (c == '(' and 1 or -1)\n            if d[i]\
    \ < 0 then return 'No' end\n        end\n    end\n    return (d[#lst] or 0) ==\
    \ 0 and 'Yes' or 'No'\nend", "\tlocal function helper(s1, s2)\n\t\tlocal function\
    \ is_good(str)\n\t\t\tlocal s = 0\n\t\t\tfor i = 1, #str do\n\t\t\t\tif str:sub(i,\
    \ i) == '(' then\n\t\t\t\t\ts = s + 1\n\t\t\t\telse\n\t\t\t\t\ts = s - 1\n\t\t\
    \t\tend\n\t\t\t\tif s < 0 then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\
    \t\t\treturn s == 0\n\t\tend\n\t\treturn is_good(s1 .. s2) or is_good(s2 .. s1)\n\
    \tend\n\treturn helper(lst[1], lst[2]) and 'Yes' or 'No'\nend", "    local function\
    \ count_parens(str)\n        return str:gsub('%(', ''):len() - str:gsub('%)',\
    \ ''):len()\n    end\n    local function is_good(str)\n        local cnt = count_parens(str)\n\
    \        return cnt == 0\n    end\n    local s0, s1 = lst[1], lst[2]\n    if is_good(s0)\
    \ then\n        return 'Yes'\n    elseif is_good(s1) then\n        return 'Yes'\n\
    \    elseif is_good(s0 .. s1) then\n        return 'Yes'\n    elseif is_good(s1\
    \ .. s0) then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end", "  local function eval(str)\n    local x = 0\n    for i = 1, str:len() do\n\
    \      if str:sub(i, i) == '(' then\n        x = x + 1\n      else\n        x\
    \ = x - 1\n      end\n      if x < 0 then\n        return false\n      end\n \
    \   end\n    return x == 0\n  end\n  if lst[1] == ')' or lst[2] == ')' then\n\
    \    return 'No'\n  end\n  local str = lst[1] .. lst[2]\n  return eval(str) and\
    \ 'Yes' or 'No'\nend", "    local s = ''\n    for _,s1 in ipairs(lst) do\n   \
    \     s = s .. s1\n    end\n    s = s:gsub('%(%s*%)', '')\n    while s:find('%(%)')\
    \ do\n        s = s:gsub('%(%)', '')\n    end\n    return (s == '') and 'Yes'\
    \ or 'No'\nend", "  local closed, opened = 0, 0\n  for _, s in ipairs(lst) do\n\
    \    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        opened = opened\
    \ + 1\n      else\n        closed = closed + 1\n      end\n    end\n  end\n  return\
    \ opened >= closed and 'Yes' or 'No'\nend", "  local s = lst[1] .. lst[2]\n  local\
    \ count = 0\n  for i = 1, #s do\n    if s:sub(i, i) == '(' then\n      count =\
    \ count + 1\n    else\n      count = count - 1\n    end\n    if count < 0 then\n\
    \      return 'No'\n    end\n  end\n  if count == 0 then\n    return 'Yes'\n \
    \ else\n    return 'No'\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
