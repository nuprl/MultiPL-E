name: HumanEval_136_largest_smallest_integers
language: lua
prompt: "-- Create a function that returns a tuple (a, b), where 'a' is\n-- the largest\
  \ of negative integers, and 'b' is the smallest\n-- of positive integers in a list.\n\
  -- If there is no negative or positive integers, return them as None.\n-- Examples:\n\
  -- largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n-- largest_smallest_integers([])\
  \ == (None, None)\n-- largest_smallest_integers([0]) == (None, None)\nlocal function\
  \ largest_smallest_integers(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n\
  \    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2,\
  \ 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5,\
  \ 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7,\
  \ 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}),\
  \ {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1,\
  \ -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}),\
  \ {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n  \
  \  lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: [end, "    if not lst or not next(lst) then\n        return nil, nil\n\
    \    end\n    local smallest, largest\n    for _, i in ipairs(lst) do\n      \
    \  if i > 0 then\n            if smallest == nil or i < smallest then\n      \
    \          smallest = i\n            end\n        elseif i < 0 then\n        \
    \    if largest == nil or i > largest then\n                largest = i\n    \
    \        end\n        end\n    end\n    return largest, smallest\nend", "  local\
    \ negative, positive\n  for _, v in ipairs(lst) do\n    if v < 0 then\n      if\
    \ not negative or v > negative then\n        negative = v\n      end\n    elseif\
    \ v > 0 then\n      if not positive or v < positive then\n        positive = v\n\
    \      end\n    end\n  end\n  return negative, positive\nend", "  local largest\
    \ = nil\n  local smallest = nil\n  for _, n in ipairs(lst) do\n    if n < 0 then\n\
    \      if largest == nil or n > largest then\n        largest = n\n      end\n\
    \    elseif n > 0 then\n      if smallest == nil or n < smallest then\n      \
    \  smallest = n\n      end\n    end\n  end\n  return largest, smallest\nend",
  "  local a, b\n  for _, v in ipairs(lst) do\n    if v < 0 then\n      if a == nil\
    \ or v > a then\n        a = v\n      end\n    elseif v > 0 then\n      if b ==\
    \ nil or v < b then\n        b = v\n      end\n    end\n  end\n  return a, b\n\
    end", "  local max_neg = nil\n  local min_pos = nil\n  for i = 1, #lst do\n  \
    \  if lst[i] < 0 then\n      if max_neg == nil or lst[i] > max_neg then\n    \
    \    max_neg = lst[i]\n      end\n    elseif lst[i] > 0 then\n      if min_pos\
    \ == nil or lst[i] < min_pos then\n        min_pos = lst[i]\n      end\n    end\n\
    \  end\n  return max_neg, min_pos\nend", "  -- Implement me!\nend", end, "   \
    \ return nil, nil\nend", "  if #lst == 0 then\n    return nil, nil\n  end\n  local\
    \ function is_negative(elem)\n    return elem < 0\n  end\n  local function is_positive(elem)\n\
    \    return elem > 0\n  end\n  local negatives = {}\n  local positives = {}\n\
    \  for i, elem in ipairs(lst) do\n    if is_negative(elem) then\n      table.insert(negatives,\
    \ elem)\n    elseif is_positive(elem) then\n      table.insert(positives, elem)\n\
    \    end\n  end\n  if #negatives == 0 then\n    table.insert(negatives, nil)\n\
    \  end\n  if #positives == 0 then\n    table.insert(positives, nil)\n  end\n \
    \ return math.max(unpack(negatives)), math.min(unpack(positives))\nend", "   \
    \ local maxNeg = 0\n    local minPos = math.huge\n    for i,v in ipairs(lst) do\n\
    \        if v < 0 then\n            if v > maxNeg then\n                maxNeg\
    \ = v\n            end\n        elseif v > 0 then\n            if v < minPos then\n\
    \                minPos = v\n            end\n        end\n    end\n    if maxNeg\
    \ == 0 then\n        maxNeg = nil\n    end\n    if minPos == math.huge then\n\
    \        minPos = nil\n    end\n    return maxNeg, minPos\nend", "  return None,\
    \ None\nend", "    local a, b = nil, nil\n    for i = 1, #lst do\n        if lst[i]\
    \ < 0 and (a == nil or lst[i] > a) then\n            a = lst[i]\n        elseif\
    \ lst[i] > 0 and (b == nil or lst[i] < b) then\n            b = lst[i]\n     \
    \   end\n    end\n    return a, b\nend", "  local largest_neg, smallest_pos =\
    \ None, None\n  for _, v in ipairs(lst) do\n    if v < 0 then\n      if largest_neg\
    \ == None or v > largest_neg then\n        largest_neg = v\n      end\n    elseif\
    \ v > 0 then\n      if smallest_pos == None or v < smallest_pos then\n       \
    \ smallest_pos = v\n      end\n    end\n  end\n  return largest_neg, smallest_pos\n\
    end", "    local largest_negative, smallest_positive = nil, nil\n    for _, n\
    \ in ipairs(lst) do\n        if n < 0 then\n            if largest_negative ==\
    \ nil or n > largest_negative then\n                largest_negative = n\n   \
    \         end\n        elseif n > 0 then\n            if smallest_positive ==\
    \ nil or n < smallest_positive then\n                smallest_positive = n\n \
    \           end\n        end\n    end\n    return largest_negative, smallest_positive\n\
    end\nassert(largest_smallest_integers({2, 4, 1, 3, 5, 7}) == (nil, 1))\nassert(largest_smallest_integers({})\
    \ == (nil, nil))\nassert(largest_smallest_integers({0}) == (nil, nil))", "   \
    \ local neg, pos = nil, nil\n    for _, num in ipairs(lst) do\n        if num\
    \ < 0 then\n            if neg == nil or num > neg then\n                neg =\
    \ num\n            end\n        elseif num > 0 then\n            if pos == nil\
    \ or num < pos then\n                pos = num\n            end\n        end\n\
    \    end\n    return neg, pos\nend", '    -- your code here', "    if not lst\
    \ then\n        return nil, nil\n    end\n    local min, max\n    for _, el in\
    \ ipairs(lst) do\n        if el > 0 then\n            if not min or el < min then\n\
    \                min = el\n            end\n        elseif el < 0 then\n     \
    \       if not max or el > max then\n                max = el\n            end\n\
    \        end\n    end\n    return max, min\nend", "    local pos, neg = None,\
    \ None\n    for i = 1, #lst do\n        if lst[i] < 0 then\n            if neg\
    \ == None or lst[i] > neg then\n                neg = lst[i]\n            end\n\
    \        elseif lst[i] > 0 then\n            if pos == None or lst[i] < pos then\n\
    \                pos = lst[i]\n            end\n        end\n    end\n    return\
    \ neg, pos\nend", "  if #lst == 0 then\n    return (None, None)\n  end\n  local\
    \ min, max = lst[1], lst[1]\n  for i = 2, #lst do\n    if lst[i] < min then\n\
    \      min = lst[i]\n    end\n    if lst[i] > max then\n      max = lst[i]\n \
    \   end\n  end\n  if min > 0 then\n    min = None\n  end\n  if max < 0 then\n\
    \    max = None\n  end\n  return (max, min)\nend", end, "  local maxn, minp =\
    \ -(10^100), 10^100\n  local maxn_found, minp_found = false, false\n  for _, i\
    \ in ipairs(lst) do\n    if i < 0 then\n      maxn_found = true\n      if i >\
    \ maxn then\n        maxn = i\n      end\n    elseif i > 0 then\n      minp_found\
    \ = true\n      if i < minp then\n        minp = i\n      end\n    end\n  end\n\
    \  if not maxn_found then\n    maxn = nil\n  end\n  if not minp_found then\n \
    \   minp = nil\n  end\n  return maxn, minp\nend", "    -- TODO: Implementation\
    \ here\nend", "    local a, b = None, None\n    for _, v in ipairs(lst) do\n \
    \       if v > 0 then\n            if b == None or v < b then\n              \
    \  b = v\n            end\n        elseif v < 0 then\n            if a == None\
    \ or v > a then\n                a = v\n            end\n        end\n    end\n\
    \    return a, b\nend", "    local a, b = nil, nil\n    for _, v in ipairs(lst)\
    \ do\n        if v < 0 then\n            if a == nil or v > a then\n         \
    \       a = v\n            end\n        elseif v > 0 then\n            if b ==\
    \ nil or v < b then\n                b = v\n            end\n        end\n   \
    \ end\n    return a, b\nend", "    return (None, None)\nend", "    return (None,\
    \ None)\nend", "    local smallest, largest\n    for _, n in ipairs(lst) do\n\
    \        if n > 0 then\n            if smallest == nil or n < smallest then\n\
    \                smallest = n\n            end\n        elseif n < 0 then\n  \
    \          if largest == nil or n > largest then\n                largest = n\n\
    \            end\n        end\n    end\n    return largest, smallest\nend", " \
    \   local min_pos = nil\n    local max_neg = nil\n    for i = 1, #lst do\n   \
    \     if lst[i] > 0 then\n            if min_pos == nil or lst[i] < min_pos then\n\
    \                min_pos = lst[i]\n            end\n        elseif lst[i] < 0\
    \ then\n            if max_neg == nil or lst[i] > max_neg then\n             \
    \   max_neg = lst[i]\n            end\n        end\n    end\n    return max_neg,\
    \ min_pos\nend", "    return (None, None)\nend", "    local negative, positive\
    \ = {}, {}\n    for _, v in ipairs(lst) do\n        if v < 0 then\n          \
    \  table.insert(negative, v)\n        elseif v > 0 then\n            table.insert(positive,\
    \ v)\n        end\n    end\n    local s, l\n    if #negative > 0 then\n      \
    \  l = table.remove(negative)\n        for _, v in ipairs(negative) do\n     \
    \       if v > l then\n                l = v\n            end\n        end\n \
    \   end\n    if #positive > 0 then\n        s = table.remove(positive)\n     \
    \   for _, v in ipairs(positive) do\n            if v < s then\n             \
    \   s = v\n            end\n        end\n    end\n    return l, s\nend", "   \
    \ if #lst == 0 then\n        return nil, nil\n    end\n    local maxn, minp =\
    \ math.mininteger, math.maxinteger\n    for i = 1, #lst do\n        if lst[i]\
    \ < 0 and lst[i] > maxn then\n            maxn = lst[i]\n        elseif lst[i]\
    \ > 0 and lst[i] < minp then\n            minp = lst[i]\n        end\n    end\n\
    \    if maxn == math.mininteger then\n        maxn = nil\n    end\n    if minp\
    \ == math.maxinteger then\n        minp = nil\n    end\n    return maxn, minp\n\
    end", "    local max_neg = nil\n    local min_pos = nil\n    for i = 1, #lst do\n\
    \        local v = lst[i]\n        if v < 0 then\n            if max_neg == nil\
    \ or v > max_neg then\n                max_neg = v\n            end\n        elseif\
    \ v > 0 then\n            if min_pos == nil or v < min_pos then\n            \
    \    min_pos = v\n            end\n        end\n    end\n    return max_neg, min_pos\n\
    end", "    local largest_neg = nil\n    local smallest_pos = nil\n    for i, v\
    \ in ipairs(lst) do\n        if v < 0 then\n            if largest_neg == nil\
    \ or v > largest_neg then\n                largest_neg = v\n            end\n\
    \        elseif v > 0 then\n            if smallest_pos == nil or v < smallest_pos\
    \ then\n                smallest_pos = v\n            end\n        end\n    end\n\
    \    return largest_neg, smallest_pos\nend", "    local a, b = 0, 0\n    for _,\
    \ v in ipairs(lst) do\n        if v > 0 then\n            if b == 0 then\n   \
    \             b = v\n            elseif v < b then\n                b = v\n  \
    \          end\n        elseif v < 0 then\n            if a == 0 then\n      \
    \          a = v\n            elseif v > a then\n                a = v\n     \
    \       end\n        end\n    end\n    return (a == 0 and nil or a), (b == 0 and\
    \ nil or b)\nend", "    local function get_largest_negative(lst)\n        local\
    \ max = 0\n        for _, v in ipairs(lst) do\n            if v < 0 and v > max\
    \ then\n                max = v\n            end\n        end\n        return\
    \ max == 0 and nil or max\n    end", "   -- your code here\nend", "\tlocal min,\
    \ max\n\tfor _, v in ipairs(lst) do\n\t\tif v > 0 then\n\t\t\tif not min or v\
    \ < min then\n\t\t\t\tmin = v\n\t\t\tend\n\t\telseif v < 0 then\n\t\t\tif not\
    \ max or v > max then\n\t\t\t\tmax = v\n\t\t\tend\n\t\tend\n\tend\n\treturn max,\
    \ min\nend\nassert(largest_smallest_integers({2, 4, 1, 3, 5, 7}) == (nil, 1))\n\
    assert(largest_smallest_integers({}) == (nil, nil))\nassert(largest_smallest_integers({0})\
    \ == (nil, nil))", "  if #lst == 0 then\n    return {None, None}\n  end\n  local\
    \ min = 0\n  local max = 0\n  for k, v in pairs(lst) do\n    if v > 0 then\n \
    \     if min == 0 then\n        min = v\n      elseif v < min then\n        min\
    \ = v\n      end\n    elseif v < 0 then\n      if max == 0 then\n        max =\
    \ v\n      elseif v > max then\n        max = v\n      end\n    end\n  end\n \
    \ if min == 0 then\n    min = None\n  end\n  if max == 0 then\n    max = None\n\
    \  end\n  return {max, min}\nend", "\t-- TODO: your code here\nend", "    local\
    \ a, b\n    for _, i in ipairs(lst) do\n        if i < 0 then\n            if\
    \ not a or i > a then\n                a = i\n            end\n        elseif\
    \ i > 0 then\n            if not b or i < b then\n                b = i\n    \
    \        end\n        end\n    end\n    return a, b\nend", "  local a, b = nil,\
    \ nil\n  for k, v in ipairs(lst) do\n    if v > 0 then\n      if b == nil or v\
    \ < b then\n        b = v\n      end\n    elseif v < 0 then\n      if a == nil\
    \ or v > a then\n        a = v\n      end\n    end\n  end\n  return a, b\nend",
  "\treturn nil, nil\nend", "  -- your code here\nend", "  error(\"Not implemented\"\
    )\nend", "  return (None, None)\nend", "  -- your code\nend", "    local max =\
    \ nil\n    local min = nil\n    for i, v in ipairs(lst) do\n        if v > 0 then\n\
    \            if min == nil or v < min then\n                min = v\n        \
    \    end\n        elseif v < 0 then\n            if max == nil or v > max then\n\
    \                max = v\n            end\n        end\n    end\n    return max,\
    \ min\nend", "    local largest = nil\n    local smallest = nil\n    for i, n\
    \ in ipairs(lst) do\n        if n < 0 then\n            if largest == nil or n\
    \ > largest then\n                largest = n\n            end\n        elseif\
    \ n > 0 then\n            if smallest == nil or n < smallest then\n          \
    \      smallest = n\n            end\n        end\n    end\n    return largest,\
    \ smallest\nend", "    return (nil, nil)\nend", "    return nil, nil\nend", " \
    \   local min_positive, max_negative = nil, nil\n    for i, n in ipairs(lst) do\n\
    \        if n > 0 then\n            if min_positive == nil or n < min_positive\
    \ then\n                min_positive = n\n            end\n        elseif n <\
    \ 0 then\n            if max_negative == nil or n > max_negative then\n      \
    \          max_negative = n\n            end\n        end\n    end\n    return\
    \ max_negative, min_positive\nend", "  local a, b = None, None\n  for i = 1, #lst\
    \ do\n    if lst[i] < 0 and (a == None or lst[i] > a) then\n      a = lst[i]\n\
    \    elseif lst[i] > 0 and (b == None or lst[i] < b) then\n      b = lst[i]\n\
    \    end\n  end\n  return a, b\nend", "  -- TODO: Implementation\nend", "    local\
    \ neg, pos = None, None\n    for _, v in ipairs(lst) do\n        if v < 0 then\n\
    \            if neg == None or v > neg then\n                neg = v\n       \
    \     end\n        elseif v > 0 then\n            if pos == None or v < pos then\n\
    \                pos = v\n            end\n        end\n    end\n    return neg,\
    \ pos\nend", "    if lst == nil or #lst == 0 then\n        return nil, nil\n \
    \   end\n    local positives = { }\n    local negatives = { }\n    for i = 1,\
    \ #lst do\n        if lst[i] < 0 then\n            negatives[#negatives + 1] =\
    \ lst[i]\n        elseif lst[i] > 0 then\n            positives[#positives + 1]\
    \ = lst[i]\n        end\n    end\n    local largest_negative = #negatives > 0\
    \ and max(unpack(negatives)) or nil\n    local smallest_positive = #positives\
    \ > 0 and min(unpack(positives)) or nil\n    return largest_negative, smallest_positive\n\
    end", end, "    local smallest_positive = nil\n    local largest_negative = nil\n\
    \    for _, n in ipairs(lst) do\n        if n > 0 then\n            if smallest_positive\
    \ == nil or n < smallest_positive then\n                smallest_positive = n\n\
    \            end\n        elseif n < 0 then\n            if largest_negative ==\
    \ nil or n > largest_negative then\n                largest_negative = n\n   \
    \         end\n        end\n    end\n    return largest_negative, smallest_positive\n\
    end", "    local largest, smallest = nil, nil\n    for _, num in ipairs(lst) do\n\
    \        if num > 0 then\n            if smallest == nil or num < smallest then\n\
    \                smallest = num\n            end\n        elseif num < 0 then\n\
    \            if largest == nil or num > largest then\n                largest\
    \ = num\n            end\n        end\n    end\n    return largest, smallest\n\
    end", "    local largest = 0\n    local smallest = 0\n    local seen_largest =\
    \ false\n    local seen_smallest = false\n    for _, v in ipairs(lst) do\n   \
    \     if v < 0 then\n            if v > largest then\n                largest\
    \ = v\n                seen_largest = true\n            end\n        elseif v\
    \ > 0 then\n            if v < smallest or not seen_smallest then\n          \
    \      smallest = v\n                seen_smallest = true\n            end\n \
    \       end\n    end\n    if not seen_largest then\n        largest = nil\n  \
    \  end\n    if not seen_smallest then\n        smallest = nil\n    end\n    return\
    \ largest, smallest\nend", "    return None, None\nend", "    -- write your code\
    \ here\nend", "  -- your code here\nend", "    local max = nil\n    local min\
    \ = nil\n    for i, v in ipairs(lst) do\n        if v > 0 then\n            if\
    \ not min or v < min then\n                min = v\n            end\n        elseif\
    \ v < 0 then\n            if not max or v > max then\n                max = v\n\
    \            end\n        end\n    end\n    return max, min\nend", "    -- your\
    \ code here\nend", "    return nil, nil\nend", "    return nil, nil\nend", "\t\
    -- Code here\nend", "  local min = nil\n  local max = nil\n  for _, v in ipairs(lst)\
    \ do\n    if v > 0 then\n      if not min or v < min then\n        min = v\n \
    \     end\n    elseif v < 0 then\n      if not max or v > max then\n        max\
    \ = v\n      end\n    end\n  end\n  return max, min\nend", "  -- your code here\n\
    end", "  local pos, neg = nil, nil\n  for _, val in ipairs(lst) do\n    if val\
    \ > 0 then\n      if pos == nil or val < pos then\n        pos = val\n      end\n\
    \    elseif val < 0 then\n      if neg == nil or val > neg then\n        neg =\
    \ val\n      end\n    end\n  end\n  return neg, pos\nend", "    return nil, nil\n\
    end", "    -- TODO\nend", "    local min_pos, max_neg = math.huge, -math.huge\n\
    \    for _, num in ipairs(lst) do\n        if num < 0 then\n            max_neg\
    \ = math.max(max_neg, num)\n        elseif num > 0 then\n            min_pos =\
    \ math.min(min_pos, num)\n        end\n    end\n    return max_neg == -math.huge\
    \ and nil or max_neg, min_pos == math.huge and nil or min_pos\nend", "    local\
    \ max_neg, min_pos = nil, nil\n    for _, v in ipairs(lst) do\n        if v <\
    \ 0 then\n            if max_neg == nil or v > max_neg then\n                max_neg\
    \ = v\n            end\n        elseif v > 0 then\n            if min_pos == nil\
    \ or v < min_pos then\n                min_pos = v\n            end\n        end\n\
    \    end\n    return max_neg, min_pos\nend", "  return (nil, nil)\nend", "   \
    \ -- TODO: Your code here\nend", "  local min, max = nil, nil\n  for _, v in ipairs(lst)\
    \ do\n    if v < 0 then\n      if min == nil or v > min then\n        min = v\n\
    \      end\n    elseif v > 0 then\n      if max == nil or v < max then\n     \
    \   max = v\n      end\n    end\n  end\n  return min, max\nend", "  return nil,\
    \ nil\nend", "  local negatives = {}\n  local positives = {}\n  for _, e in ipairs(lst)\
    \ do\n    if e < 0 then\n      table.insert(negatives, e)\n    elseif e > 0 then\n\
    \      table.insert(positives, e)\n    end\n  end\n  local a = table.max(negatives)\n\
    \  local b = table.min(positives)\n  return a, b\nend", "    local max_neg, min_pos\n\
    \    for _, x in ipairs(lst) do\n        if x > 0 then\n            if not min_pos\
    \ or x < min_pos then\n                min_pos = x\n            end\n        elseif\
    \ x < 0 then\n            if not max_neg or x > max_neg then\n               \
    \ max_neg = x\n            end\n        end\n    end\n    return max_neg, min_pos\n\
    end", "\tif #lst == 0 then\n\t\treturn nil, nil\n\tend\n\tlocal smallest = nil\n\
    \tlocal largest = nil\n\tfor _, value in ipairs(lst) do\n\t\tif value > 0 then\n\
    \t\t\tif smallest == nil or value < smallest then\n\t\t\t\tsmallest = value\n\t\
    \t\tend\n\t\telseif value < 0 then\n\t\t\tif largest == nil or value > largest\
    \ then\n\t\t\t\tlargest = value\n\t\t\tend\n\t\tend\n\tend\n\treturn largest,\
    \ smallest\nend", "    local min = math.huge\n    local max = -math.huge\n   \
    \ for _, v in ipairs(lst) do\n        if v < 0 then\n            max = math.max(max,\
    \ v)\n        elseif v > 0 then\n            min = math.min(min, v)\n        end\n\
    \    end\n    return (max == -math.huge and nil or max), (min == math.huge and\
    \ nil or min)\nend", "    -- your code here\nend", "    -- Write your code here\n\
    end", "\tlocal largest_neg, smallest_pos\n\tfor _, v in ipairs(lst) do\n\t\tif\
    \ v < 0 then\n\t\t\tif largest_neg == nil or v > largest_neg then\n\t\t\t\tlargest_neg\
    \ = v\n\t\t\tend\n\t\telseif v > 0 then\n\t\t\tif smallest_pos == nil or v < smallest_pos\
    \ then\n\t\t\t\tsmallest_pos = v\n\t\t\tend\n\t\tend\n\tend\n\treturn largest_neg,\
    \ smallest_pos\nend", "  local a, b\n  for _, v in ipairs(lst) do\n    if v >\
    \ 0 then\n      if not b or v < b then\n        b = v\n      end\n    elseif v\
    \ < 0 then\n      if not a or v > a then\n        a = v\n      end\n    end\n\
    \  end\n  return a, b\nend", "    local largest_neg, smallest_pos = None, None\n\
    \    for _, num in ipairs(lst) do\n        if num < 0 and (largest_neg == None\
    \ or num > largest_neg) then\n            largest_neg = num\n        elseif num\
    \ > 0 and (smallest_pos == None or num < smallest_pos) then\n            smallest_pos\
    \ = num\n        end\n    end\n    return largest_neg, smallest_pos\nend", "\t\
    local largest = nil\n\tlocal smallest = nil\n\tfor _, v in ipairs(lst) do\n\t\t\
    if v < 0 then\n\t\t\tif largest == nil or v > largest then\n\t\t\t\tlargest =\
    \ v\n\t\t\tend\n\t\telseif v > 0 then\n\t\t\tif smallest == nil or v < smallest\
    \ then\n\t\t\t\tsmallest = v\n\t\t\tend\n\t\tend\n\tend\n\treturn largest, smallest\n\
    end", "  return (nil, nil)\nend", "    local min, max = nil, nil\n    for _, value\
    \ in ipairs(lst) do\n        if value > 0 then\n            if min == nil or value\
    \ < min then\n                min = value\n            end\n        elseif value\
    \ < 0 then\n            if max == nil or value > max then\n                max\
    \ = value\n            end\n        end\n    end\n    return max, min\nend", end,
  "    local neg = lst:filter(function(el) return el < 0 end):sort()\n    local pos\
    \ = lst:filter(function(el) return el > 0 end):sort()\n    return neg:last(),\
    \ pos:first()\nend", "  -- put the code here\nend", "  if #lst == 0 then\n   \
    \ return nil, nil\n  end\n  local negs = {}\n  local poss = {}\n  for _, v in\
    \ ipairs(lst) do\n    if v > 0 then\n      poss[#poss + 1] = v\n    elseif v <\
    \ 0 then\n      negs[#negs + 1] = v\n    end\n  end\n  table.sort(negs)\n  table.sort(poss)\n\
    \  return negs[#negs], poss[1]\nend", "    local neg = nil\n    local pos = nil\n\
    \    for _, e in ipairs(lst) do\n        if e < 0 then\n            if neg ==\
    \ nil or e > neg then\n                neg = e\n            end\n        elseif\
    \ e > 0 then\n            if pos == nil or e < pos then\n                pos =\
    \ e\n            end\n        end\n    end\n    return neg, pos\nend", "    return\
    \ nil, nil\nend", "    local max = nil\n    local min = nil\n    for i = 1, #lst\
    \ do\n        if not max and lst[i] < 0 then\n            max = lst[i]\n     \
    \   elseif lst[i] < 0 and lst[i] > max then\n            max = lst[i]\n      \
    \  end\n        if not min and lst[i] > 0 then\n            min = lst[i]\n   \
    \     elseif lst[i] > 0 and lst[i] < min then\n            min = lst[i]\n    \
    \    end\n    end\n    return max, min\nend", "    local smallest = nil\n    local\
    \ largest = nil\n    for _, v in ipairs(lst) do\n        if v > 0 then\n     \
    \       if smallest == nil or v < smallest then\n                smallest = v\n\
    \            end\n        elseif v < 0 then\n            if largest == nil or\
    \ v > largest then\n                largest = v\n            end\n        end\n\
    \    end\n    return largest, smallest\nend\nprint(largest_smallest_integers({2,\
    \ 4, 1, 3, 5, 7}))\nprint(largest_smallest_integers({}))\nprint(largest_smallest_integers({0}))",
  "    return \nend", "    -- your code goes here\nend", "    local largest_neg_number,\
    \ smallest_pos_number\n    local largest_neg_number_found, smallest_pos_number_found\n\
    \    for _, num in ipairs(lst) do\n        if not largest_neg_number_found and\
    \ num < 0 then\n            largest_neg_number = num\n            largest_neg_number_found\
    \ = true\n        elseif num < 0 and num > largest_neg_number then\n         \
    \   largest_neg_number = num\n        end\n        if not smallest_pos_number_found\
    \ and num > 0 then\n            smallest_pos_number = num\n            smallest_pos_number_found\
    \ = true\n        elseif num > 0 and num < smallest_pos_number then\n        \
    \    smallest_pos_number = num\n        end\n    end\n    return largest_neg_number,\
    \ smallest_pos_number\nend", "  if #lst == 0 then\n    return { None, None }\n\
    \  end\n  local max_neg, min_pos = None, None\n  for i, v in ipairs(lst) do\n\
    \    if v < 0 then\n      if max_neg == None or v > max_neg then\n        max_neg\
    \ = v\n      end\n    elseif v > 0 then\n      if min_pos == None or v < min_pos\
    \ then\n        min_pos = v\n      end\n    end\n  end\n  return { max_neg, min_pos\
    \ }\nend", "    local a, b = None, None\n    for _, v in ipairs(lst) do\n    \
    \    if v < 0 then\n            if a == None or v > a then\n                a\
    \ = v\n            end\n        elseif v > 0 then\n            if b == None or\
    \ v < b then\n                b = v\n            end\n        end\n    end\n \
    \   return a, b\nend", "    if #lst == 0 then\n        return nil, nil\n    end\n\
    \    local smallest = nil\n    local largest = nil\n    for _, v in ipairs(lst)\
    \ do\n        if v > 0 then\n            if not smallest or v < smallest then\n\
    \                smallest = v\n            end\n        elseif v < 0 then\n  \
    \          if not largest or v > largest then\n                largest = v\n \
    \           end\n        end\n    end\n    return largest, smallest\nend", " \
    \   -- body\nend", "    return (nil, nil)\nend", "    local largest_negative,\
    \ smallest_positive = nil, nil\n    for _, n in ipairs(lst) do\n        if n <\
    \ 0 then\n            if largest_negative == nil or n > largest_negative then\n\
    \                largest_negative = n\n            end\n        elseif n > 0 then\n\
    \            if smallest_positive == nil or n < smallest_positive then\n     \
    \           smallest_positive = n\n            end\n        end\n    end\n   \
    \ return largest_negative, smallest_positive\nend", "    local negative_numbers\
    \ = {}\n    local positive_numbers = {}\n    for _, item in ipairs(lst) do\n \
    \       if item > 0 then\n            table.insert(positive_numbers, item)\n \
    \       elseif item < 0 then\n            table.insert(negative_numbers, item)\n\
    \        end\n    end\n    table.sort(negative_numbers)\n    table.sort(positive_numbers)\n\
    \    return negative_numbers[#negative_numbers] or None, positive_numbers[1] or\
    \ None\nend", "    local neg, pos = nil, nil\n    for i,n in ipairs(lst) do\n\
    \        if n < 0 then\n            if neg == nil or n > neg then\n          \
    \      neg = n\n            end\n        elseif n > 0 then\n            if pos\
    \ == nil or n < pos then\n                pos = n\n            end\n        end\n\
    \    end\n    return neg, pos\nend", "    local max_neg, min_pos = nil, nil\n\
    \    for _, n in ipairs(lst) do\n        if n < 0 then\n            if not max_neg\
    \ or n > max_neg then\n                max_neg = n\n            end\n        elseif\
    \ n > 0 then\n            if not min_pos or n < min_pos then\n               \
    \ min_pos = n\n            end\n        end\n    end\n    return max_neg, min_pos\n\
    end", "    local max_neg = nil\n    local min_pos = nil\n    for i = 1, #lst do\n\
    \        if lst[i] < 0 then\n            if max_neg == nil or lst[i] > max_neg\
    \ then\n                max_neg = lst[i]\n            end\n        elseif lst[i]\
    \ > 0 then\n            if min_pos == nil or lst[i] < min_pos then\n         \
    \       min_pos = lst[i]\n            end\n        end\n    end\n    return max_neg,\
    \ min_pos\nend", "    if #lst == 0 then\n        return (None, None)\n    end\n\
    \    local smallest_pos, largest_neg\n    for _, v in ipairs(lst) do\n       \
    \ if v > 0 then\n            if smallest_pos == nil or v < smallest_pos then\n\
    \                smallest_pos = v\n            end\n        elseif v < 0 then\n\
    \            if largest_neg == nil or v > largest_neg then\n                largest_neg\
    \ = v\n            end\n        end\n    end\n    return (largest_neg, smallest_pos)\n\
    end", "    local largest_negative, smallest_positive\n    for _, val in ipairs(lst)\
    \ do\n        if val < 0 then\n            if largest_negative == nil or val >\
    \ largest_negative then\n                largest_negative = val\n            end\n\
    \        elseif val > 0 then\n            if smallest_positive == nil or val <\
    \ smallest_positive then\n                smallest_positive = val\n          \
    \  end\n        end\n    end\n    return largest_negative, smallest_positive\n\
    end", "  local min = nil\n  local max = nil\n  for _, v in ipairs(lst) do\n  \
    \  if v > 0 then\n      if min == nil or v < min then\n        min = v\n     \
    \ end\n    elseif v < 0 then\n      if max == nil or v > max then\n        max\
    \ = v\n      end\n    end\n  end\n  return max, min\nend", "    -- your code goes\
    \ here\nend", "    local neg, pos = {}, {}\n    for _, n in ipairs(lst) do\n \
    \       if n < 0 then\n            table.insert(neg, n)\n        elseif n > 0\
    \ then\n            table.insert(pos, n)\n        end\n    end\n    table.sort(neg)\n\
    \    table.sort(pos)\n    return neg[#neg] or nil, pos[1] or nil\nend", "    local\
    \ smallest, largest\n    for _, v in ipairs(lst) do\n        if v > 0 then\n \
    \           if smallest == nil or v < smallest then\n                smallest\
    \ = v\n            end\n        elseif v < 0 then\n            if largest == nil\
    \ or v > largest then\n                largest = v\n            end\n        end\n\
    \    end\n    return largest, smallest\nend", "  -- YOUR CODE HERE\n  local largest_n\
    \ = nil\n  local smallest_p = nil\n  for i, v in ipairs(lst) do\n    if v < 0\
    \ then\n      if largest_n == nil or v > largest_n then\n        largest_n = v\n\
    \      end\n    elseif v > 0 then\n      if smallest_p == nil or v < smallest_p\
    \ then\n        smallest_p = v\n      end\n    end\n  end\n  return largest_n,\
    \ smallest_p\nend", "  return nil, nil\nend", "  return nil, nil\nend", "  local\
    \ lst_pos = {}\n  local lst_neg = {}\n  for _, n in ipairs(lst) do\n    if n >\
    \ 0 then\n      table.insert(lst_pos, n)\n    elseif n < 0 then\n      table.insert(lst_neg,\
    \ n)\n    end\n  end\n  table.sort(lst_pos)\n  table.sort(lst_neg)\n  local neg\
    \ = lst_neg[#lst_neg]\n  local pos = lst_pos[1]\n  if neg == nil then\n    neg\
    \ = 'None'\n  end\n  if pos == nil then\n    pos = 'None'\n  end\n  return neg,\
    \ pos\nend", "  -- ...\nend", end, "   if not lst then return nil, nil end\n \
    \  local max = nil\n   local min = nil\n   for _, v in ipairs(lst) do\n      if\
    \ v > 0 then\n         if not min or v < min then min = v end\n      elseif v\
    \ < 0 then\n         if not max or v > max then max = v end\n      end\n   end\n\
    \   return max, min\nend", "    local largest_negative = nil\n    local smallest_positive\
    \ = nil\n    for _, e in ipairs(lst) do\n        if e < 0 then\n            if\
    \ largest_negative == nil or e > largest_negative then\n                largest_negative\
    \ = e\n            end\n        elseif e > 0 then\n            if smallest_positive\
    \ == nil or e < smallest_positive then\n                smallest_positive = e\n\
    \            end\n        end\n    end\n    return largest_negative, smallest_positive\n\
    end", "  if not lst or #lst == 0 then\n    return nil, nil\n  end\n  local negs\
    \ = {}\n  local poss = {}\n  for _, n in ipairs(lst) do\n    if n < 0 then\n \
    \     table.insert(negs, n)\n    elseif n > 0 then\n      table.insert(poss, n)\n\
    \    end\n  end\n  local a = negs[1]\n  local b = poss[1]\n  for _, n in ipairs(negs)\
    \ do\n    if n > a then\n      a = n\n    end\n  end\n  for _, n in ipairs(poss)\
    \ do\n    if n < b then\n      b = n\n    end\n  end\n  return a, b\nend", " \
    \   -- your code here\nend", "  -- your code here\nend", "    if not lst or #lst\
    \ == 0 then\n        return nil, nil\n    end\n    local min, max = lst[1], lst[1]\n\
    \    for _, i in ipairs(lst) do\n        if i < min then\n            min = i\n\
    \        end\n        if i > max then\n            max = i\n        end\n    end\n\
    \    if min >= 0 then\n        min = nil\n    end\n    if max <= 0 then\n    \
    \    max = nil\n    end\n    return max, min\nend", "  local neg = 0\n  local\
    \ pos = 0\n  for _,v in ipairs(lst) do\n    if v > 0 then\n      if v < pos or\
    \ pos == 0 then\n        pos = v\n      end\n    elseif v < 0 then\n      if v\
    \ > neg or neg == 0 then\n        neg = v\n      end\n    end\n  end\n  return\
    \ neg, pos\nend", "    return error \"todo\"\nend", "\tlocal a, b = nil, nil\n\
    \tfor i, v in ipairs(lst) do\n\t\tif v > 0 then\n\t\t\tif b == nil or v < b then\n\
    \t\t\t\tb = v\n\t\t\tend\n\t\telseif v < 0 then\n\t\t\tif a == nil or v > a then\n\
    \t\t\t\ta = v\n\t\t\tend\n\t\tend\n\tend\n\treturn a, b\nend", "    local min,\
    \ max = nil, nil\n    for _, item in ipairs(lst) do\n        if item < 0 then\n\
    \            max = math.max(max or 0, item)\n        elseif item > 0 then\n  \
    \          min = math.min(min or item, item)\n        end\n    end\n    return\
    \ max, min\nend", "  local a, b\n  for _, v in ipairs(lst) do\n    if v > 0 then\n\
    \      if not b or v < b then\n        b = v\n      end\n    elseif v < 0 then\n\
    \      if not a or v > a then\n        a = v\n      end\n    end\n  end\n  return\
    \ a, b\nend", "  return nil, nil\nend", "    -- TODO: implement\nend", "    local\
    \ smaller = nil\n    local largest = nil\n    for _, n in ipairs(lst) do\n   \
    \     if n > 0 then\n            if smaller == nil or n < smaller then\n     \
    \           smaller = n\n            end\n        elseif n < 0 then\n        \
    \    if largest == nil or n > largest then\n                largest = n\n    \
    \        end\n        end\n    end\n    return largest, smaller\nend", "    local\
    \ largest = nil\n    local smallest = nil\n    for _, v in ipairs(lst) do\n  \
    \      if v > 0 then\n            if smallest == nil or v < smallest then\n  \
    \              smallest = v\n            end\n        elseif v < 0 then\n    \
    \        if largest == nil or v > largest then\n                largest = v\n\
    \            end\n        end\n    end\n    return largest, smallest\nend\nassert(largest_smallest_integers({})\
    \ == (nil, nil))\nassert(largest_smallest_integers({-1, -2, -3}) == (-1, nil))\n\
    assert(largest_smallest_integers({-1, 1, -2, 2, -3, 3}) == (-1, 1))\nassert(largest_smallest_integers({3,\
    \ 2, 1}) == (nil, 1))\nassert(largest_smallest_integers({1, 2, 3}) == (nil, 1))\n\
    assert(largest_smallest_integers({-3, -2, -1}) == (-1, nil))\nassert(largest_smallest_integers({-1,\
    \ 2, -3, 1, -2}) == (-1, 1))\nassert(largest_smallest_integers({1, -2, 3, -1,\
    \ 2}) == (-1, 1))\nassert(largest_smallest_integers({-3, 1, -2, 2, -1}) == (-1,\
    \ 1))\nassert(largest_smallest_integers({-1, -2, 1, 2, -3, 3}) == (-1, 1))\nassert(largest_smallest_integers({3,\
    \ -2, 1, -1, 2}) == (-1, 1))\nassert(largest_smallest_integers({1, -1, 2, -2,\
    \ 3, -3}) == (-1, 1))\nassert(largest_smallest_integers({2, 3, 1}) == (nil, 1))\n\
    assert(largest_smallest_integers({-2, -3, -1}) == (-1, nil))\nassert(largest_smallest_integers({-1,\
    \ 3, -2, 2, -3, 1}) == (-1, 1))\nassert(largest_smallest_", "    local l, s\n\
    \    for _, v in ipairs(lst) do\n        if v > 0 then\n            if not s or\
    \ v < s then\n                s = v\n            end\n        elseif v < 0 then\n\
    \            if not l or v > l then\n                l = v\n            end\n\
    \        end\n    end\n    return l, s\nend", "    local a, b = None, None\n \
    \   for _, v in ipairs(lst) do\n        if v < 0 then\n            if a == None\
    \ or v > a then\n                a = v\n            end\n        elseif v > 0\
    \ then\n            if b == None or v < b then\n                b = v\n      \
    \      end\n        end\n    end\n    return a, b\nend", "    return (nil, nil)\n\
    end", "    -- write your code here\nend", "    -- Write your code here.\nend",
  "    return 0,0\nend", "  if #lst == 0 then\n    return nil, nil\n  end\n  local\
    \ max_neg, min_pos = nil, nil\n  for i = 1, #lst do\n    if lst[i] < 0 then\n\
    \      if not max_neg or lst[i] > max_neg then\n        max_neg = lst[i]\n   \
    \   end\n    elseif lst[i] > 0 then\n      if not min_pos or lst[i] < min_pos\
    \ then\n        min_pos = lst[i]\n      end\n    end\n  end\n  return max_neg,\
    \ min_pos\nend", "  local pos = {};\n  local neg = {};\n  local min = nil;\n \
    \ local max = nil;\n  for i = 1, #lst do\n    if lst[i] > 0 then\n      table.insert(pos,\
    \ lst[i]);\n    elseif lst[i] < 0 then\n      table.insert(neg, lst[i]);\n   \
    \ end\n  end\n  if #pos > 0 then\n    min = math.min(unpack(pos));\n  end\n  if\
    \ #neg > 0 then\n    max = math.max(unpack(neg));\n  end\n  return max, min;\n\
    end", "  local largest_neg, smallest_pos, has_neg, has_pos = 0, math.huge, false,\
    \ false\n  for _, v in ipairs(lst) do\n    if v < 0 then\n      largest_neg =\
    \ math.max(largest_neg, v)\n      has_neg = true\n    elseif v > 0 then\n    \
    \  smallest_pos = math.min(smallest_pos, v)\n      has_pos = true\n    end\n \
    \ end\n  return has_neg and largest_neg or nil, has_pos and smallest_pos or nil\n\
    end", "    return\nend", "    if #lst == 0 then\n        return nil, nil\n   \
    \ end\n    local result = {}\n    local a = nil\n    local b = nil\n    for _,\
    \ value in ipairs(lst) do\n        if value < 0 then\n            if a == nil\
    \ or value > a then\n                a = value\n            end\n        elseif\
    \ value > 0 then\n            if b == nil or value < b then\n                b\
    \ = value\n            end\n        end\n    end\n    return a, b\nend", "   \
    \ -- TODO: implement\nend", "    local max_neg, min_pos\n    for _, x in ipairs(lst)\
    \ do\n        if x < 0 then\n            if not max_neg or x > max_neg then\n\
    \                max_neg = x\n            end\n        elseif x > 0 then\n   \
    \         if not min_pos or x < min_pos then\n                min_pos = x\n  \
    \          end\n        end\n    end\n    return max_neg, min_pos\nend", "   \
    \ local largest, smallest\n    for _, v in ipairs(lst) do\n        if v < 0 then\n\
    \            if not largest or v > largest then\n                largest = v\n\
    \            end\n        elseif v > 0 then\n            if not smallest or v\
    \ < smallest then\n                smallest = v\n            end\n        end\n\
    \    end\n    return largest, smallest\nend", "  -- your code here\nend", "  \
    \  local max_negative = nil\n    local min_positive = nil\n    for _, v in ipairs(lst)\
    \ do\n        if v < 0 then\n            if max_negative == nil or v > max_negative\
    \ then\n                max_negative = v\n            end\n        elseif v >\
    \ 0 then\n            if min_positive == nil or v < min_positive then\n      \
    \          min_positive = v\n            end\n        end\n    end\n    return\
    \ max_negative, min_positive\nend", "    local min, max = nil, nil\n    for _,\
    \ x in ipairs(lst) do\n        if min == nil or x < min then\n            min\
    \ = x\n        end\n        if max == nil or x > max then\n            max = x\n\
    \        end\n    end\n    return min, max\nend", "\tlocal l_neg, l_pos = nil,\
    \ nil", "    local a, b = None, None\n    for _, v in ipairs(lst) do\n       \
    \ if v > 0 then\n            if b == None or v < b then\n                b = v\n\
    \            end\n        elseif v < 0 then\n            if a == None or v > a\
    \ then\n                a = v\n            end\n        end\n    end\n    return\
    \ a, b\nend", "  local n, p = max_min(lst)\n  if n then n = -n else n = nil end\n\
    \  if p then p = -p else p = nil end\n  return n, p\nend", "    local max_negative,\
    \ min_positive = nil, nil\n    for _, val in ipairs(lst) do\n        if val <\
    \ 0 then\n            if not max_negative or val > max_negative then\n       \
    \         max_negative = val\n            end\n        elseif val > 0 then\n \
    \           if not min_positive or val < min_positive then\n                min_positive\
    \ = val\n            end\n        end\n    end\n    return max_negative, min_positive\n\
    end", "  --your code here\n  local min = lst[1]\n  local max = lst[1]\n  for i\
    \ = 1, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    end\n    if\
    \ lst[i] > max then\n      max = lst[i]\n    end\n  end\n  if min > 0 then\n \
    \   min = nil\n  end\n  if max < 0 then\n    max = nil\n  end\n  return max, min\n\
    end", "    local a, b = None, None\n    for _, v in ipairs(lst) do\n        if\
    \ v < 0 then\n            if a == None or v > a then\n                a = v\n\
    \            end\n        elseif v > 0 then\n            if b == None or v < b\
    \ then\n                b = v\n            end\n        end\n    end\n    return\
    \ a, b\nend", "    local largest_negative, smallest_positive = 0, 0\n    for _,\
    \ n in ipairs(lst) do\n        if n < 0 then\n            if n > largest_negative\
    \ then\n                largest_negative = n\n            end\n        elseif\
    \ n > 0 then\n            if smallest_positive == 0 or n < smallest_positive then\n\
    \                smallest_positive = n\n            end\n        end\n    end\n\
    \    return largest_negative == 0 and None or largest_negative,\n           smallest_positive\
    \ == 0 and None or smallest_positive\nend", "    local min, max\n    for _, v\
    \ in ipairs(lst) do\n        if v > 0 then\n            if not min or v < min\
    \ then\n                min = v\n            end\n        elseif v < 0 then\n\
    \            if not max or v > max then\n                max = v\n           \
    \ end\n        end\n    end\n    return max, min\nend", "    -- Your code goes\
    \ here.\nend", "  -- your solution here\nend", "    local min, max = nil, nil\n\
    \    for _, v in ipairs(lst) do\n        if v > 0 then\n            if min ==\
    \ nil or v < min then\n                min = v\n            end\n        elseif\
    \ v < 0 then\n            if max == nil or v > max then\n                max =\
    \ v\n            end\n        end\n    end\n    return max, min\nend", end, " \
    \   local positive_max = math.maxinteger\n    local negative_min = math.mininteger\n\
    \    local positive_min, negative_max\n    for _, i in ipairs(lst) do\n      \
    \  if i > 0 then\n            if not positive_min or i < positive_min then\n \
    \               positive_min = i\n            end\n        elseif i < 0 then\n\
    \            if not negative_max or i > negative_max then\n                negative_max\
    \ = i\n            end\n        end\n    end\n    if positive_min == positive_max\
    \ then\n        positive_min = nil\n    end\n    if negative_max == negative_min\
    \ then\n        negative_max = nil\n    end\n    return negative_max, positive_min\n\
    end", end, "    if lst == nil or #lst == 0 then\n        return nil, nil\n   \
    \ end\n    local is_pos = false\n    local is_neg = false\n    local a = nil\n\
    \    local b = nil\n    for _, v in ipairs(lst) do\n        if v > 0 then\n  \
    \          if not is_pos then\n                b = v\n                is_pos =\
    \ true\n            else\n                b = math.min(b, v)\n            end\n\
    \        elseif v < 0 then\n            if not is_neg then\n                a\
    \ = v\n                is_neg = true\n            else\n                a = math.max(a,\
    \ v)\n            end\n        end\n    end\n    return a, b\nend", "  return\
    \ nil, nil\nend", "   if #lst == 0 then\n      return nil, nil\n   end\n   local\
    \ neg = nil\n   local pos = nil\n   for _, x in ipairs(lst) do\n      if x > 0\
    \ then\n         if pos == nil or x < pos then\n            pos = x\n        \
    \ end\n      elseif x < 0 then\n         if neg == nil or x > neg then\n     \
    \       neg = x\n         end\n      end\n   end\n   return neg, pos\nend", " \
    \ local l = #lst\n  local max_neg = nil\n  local min_pos = nil\n  for i = 1, l\
    \ do\n    if lst[i] < 0 then\n      if not max_neg or lst[i] > max_neg then\n\
    \        max_neg = lst[i]\n      end\n    elseif lst[i] > 0 then\n      if not\
    \ min_pos or lst[i] < min_pos then\n        min_pos = lst[i]\n      end\n    end\n\
    \  end\n  return max_neg, min_pos\nend", "    local l_pos = lst[1]\n    local\
    \ l_neg = lst[1]\n    local idx = 0\n    while idx < #lst do\n        local e\
    \ = lst[idx + 1]\n        if e > 0 and e < l_pos then\n            l_pos = e\n\
    \        elseif e < 0 and e > l_neg then\n            l_neg = e\n        end\n\
    \        idx = idx + 1\n    end\n    return l_neg ~= lst[1] and l_neg or nil,\
    \ l_pos ~= lst[1] and l_pos or nil\nend", "  local min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n  if min > 0 then\n    return None, min\n  elseif max\
    \ < 0 then\n    return max, None\n  else\n    return None, None\n  end\nend",
  "    -- TODO: Implement the function here\nend", end, end, "    local pos = max(filter(lst,\
    \ function(n) return n > 0 end))\n    local neg = min(filter(lst, function(n)\
    \ return n < 0 end))\n    return neg or nil, pos or nil\nend", "  local largest_negative_number,\
    \ smallest_positive_number\n  for k, v in ipairs(lst) do\n    if v < 0 then\n\
    \      if not largest_negative_number or v > largest_negative_number then\n  \
    \      largest_negative_number = v\n      end\n    elseif v > 0 then\n      if\
    \ not smallest_positive_number or v < smallest_positive_number then\n        smallest_positive_number\
    \ = v\n      end\n    end\n  end\n  return largest_negative_number, smallest_positive_number\n\
    end", "  -- write your code here\nend", "  \n  local min = nil\n  local max =\
    \ nil\n  \n  if #lst == 0 then\n    return {min, max}\n  end\n  \n  for _, v in\
    \ ipairs(lst) do\n    if v < 0 then\n      if not max or v > max then\n      \
    \  max = v\n      end\n    elseif v > 0 then\n      if not min or v < min then\n\
    \        min = v\n      end\n    end\n  end\n  \n  return {max, min}\nend", " \
    \ local nmin, nmax, pmin, pmax = nil, nil, nil, nil\n  for _,x in ipairs(lst)\
    \ do\n    if x < 0 then\n      if nmin == nil or x < nmin then\n        nmin =\
    \ x\n      end\n      if nmax == nil or x > nmax then\n        nmax = x\n    \
    \  end\n    elseif x > 0 then\n      if pmin == nil or x < pmin then\n       \
    \ pmin = x\n      end\n      if pmax == nil or x > pmax then\n        pmax = x\n\
    \      end\n    end\n  end\n  return nmax, pmin\nend", "  --[[ your code here\
    \ ]]\nend", "  -- write your code here\nend", "  return nil, nil\nend", "    local\
    \ min_pos, max_neg\n    for i = 1, #lst do\n        if lst[i] > 0 then\n     \
    \       if not min_pos or lst[i] < min_pos then\n                min_pos = lst[i]\n\
    \            end\n        elseif lst[i] < 0 then\n            if not max_neg or\
    \ lst[i] > max_neg then\n                max_neg = lst[i]\n            end\n \
    \       end\n    end\n    return max_neg, min_pos\nend", "  local a, b = None,\
    \ None\n  local n, p = None, None\n  for _, n in ipairs(lst) do\n    if n > 0\
    \ then\n      if p == None or n < p then\n        p = n\n      end\n    elseif\
    \ n < 0 then\n      if n > a then\n        a = n\n      end\n    end\n  end\n\
    \  return a, p\nend", "    local last = None\n    local smallest = None\n    local\
    \ largest = None\n    for i = 1, #lst do\n        if lst[i] < 0 then\n       \
    \     if lst[i] > largest then\n                largest = lst[i]\n           \
    \ end\n        elseif lst[i] > 0 then\n            if smallest == None or lst[i]\
    \ < smallest then\n                smallest = lst[i]\n            end\n      \
    \  end\n    end\n    return (largest, smallest)\nend", "   local largest, smallest,\
    \ found_neg, found_pos = -math.huge, math.huge, false, false\n   for i, v in ipairs(lst)\
    \ do\n      if v < 0 then\n         found_neg = true\n         if v > largest\
    \ then\n            largest = v\n         end\n      elseif v > 0 then\n     \
    \    found_pos = true\n         if v < smallest then\n            smallest = v\n\
    \         end\n      end\n   end\n   if not found_neg then\n      largest = nil\n\
    \   end\n   if not found_pos then\n      smallest = nil\n   end\n   return largest,\
    \ smallest\nend", "  local largest_neg = math.mininteger\n  local smallest_pos\
    \ = math.maxinteger\n  for i,v in ipairs(lst) do\n    if v < 0 and v > largest_neg\
    \ then\n      largest_neg = v\n    elseif v > 0 and v < smallest_pos then\n  \
    \    smallest_pos = v\n    end\n  end\n  if largest_neg == math.mininteger then\n\
    \    largest_neg = nil\n  end\n  if smallest_pos == math.maxinteger then\n   \
    \ smallest_pos = nil\n  end\n  return largest_neg, smallest_pos\nend", "    local\
    \ negatives = {}\n    local positives = {}\n    for _,v in ipairs(lst) do\n  \
    \      if v < 0 then\n            table.insert(negatives, v)\n        elseif v\
    \ > 0 then\n            table.insert(positives, v)\n        end\n    end\n   \
    \ return (\n        (not is_empty(negatives) and max(negatives) or nil),\n   \
    \     (not is_empty(positives) and min(positives) or nil)\n    )\nend", "    error()\n\
    end", "    local function go(acc, x)\n        local acc_1, acc_2 = acc[1], acc[2]\n\
    \        if x < 0 then\n            if acc_1 == nil or x > acc_1 then\n      \
    \          return {x, acc_2}\n            else\n                return {acc_1,\
    \ acc_2}\n            end\n        elseif x > 0 then\n            if acc_2 ==\
    \ nil or x < acc_2 then\n                return {acc_1, x}\n            else\n\
    \                return {acc_1, acc_2}\n            end\n        else\n      \
    \      return {acc_1, acc_2}\n        end\n    end\n    local t = foldr(go, {nil,\
    \ nil}, lst)\n    return {t[1], t[2]}\nend", "    local largest = nil\n    local\
    \ smallest = nil\n    for i, v in ipairs(lst) do\n        if v < 0 then\n    \
    \        if largest == nil or v > largest then\n                largest = v\n\
    \            end\n        elseif v > 0 then\n            if smallest == nil or\
    \ v < smallest then\n                smallest = v\n            end\n        end\n\
    \    end\n    return largest, smallest\nend", "    local min_pos, max_neg = math.huge,\
    \ -math.huge\n    for i, v in ipairs(lst) do\n        if v > 0 then\n        \
    \    min_pos = math.min(min_pos, v)\n        elseif v < 0 then\n            max_neg\
    \ = math.max(max_neg, v)\n        end\n    end\n    return max_neg == -math.huge\
    \ and None or max_neg, min_pos == math.huge and None or min_pos\nend", "    return\
    \ None\nend", end, "   local neg, pos = nil, nil\n   for i, v in ipairs(lst) do\n\
    \      if v < 0 then\n         if neg == nil or v > neg then\n            neg\
    \ = v\n         end\n      elseif v > 0 then\n         if pos == nil or v < pos\
    \ then\n            pos = v\n         end\n      end\n   end\n   return neg, pos\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
