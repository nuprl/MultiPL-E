name: HumanEval_93_encode
language: lua
prompt: "-- Write a function that takes a message, and encodes in such a \n-- way\
  \ that it swaps case of all letters, replaces all vowels in \n-- the message with\
  \ the letter that appears 2 places ahead of that \n-- vowel in the english alphabet.\
  \ \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n--\
  \ >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n\
  \    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'),\
  \ 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This\
  \ is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw\
  \ WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local output = ''\n \
    \ for c in message:gmatch('.') do\n    local is_vowel = false\n    for i,v in\
    \ ipairs(vowels) do\n      if v == c:lower() then\n        output = output ..\
    \ vowels[(i + 2) % 5 + 1]\n        is_vowel = true\n        break\n      end\n\
    \    end\n    if not is_vowel then\n      output = output .. (c:lower() == c and\
    \ c:upper() or c:lower())\n    end\n  end\n  return output\nend", "    local output\
    \ = \"\"\n    for i = 1, #message do\n        local char = message:sub(i, i)\n\
    \        if char:find(\"%u\") then\n            output = output .. char:lower()\n\
    \        elseif char:find(\"%l\") then\n            output = output .. char:upper()\n\
    \        else\n            output = output .. char\n        end\n    end\n   \
    \ return output\nend", "\tlocal alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tlocal\
    \ vowels = 'AEIOU'\n\tlocal alphabet_lookup = {}\n\tfor i=1,#alphabet do\n\t\t\
    alphabet_lookup[alphabet:sub(i,i)] = i\n\tend\n\tlocal encoded = {}\n\tfor i=1,#message\
    \ do\n\t\tlocal ch = message:sub(i,i)\n\t\tlocal lookup = alphabet_lookup[ch:upper()]\n\
    \t\tif lookup then\n\t\t\tif ch == ch:upper() then\n\t\t\t\tch = alphabet:sub(lookup,lookup)\n\
    \t\t\telse\n\t\t\t\tch = alphabet:sub(lookup,lookup):lower()\n\t\t\tend\n\t\t\t\
    if vowels:find(ch) then\n\t\t\t\tch = (ch == 'Z' or ch == 'z') and vowels:sub(1,1)\
    \ or vowels:sub(vowels:find(ch)+2,vowels:find(ch)+2)\n\t\t\tend\n\t\tend\n\t\t\
    encoded[#encoded+1] = ch\n\tend\n\treturn table.concat(encoded)\nend", end, " \
    \ -- TODO: implementation\nend", "\t\nend", end, "    local function encode_one(c)\n\
    \        if c == 'a' then return 'c'\n        elseif c == 'e' then return 'g'\n\
    \        elseif c == 'i' then return 'k'\n        elseif c == 'o' then return\
    \ 'q'\n        elseif c == 'u' then return 'y'\n        else return string.lower(c)\
    \ end\n    end\n    local function encode_two(c)\n        if c == 'a' then return\
    \ 'c'\n        elseif c == 'e' then return 'g'\n        elseif c == 'i' then return\
    \ 'k'\n        elseif c == 'o' then return 'q'\n        elseif c == 'u' then return\
    \ 'y'\n        else return string.upper(c) end\n    end\n    local function encode_other(c)\n\
    \        if c == 'a' then return 'c'\n        elseif c == 'e' then return 'g'\n\
    \        elseif c == 'i' then return 'k'\n        elseif c == 'o' then return\
    \ 'q'\n        elseif c == 'u' then return 'y'\n        else return c end\n  \
    \  end\n    local encoded = string.gsub(message, \"(%a)\", function(c)\n     \
    \   if string.match(c, \"%a\") then\n            if string.match(c, \"%l\") then\n\
    \                return encode_one(c)\n            elseif string.match(c, \"%u\"\
    ) then\n                return encode_two(c)\n            else return encode_other(c)\
    \ end\n        end\n    end)\n    return encoded\nend", "   local vowels = 'aeiou'\n\
    \   local res = ''\n   local len = #message\n   for i = 1, len do\n      local\
    \ char = message:sub(i, i)\n      local is_vowel = false\n      for j = 1, #vowels\
    \ do\n         if char == vowels:sub(j, j) then\n            is_vowel = true\n\
    \            res = res .. vowels:sub((j + 2) % #vowels + 1, (j + 2) % #vowels\
    \ + 1)\n            break\n         end\n      end\n      if not is_vowel then\n\
    \         if char:lower() == char then\n            res = res .. char:upper()\n\
    \         else\n            res = res .. char:lower()\n         end\n      end\n\
    \   end\n   return res\nend", "\tlocal letters = {\"a\", \"b\", \"c\", \"d\",\
    \ \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    }\n\tlocal vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n\tlocal encoded_message\
    \ = \"\"\n\tfor i = 1, #message do\n\t\tlocal letter = message:sub(i, i)\n\t\t\
    if letters[letter] then\n\t\t\tlocal index = letters[letter]\n\t\t\tlocal new_index\
    \ = index + 2\n\t\t\tif new_index > #letters then\n\t\t\t\tnew_index = new_index\
    \ - #letters\n\t\t\tend\n\t\t\tlocal new_letter = letters[new_index]\n\t\t\tif\
    \ vowels[new_letter] then\n\t\t\t\tencoded_message = encoded_message .. new_letter:upper()\n\
    \t\t\telse\n\t\t\t\tencoded_message = encoded_message .. new_letter\n\t\t\tend\n\
    \t\telse\n\t\t\tencoded_message = encoded_message .. letter\n\t\tend\n\tend\n\t\
    return encoded_message\nend", "    local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = 'aeiou'\n    local vowels_lower = vowels:lower()\n    local\
    \ vowel_map = {}\n    local result = {}\n    local result_string = ''\n    local\
    \ upper_vowels = vowels:upper()\n    for i = 1, #vowels do\n        vowel_map[vowels:sub(i,\
    \ i)] = vowels:sub(i+2, i+2)\n        vowel_map[vowels_lower:sub(i, i)] = vowels_lower:sub(i+2,\
    \ i+2)\n        vowel_map[upper_vowels:sub(i, i)] = upper_vowels:sub(i+2, i+2)\n\
    \    end\n    for i = 1, #message do\n        local char = message:sub(i, i)\n\
    \        if vowel_map[char] ~= nil then\n            table.insert(result, vowel_map[char])\n\
    \        else\n            if char == char:upper() then\n                table.insert(result,\
    \ char:lower())\n            else\n                table.insert(result, char:upper())\n\
    \            end\n        end\n    end\n    result_string = table.concat(result)\n\
    \    return result_string\nend", "\tlocal vowels = {['a'] = true, ['e'] = true,\
    \ ['i'] = true, ['o'] = true, ['u'] = true}\n\tlocal encoded = ''\n\tfor i = 1,\
    \ #message do\n\t\tlocal c = message:sub(i, i)\n\t\tlocal charcode = c:byte()\n\
    \t\tif charcode >= 97 and charcode <= 122 then\n\t\t\tcharcode = charcode - 32\n\
    \t\telseif charcode >= 65 and charcode <= 90 then\n\t\t\tcharcode = charcode +\
    \ 32\n\t\tend\n\t\tif vowels[c:lower()] then\n\t\t\tcharcode = charcode + 2\n\t\
    \t\tif charcode > 122 then\n\t\t\t\tcharcode = charcode - 26\n\t\t\tend\n\t\t\
    end\n\t\tencoded = encoded .. string.char(charcode)\n\tend\n\treturn encoded\n\
    end", end, "  local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  local vowels =\
    \ 'AEIOU'\n  local encoded = ''\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    local index = alphabet:find(char)\n    if index then\n      index =\
    \ (index + 2) % #alphabet\n      encoded = encoded .. alphabet:sub(index, index)\n\
    \    else\n      encoded = encoded .. char\n    end\n  end\n  return encoded\n\
    end", "    -- body\nend", "  return table.concat(\n    table.map(\n      string.to_table(message),\n\
    \      function(char)\n        return char:swapcase()\n          :gsub('[AEIOUaeiou]',\n\
    \            function(vowel)\n              return string.char(\n            \
    \    string.byte(vowel) + 2)\n            end)\n      end), '')\nend", "  local\
    \ encoded = {}\n  local vowels = \"AEIOUaeiou\"\n  local swap = {\n    ['a'] =\
    \ 'c',\n    ['b'] = 'd',\n    ['c'] = 'e',\n    ['d'] = 'f',\n    ['e'] = 'g',\n\
    \    ['f'] = 'h',\n    ['g'] = 'i',\n    ['h'] = 'j',\n    ['i'] = 'k',\n    ['j']\
    \ = 'l',\n    ['k'] = 'm',\n    ['l'] = 'n',\n    ['m'] = 'o',\n    ['n'] = 'p',\n\
    \    ['o'] = 'q',\n    ['p'] = 'r',\n    ['q'] = 's',\n    ['r'] = 't',\n    ['s']\
    \ = 'u',\n    ['t'] = 'v',\n    ['u'] = 'w',\n    ['v'] = 'x',\n    ['w'] = 'y',\n\
    \    ['x'] = 'z',\n    ['y'] = 'a',\n    ['z'] = 'b',\n    ['A'] = 'C',\n    ['B']\
    \ = 'D',\n    ['C'] = 'E',\n    ['D'] = 'F',\n    ['E'] = 'G',\n    ['F'] = 'H',\n\
    \    ['G'] = 'I',\n    ['H'] = 'J',\n    ['I'] = 'K',\n    ['J'] = 'L',\n    ['K']\
    \ = 'M',\n    ['L'] = 'N',\n    ['M'] = 'O',\n    ['N'] = 'P',\n    ['O'] = 'Q',\n\
    \    ['P'] = 'R',\n    ['Q'] = 'S',\n    ['R'] = 'T',\n    ['S'] = 'U',\n    ['T']\
    \ = 'V',\n    ['U'] = 'W',\n    ['V'] = 'X',\n    ['W'] = 'Y',\n    ['X'] = 'Z',\n\
    \    ['Y'] = 'A',\n    ['Z'] = 'B',\n  }\n  for i = 1, string.len(message) do\n",
  end, "  -- TODO: write the function\nend", "  --[[\n    Let's break down the problem.\
    \ We'll\n    do this in the following stages:\n    1. Go through the message and\
    \ make sure\n    all characters are upper case.\n    2. Swap the case of all characters.\n\
    \    3. Go through the message and encode\n    vowels.\n  ]]\n  -- make all characters\
    \ uppercase\n  local result = string.upper(message)\n  -- swap case of all characters\n\
    \  result = string.gsub(result, '(%a)', function(x)\n    if string.lower(x) ==\
    \ x then\n      return string.upper(x)\n    else\n      return string.lower(x)\n\
    \    end\n  end)\n  -- now let's replace vowels\n  result = string.gsub(result,\
    \ '(%a)', function(x)\n    local vowels = 'AEIOU'\n    -- if the character isn't\
    \ a vowel, we return it\n    -- as is\n    if string.find(vowels, x) == nil then\n\
    \      return x\n    else\n      local nextTwo = string.sub(vowels, string.find(vowels,\
    \ x) + 2, string.find(vowels, x) + 2)\n      return nextTwo\n    end\n  end)\n\
    \  return result\nend", "    local lower = 'a'\n    local upper = 'A'\n    local\
    \ isupper = false\n    local letters = {}\n    for i = 1, 26 do\n        if i\
    \ % 5 == 0 then\n            isupper = true\n        end\n        if isupper then\n\
    \            letters[lower] = string.char(upper)\n            lower = string.char(string.byte(lower)\
    \ + 1)\n            upper = string.char(string.byte(upper) + 1)\n            isupper\
    \ = false\n        else\n            letters[lower] = string.char(lower)\n   \
    \         lower = string.char(string.byte(lower) + 1)\n        end\n    end\n\
    \    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n    local encoded = ''\n    for\
    \ i = 1, #message do\n        local c = string.sub(message, i, i)\n        local\
    \ isvowel = false\n        local shift = 2\n        for j = 1, #vowels do\n  \
    \          if string.lower(c) == vowels[j] then\n                isvowel = true\n\
    \                break\n            end\n        end\n        if isvowel then\n\
    \            c = letters[c]\n            if c == 'c' then\n                shift\
    \ = 1\n            end\n            c = string.char(string.byte(c) + shift)\n\
    \        end\n        encoded = encoded .. c\n    end\n    return encoded\nend",
  "    local mapping = {a = 3, e = 5, i = 7, o = 9, u = 11}\n    local encoded_message\
    \ = message:gsub(\"%a\", function(c)\n        if mapping[c:lower()] then\n   \
    \         return string.char(c:byte() + mapping[c:lower()])\n        else\n  \
    \          if c:lower() == c then\n                return c:upper()\n        \
    \    else\n                return c:lower()\n            end\n        end\n  \
    \  end)\n    return encoded_message\nend\nassert(encode('test') == 'TGST')\nassert(encode('This\
    \ is a message') == 'tHKS KS C MGSSCGG')", "  local result = {}\n  for i=1, #message\
    \ do\n    local char = message:sub(i,i)\n    if char == 'A' then\n      table.insert(result,\
    \ 'C')\n    elseif char == 'a' then\n      table.insert(result, 'c')\n    elseif\
    \ char == 'E' then\n      table.insert(result, 'G')\n    elseif char == 'e' then\n\
    \      table.insert(result, 'g')\n    elseif char == 'I' then\n      table.insert(result,\
    \ 'K')\n    elseif char == 'i' then\n      table.insert(result, 'k')\n    elseif\
    \ char == 'O' then\n      table.insert(result, 'Q')\n    elseif char == 'o' then\n\
    \      table.insert(result, 'q')\n    elseif char == 'U' then\n      table.insert(result,\
    \ 'Y')\n    elseif char == 'u' then\n      table.insert(result, 'y')\n    elseif\
    \ char == char:upper() then\n      table.insert(result, char:lower())\n    else\n\
    \      table.insert(result, char:upper())\n    end\n  end\n  return table.concat(result)\n\
    end", "    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n    local alphabet = {\n\
    \        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n  \
    \      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    }\n\
    \    local encoded = ''\n    for i = 1, #message do\n        local letter = message:sub(i,\
    \ i)\n        local pos = table.indexOf(alphabet, letter:lower())\n        if\
    \ pos then\n            if table.indexOf(vowels, letter:lower()) then\n      \
    \          encoded = encoded .. alphabet[pos + 2]\n            else\n        \
    \        encoded = encoded .. alphabet[pos + 1]\n            end\n        else\n\
    \            encoded = encoded .. letter\n        end\n    end\n    return encoded\n\
    end", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local a = 97\n  local cipher\
    \ = {}\n  local letter = {}\n  local pos = 0\n  local ascii = 0\n  local after_vowel\
    \ = 0\n  local encoded = {}\n  for k, v in pairs(vowels) do\n    cipher[v:byte()]\
    \ = v:byte() + 2\n  end\n  for i = 1, message:len() do\n    table.insert(letter,\
    \ message:sub(i, i))\n  end\n  for i = 1, #letter do\n    pos = letter[i]:byte()\n\
    \    if letter[i] == letter[i]:upper() then\n      if letter[i] == letter[i]:lower()\
    \ then\n        if cipher[pos] then\n          if pos > a + 19 then\n        \
    \    ascii = pos - a - 21\n            after_vowel = cipher[a + ascii]\n     \
    \     else\n            after_vowel = cipher[pos]\n          end\n          table.insert(encoded,\
    \ string.char(after_vowel):upper())\n        else\n          table.insert(encoded,\
    \ letter[i]:upper())\n        end\n      else\n        if cipher[pos] then\n \
    \         if pos > a + 19 then\n            ascii = pos - a - 21\n           \
    \ after_vowel = cipher[a + ascii]\n          else\n            after_vowel = cipher[pos]\n\
    \          end\n          table.insert(encoded, string.char(after_vowel):lower())\n\
    \        else\n          table.insert(encoded, letter[i]:lower())\n        end\n\
    \      end\n    else\n      if cipher[pos] then\n        if pos > a + 19 then\n\
    \          ascii = pos - a - 21\n          after_vowel = cipher[a + ascii]\n \
    \       else\n          after_vowel = cipher[pos]\n        end\n        table.insert(encoded,\
    \ string.char(after_vowel))\n      else\n        table.insert(encoded, letter[i])\n\
    \      end\n    end\n  end\n  return table", "    return string.gsub(message,\
    \ '[%a]', function(c)\n        return string.gsub(string.upper(c), '[AEIOU]',\
    \ function(v)\n            return string.char(string.byte(v) + 2)\n        end)\n\
    \    end)\nend", "\treturn message:gsub(\"[aeiouAEIOU]\", function(c)\n\t\tlocal\
    \ new = string.char(c:byte() + 2)\n\t\tif new:match(\"[aeiouAEIOU]\") then\n\t\
    \t\treturn new\n\t\telse\n\t\t\treturn string.char(new:byte() + 1)\n\t\tend\n\t\
    end):upper()\nend", "    local letters = {\n        a = 'c',\n        b = 'd',\n\
    \        c = 'e',\n        d = 'f',\n        e = 'g',\n        f = 'h',\n    \
    \    g = 'i',\n        h = 'j',\n        i = 'k',\n        j = 'l',\n        k\
    \ = 'm',\n        l = 'n',\n        m = 'o',\n        n = 'p',\n        o = 'q',\n\
    \        p = 'r',\n        q = 's',\n        r = 't',\n        s = 'u',\n    \
    \    t = 'v',\n        u = 'w',\n        v = 'x',\n        w = 'y',\n        x\
    \ = 'z',\n        y = 'a',\n        z = 'b'\n    }\n    local encoded = ''\n \
    \   for char in message:gmatch('.') do\n        if letters[char:lower()] then\n\
    \            encoded = encoded .. letters[char:lower()]:upper()\n        else\n\
    \            encoded = encoded .. char:upper()\n        end\n    end\n    return\
    \ encoded\nend", "   local vowels = 'aeiou'\n   local encoded = message:gsub('.',\
    \ {\n      ['a'] = 'c', ['e'] = 'g', ['i'] = 'k',\n      ['o'] = 'q', ['u'] =\
    \ 'w',\n      ['A'] = 'C', ['E'] = 'G', ['I'] = 'K',\n      ['O'] = 'Q', ['U']\
    \ = 'W',\n   })\n   return encoded\nend", "    local res = \"\"\n    for c in\
    \ message:gmatch(\".\") do\n        local s,n = c:match\"(%l)(%d*)\"\n       \
    \ if not s then\n            res = res .. c\n        else\n            res = res\
    \ .. (n and c or s:swapcase())\n            if isVowel(s) then\n             \
    \   res = res .. (alphabet[s] + 2)\n            end\n        end\n    end\n  \
    \  return res\nend", "    local code = string.gsub(message, \"[aeiou]\", function(char)\n\
    \        return string.char(string.byte(char) + 2)\n    end)\n    return string.upper(code)\n\
    end", "    local function encodeChar(char)\n        if not char:match('%a') then\
    \ return char end\n        local letter = char:lower()\n        if vowels[letter]\
    \ then return vowels[letter] end\n        if char == letter then return letter:upper()\
    \ end\n        return letter\n    end\n    return string.gsub(message, '(%a)',\
    \ encodeChar)\nend", "    local first = 97 -- 'a'\n    local last = 122 -- 'z'\n\
    \    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local shift = 2\n    local\
    \ encoded = ''\n    for i = 1, #message do\n        -- These loops just check\
    \ if the character is a\n        -- vowel or letter, then substitute the characters\n\
    \        -- accordingly and then concat it to the string.\n        local c = message:sub(i,\
    \ i)\n        local low = c:lower()\n        local up = c:upper()\n        local\
    \ n = 0\n        for j = 1, #vowels do\n            if low == vowels[j] then\n\
    \                n = j\n                break\n            end\n        end\n\
    \        if n > 0 then\n            -- A vowel, encode it.\n            low =\
    \ vowels[(n + shift) % #vowels + 1]\n            up = low:upper()\n        elseif\
    \ low >= first and low <= last then\n            -- A letter, shift it.\n    \
    \        if low + shift > last then\n                low = low + shift - last\
    \ + first - 1\n            else\n                low = low + shift\n         \
    \   end\n            up = low:upper()\n        end\n        encoded = encoded\
    \ .. (c == c:lower() and low or up)\n    end\n    return encoded\nend", "\t--\
    \ The original message\n\tlocal result = ''", end, "  local encoder = {\n    ['a']\
    \ = 'c',\n    ['e'] = 'g',\n    ['i'] = 'k',\n    ['o'] = 'q',\n    ['u'] = 'w',\n\
    \    ['A'] = 'C',\n    ['E'] = 'G',\n    ['I'] = 'K',\n    ['O'] = 'Q',\n    ['U']\
    \ = 'W'\n  }\n  local encoded = ''\n  for letter in message:gmatch('%a') do\n\
    \    if encoder[letter] then\n      encoded = encoded .. encoder[letter]\n   \
    \ else\n      encoded = encoded .. letter:gsub('%a', {\n        ['a'] = 'c',\n\
    \        ['e'] = 'g',\n        ['i'] = 'k',\n        ['o'] = 'q',\n        ['u']\
    \ = 'w',\n        ['A'] = 'C',\n        ['E'] = 'G',\n        ['I'] = 'K',\n \
    \       ['O'] = 'Q',\n        ['U'] = 'W'\n      })\n    end\n  end\n  return\
    \ encoded\nend", end, "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local encoded_message\
    \ = \"\"\n  for i = 1, #message do\n    local c = message:sub(i, i)\n    local\
    \ found = false\n    for j = 1, #vowels do\n      if c == vowels[j] then\n   \
    \     c = vowels[j + 2]\n        if c == nil then\n          c = vowels[2]\n \
    \       end\n        found = true\n        break\n      end\n    end\n    if found\
    \ == false then\n      if c:upper() == c then\n        c = c:lower()\n      else\n\
    \        c = c:upper()\n      end\n    end\n    encoded_message = encoded_message\
    \ .. c\n  end\n  return encoded_message\nend", "    local encoded = {}\n    for\
    \ i = 1, #message do\n        local letter = message:sub(i, i)\n        if is_lower_case(letter)\
    \ then\n            encoded[i] = letter:upper()\n        elseif is_upper_case(letter)\
    \ then\n            encoded[i] = letter:lower()\n        elseif is_vowel(letter)\
    \ then\n            encoded[i] = get_next_vowel(letter)\n        else\n      \
    \      encoded[i] = letter\n        end\n    end\n    return table.concat(encoded)\n\
    end", "  local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n\
    \  local newMessage = ''\n  for i = 1, #message do\n    local currentLetter =\
    \ message:sub(i, i)\n    local isUpper = currentLetter == currentLetter:upper()\n\
    \    local currentLetterToLower = currentLetter:lower()\n    local currentLetterIndex\
    \ = 1\n    for index, letter in ipairs(alphabet) do\n      if letter == currentLetterToLower\
    \ then\n        currentLetterIndex = index\n      end\n    end\n    local newLetter\
    \ = alphabet[currentLetterIndex + 2]\n    if (currentLetterToLower == 'a' or currentLetterToLower\
    \ == 'e' or currentLetterToLower == 'i' or currentLetterToLower == 'o' or currentLetterToLower\
    \ == 'u') then\n      newLetter = alphabet[currentLetterIndex + 2]\n    end\n\
    \    if newLetter == nil then\n      newLetter = alphabet[(currentLetterIndex\
    \ + 2) - 26]\n    end\n    if isUpper then\n      newLetter = newLetter:upper()\n\
    \    end\n    newMessage = newMessage .. newLetter\n  end\n  return newMessage\n\
    end", "  if message == '' then\n    return ''\n  end\n  -- To handle upper and\
    \ lower case\n  local low_vowels = 'aeiou'\n  local up_vowels = 'AEIOU'\n  local\
    \ low_subs = 'cgkmnpqtwxz'\n  local up_subs = 'CGKMNPQTWXZ'\n  -- Convert all\
    \ to lower case\n  local lower = string.lower(message)\n  -- For each character\
    \ in the message\n  local result = ''\n  for i = 1, string.len(lower) do\n   \
    \ local c = string.sub(lower, i, i)\n    -- Find location of the character in\
    \ the alphabet\n    local n = string.find(low_vowels, c)\n    -- If the character\
    \ is in the alphabet\n    if n then\n      -- Replace the vowel with the one 2\
    \ places away\n      local sub = string.sub(low_subs, n, n)\n      result = result\
    \ .. sub\n    else\n      -- Otherwise capitalise the letter\n      local cap\
    \ = string.upper(c)\n      result = result .. cap\n    end\n  end\n  return result\n\
    end", end, "  \nend", end, "  -- your code here\nend", "  local list = {}\n  local\
    \ liste = {}\n  local liste2 = {}\n  local liste3 = {}\n  local liste4 = {}\n\
    \  local final = {}\n  local final2 = {}\n  local vowels = {\"a\", \"e\", \"i\"\
    , \"o\", \"u\"}\n  for i = 1, string.len(message) do\n    list[i] = string.sub(message,\
    \ i, i)\n  end\n  for i = 1, string.len(message) do\n    liste[i] = string.upper(list[i])\n\
    \  end\n  for i = 1, string.len(message) do\n    if (list[i] == liste[i]) then\n\
    \      liste2[i] = string.lower(list[i])\n    else\n      liste2[i] = list[i]\n\
    \    end\n  end\n  for i = 1, string.len(message) do\n    for j = 1, 5 do\n  \
    \    if (vowels[j] == liste2[i]) then\n        liste3[i] = j\n      end\n    end\n\
    \  end\n  for i = 1, string.len(message) do\n    if (liste3[i] == nil) then\n\
    \      liste4[i] = liste2[i]\n    else\n      if (liste3[i] == 1) then\n     \
    \   liste4[i] = vowels[3]\n      elseif (liste3[i] == 2) then\n        liste4[i]\
    \ = vowels[4]\n      elseif (liste3[i] == 3) then\n        liste4[i] = vowels[5]\n\
    \      elseif (liste3[i] == 4) then\n        liste4[i] = vowels[1]\n      elseif\
    \ (liste3[i] == 5) then\n        liste4[i] = vowels[2]\n      end\n    end\n \
    \ end\n  for i = 1, string.len(message) do\n    if (liste2[i] == liste4[i]) then\n\
    \      final[i] = liste[i]\n    else", "  local upper_case_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local lower_case_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  local vowels\
    \ = {\n    [\"a\"] = \"c\",\n    [\"e\"] = \"g\",\n    [\"i\"] = \"k\",\n    [\"\
    o\"] = \"q\",\n    [\"u\"] = \"w\",\n    [\"A\"] = \"C\",\n    [\"E\"] = \"G\"\
    ,\n    [\"I\"] = \"K\",\n    [\"O\"] = \"Q\",\n    [\"U\"] = \"W\"\n  }\n  local\
    \ function switch_case(c)\n    if (upper_case_letters:find(c)) then\n      return\
    \ lower_case_letters:sub(upper_case_letters:find(c),upper_case_letters:find(c))\n\
    \    else\n      return upper_case_letters:sub(lower_case_letters:find(c),lower_case_letters:find(c))\n\
    \    end\n  end\n  local result = \"\"\n  for c in message:gmatch(\".\") do\n\
    \    if (vowels[c]) then\n      result = result .. vowels[c]\n    else\n     \
    \ result = result .. switch_case(c)\n    end\n  end\n  return result\nend", end,
  "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n  local encoded = ''\n  for i = 1, message:len() do\n    local char\
    \ = message:sub(i, i)\n    local isVowel = false\n    for j = 1, #vowels do\n\
    \      if char == vowels[j] then\n        isVowel = true\n        break\n    \
    \  end\n    end\n    if isVowel then\n      local index = alphabet:find(char)\n\
    \      index = (index + 2) % #alphabet\n      encoded = encoded .. alphabet:sub(index,\
    \ index)\n    else\n      if char == char:upper() then\n        encoded = encoded\
    \ .. char:lower()\n      else\n        encoded = encoded .. char:upper()\n   \
    \   end\n    end\n  end\n  return encoded\nend", end, end, "    local encoding\
    \ = {['a'] = 'c', ['e'] = 'g', ['i'] = 'k', ['o'] = 'q', ['u'] = 'w'}\n    local\
    \ chars = {}\n    for c in message:gmatch(\".\") do\n        if c:match(\"%a\"\
    ) then\n            if encoding[c:lower()] then \n                c = encoding[c:lower()]\n\
    \            elseif c:match(\"%l\") then\n                c = c:upper()\n    \
    \        else\n                c = c:lower()\n            end\n        end\n \
    \       table.insert(chars, c)\n    end\n    return table.concat(chars)\nend",
  "  message = message:lower()\n  local vowels = 'aeiou'\n  local newMessage = ''\n\
    \  for i = 1, #message do\n    if message:sub(i, i) == vowels:sub(vowels:find(message:sub(i,\
    \ i)), vowels:find(message:sub(i, i))) then\n      newMessage = newMessage ..\
    \ vowels:sub(vowels:find(message:sub(i, i)) + 2, vowels:find(message:sub(i, i))\
    \ + 2)\n    elseif message:sub(i, i) == ' ' then\n      newMessage = newMessage\
    \ .. ' '\n    else\n      newMessage = newMessage .. message:sub(i, i):upper()\n\
    \    end\n  end\n  return newMessage\nend", "    local encoded = ''\n    for i\
    \ = 1, #message do\n        local letter = message:sub(i, i)\n        local l\
    \ = letter:lower()\n        if string.find(vowels, l) then\n            local\
    \ index = string.find(vowels, l)\n            local c = (index + 2) % #vowels\n\
    \            letter = vowels:sub(c + 1, c + 1)\n        end\n        if letter\
    \ == letter:lower() then\n            letter = letter:upper()\n        else\n\
    \            letter = letter:lower()\n        end\n        encoded = encoded ..\
    \ letter\n    end\n    return encoded\nend", "    local vowels = {\n        ['a']\
    \ = 'c',\n        ['e'] = 'g',\n        ['i'] = 'k',\n        ['o'] = 'q',\n \
    \       ['u'] = 'y'\n    }\n    message = message:lower()\n    local encoded =\
    \ ''\n    for i = 1, message:len() do\n        local l = message:sub(i, i)\n \
    \       if vowels[l] then\n            encoded = encoded .. vowels[l]\n      \
    \  else\n            encoded = encoded .. string.char(string.byte(l) - 32)\n \
    \       end\n    end\n    return encoded\nend", "    local function encode_character(character)\n\
    \        if character:match('[aeiou]') then\n            local i = character:byte()\
    \ + 2\n            return string.char(i)\n        elseif character:match('[AEIOU]')\
    \ then\n            local i = character:byte() + 2\n            return string.char(i):lower()\n\
    \        elseif character:match('[A-Z]') then\n            local i = character:byte()\
    \ + 32\n            return string.char(i)\n        elseif character:match('[a-z]')\
    \ then\n            local i = character:byte() - 32\n            return string.char(i)\n\
    \        else\n            return character\n        end\n    end\n    return\
    \ string.gsub(message, '.', encode_character)\nend", "  -- check for string\n\
    \  assert(type(message) == 'string', 'Argument must be a string')\n  -- convert\
    \ to lowercase\n  message = message:lower()\n  -- local copy of vowels\n  local\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n  -- table to store converted values\n \
    \ local converted = {}\n  -- pass through message\n  for _, char in ipairs(message:split(''))\
    \ do\n    -- check for letter in vowels\n    local letter = false\n    for _,\
    \ vowel in ipairs(vowels) do\n      if char == vowel then\n        letter = vowel\n\
    \        break\n      end\n    end\n    -- check if letter\n    if letter then\n\
    \      -- swap case\n      letter = letter:upper()\n      -- get index of letter\n\
    \      local index = vowels:indexOf(letter:lower())\n      -- check if at end\n\
    \      if index == #vowels then\n        -- go to start\n        index = 1\n \
    \     else\n        -- increment\n        index = index + 1\n      end\n     \
    \ -- add converted letter\n      converted[#converted + 1] = vowels[index]\n \
    \   else\n      -- change case\n      if char:isupper() then\n        converted[#converted\
    \ + 1] = char:lower()\n      else\n        converted[#converted + 1] = char:upper()\n\
    \      end\n    end\n  end\n  -- return converted value\n  return table.concat(converted)\n\
    end", "\t\n\tlocal result = {}\n\tlocal alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \t\n\tfor i=1, string.len(message) do\n\t\tlocal char = string.sub(message, i,\
    \ i)\n\t\tlocal charInAlphabet = false\n\t\t\n\t\tfor j,v in ipairs(alphabet)\
    \ do\n\t\t\tif char == v then\n\t\t\t\tcharInAlphabet = true\n\t\t\t\t\n\t\t\t\
    \tif string.match(char, \"[aeiou]\") then\n\t\t\t\t\tif j + 2 > 26 then\n\t\t\t\
    \t\t\tchar = alphabet[(j + 2) - 26]\n\t\t\t\t\telse\n\t\t\t\t\t\tchar = alphabet[j\
    \ + 2]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tif string.match(char, \"\
    [A-Z]\") then\n\t\t\t\t\tchar = string.lower(char)\n\t\t\t\telse\n\t\t\t\t\tchar\
    \ = string.upper(char)\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tbreak\n\t\t\tend\n\t\t\
    end\n\t\t\n\t\tif not charInAlphabet then\n\t\t\tchar = ''\n\t\tend\n\t\t\n\t\t\
    table.insert(result, char)\n\tend\n\t\n\treturn table.concat(result)\nend", " \
    \ local letters = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local encoded_message = ''\n  for character in message:gmatch('.') do\n   \
    \ local is_letter = false\n    for i, letter in ipairs(letters) do\n      if character:lower()\
    \ == letter then\n        is_letter = true\n        local index = i\n        local\
    \ is_upper = false\n        if character == character:upper() then\n         \
    \ is_upper = true\n        end\n        if index > 23 then\n          index =\
    \ index - 23\n        else\n          index = index + 2\n        end\n       \
    \ character = letters[index]\n        if is_upper then\n          character =\
    \ character:upper()\n        end\n      end\n    end\n    if not is_letter then\n\
    \      character = character:lower()\n    end\n    encoded_message = encoded_message\
    \ .. character\n  end\n  return encoded_message\nend", "  return message:gsub(\"\
    [aeiou]\", {\n    [\"a\"] = \"c\", [\"e\"] = \"g\", [\"i\"] = \"k\", [\"o\"] =\
    \ \"q\", [\"u\"] = \"y\"\n  })\nend", "    -- TODO\nend", "    -- your code here\n\
    end", "  message = string.lower(message)\n  message = string.gsub(message, \"\
    a\", \"c\")\n  message = string.gsub(message, \"e\", \"g\")\n  message = string.gsub(message,\
    \ \"i\", \"k\")\n  message = string.gsub(message, \"o\", \"q\")\n  message = string.gsub(message,\
    \ \"u\", \"w\")\n  message = string.gsub(message, \"y\", \"a\")\n  return message\n\
    end", "\tlocal vowels, new_message = {\"a\", \"e\", \"i\", \"o\", \"u\"}, \"\"\
    \n\tfor index = 1, #message do\n\t\tif(message:sub(index, index) == \" \") then\n\
    \t\t\tnew_message = new_message .. \" \"\n\t\telseif(message:sub(index, index)\
    \ == \"z\") then\n\t\t\tnew_message = new_message .. \"b\"\n\t\telseif(message:sub(index,\
    \ index) == \"Z\") then\n\t\t\tnew_message = new_message .. \"B\"\n\t\telseif(table.indexOf(vowels,\
    \ message:sub(index, index)) == 1) then\n\t\t\tnew_message = new_message .. \"\
    C\"\n\t\telseif(table.indexOf(vowels, message:sub(index, index)) == 2) then\n\t\
    \t\tnew_message = new_message .. \"F\"\n\t\telseif(table.indexOf(vowels, message:sub(index,\
    \ index)) == 3) then\n\t\t\tnew_message = new_message .. \"I\"\n\t\telseif(table.indexOf(vowels,\
    \ message:sub(index, index)) == 4) then\n\t\t\tnew_message = new_message .. \"\
    L\"\n\t\telseif(table.indexOf(vowels, message:sub(index, index)) == 5) then\n\t\
    \t\tnew_message = new_message .. \"O\"\n\t\telseif(message:sub(index, index) ==\
    \ message:sub(index, index):upper()) then\n\t\t\tnew_message = new_message ..\
    \ message:sub(index, index):lower()\n\t\telse\n\t\t\tnew_message = new_message\
    \ .. message:sub(index, index):upper()\n\t\tend\n\tend\n\treturn new_message\n\
    end", "  local dictionary = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\",\
    \ \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"}\n  local vowels = {\"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n  local counter = 0\n  local temp = {}\n  for i = 1, #message\
    \ do\n    for j = 1, #dictionary do\n      if message:sub(i, i) == dictionary[j]\
    \ then\n        if j < #dictionary/2 then\n          counter = j+2\n        else\n\
    \          counter = j-24\n        end\n        if vowels[j] then\n          table.insert(temp,\
    \ counter)\n        else\n          table.insert(temp, j)\n        end\n     \
    \ end\n    end\n  end\n  local newMessage = \"\"\n  for i = 1, #temp do\n    newMessage\
    \ = newMessage..dictionary[temp[i]]\n  end\n  return newMessage\nend", end, " \
    \   local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encoded = ''\n    for\
    \ i = 1, #message do\n        local char = message:sub(i, i)\n        if table.contains(vowels,\
    \ char) then\n            local next = vowels[(table.indexof(vowels, char) + 2)\
    \ % #vowels]\n            encoded = encoded .. next\n        else\n          \
    \  encoded = encoded .. char\n        end\n    end\n    return encoded\nend",
  "  if type(message) ~= 'string' then \n    error('encode: message should be a string',2)\n\
    \  end\n  local function to_upper(c)\n    return c:upper()\n  end\n  local function\
    \ to_lower(c)\n    return c:lower()\n  end\n  local function encode_char(c)\n\
    \    local char = c:lower()\n    local vowels = 'aeiou'\n    if char == 'z' then\n\
    \      return 'B'\n    elseif char == 'y' then\n      return 'A'\n    elseif vowels:find(char)\
    \ then\n      local pos = vowels:find(char)\n      return vowels:sub(pos%5+1,pos%5+1)\n\
    \    else\n      return char\n    end\n  end\n  return message:gsub('%a',function(c)\n\
    \    if c:match('%l') then \n      return encode_char(c)\n    elseif c:match('%u')\
    \ then\n      return encode_char(c):upper()\n    else\n      return c\n    end\n\
    \  end)\nend", end, "    local m = string.lower(message)\n    local s = \"\"\n\
    \    for i = 1, #m do\n        local c = m:sub(i, i)\n        if c == 'a' then\
    \ s = s .. 'c'\n        elseif c == 'e' then s = s .. 'g'\n        elseif c ==\
    \ 'i' then s = s .. 'k'\n        elseif c == 'o' then s = s .. 'm'\n        elseif\
    \ c == 'u' then s = s .. 'o'\n        elseif c == ' ' then s = s .. ' '\n    \
    \    else s = s .. c:upper() end\n    end\n    return s\nend", "    local vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n    local new_message = {}\n    for i=1, #message\
    \ do\n        local char = message:sub(i, i)\n        if char == char:upper()\
    \ then\n            new_message[i] = char:lower()\n        else\n            new_message[i]\
    \ = char:upper()\n        end\n        for j=1, #vowels do\n            if char\
    \ == vowels[j] then\n                new_message[i] = vowels[j+2]\n          \
    \  end\n        end\n    end\n    return table.concat(new_message)\nend", "\t\
    local coded = ''\n\tfor i = 1, #message do\n\t\tlocal c = message:sub(i, i)\n\t\
    \tlocal low = c:lower()\n\t\tif low == 'a' then\n\t\t\tcoded = coded .. 'c'\n\t\
    \telseif low == 'e' then\n\t\t\tcoded = coded .. 'g'\n\t\telseif low == 'i' then\n\
    \t\t\tcoded = coded .. 'k'\n\t\telseif low == 'o' then\n\t\t\tcoded = coded ..\
    \ 'm'\n\t\telseif low == 'u' then\n\t\t\tcoded = coded .. 'q'\n\t\telseif low\
    \ == 'y' then\n\t\t\tcoded = coded .. 's'\n\t\telseif c == c:upper() then\n\t\t\
    \tcoded = coded .. low\n\t\telse\n\t\t\tcoded = coded .. c:upper()\n\t\tend\n\t\
    end\n\treturn coded\nend", "    local encodedMessage = ''\n    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in message:gmatch('.') do\n \
    \       local pos = alphabet:find(letter:lower())\n        local newChar = pos\
    \ and alphabet:sub(pos + 2, pos + 2) or ''\n        encodedMessage = encodedMessage\
    \ .. newChar:upper()\n    end\n    return encodedMessage\nend", "    local result\
    \ = ''\n    for _,letter in utf8.codes(message) do\n        if utf8.isupper(letter)\
    \ then\n            result = result .. utf8.char(letter + 32)\n        elseif\
    \ utf8.islower(letter) then\n            result = result .. utf8.char(letter -\
    \ 32)\n        else\n            local vowelIndex = find_element(letter, vowels)\n\
    \            if vowelIndex then\n                result = result .. \n       \
    \             utf8.char(vowels[(vowelIndex + 2) % #vowels])\n            else\n\
    \                result = result .. utf8.char(letter)\n            end\n     \
    \   end\n    end\n    return result\nend", end, "    return message:gsub('%a',\
    \ function(letter)\n        local offset = letter:lower() == letter and 97 or\
    \ 65\n        local new_offset = offset + 2\n        return string.char(new_offset\
    \ + letter:byte() - offset)\n    end)\nend", "  return message:gsub(\".\",\n \
    \     function(c)\n        local cc = c:lower()\n        if cc == 'a' then\n \
    \         return 'c'\n        elseif cc == 'e' then\n          return 'g'\n  \
    \      elseif cc == 'i' then\n          return 'k'\n        elseif cc == 'o' then\n\
    \          return 'm'\n        elseif cc == 'u' then\n          return 'q'\n \
    \       elseif cc == 'y' then\n          return 's'\n        elseif cc == 'z'\
    \ then\n          return 'a'\n        else\n          return string.char(string.byte(c)\
    \ + 2)\n        end\n      end\n    )\nend", "    local function shift_letter(l)\n\
    \        if l >= 'a' and l <= 'z' then\n            l = string.char((l:byte()\
    \ - 97 + 2) % 26 + 97)\n        elseif l >= 'A' and l <= 'Z' then\n          \
    \  l = string.char((l:byte() - 65 + 2) % 26 + 65)\n        end\n        return\
    \ l\n    end\n    local encode_table = {'a', 'e', 'i', 'o', 'u'}\n    local encode_string\
    \ = ''\n    for i = 1, #message do\n        local l = message:sub(i, i)\n    \
    \    for j = 1, #encode_table do\n            if l == encode_table[j] then\n \
    \               l = shift_letter(l)\n            end\n        end\n        encode_string\
    \ = encode_string .. l\n    end\n    return encode_string\nend", "    message\
    \ = message:gsub(\"(%w)\", function(c) \n        if not c:find(\"[AEIOUaeiou]\"\
    ) then\n            return c:upper()\n        elseif c == \"Z\" or c == \"z\"\
    \ then\n            return \"B\"\n        else\n            -- Since strings are\
    \ immutable, we will have to\n            -- convert the character to a number,\
    \ add 2, and then\n            -- convert it back to a character.\n          \
    \  return string.char(string.byte(c) + 2)\n        end\n    end)\n    return message\n\
    end", "  local encoded = \"\"\n  local vowels = \"AEIOUaeiou\"\n  for i = 1, message:len()\
    \ do\n    local char = message:sub(i, i)\n    if char:find(\"%a\") then\n    \
    \  local t = char:upper()\n      if t == \"Z\" then\n        encoded = encoded\
    \ .. \"B\"\n      elseif t == \"Y\" then\n        encoded = encoded .. \"A\"\n\
    \      elseif vowels:find(t) then\n        local num = vowels:find(t)\n      \
    \  if num + 2 > vowels:len() then\n          num = num + 2 - vowels:len()\n  \
    \      else\n          num = num + 2\n        end\n        encoded = encoded ..\
    \ vowels:sub(num, num)\n      else\n        encoded = encoded .. string.char(string.byte(t)\
    \ + 2)\n      end\n    else\n      encoded = encoded .. char\n    end\n  end\n\
    \  return encoded\nend", "   local encoded_message = message:gsub(\"[a-zA-Z]\"\
    , {\n      ['a'] = 'c',\n      ['b'] = 'd',\n      ['c'] = 'e',\n      ['d'] =\
    \ 'f',\n      ['e'] = 'g',\n      ['f'] = 'h',\n      ['g'] = 'i',\n      ['h']\
    \ = 'j',\n      ['i'] = 'k',\n      ['j'] = 'l',\n      ['k'] = 'm',\n      ['l']\
    \ = 'n',\n      ['m'] = 'o',\n      ['n'] = 'p',\n      ['o'] = 'q',\n      ['p']\
    \ = 'r',\n      ['q'] = 's',\n      ['r'] = 't',\n      ['s'] = 'u',\n      ['t']\
    \ = 'v',\n      ['u'] = 'w',\n      ['v'] = 'x',\n      ['w'] = 'y',\n      ['x']\
    \ = 'z',\n      ['y'] = 'a',\n      ['z'] = 'b',\n      ['A'] = 'C',\n      ['B']\
    \ = 'D',\n      ['C'] = 'E',\n      ['D'] = 'F',\n      ['E'] = 'G',\n      ['F']\
    \ = 'H',\n      ['G'] = 'I',\n      ['H'] = 'J',\n      ['I'] = 'K',\n      ['J']\
    \ = 'L',\n      ['K'] = 'M',\n      ['L'] = 'N',\n      ['M'] = 'O',\n      ['N']\
    \ = 'P',\n      ['O'] = 'Q',\n      ['P'] = 'R',\n      ['Q'] = 'S',\n      ['R']\
    \ = 'T',\n      ['S'] = 'U',\n      ['T'] = 'V',\n      ['U'] = 'W',\n      ['V']\
    \ = 'X',\n      ['W'] = 'Y',\n      ['X'] = 'Z',\n      ['Y'] = 'A',\n      ['Z']\
    \ = 'B',\n   })\n   return encoded_message\nend", end, "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local result = {}\n    for character in message:gmatch('.') do\n        local\
    \ ascii = character:byte()\n        if ascii > 64 and ascii < 91 then\n      \
    \      table.insert(result, string.char(ascii + 32))\n        elseif ascii > 96\
    \ and ascii < 123 then\n            local index = alphabet:find(character)\n \
    \           local code = index + 2\n            code = code > 26 and code - 26\
    \ or code\n            table.insert(result, alphabet:sub(code, code))\n      \
    \  else\n            table.insert(result, character)\n        end\n    end\n \
    \   return table.concat(result)\nend", "    local vowels = {'a', 'e', 'i', 'o',\
    \ 'u'}\n    local result = {}\n    for c in message:gmatch('.') do\n        local\
    \ n = c:byte()\n        if c:match('%a') then\n            if n > 96 then\n  \
    \              n = n - 32\n            else\n                n = n + 32\n    \
    \        end\n            if c:match('[aeiou]') then\n                n = n +\
    \ 2\n                if n > 90 then\n                    n = n - 26\n        \
    \        end\n            end\n        end\n        table.insert(result, string.char(n))\n\
    \    end\n    return table.concat(result)\nend", "    local encodedMessage = ''\n\
    \    for i = 1, #message do\n        local letter = message:sub(i, i)\n      \
    \  local lowerLetter = letter:lower()\n        if lowerLetter == 'a' then\n  \
    \          letter = 'c'\n        elseif lowerLetter == 'e' then\n            letter\
    \ = 'g'\n        elseif lowerLetter == 'i' then\n            letter = 'k'\n  \
    \      elseif lowerLetter == 'o' then\n            letter = 'q'\n        elseif\
    \ lowerLetter == 'u' then\n            letter = 's'\n        elseif letter ==\
    \ letter:upper() then\n            letter = letter:lower()\n        else\n   \
    \         letter = letter:upper()\n        end\n        encodedMessage = encodedMessage\
    \ .. letter\n    end\n    return encodedMessage\nend", end, "    local message_upper\
    \ = string.upper(message)\n    local result = ''\n    for i = 1, #message_upper\
    \ do\n        local c = message_upper:sub(i, i)\n        local upper_vowel = is_upper_vowel(c)\n\
    \        local lower_vowel = is_lower_vowel(c)\n        if upper_vowel or lower_vowel\
    \ then\n            if upper_vowel then\n                c = shift_upper_vowel(c)\n\
    \            else\n                c = shift_lower_vowel(c)\n            end\n\
    \        else\n            c = string.lower(c)\n        end\n        result =\
    \ result .. c\n    end\n    return result\nend", "  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local ret = ''\n  local current = ''\n  local isUp = false\n  local found =\
    \ false\n  local newLetter = ''\n  local twoLater = 0\n  local lookupIndex = 0\n\
    \  local lookupLetter = ''\n  for i = 1, #message do\n    -- If it's a letter\n\
    \    if message:sub(i, i):match('%a') then\n      current = message:sub(i, i)\n\
    \      -- Check for upper case\n      if current:match('%u') then\n        isUp\
    \ = true\n        current = current:lower()\n      end\n      -- Check for lower\
    \ case\n      if current:match('%l') then\n        isUp = false\n      end\n \
    \     -- Check for vowel\n      for j = 1, #alpha do\n        if current == alpha:sub(j,\
    \ j) then\n          found = true\n          twoLater = j + 2\n          if twoLater\
    \ > #alpha then\n            twoLater = twoLater - #alpha\n          end\n   \
    \       newLetter = alpha:sub(twoLater, twoLater)\n          if isUp then\n  \
    \          newLetter = newLetter:upper()\n          end\n          ret = ret ..\
    \ newLetter\n        end\n      end\n      -- If not vowel, insert current char\n\
    \      if not found then\n        ret = ret .. current\n      end\n      found\
    \ = false\n    else\n      ret = ret .. message:sub(i, i)\n    end\n  end\n  return\
    \ ret\nend", "    -- TODO: Your code here\nend", "  -- Your code here\nend", " \
    \   local alphabet = {}\n    for i = 97, 122 do\n        alphabet[string.char(i)]\
    \ = i\n    end\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local s = {}\n\
    \    for l in message:gmatch('.') do\n        if alphabet[l] then\n          \
    \  if is_vowel(l) then\n                l = get_next_letter(l, 2)\n          \
    \  end\n            s[#s + 1] = (l == l:lower()) and l:upper() or l:lower()\n\
    \        else\n            s[#s + 1] = l\n        end\n    end\n    return table.concat(s)\n\
    end", "\treturn nil\nend", "    local vowels = {['a'] = 1, ['e'] = 1, ['i'] =\
    \ 1, ['o'] = 1, ['u'] = 1}\n    local function encode_char(c)\n        local code\
    \ = c:byte()\n        if code >= 65 and code <= 90 then\n            return c:lower()\n\
    \        elseif code >= 97 and code <= 122 then\n            if vowels[c] then\n\
    \                code = code + 2\n                while code > 122 do\n      \
    \              code = code - 26\n                end\n                return string.char(code)\n\
    \            else\n                return c:upper()\n            end\n       \
    \ else\n            return c\n        end\n    end\n    return string.gsub(message,\
    \ '.', encode_char)\nend", end, "  -- your code here\nend", "\t-- create a table\
    \ of letters in reverse order\n\t-- use this table as a lookup for letters\n\t\
    local lookup = {}\n\tfor i = 1, 26 do\n\t\tlookup[#lookup + 1] = string.char(97\
    \ + (i - 1))\n\tend\n\tlookup = table.concat(lookup)", "    local step = 2\n \
    \   local encodedMessage = \"\"\n    for letter in message:gmatch(\"%a\") do\n\
    \        local asciiNumber = string.byte(letter)\n        local isUpperCase =\
    \ asciiNumber >= 65 and asciiNumber <= 90\n        local isLowerCase = asciiNumber\
    \ >= 97 and asciiNumber <= 122\n        if isUpperCase then\n            asciiNumber\
    \ = asciiNumber + step\n            if asciiNumber > 90 then\n               \
    \ asciiNumber = asciiNumber - 26\n            end\n        elseif isLowerCase\
    \ then\n            asciiNumber = asciiNumber + step\n            if asciiNumber\
    \ > 122 then\n                asciiNumber = asciiNumber - 26\n            end\n\
    \        end\n        local encodedLetter = string.char(asciiNumber)\n       \
    \ encodedMessage = encodedMessage .. encodedLetter\n    end\n    return encodedMessage\n\
    end", "\treturn nil\nend", "    local result = \"\"\n    for letter in message:gmatch('%a')\
    \ do\n        result = result .. encode_letter(letter)\n    end\n    return result\n\
    end", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encode_char\n \
    \   encode_char = function(c)\n        local encoded_c = c\n        local c_lower\
    \ = c:lower()\n        if c_lower:match('[a-z]') then\n            local is_vowel\
    \ = false\n            for _,v in ipairs(vowels) do\n                if c_lower\
    \ == v then\n                    is_vowel = true\n                    break\n\
    \                end\n            end\n            if is_vowel then\n        \
    \        encoded_c = vowels[index(vowels, c_lower) + 2]\n            else\n  \
    \              if c_lower == 'z' then\n                    encoded_c = 'B'\n \
    \               elseif c_lower == 'y' then\n                    encoded_c = 'A'\n\
    \                else\n                    encoded_c = string.char(c:byte() +\
    \ 2)\n                end\n            end\n        end\n        return encoded_c\n\
    \    end\n    return message:gsub('.', encode_char)\nend", "    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    local result = ''\n    local vowels = 'aeiou'\n\
    \    local findVowel = function(vowel)\n        return '%' .. vowel .. '%'\n \
    \   end\n    for letter in message:gmatch('.') do\n        if letter:match('%u')\
    \ then\n            result = result .. letter:lower()\n        elseif letter:match('%l')\
    \ then\n            result = result .. letter:upper()\n        else\n        \
    \    result = result .. letter\n        end\n    end\n    for vowel in vowels:gmatch('.')\
    \ do\n        local place = alphabet:find(vowel)\n        local newVowel = alphabet:sub(place+2,\
    \ place+2)\n        result = result:gsub(findVowel(vowel), newVowel)\n    end\n\
    \    return result\nend", "    local encode_message = ''\n    for char in message:gmatch(\"\
    .\") do\n        local char_lower = char:lower()\n        if char_lower == 'a'\
    \ then\n            encode_message = encode_message .. 'c'\n        elseif char_lower\
    \ == 'e' then\n            encode_message = encode_message .. 'g'\n        elseif\
    \ char_lower == 'i' then\n            encode_message = encode_message .. 'k'\n\
    \        elseif char_lower == 'o' then\n            encode_message = encode_message\
    \ .. 'q'\n        elseif char_lower == 'u' then\n            encode_message =\
    \ encode_message .. 's'\n        elseif char_lower == 'y' then\n            encode_message\
    \ = encode_message .. 'a'\n        elseif char_lower == 'z' then\n           \
    \ encode_message = encode_message .. 'b'\n        else\n            local char_dec\
    \ = char:byte()\n            if char_dec >= 97 and char_dec <= 122 then\n    \
    \            encode_message = encode_message .. string.char(char_dec + 2)\n  \
    \          elseif char_dec >= 65 and char_dec <= 90 then\n                encode_message\
    \ = encode_message .. string.char(char_dec + 32 + 2)\n            else\n     \
    \           encode_message = encode_message .. char\n            end\n       \
    \ end\n    end\n    return encode_message\nend", '    -- Encode a message', "\t\
    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tlocal alpha_set = {}\n\tlocal new_message = \"\"\n\tfor i=1, #alphabet do\n\t\
    \talpha_set[alphabet[i]] = i\n\tend\n\tfor i=1, #message do\n\t\tlocal letter\
    \ = message:sub(i,i)\n\t\tif alpha_set[letter] then\n\t\t\tif alpha_set[letter]\
    \ == #alphabet then\n\t\t\t\tlocal new_letter = alphabet[1]\n\t\t\t\tnew_message\
    \ = new_message .. new_letter\n\t\t\telse\n\t\t\t\tlocal new_letter = alphabet[alpha_set[letter]\
    \ + 1]\n\t\t\t\tnew_message = new_message .. new_letter\n\t\t\tend\n\t\telse\n\
    \t\t\tnew_message = new_message .. letter\n\t\tend\n\tend\n\treturn new_message\n\
    end", "    local encode_table = {\n        ['a'] = 'c',\n        ['e'] = 'g',\n\
    \        ['i'] = 'k',\n        ['o'] = 'q',\n        ['u'] = 'w',\n        ['A']\
    \ = 'C',\n        ['E'] = 'G',\n        ['I'] = 'K',\n        ['O'] = 'Q',\n \
    \       ['U'] = 'W',\n    }\n    local result = ''\n    for char in message:gmatch('.')\
    \ do\n        if encode_table[char] then\n            result = result .. encode_table[char]\n\
    \        else\n            result = result .. char:lower()\n        end\n    end\n\
    \    return result\nend", "  return nil\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local replacement = {}\n    for i = 1, #alphabet do\n        replacement[alphabet:sub(i,\
    \ i)] = i + 2\n    end\n    for i = 1, #alphabet do\n        replacement[alphabet:sub(i,\
    \ i):upper()] = i + 2\n    end\n    replacement['u'] = 'a'\n    replacement['U']\
    \ = 'A'\n    replacement['v'] = 'b'\n    replacement['V'] = 'B'\n    replacement['w']\
    \ = 'c'\n    replacement['W'] = 'C'\n    replacement['x'] = 'd'\n    replacement['X']\
    \ = 'D'\n    replacement['y'] = 'e'\n    replacement['Y'] = 'E'\n    replacement['z']\
    \ = 'f'\n    replacement['Z'] = 'F'\n    local new_message = ''\n    for i = 1,\
    \ #message do\n        local char = message:sub(i, i)\n        if replacement[char]\
    \ then\n            new_message = new_message .. replacement[char]\n        else\n\
    \            new_message = new_message .. char\n        end\n    end\n    return\
    \ new_message\nend", "  -- code here\nend", "    local enc = ''\n    local vowels\
    \ = {'a', 'e', 'i', 'o', 'u'}\n    for i = 1, #message do\n        local ch =\
    \ message:sub(i, i)\n        local code = ch:byte()\n        if code >= 97 and\
    \ code <= 122 then\n            code = code - 32\n        elseif code >= 65 and\
    \ code <= 90 then\n            code = code + 32\n        end\n        for _, v\
    \ in ipairs(vowels) do\n            if ch == v then\n                ch = vowels[((code-64)%5)\
    \ + 1]\n            end\n        end\n        enc = enc .. ch\n    end\n    return\
    \ enc\nend", "    local msg = message:lower()\n    local function is_vowel(letter)\n\
    \        return letter == 'a' or letter == 'e' or letter == 'i' or letter == 'o'\
    \ or letter == 'u'\n    end\n    local function encode_char(letter)\n        local\
    \ is_upper = letter:upper() == letter\n        local enc = is_vowel(letter) and\
    \ (string.byte(letter) + 2) or string.byte(letter)\n        local c = string.char(enc)\n\
    \        return is_upper and c:upper() or c\n    end\n    return msg:gsub('.',\
    \ encode_char)\nend", "  -- TODO\nend", "    local encoded = ''\n    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels = 'aeiou'\n    for i = 1, #message\
    \ do\n        local char = message:sub(i, i)\n        local upper = char:upper()\
    \ == char\n        local lower = char:lower() == char\n        if upper then\n\
    \            char = char:lower()\n        end\n        local is_vowel = vowels:find(char)\n\
    \        if is_vowel then\n            local offset = is_vowel + 2\n         \
    \   if offset > #vowels then\n                offset = offset - #vowels\n    \
    \        end\n            char = vowels:sub(offset, offset)\n        end\n   \
    \     if upper then\n            char = char:upper()\n        end\n        encoded\
    \ = encoded .. char\n    end\n    return encoded\nend", end, "    local encoded\
    \ = \"\"\n    for i = 1, #message do\n        local char = message:sub(i, i)\n\
    \        if string.find(char, \"[aeiou]\") then\n            local next = string.find(ALPHABET,\
    \ char) + 2\n            char = ALPHABET:sub(next, next)\n        end\n      \
    \  encoded = encoded .. string.upper(char)\n    end\n    return encoded\nend",
  "   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n   local newalphabet = alphabet\
    \ .. alphabet\n   local message_table = {}\n   for char in message:gmatch('.')\
    \ do\n      local index = alphabet:find(char:lower())\n      if index then\n \
    \        if char == char:upper() then\n            message_table[#message_table\
    \ + 1] = newalphabet:sub(index + 2, index + 2):upper()\n         else\n      \
    \      message_table[#message_table + 1] = newalphabet:sub(index + 2, index +\
    \ 2)\n         end\n      else\n         message_table[#message_table + 1] = char\n\
    \      end\n   end\n   return table.concat(message_table)\nend", end, "    local\
    \ new_message = ''\n    for letter in message:gmatch('.') do\n        local new_letter\
    \ = letter\n        if letter:match('[a-z]') then\n            if letter == letter:upper()\
    \ then\n                new_letter = letter:lower()\n            else\n      \
    \          new_letter = letter:upper()\n            end\n        end\n       \
    \ if new_letter:match('[aeiou]') then\n            local next_letter = new_letter:byte()\
    \ + 2\n            if next_letter > ('u'):byte() then\n                next_letter\
    \ = next_letter - 5\n            end\n            new_letter = string.char(next_letter)\n\
    \        end\n        new_message = new_message .. new_letter\n    end\n    return\
    \ new_message\nend", "    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'}\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local encoded\
    \ = {}\n    for i = 1, #message do\n        local letter = message:sub(i, i)\n\
    \        local lower = letter:lower()\n        if lower == letter then\n     \
    \       encoded[i] = letter:upper()\n        else\n            encoded[i] = letter:lower()\n\
    \        end\n        for index, vowel in ipairs(vowels) do\n            if lower\
    \ == vowel then\n                encoded[i] = alphabet[index + 2]\n          \
    \  end\n        end\n    end\n    return table.concat(encoded)\nend", end, " \
    \   local result = ''\n    for ch in message:gmatch('.') do\n        local char\
    \ = ch:lower()\n        if char:find('[aeiou]') then\n            char = char:gsub('[aeiou]',\
    \ function(vowel)\n                local offset = 'abcdefghijklmnopqrstuvwxyz':find(vowel)\
    \ + 2\n                if offset > 26 then\n                    offset = offset\
    \ - 26\n                end\n                return 'abcdefghijklmnopqrstuvwxyz':sub(offset,\
    \ offset)\n            end)\n        end\n        if ch:match('%u') then\n   \
    \         char = char:upper()\n        end\n        result = result .. char\n\
    \    end\n    return result\nend", "  return string.gsub(message, \"[a-zA-Z]\"\
    , function(c)\n    local char = string.upper(c)\n    if char == 'A' then return\
    \ 'C' end\n    if char == 'E' then return 'G' end\n    if char == 'I' then return\
    \ 'K' end\n    if char == 'O' then return 'M' end\n    if char == 'U' then return\
    \ 'O' end\n    if char == 'B' then return 'A' end\n    if char == 'F' then return\
    \ 'E' end\n    if char == 'J' then return 'I' end\n    if char == 'N' then return\
    \ 'O' end\n    if char == 'V' then return 'U' end\n    if char == 'C' then return\
    \ 'B' end\n    if char == 'G' then return 'F' end\n    if char == 'K' then return\
    \ 'J' end\n    if char == 'P' then return 'N' end\n    if char == 'W' then return\
    \ 'V' end\n    if char == 'D' then return 'C' end\n    if char == 'H' then return\
    \ 'G' end\n    if char == 'L' then return 'K' end\n    if char == 'Q' then return\
    \ 'P' end\n    if char == 'X' then return 'W' end\n    if char == 'Y' then return\
    \ 'X' end\n    if char == 'Z' then return 'Y' end\n    return char\n  end)\nend",
  "  message = message:gsub(\"[aeiou]\", \n    function(vowel)\n      -- If the vowel\
    \ is a \"u\", we loop around\n      if (vowel == \"u\") then\n        return \"\
    a\"\n      end\n      -- Otherwise, just take the next one\n      return string.char(string.byte(vowel)\
    \ + 1)\n    end)\n  return message:gsub(\".\",\n    function(ch)\n      -- Swap\
    \ the case of the letter\n      if (ch:find(\"[a-z]\")) then\n        return ch:upper()\n\
    \      else\n        return ch:lower()\n      end\n    end)\nend", "  local t\
    \ = {}\n  local swappedCaseMessage = swapCase(message)\n  local twoPlacesAheadVowelsMessage\
    \ = replaceTwoPlacesAheadVowels(swappedCaseMessage)\n  return twoPlacesAheadVowelsMessage\n\
    end", "    local function encode_char(char)\n        local ascii = string.byte(char)\n\
    \        if ascii >= 65 and ascii <= 90 then\n            if ascii == 90 then\n\
    \                return string.char(65)\n            else\n                return\
    \ string.char(ascii + 1)\n            end\n        elseif ascii >= 97 and ascii\
    \ <= 122 then\n            if ascii == 122 then\n                return string.char(97)\n\
    \            else\n                return string.char(ascii + 1)\n           \
    \ end\n        elseif char == 'a' then\n            return 'c'\n        elseif\
    \ char == 'e' then\n            return 'g'\n        elseif char == 'i' then\n\
    \            return 'k'\n        elseif char == 'o' then\n            return 'q'\n\
    \        elseif char == 'u' then\n            return 'w'\n        else\n     \
    \       return char\n        end\n    end\n    local encoded = {}\n    for char\
    \ in string.gmatch(message, '.') do\n        encoded[#encoded + 1] = encode_char(char)\n\
    \    end\n    return table.concat(encoded)\nend", end, end, "\tlocal alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal result = \"\"\n\tfor character in\
    \ message:gmatch(\".\") do\n\t\tif character:match(\"%a\") then\n\t\t\tlocal encode\
    \ = character:match(\"%u\") and character:lower() or character:upper()\n\t\t\t\
    local index = alphabet:find(encode)\n\t\t\tlocal vowel = encode:match(\"[aeiou]\"\
    )\n\t\t\tif vowel then\n\t\t\t\tlocal new_index = (index + 2) % #alphabet\n\t\t\
    \t\tencode = alphabet:sub(new_index, new_index)\n\t\t\tend\n\t\t\tresult = result\
    \ .. encode\n\t\telse\n\t\t\tresult = result .. character\n\t\tend\n\tend\n\t\
    return result\nend", "\t-- your code here\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local result = \"\"\n  for char in message:gmatch(\".\") do\n    local charIndex\
    \ = alphabet:find(char:lower())\n    if charIndex then\n      local nextCharIndex\
    \ = charIndex + 2\n      if nextCharIndex > #alphabet then\n        nextCharIndex\
    \ = nextCharIndex - #alphabet\n      end\n      if char:upper() == char then\n\
    \        result = result .. alphabet:sub(nextCharIndex, nextCharIndex):upper()\n\
    \      else\n        result = result .. alphabet:sub(nextCharIndex, nextCharIndex)\n\
    \      end\n    else\n      result = result .. char\n    end\n  end\n  return\
    \ result\nend", "\tlocal s = string.gsub(message, '[aeiou]', {['a'] = 'c', ['e']\
    \ = 'g', ['i'] = 'k', ['o'] = 'q', ['u'] = 's'})\n\treturn s:upper()\nend", " \
    \   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local out = ''\n    local\
    \ i = 1\n    while i <= #message do\n        local char = message:sub(i, i)\n\
    \        local char_pos = alphabet:find(char:lower())\n        if char_pos then\n\
    \            local offset = char_pos + 2\n            offset = offset - 26 * (offset\
    \ > 26)\n            local new_char = alphabet:sub(offset, offset)\n         \
    \   if char == char:upper() then\n                new_char = new_char:upper()\n\
    \            end\n            out = out .. new_char\n        else\n          \
    \  out = out .. char\n        end\n        i = i + 1\n    end\n    return out\n\
    end", "  assert(type(message) == 'string', 'expected string, but got ' .. type(message))\n\
    \  --  assert is a function that takes 3 parameters\n  -- 1. a boolean\n  -- 2.\
    \ an error message\n  -- 3. an optional level of stack to go back when tracing\
    \ error", "\t-- @TODO: Implement\n\treturn nil\nend", end, "  -- TODO: implement\
    \ this function.\nend", "  -- TODO: Implement me\nend", "    message = string.gsub(message,\
    \ \"[a]\", \"c\")\n    message = string.gsub(message, \"[e]\", \"g\")\n    message\
    \ = string.gsub(message, \"[i]\", \"k\")\n    message = string.gsub(message, \"\
    [o]\", \"q\")\n    message = string.gsub(message, \"[u]\", \"s\")\n    message\
    \ = string.gsub(message, \"[A]\", \"C\")\n    message = string.gsub(message, \"\
    [E]\", \"G\")\n    message = string.gsub(message, \"[I]\", \"K\")\n    message\
    \ = string.gsub(message, \"[O]\", \"Q\")\n    message = string.gsub(message, \"\
    [U]\", \"S\")\n    return message\nend", "\tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \tlocal encoded = ''\n\tfor index = 1, #message do\n\t\tlocal letter = message:sub(index,\
    \ index)\n\t\tlocal pos = alphabet:find(letter:lower())\n\t\tif pos then\n\t\t\
    \tif pos > 24 then\n\t\t\t\tpos = pos - 24\n\t\t\telse\n\t\t\t\tpos = pos + 2\n\
    \t\t\tend\n\t\t\tlocal c = alphabet:sub(pos, pos)\n\t\t\tencoded = encoded ..\
    \ (letter:lower() == letter and c or c:upper())\n\t\telse\n\t\t\tencoded = encoded\
    \ .. letter\n\t\tend\n\tend\n\treturn encoded\nend", "  \n  local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local vowels = {'a','e','i','o','u'}\n  local space = {' '}\n  local letter\n\
    \  local result = ''\n  local lower\n  local new\n  local temp\n  local num\n\
    \  local code\n  local space_count = 0\n  local space_skip = 0\n  local i = 1\n\
    \  local j = 1\n  local k = 1\n  local size = string.len(message)\n  local alpha_size\
    \ = table.getn(alphabet)\n  local vowel_size = table.getn(vowels)\n  local space_size\
    \ = table.getn(space)\n  \n  for i = 1, size do\n    for j = 1, alpha_size do\n\
    \      if message:sub(i,i) == alphabet[j] then\n        lower = message:sub(i,i)\n\
    \        new = lower:upper()\n        letter = new\n        break\n      elseif\
    \ message:sub(i,i) == alphabet[j]:upper() then\n        letter = message:sub(i,i)\n\
    \        break\n      elseif message:sub(i,i) == space[1] then\n        letter\
    \ = space[1]\n        break\n      end\n    end\n    for k = 1, vowel_size do\n\
    \      if letter == vowels[k] then\n        if letter == 'u' then\n          temp\
    \ = vowels[1]\n        else\n          temp = vowels[k+1]\n        end\n     \
    \   break\n      elseif letter == vowels[k]:upper() then\n        if letter ==\
    \ 'U' then\n          temp = vowels[1]:upper()\n        else\n          temp =\
    \ vowels[k+1]:upper()\n        end\n        break\n      elseif letter == space[1]\
    \ then\n        temp = space[1]\n        break\n      end\n    end\n    if letter\
    \ == space[1] then\n      result = result .. letter\n      space_", "  local ret\
    \ = {}\n  for i=1,#message do\n    local char = message:sub(i,i)\n    if char:match('[a-zA-Z]')\
    \ then\n      local char_num = string.byte(char:lower())\n      if char_num >=\
    \ 97 and char_num <= 101 then\n        char_num = char_num + 23\n      elseif\
    \ char_num >= 102 and char_num <= 122 then\n        char_num = char_num + 2\n\
    \      end\n      if char == char:lower() then\n        char = string.char(char_num)\n\
    \      else\n        char = string.char(char_num - 32)\n      end\n    end\n \
    \   table.insert(ret, char)\n  end\n  return table.concat(ret)\nend", "  return\
    \ string.gsub(message, \"[A-Za-z]\", function(c)\n    -- Is it uppercase?\n  \
    \  local is_upper = (c == string.upper(c))\n    -- Swap case\n    local c = string.lower(c)\n\
    \    -- We can do a simple modulo to wrap characters from the front\n    -- if\
    \ we add the length of the alphabet to the index.\n    local index = (ENGLISH_ALPHABET:find(c)\
    \ + #ENGLISH_ALPHABET) % #ENGLISH_ALPHABET\n    local new_c = ENGLISH_ALPHABET:sub(index\
    \ + 1, index + 1)\n    -- Only swap vowels\n    if VOWELS:find(c) then\n     \
    \ new_c = VOWELS:sub(index + 1, index + 1)\n    end\n    -- Restore case\n   \
    \ if is_upper then\n      new_c = string.upper(new_c)\n    end\n    return new_c\n\
    \  end)\nend", "\tlocal vowels = \"aeiou\"\n\tlocal encoded = \"\"\n\tfor i =\
    \ 1, #message do\n\t\tlocal letter = message:sub(i, i)\n\t\tif vowels:find(letter:lower())\
    \ then\n\t\t\tlocal n = vowels:find(letter:lower()) + 2\n\t\t\tif n > #vowels\
    \ then\n\t\t\t\tn = n - #vowels\n\t\t\tend\n\t\t\tencoded = encoded .. vowels:sub(n,\
    \ n)\n\t\telse\n\t\t\tif letter:lower() == letter then\n\t\t\t\tencoded = encoded\
    \ .. letter:upper()\n\t\t\telse\n\t\t\t\tencoded = encoded .. letter:lower()\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn encoded\nend", "\tlocal newmessage = ''\n\t\
    for i = 1, #message do\n\t\tlocal c = message:sub(i,i)\n\t\tif c == c:upper()\
    \ then\n\t\t\tc = c:lower()\n\t\telse\n\t\t\tc = c:upper()\n\t\tend\n\t\tif c\
    \ == 'a' then\n\t\t\tc = 'c'\n\t\telseif c == 'e' then\n\t\t\tc = 'g'\n\t\telseif\
    \ c == 'i' then\n\t\t\tc = 'k'\n\t\telseif c == 'o' then\n\t\t\tc = 'm'\n\t\t\
    elseif c == 'u' then\n\t\t\tc = 'o'\n\t\tend\n\t\tnewmessage = newmessage .. c\n\
    \tend\n\treturn newmessage\nend", "    local vowels = { 'a', 'e', 'i', 'o', 'u'\
    \ }\n    local result = ''\n    for i = 1, #message do\n        local c = message:sub(i,\
    \ i)\n        if c == c:upper() then c = c:lower() else c = c:upper() end\n  \
    \      for _,v in ipairs(vowels) do\n            if c == v then c = vowels[#vowels\
    \ % #vowels + 1] end\n        end\n        result = result .. c\n    end\n   \
    \ return result\nend", "    message = message:gsub('[aeiou]', 'a'):gsub('[AEIOU]',\
    \ 'A')\n    return message:gsub('.', function(c)\n        local n = string.byte(c)\
    \ + 2\n        if n > 122 then n = n - 26 end\n        if n > 90 and n < 97 then\
    \ n = n - 26 end\n        return string.char(n)\n    end)\nend", "    local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    local encoded = \"\"\n    local re = {\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    local rep = {'c', 'g', 'k', 'o', 's'}\n\
    \    for i=1, #message do\n        local c = message:sub(i,i)\n        if c ==\
    \ c:upper() then\n            c = c:lower()\n        else\n            c = c:upper()\n\
    \        end\n        for j=1, #re do\n            if c == re[j] then\n      \
    \          c = rep[j]\n            end\n        end\n        encoded = encoded\
    \ .. c\n    end\n    return encoded\nend", "    -- TODO: write this function!\n\
    end", "    if #message == 0 then return end\n    local encoded = ''\n    for i\
    \ = 1, #message do\n        encoded = encoded .. encode_char(message:sub(i, i))\n\
    \    end\n    return encoded\nend", end, "\tlocal j\n\tlocal res = \"\"\n\tfor\
    \ i = 1, #message do\n\t\tif string.find(\"AEIOUaeiou\", string.sub(message, i,\
    \ i)) then\n\t\t\tif string.sub(message, i, i) == \"U\" or string.sub(message,\
    \ i, i) == \"u\" then\n\t\t\t\tj = 1\n\t\t\telseif string.sub(message, i, i) ==\
    \ \"Z\" or string.sub(message, i, i) == \"z\" then\n\t\t\t\tj = 2\n\t\t\telse\n\
    \t\t\t\tj = string.byte(string.sub(message, i, i)) + 2\n\t\t\tend\n\t\t\tres =\
    \ res .. string.char(j)\n\t\telse\n\t\t\tres = res .. string.sub(message, i, i)\n\
    \t\tend\n\tend\n\treturn res\nend", "    return message:gsub('(%a)', function(char)\n\
    \        if char:match('%a') then\n            return char:gsub('([aeiou])', function(vowel)\n\
    \                return ALPHABET[ALPHABET:find(vowel, 1, true) + 2]\n        \
    \    end):gsub('([AEIOU])', function(vowel)\n                return ALPHABET:upper():sub(ALPHABET:upper():find(vowel,\
    \ 1, true) + 2, ALPHABET:upper():find(vowel, 1, true) + 2)\n            end)\n\
    \        end\n    end)\nend", "    local step = 2\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = 'aeiou'\n    local encoded = ''\n    for i = 1, #message do\n\
    \        local letter = message:sub(i, i)\n        if letter == letter:upper()\
    \ then\n            letter = letter:lower()\n        else\n            letter\
    \ = letter:upper()\n        end\n        if vowels:find(letter) then\n       \
    \     local position = vowels:find(letter)\n            encoded = encoded .. vowels:sub((position\
    \ + step) % 5 + 1, (position + step) % 5 + 1)\n        else\n            encoded\
    \ = encoded .. letter\n        end\n    end\n    return encoded\nend", "\tlocal\
    \ vowels = {['a'] = true, ['e'] = true, ['i'] = true, ['o'] = true, ['u'] = true}\n\
    \tlocal alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal new_message = ''\n\t\
    for i = 1, #message do\n\t\tlocal current_letter = message:sub(i, i)\n\t\tif vowels[current_letter]\
    \ then\n\t\t\tlocal is_lowercase = current_letter == current_letter:lower()\n\t\
    \t\tlocal next_letter = alphabet:find(current_letter:lower()) + 2\n\t\t\tif next_letter\
    \ > #alphabet then\n\t\t\t\tnext_letter = next_letter - #alphabet\n\t\t\tend\n\
    \t\t\tnew_message = new_message .. alphabet:sub(next_letter, next_letter):upper()\n\
    \t\telse\n\t\t\tnew_message = new_message .. current_letter:upper()\n\t\tend\n\
    \tend\n\treturn new_message\nend", "    return ''\nend", "  return message:gsub(\"\
    [aA]\", \"C\"):gsub(\"[eE]\", \"G\"):gsub(\"[iI]\", \"K\"):gsub(\"[oO]\", \"M\"\
    ):gsub(\"[uU]\", \"Q\"):gsub(\".\", function(c) return c:lower() == c and c:upper()\
    \ or c:lower() end)\nend", "    return string.gsub(message:lower(), '[a-z]', encoder)\n\
    end", "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal function isVowel(c)\n\
    \t\tfor i, v in ipairs(vowels) do\n\t\t\tif c == v then\n\t\t\t\treturn true\n\
    \t\t\tend\n\t\tend\n\t\treturn false\n\tend\n\tlocal function change(c)\n\t\t\
    if isVowel(c) then\n\t\t\tlocal idx = string.find(vowels, c)\n\t\t\tif idx ==\
    \ 5 then\n\t\t\t\treturn vowels[1]\n\t\t\telse\n\t\t\t\treturn vowels[idx + 2]\n\
    \t\t\tend\n\t\telse\n\t\t\tif c == c:upper() then\n\t\t\t\treturn c:lower()\n\t\
    \t\telse\n\t\t\t\treturn c:upper()\n\t\t\tend\n\t\tend\n\tend\n\treturn string.gsub(message,\
    \ '(%a)', change)\nend", "  -- your code here\nend", "    local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local out = {}\n    for c in\
    \ message:gmatch('.') do\n        c = c:lower()\n        if c == c:upper() then\n\
    \            c = c:lower()\n            c = alpha:sub(alpha:find(c) + 2, alpha:find(c)\
    \ + 2):upper()\n        else\n            c = alpha:sub(alpha:find(c) + 2, alpha:find(c)\
    \ + 2)\n        end\n        for _, v in ipairs(vowels) do\n            if c ==\
    \ v then\n                c = alpha:sub(alpha:find(c) + 2, alpha:find(c) + 2)\n\
    \            end\n        end\n        table.insert(out, c)\n    end\n    return\
    \ table.concat(out)\nend", "    message = string.lower(message)\n    local new_message\
    \ = \"\"\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    for i = 1, #message\
    \ do\n        if message:sub(i, i) == \" \" then\n            new_message = new_message\
    \ .. \" \"\n        elseif in_table(vowels, message:sub(i, i)) then\n        \
    \    new_message = new_message .. string.char(message:byte(i) + 2)\n        else\n\
    \            new_message = new_message .. string.char(message:byte(i) - 2)\n \
    \       end\n    end\n    return new_message\nend", "    return message:gsub('%a',\
    \ function(character)\n        if type(character) == 'string' then\n         \
    \   if is_letter(character) then\n                local char_code = string.byte(character)\n\
    \                if is_lower_case(character) then\n                    char_code\
    \ = char_code - 32\n                end\n                local v = char_code +\
    \ 2\n                if is_vowel(character) then\n                    v = is_vowel(character)\n\
    \                end\n                return string.char(v)\n            end\n\
    \        end\n    end)\nend", "  -- your implementation goes here\nend", "   \
    \ local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local new_message = ''\n    for\
    \ char in message:gmatch('.') do\n        if char:find('%u') then\n          \
    \  new_message = new_message .. char:lower()\n        elseif char:find('%l') then\n\
    \            new_message = new_message .. char:upper()\n        else\n       \
    \     new_message = new_message .. char\n        end\n    end\n    for i,v in\
    \ ipairs(vowels) do\n        new_message = new_message:gsub(v, vowels[((i % #vowels)\
    \ + 1)])\n    end\n    return new_message\nend", "    local vowels = {\"a\", \"\
    e\", \"i\", \"o\", \"u\"}\n    local alphabet = {\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n \
    \   local newMessage = \"\"\n    local temp", "  --[[\n  First, you need to figure\
    \ out how to swap cases. The string \n  library has an upper and lower method\
    \ that can convert a \n  character to upper or lower case. The char library has\
    \ a \n  method called byte which will return the value of a character. \n  Since\
    \ we know the ascii code for upper and lowercase letters, \n  we can easily test\
    \ what case the character is in, and swap the \n  case to the other.", "    local\
    \ vowels = { 'a', 'e', 'i', 'o', 'u' }\n    local alphabet = {\n        'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    }\n    local function encodeLetter(letter)\n\
    \        local letterIndex = table.find(alphabet, letter:lower())\n        if\
    \ letterIndex then\n            if table.find(vowels, letter:lower()) then\n \
    \               if letterIndex + 2 > 26 then\n                    letterIndex\
    \ = (letterIndex + 2) - 26\n                else\n                    letterIndex\
    \ = letterIndex + 2\n                end\n                return alphabet[letterIndex]\n\
    \            else\n                if letterIndex + 2 > 26 then\n            \
    \        letterIndex = (letterIndex + 2) - 26\n                else\n        \
    \            letterIndex = letterIndex + 2\n                end\n            \
    \    return letterIndex\n            end\n        end\n    end\n    local encodedMessage\
    \ = ''\n    for letter in message:gmatch('%a') do\n        if letter:lower() ==\
    \ letter then\n            encodedMessage = encodedMessage .. encodeLetter(letter):upper()\n\
    \        else\n            encodedMessage = encodedMessage .. encodeLetter(letter):lower()\n\
    \        end\n    end\n    return encodedMessage\nend", "    local alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n    local encoded = \"\"\n    for char in message:gmatch(\"\
    .\") do\n        local lower_char = char:lower()\n        local lower_pos = alphabet:find(lower_char)\n\
    \        if lower_pos == nil then\n            encoded = encoded .. char\n   \
    \     else\n            local upper_pos = lower_pos + 1\n            local upper_char\
    \ = alphabet:sub(upper_pos, upper_pos)\n            local next_lower_pos = lower_pos\
    \ + 2\n            local next_lower_char = alphabet:sub(next_lower_pos, next_lower_pos)\n\
    \            local next_upper_pos = next_lower_pos + 1\n            local next_upper_char\
    \ = alphabet:sub(next_upper_pos, next_upper_pos)\n            if char == lower_char\
    \ then\n                encoded = encoded .. next_lower_char\n            else\n\
    \                encoded = encoded .. next_upper_char\n            end\n     \
    \   end\n    end\n    return encoded\nend", "  \nend", "\tlocal alphabet = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tlocal vowel = \"AEIOU\"\n\tlocal msg = \"\"\n\t\
    for letter in message:gmatch('.') do\n\t\tif letter == letter:upper() then\n\t\
    \t\tif vowel:find(letter) then\n\t\t\t\tmsg = msg .. vowel:sub(vowel:find(letter)\
    \ + 2, vowel:find(letter) + 2)\n\t\t\telse\n\t\t\t\tmsg = msg .. alphabet:sub(alphabet:find(letter)\
    \ + 2, alphabet:find(letter) + 2)\n\t\t\tend\n\t\telse\n\t\t\tif vowel:find(letter:upper())\
    \ then\n\t\t\t\tmsg = msg .. vowel:sub(vowel:find(letter:upper()) + 2, vowel:find(letter:upper())\
    \ + 2):lower()\n\t\t\telse\n\t\t\t\tmsg = msg .. alphabet:sub(alphabet:find(letter:upper())\
    \ + 2, alphabet:find(letter:upper()) + 2):lower()\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn msg\nend", end, "    return message:gsub('%a', function(x)\n        --\
    \ check if uppercase, change to lowercase if so\n        local lower = x == x:lower()\
    \ and x or x:lower()\n        -- check if vowel, change to new letter if so\n\
    \        return 'aeiouAEIOU':find(lower, 1, true) and \n            -- get next\
    \ letter from alphabet\n            string.char(string.byte(lower) + 1) or lower\n\
    \    end)\nend", "  local new_message = ''\n  for i = 1, #message do\n    -- if\
    \ we get a vowel then call the encode_vowel function \n    if check_if_vowel(message:sub(i,\
    \ i)) then\n      new_message = new_message .. encode_vowel(message:sub(i, i))\n\
    \    else\n      -- call the encode_consonant function\n      new_message = new_message\
    \ .. encode_consonant(message:sub(i, i))\n    end\n  end\n  return new_message\n\
    end", "    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local vowels2 = {'c',\
    \ 'f', 'j', 'n', 'r'}\n    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'}\n    local newMessage = ''\n    for i = 1, string.len(message)\
    \ do\n        local letter = string.sub(message, i, i)\n        if letter == string.upper(letter)\
    \ then\n            letter = string.lower(letter)\n        elseif letter == string.lower(letter)\
    \ then\n            letter = string.upper(letter)\n        end\n        local\
    \ found = false\n        for j = 1, #vowels do\n            if letter == vowels[j]\
    \ then\n                letter = vowels2[j]\n                found = true\n  \
    \              break\n            end\n        end\n        if not found then\n\
    \            for j = 1, #alphabet do\n                if letter == alphabet[j]\
    \ then\n                    if j == 26 then\n                        letter =\
    \ alphabet[1]\n                    else\n                        letter = alphabet[j\
    \ + 1]\n                    end\n                    break\n                end\n\
    \            end\n        end\n        newMessage = newMessage .. letter\n   \
    \ end\n    return newMessage\nend", "    local change_case = function(letter)\n\
    \        local lower = letter:lower()\n        local index = string.find('abcdefghijklmnopqrstuvwxyz',\
    \ lower)\n        if not index then\n            return letter\n        end\n\
    \        local new_letter = (index + 2) % #'abcdefghijklmnopqrstuvwxyz'\n    \
    \    if new_letter == 0 then\n            new_letter = #'abcdefghijklmnopqrstuvwxyz'\n\
    \        end\n        new_letter = string.sub('abcdefghijklmnopqrstuvwxyz', new_letter,\
    \ new_letter)\n        if letter == letter:lower() then\n            return new_letter\n\
    \        else\n            return new_letter:upper()\n        end\n    end\n \
    \   local new_msg = message:gsub('[a-zA-Z]', change_case)\n    return new_msg\n\
    end", "  local characters = {}\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    if char == ' ' then\n      table.insert(characters, ' ')\n    else\n\
    \      if char == char:upper() then\n        char = char:lower()\n      else\n\
    \        char = char:upper()\n      end\n      if char == 'a' then\n        char\
    \ = 'c'\n      elseif char == 'e' then\n        char = 'g'\n      elseif char\
    \ == 'i' then\n        char = 'k'\n      elseif char == 'o' then\n        char\
    \ = 'q'\n      elseif char == 'u' then\n        char = 'y'\n      end\n      table.insert(characters,\
    \ char)\n    end\n  end\n  return table.concat(characters)\nend", "  local alpha\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  local vowels = {'a', 'e', 'i', 'o', 'u'}\n\
    \  local encodedMessage = ''\n  for i = 1, #message do\n    local char = message:sub(i,\
    \ i)\n    if alpha:find(char) then\n      local upper = char == char:upper()\n\
    \      char = char:lower()\n      if upper then\n        char = char:upper()\n\
    \      end\n      if alpha:find(char) then\n        for j = 1, #vowels do\n  \
    \        if char == vowels[j] then\n            char = vowels[(j + 2) % 5 + 1]\n\
    \            break\n          end\n        end\n        if not upper then\n  \
    \        char = char:lower()\n        end\n      end\n    end\n    encodedMessage\
    \ = encodedMessage .. char\n  end\n  return encodedMessage\nend", end, "  -- TODO:\
    \ Complete this function\nend", "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\t\
    local result = ''\n\tfor i = 1, #message do\n\t\tlocal char = message:sub(i, i)\n\
    \t\tif char == char:upper() then\n\t\t\tchar = char:lower()\n\t\telse\n\t\t\t\
    char = char:upper()\n\t\tend\n\t\tlocal found = false\n\t\tfor j = 1, #vowels\
    \ do\n\t\t\tif char == vowels[j] then\n\t\t\t\tfound = true\n\t\t\t\tchar = vowels[(j\
    \ + 2) % #vowels]\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif not found then\n\t\
    \t\tresult = result .. char\n\t\telse\n\t\t\tif char == char:upper() then\n\t\t\
    \t\tchar = char:lower()\n\t\t\telse\n\t\t\t\tchar = char:upper()\n\t\t\tend\n\t\
    \t\tresult = result .. char\n\t\tend\n\tend\n\treturn result\nend", "    return\
    \ message\nend", "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal encoded\
    \ = {}\n\tfor i = 1, message:len() do\n\t\tlocal c = message:sub(i, i)\n\t\tlocal\
    \ lower = c:lower()\n\t\tif lower == 'z' then\n\t\t\tc = 'b'\n\t\telseif lower\
    \ == 'y' then\n\t\t\tc = 'a'\n\t\telseif table.indexOf(vowels, lower) then\n\t\
    \t\tc = lower:char(lower:byte() + 2)\n\t\telse\n\t\t\tc = c:char(c:byte() + 1)\n\
    \t\tend\n\t\tencoded[i] = c\n\tend\n\treturn table.concat(encoded)\nend", end,
  end, "\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal newMessage = ''\n\tfor\
    \ i = 1, #message do\n\t\tlocal char = message:sub(i, i)\n\t\tif char == char:upper()\
    \ then\n\t\t\tchar = char:lower()\n\t\telse\n\t\t\tchar = char:upper()\n\t\tend\n\
    \t\tfor j = 1, #vowels do\n\t\t\tif char == vowels[j] then\n\t\t\t\tchar = vowels[(j\
    \ + 2) % #vowels]\n\t\t\tend\n\t\tend\n\t\tnewMessage = newMessage .. char\n\t\
    end\n\treturn newMessage\nend", "  local vowels = {\n    ['a'] = 'c',\n    ['e']\
    \ = 'g',\n    ['i'] = 'k',\n    ['o'] = 'q',\n    ['u'] = 'y'\n  }\n  return (message:gsub('%a',\
    \ function(letter)\n    return ((letter == letter:upper()) and letter:lower()\
    \ or letter:upper())\n      :gsub('[aeiou]', function(vowel)\n        return vowels[vowel]\n\
    \      end)\n  end))\nend", end, end, end, "\tmessage = message:lower()\n\tlocal\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal function isVowel(char)\n\t\tfor\
    \ _,v in ipairs(vowels) do\n\t\t\tif char == v then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\t\treturn false\n\tend\n\tlocal function encodeChar(char)\n\t\
    \tlocal newChar = char\n\t\tif isVowel(char) then\n\t\t\tlocal pos = table.indexOf(vowels,\
    \ char)\n\t\t\tnewChar = vowels[((pos + 2) % #vowels) + 1]\n\t\tend\n\t\treturn\
    \ newChar:upper()\n\tend\n\treturn message:gsub('.', encodeChar)\nend", "  --\
    \ TODO: implement this function\nend", end, "\treturn message\nend", "  local\
    \ encoded = ''\n  for i = 1, #message do\n    local c = message:sub(i, i)\n  \
    \  if c == c:upper() then\n      encoded = encoded .. c:lower()\n    else\n  \
    \    encoded = encoded .. c:upper()\n    end\n  end\n  return encoded\nend", " \
    \ return message:gsub(\"[a-zA-Z]\", function(x)\n    local x_code = x:byte()\n\
    \    if x_code >= 65 and x_code <= 90 then\n      x_code = x_code + 32\n    elseif\
    \ x_code >= 97 and x_code <= 122 then\n      x_code = x_code - 32\n    end\n \
    \   local char = string.char(x_code)\n    if char == 'a' then\n      return 'c'\n\
    \    elseif char == 'e' then\n      return 'g'\n    elseif char == 'i' then\n\
    \      return 'k'\n    elseif char == 'o' then\n      return 'q'\n    elseif char\
    \ == 'u' then\n      return 'y'\n    else\n      return char\n    end\n  end)\n\
    end", "    if type(message) ~= 'string' then return end\n    local vowels = {'a',\
    \ 'e', 'i', 'o', 'u'}\n    local encoded_msg = ''\n    local ascii_a, ascii_z\
    \ = string.byte('a'), string.byte('z')\n    local ascii_A, ascii_Z = string.byte('A'),\
    \ string.byte('Z')\n    for char in message:gmatch('.') do\n        local ascii\
    \ = string.byte(char)\n        if ascii >= ascii_a and ascii <= ascii_z then\n\
    \            encoded_msg = encoded_msg .. string.char(ascii - ascii_a + ascii_A)\n\
    \        elseif ascii >= ascii_A and ascii <= ascii_Z then\n            encoded_msg\
    \ = encoded_msg .. string.char(ascii - ascii_A + ascii_a)\n        else\n    \
    \        encoded_msg = encoded_msg .. char\n        end\n    end\n    for k,v\
    \ in pairs(vowels) do\n        encoded_msg = encoded_msg:gsub(v, '_')\n    end\n\
    \    for k,v in pairs(vowels) do\n        local vowel = v:gsub('%w', string.char(string.byte(v)\
    \ + 2))\n        encoded_msg = encoded_msg:gsub('_', vowel)\n    end\n    return\
    \ encoded_msg\nend", "    local encodedMessage = \"\"\n    for i = 1, #message\
    \ do\n        local character = message:sub(i, i)\n        if character:find(\"\
    %a\") then\n            local alphabet = getAlphabet(character)\n            local\
    \ position = character:byte() - alphabet.first + 1\n            local encodedChar\
    \ = alphabet.letters:sub(position + 2, position + 2)\n            encodedMessage\
    \ = encodedMessage .. encodedChar\n        else\n            encodedMessage =\
    \ encodedMessage .. character\n        end\n    end\n    return encodedMessage\n\
    end", "    -- TODO: Implement this function\nend", "    if type(message) ~= 'string'\
    \ then\n        return nil\n    end\n    local encoded_message = ''\n    for index,\
    \ letter in ipairs(message) do\n        if letter:find('[%a]') ~= nil then\n \
    \           local is_upper = letter:find('[%u]') ~= nil\n            local char_code\
    \ = string.byte(letter)\n            if is_upper then\n                char_code\
    \ = char_code + 32\n            end\n            char_code = char_code + 1\n \
    \           if char_code == 97 then\n                char_code = 101\n       \
    \     elseif char_code == 101 then\n                char_code = 105\n        \
    \    elseif char_code == 105 then\n                char_code = 111\n         \
    \   elseif char_code == 111 then\n                char_code = 117\n          \
    \  elseif char_code == 117 then\n                char_code = 97\n            end\n\
    \            if is_upper then\n                char_code = char_code - 32\n  \
    \          end\n            encoded_message = encoded_message .. string.char(char_code)\n\
    \        else\n            encoded_message = encoded_message .. letter\n     \
    \   end\n    end\n    return encoded_message\nend", "\tlocal encoded = ''\n\t\
    local ccode = 0\n\tlocal ccode_n = 0\n\tlocal cchar = ''\n\tlocal cchar_n = ''\n\
    \tlocal cchar_nc = ''\n\tlocal vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal lookup\
    \ = { a = \"c\", e = \"g\", i = \"k\", o = \"s\", u = \"y\" }\n\tlocal re = \"\
    ([%a%d])([%a%d])([%a%d])\"\n\tfor i = 1, string.len(message) do\n\t\tcchar = string.sub(message,\
    \ i, i)\n\t\tccode = string.byte(cchar)\n\t\tif ccode > 96 and ccode < 123 then\n\
    \t\t\tccode_n = ccode - 32\n\t\t\tcchar_n = string.char(ccode_n)\n\t\t\tcchar_nc\
    \ = cchar_n\n\t\telseif ccode > 64 and ccode < 91 then\n\t\t\tccode_n = ccode\
    \ + 32\n\t\t\tcchar_n = string.char(ccode_n)\n\t\t\tcchar_nc = cchar_n\n\t\telse\n\
    \t\t\tcchar_n = cchar\n\t\t\tcchar_nc = cchar\n\t\tend\n\t\tif lookup[cchar_n]\
    \ then\n\t\t\tencoded = encoded .. lookup[cchar_n]\n\t\telse\n\t\t\tencoded =\
    \ encoded .. cchar_nc\n\t\tend\n\tend\n\treturn encoded\nend", "  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local encoding = \"cdefghijklmnopqrstuvwxyzab\"\
    \n  local i = 1\n  local letter = message:sub(i,i)\n  local encoded_message =\
    \ ''\n  while letter do\n    local pos = alphabet:find(letter:lower())\n    if\
    \ pos then\n      if letter == letter:upper() then\n        letter = encoding:sub(pos,pos):upper()\n\
    \      else\n        letter = encoding:sub(pos,pos)\n      end\n    end\n    encoded_message\
    \ = encoded_message .. letter\n    i = i + 1\n    letter = message:sub(i,i)\n\
    \  end\n  return encoded_message\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
