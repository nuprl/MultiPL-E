name: HumanEval_115_max_fill
language: lua
prompt: "-- You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n-- and\
  \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
  \ the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example\
  \ 1:\n-- Input: \n-- grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n-- bucket_capacity\
  \ : 1\n-- Output: 6\n-- Example 2:\n-- Input: \n-- grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n-- bucket_capacity : 2\n-- Output: 5\n-- Example 3:\n--\
  \ Input: \n-- grid : [[0,0,0], [0,0,0]]\n-- bucket_capacity : 5\n-- Output: 0\n\
  -- Constraints:\n-- * all wells have the same length\n-- * 1 <= grid.length <= 10^2\n\
  -- * 1 <= grid[:,1].length <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- * 1 <= capacity\
  \ <= 10\nlocal function max_fill(grid, capacity)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1,\
  \ 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n\
  \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1,\
  \ 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local r = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            if grid[i][j] == 1 then\n       \
    \         fill = fill + 1\n            end\n        end\n        r = math.max(r,\
    \ fill)\n    end\n    return r\nend", "  local len = #grid\n  local max = 0\n\
    \  for i = 1, len do\n    local w = 0\n    for j = 1, len do\n      w = w + grid[i][j]\n\
    \    end\n    max = math.max(max, w)\n  end\n  local max_row = math.ceil(max /\
    \ capacity)\n  return max_row\nend", "    local max, sum = 0, 0\n    for _, row\
    \ in ipairs(grid) do\n        for _, d in ipairs(row) do\n            sum = sum\
    \ + d\n            if sum > capacity then\n                max = math.max(max,\
    \ sum - capacity)\n                sum = capacity\n            end\n        end\n\
    \    end\n    return max\nend", "    local count = 0\n    for row = 1, #grid do\n\
    \        for col = 1, #grid[row] do\n            if grid[row][col] == 1 then\n\
    \                grid[row][col] = 0\n                local need = capacity - 1\n\
    \                while need > 0 do\n                    local list = {}\n    \
    \                if row > 1 and grid[row - 1][col] == 1 then\n               \
    \         table.insert(list, {row - 1, col})\n                    end\n      \
    \              if row < #grid and grid[row + 1][col] == 1 then\n             \
    \           table.insert(list, {row + 1, col})\n                    end\n    \
    \                if col > 1 and grid[row][col - 1] == 1 then\n               \
    \         table.insert(list, {row, col - 1})\n                    end\n      \
    \              if col < #grid[row] and grid[row][col + 1] == 1 then\n        \
    \                table.insert(list, {row, col + 1})\n                    end\n\
    \                    if #list > 0 then\n                        local i = math.random(#list)\n\
    \                        local p = list[i]\n                        grid[p[1]][p[2]]\
    \ = 0\n                        need = need - 1\n                    else\n   \
    \                     break\n                    end\n                end\n  \
    \              count = count + 1\n            end\n        end\n    end\n    return\
    \ count\nend\nreturn max_fill", "    local n, m = #grid, #grid[1]\n    local total\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                total = total + 1\n            end\n        end\n\
    \    end\n    local function fill(grid, visited, x, y, capacity)\n        local\
    \ ans = 0\n        for _, pos in ipairs({{x, y}, {x - 1, y}, {x + 1, y}, {x, y\
    \ - 1}, {x, y + 1}}) do\n            local x, y = pos[1], pos[2]\n           \
    \ if x > 0 and x <= n and y > 0 and y <= m and grid[x][y] == 1 and visited[x][y]\
    \ == 0 then\n                visited[x][y] = 1\n                ans = ans + 1\n\
    \                if ans == capacity then\n                    return true\n  \
    \              end\n            end\n        end\n        return false\n    end\n\
    \    local function dfs(grid, visited, x, y)\n        if visited[x][y] == 1 then\n\
    \            return\n        end\n        visited[x][y] = 1\n        for _, pos\
    \ in ipairs({{x, y}, {x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}) do\n   \
    \         local x, y = pos[1], pos[2]\n            if x > 0 and x <= n and y >\
    \ 0 and y <= m and grid[x][y] == 1 then\n                dfs(grid, visited, x,\
    \ y)\n            end\n        end\n    end\n    local function calc(grid, capacity)\n\
    \        local sum = 0\n        local visited = {}\n        for i = 1, n do\n\
    \            visited[i] = {}\n            for j = 1, m do\n                visited[i][j]\
    \ = 0\n            end\n        end\n        for i = 1, n do\n            for\
    \ j = 1, m do\n                if grid[i][j] == 1 and visited[i][j] == 0 then\n\
    \                    if fill(grid, visited, i, j, capacity) then\n           \
    \             sum = sum + 1\n                    else", "    local max_fill_map\
    \ = {}\n    for r, row in ipairs(grid) do\n        for c, col in ipairs(row) do\n\
    \            if grid[r][c] == 1 then\n                local max_fill_val = 0\n\
    \                for r2, row2 in ipairs(grid) do\n                    if grid[r2][c]\
    \ == 1 then\n                        max_fill_val = max_fill_val + 1\n       \
    \             else\n                        break\n                    end\n \
    \               end\n                max_fill_map[r .. '_' .. c] = max_fill_val\n\
    \            end\n        end\n    end\n    return max_fill_map\nend", "    local\
    \ sum = 0\n    for i = 1, #grid do\n        local line = grid[i]\n        for\
    \ j = 1, #line do\n            local v = line[j]\n            if v == 1 then\n\
    \                sum = sum + 1\n            end\n        end\n    end\n    local\
    \ moves = math.ceil(sum / capacity)\n    return moves\nend", "    local max_depth\
    \ = 0\n    for _, row in ipairs(grid) do\n        local depth = 0\n        for\
    \ _, x in ipairs(row) do\n            if x == 1 then\n                depth =\
    \ depth + 1\n            else\n                depth = 0\n            end\n  \
    \      end\n        max_depth = math.max(max_depth, depth)\n    end\n    return\
    \ math.min(max_depth, capacity)\nend", "    local function up(i, j)\n        local\
    \ m, n = 0, 0\n        for k = 1, capacity do\n            if grid[i][j - k] ~=\
    \ nil then\n                m = m + 1\n            else\n                break\n\
    \            end\n        end\n        for k = 1, capacity do\n            if\
    \ grid[i][j + k] ~= nil then\n                n = n + 1\n            else\n  \
    \              break\n            end\n        end\n        return m + n, {m,\
    \ n}\n    end\n    local n, nmax = 0, 0\n    local dmax = {}\n    for i = 1, #grid\
    \ do\n        for j = 1, #grid[i] do\n            if grid[i][j] == 1 then\n  \
    \              n, d = up(i, j)\n                if n > nmax then\n           \
    \         nmax = n\n                    dmax = d\n                end\n      \
    \      end\n        end\n    end\n    return nmax, dmax\nend", "    local m, n\
    \ = #grid, #grid[1]\n    local max_fill = function(i, j)\n        if i < 0 or\
    \ i > m - 1 or j < 0 or j > n - 1 then\n            return 0\n        end\n  \
    \      if grid[i][j] == 0 then\n            return 0\n        end\n        local\
    \ count = 0\n        grid[i][j] = 0\n        count = 1 + max_fill(i - 1, j) +\
    \ max_fill(i + 1, j) + max_fill(i, j - 1) + max_fill(i, j + 1)\n        grid[i][j]\
    \ = 1\n        return count\n    end\n    local sum = 0\n    for i = 1, m do\n\
    \        for j = 1, n do\n            if grid[i][j] == 1 then\n              \
    \  local c = max_fill(i, j)\n                local times = math.ceil(c / capacity)\n\
    \                sum = sum + times\n            end\n        end\n    end\n  \
    \  return sum\nend", "    local last_fill = {}\n    local max_fill_amount = capacity\n\
    \    local lowest_row = grid[1]\n    for i = 2, #grid do\n        if grid[i] >\
    \ lowest_row then\n            lowest_row = grid[i]\n        end\n    end\n  \
    \  for _, row in ipairs(grid) do\n        local fill_amount = 0\n        local\
    \ last_fill_amount = 0\n        for _, cell in ipairs(row) do\n            if\
    \ cell == 1 then\n                fill_amount = fill_amount + 1\n            else\n\
    \                fill_amount = 0\n            end\n            if fill_amount\
    \ > max_fill_amount then\n                fill_amount = capacity\n           \
    \ end\n            if last_fill_amount ~= fill_amount then\n                max_fill_amount\
    \ = max_fill_amount + (fill_amount - last_fill_amount)\n                last_fill_amount\
    \ = fill_amount\n            end\n        end\n    end\n    return max_fill_amount\n\
    end", "    local n, m = #grid, #grid[1]\n    local function dfs(row, col)\n  \
    \      grid[row][col] = -1\n        local cnt = 1\n        if col < m and grid[row][col\
    \ + 1] == 1 then\n            cnt = cnt + dfs(row, col + 1)\n        end\n   \
    \     if row < n and grid[row + 1][col] == 1 then\n            cnt = cnt + dfs(row\
    \ + 1, col)\n        end\n        return cnt\n    end\n    local function find_biggest_well()\n\
    \        local max_cnt, r, c = 0, 0, 0\n        for i = 1, n do\n            for\
    \ j = 1, m do\n                if grid[i][j] == 1 then\n                    local\
    \ cnt = dfs(i, j)\n                    if cnt > max_cnt then\n               \
    \         max_cnt, r, c = cnt, i, j\n                    end\n               \
    \ end\n            end\n        end\n        return max_cnt, r, c\n    end\n \
    \   local function reset_biggest_well(r, c)\n        local cnt = grid[r][c]\n\
    \        grid[r][c] = -1\n        if c < m and grid[r][c + 1] == -1 then\n   \
    \         cnt = cnt + reset_biggest_well(r, c + 1)\n        end\n        if r\
    \ < n and grid[r + 1][c] == -1 then\n            cnt = cnt + reset_biggest_well(r\
    \ + 1, c)\n        end\n        grid[r][c] = cnt\n        return cnt\n    end\n\
    \    local function extract_water(r, c, capacity)\n        local r = r\n     \
    \   while r <= n do\n            while c > 0 and grid[r][c] == 1 do\n        \
    \        c = c - 1\n            end\n            local cnt = capacity\n      \
    \      while cnt > 0 and grid[r][c] == -1 do\n                grid[r][c] = 0\n\
    \                cnt = cnt - 1\n            end\n            c = c + 1\n     \
    \       r = r + 1\n       ", "    local max, height = 0, #grid\n    for i = 1,\
    \ height do\n        local row, rmax = grid[i], 0\n        for j = 1, #row do\n\
    \            rmax = rmax + row[j]\n        end\n        max = math.max(max, rmax)\n\
    \    end\n    return math.ceil(max / capacity)\nend", "    local n = #grid\n \
    \   local m = #grid[1]\n    local fill_count = 0\n    for i = 1, n do\n      \
    \  for j = 1, m do\n            if grid[i][j] == 1 then\n                fill_count\
    \ = fill_count + 1\n            end\n        end\n    end\n    if capacity >=\
    \ fill_count then\n        return fill_count\n    end\n    local ans = 0\n   \
    \ while true do\n        local f = 0\n        for i = 1, n do\n            local\
    \ j = 1\n            while j <= m do\n                if grid[i][j] == 1 then\n\
    \                    local c = 0\n                    while j <= m and grid[i][j]\
    \ == 1 do\n                        c = c + 1\n                        j = j +\
    \ 1\n                    end\n                    if c == 1 then\n           \
    \             f = f + 1\n                    elseif c % capacity == 0 then\n \
    \                       f = f + math.floor(c / capacity)\n                   \
    \ else\n                        f = f + math.floor(c / capacity) + 1\n       \
    \             end\n                else\n                    j = j + 1\n     \
    \           end\n            end\n        end\n        if f == fill_count then\n\
    \            return ans\n        end\n        for i = 1, n do\n            for\
    \ j = 1, m do\n                if grid[i][j] == 1 then\n                    grid[i][j]\
    \ = 0\n                end\n            end\n        end\n        for i = 1, n\
    \ do\n            local j = 1\n            while j <= m do\n                if\
    \ grid[i][j] == 0 then\n                    local k = j\n                    while\
    \ k <= m and grid[i][k] == 0 do\n                        k = k + 1\n         \
    \           end\n                    local c = k - j\n                    if c\
    \ <= capacity then\n                        for p = j, k - 1 do\n            \
    \                grid[i][p] = 1\n                        end\n               \
    \     else\n                        if c % capacity == 0 then\n              \
    \              local d = c / capacity\n                            for p = 0,\
    \ d - 1 do\n                                for q = j + p * capacity, j + (p +\
    \ 1) * capacity - 1 do\n                                    grid[i][q] = 1\n \
    \                               end\n                            end\n       \
    \                 else", "    local max_cnt = 0\n    for i = 1, #grid do\n   \
    \     local cnt = 0\n        for j = 1, #grid[i] do\n            if grid[i][j]\
    \ == 1 then\n                cnt = cnt + 1\n            end\n        end\n   \
    \     max_cnt = math.max(max_cnt, cnt)\n    end\n    return math.ceil(max_cnt\
    \ / capacity)\nend", "  local columns, rows = #grid[1], #grid\n  local result\
    \ = 0\n  for i = 1, rows do\n    local highest = 0\n    for j = 1, columns do\n\
    \      highest = math.max(highest, grid[i][j])\n    end\n    local fill = math.ceil(highest\
    \ / capacity)\n    result = result + fill\n  end\n  return result\nend", "  local\
    \ n = #grid\n  local m = #grid[1]\n  local function dfs(x, y, visited)\n    if\
    \ grid[x][y] == 1 then\n      grid[x][y] = 0\n      capacity = capacity - 1\n\
    \    end\n    if capacity == 0 then\n      return 1\n    end\n    visited[x][y]\
    \ = true\n    if x > 1 and grid[x - 1][y] > 0 and not visited[x - 1][y] then\n\
    \      local ret = dfs(x - 1, y, visited)\n      if ret > 0 then\n        return\
    \ ret + 1\n      end\n    end\n    if x < n and grid[x + 1][y] > 0 and not visited[x\
    \ + 1][y] then\n      local ret = dfs(x + 1, y, visited)\n      if ret > 0 then\n\
    \        return ret + 1\n      end\n    end\n    if y > 1 and grid[x][y - 1] >\
    \ 0 and not visited[x][y - 1] then\n      local ret = dfs(x, y - 1, visited)\n\
    \      if ret > 0 then\n        return ret + 1\n      end\n    end\n    if y <\
    \ m and grid[x][y + 1] > 0 and not visited[x][y + 1] then\n      local ret = dfs(x,\
    \ y + 1, visited)\n      if ret > 0 then\n        return ret + 1\n      end\n\
    \    end\n    return -1\n  end\n  local ret = 0\n  for i = 1, n do\n    for j\
    \ = 1, m do\n      local tmp = dfs(i, j, {})\n      if tmp > 0 then\n        ret\
    \ = ret + tmp\n      end\n    end\n  end\n  return ret\nend\nreturn max_fill",
  "    local m, n = #grid, #grid[1]\n    local times = 0\n    for i = 1, m do\n  \
    \      for j = 1, n do\n            if grid[i][j] == 1 then\n                local\
    \ fill = capacity\n                local k = i\n                while fill > 0\
    \ and k <= m do\n                    fill = fill - grid[k][j]\n              \
    \      grid[k][j] = 0\n                    k = k + 1\n                end\n  \
    \              times = times + 1\n            end\n        end\n    end\n    return\
    \ times\nend\nreturn max_fill", "    local r, rows, columns = 0, #grid, #grid[1]\n\
    \    for c = 1, columns do\n        local sum = 0\n        for r = 1, rows do\n\
    \            sum = sum + grid[r][c]\n        end\n        r = r + math.ceil(sum\
    \ / capacity)\n    end\n    return r\nend\nreturn max_fill", "    local w = #grid[1]\n\
    \    local a = {}\n    for r = 1, #grid do\n        local last = math.maxinteger\n\
    \        for c = 1, w do\n            if grid[r][c] == 1 then\n              \
    \  last = c\n            end\n        end\n        a[r] = last\n    end\n    local\
    \ res = 0\n    local start = 0\n    local finish = 0\n    while start < #grid\
    \ do\n        while finish < #grid and finish - start + 1 <= capacity do\n   \
    \         finish = finish + 1\n            if a[finish] > a[start] then\n    \
    \            start = finish\n            end\n        end\n        res = res +\
    \ 1\n        start = start + 1\n    end\n    return res\nend", "    local rows,\
    \ cols = #grid, #grid[1]\n    local total = 0\n    local m, p\n    for j = 1,\
    \ cols do\n        m, p = 0, 0\n        for i = 1, rows do\n            if grid[i][j]\
    \ == 1 then\n                m = m + 1\n            else\n                p =\
    \ p + 1\n            end\n        end\n        total = total + math.min(m, p)\n\
    \    end\n    return total\nend\nreturn function(grid, capacity)\n    local total\
    \ = 0\n    for i = 1, #grid do\n        local m, p = 0, 0\n        for j = 1,\
    \ #grid[i] do\n            if grid[i][j] == 1 then\n                m = m + 1\n\
    \            else\n                p = p + 1\n            end\n        end\n \
    \       local row_total = math.min(m, p)\n        if row_total > 0 then\n    \
    \        total = total + row_total\n            for j = 1, #grid[i] do\n     \
    \           if row_total > 0 then\n                    if grid[i][j] == 1 then\n\
    \                        grid[i][j] = 0\n                        row_total = row_total\
    \ - 1\n                    end\n                else\n                    if grid[i][j]\
    \ == 0 then\n                        grid[i][j] = 1\n                    end\n\
    \                end\n            end\n        end\n    end\n    local m, p =\
    \ 0, 0\n    for i = 1, #grid do\n        if grid[i][1] == 1 then\n           \
    \ m = m + 1\n        else\n            p = p + 1\n        end\n    end\n    local\
    \ row_total = math.min(m, p)\n    if row_total > 0 then\n        total = total\
    \ + row_total\n        for i = 1, #grid do\n            if row_total > 0 then\n\
    \                if grid[i][1] == 1 then\n                    grid[i][1] = 0\n\
    \                    row_total = row_total - 1\n                end\n        \
    \    else\n                if grid[i][1] == 0 then\n                    grid[i][1]\
    \ = 1\n                end\n            end\n        end\n    end\n    return\
    \ total +", "    local len = #grid\n    local dp = {}\n    for i = 1, len do\n\
    \        dp[i] = {}\n        for j = 1, len do\n            dp[i][j] = 0\n   \
    \     end\n    end\n    local function fill(i, j)\n        if i == 1 and j ==\
    \ 1 then\n            return 0\n        end\n        if dp[i][j] ~= 0 then\n \
    \           return dp[i][j]\n        end\n        local ret = 0\n        local\
    \ left = capacity - grid[i][j]\n        if i ~= 1 then\n            local left_up\
    \ = fill(i - 1, j)\n            ret = math.max(ret, left_up + math.min(left, capacity))\n\
    \        end\n        if j ~= 1 then\n            local up = fill(i, j - 1)\n\
    \            ret = math.max(ret, up + math.min(left, capacity))\n        end\n\
    \        dp[i][j] = ret\n        return ret\n    end\n    return len * capacity\
    \ - fill(len, len)\nend\nreturn max_fill", "    local n, n_rows = #grid[1], #grid\n\
    \    local top = {}\n    for i = 1, n do\n        local j = 1\n        while j\
    \ <= n_rows and grid[j][i] == 0 do\n            j = j + 1\n        end\n     \
    \   top[i] = j\n    end\n    local fill_count = 0\n    for i = 1, n do\n     \
    \   local k = top[i]\n        if k <= n_rows then\n            local j = k\n \
    \           while j <= n_rows and grid[j][i] > 0 do\n                fill_count\
    \ = fill_count + 1\n                j = j + 1\n            end\n            local\
    \ l = j\n            while l <= n_rows and (j - k) < capacity do\n           \
    \     fill_count = fill_count + 1\n                l = l + 1\n            end\n\
    \        end\n    end\n    return fill_count\nend\nreturn max_fill", "    local\
    \ size = #grid\n    local capacity_grid = {}\n    for i = 1, size do\n       \
    \ capacity_grid[i] = {}\n        for j = 1, size do\n            capacity_grid[i][j]\
    \ = grid[i][j]\n        end\n    end\n    for i = 1, size do\n        for j =\
    \ 1, size do\n            if grid[i][j] == 1 then\n                for y = i,\
    \ math.min(i + capacity - 1, size) do\n                    for x = j, math.min(j\
    \ + capacity - 1, size) do\n                        capacity_grid[y][x] = 0\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    local cnt = 0\n    for i = 1, size do\n        for j = 1, size do\n\
    \            if capacity_grid[i][j] == 1 then\n                cnt = cnt + 1\n\
    \            end\n        end\n    end\n    return cnt\nend\nreturn max_fill",
  "    local n = #grid\n    local m = #grid[1]\n    local max_filled = {}\n    local\
    \ filled = {}\n    for i = 1, n do\n        max_filled[i] = {}\n        filled[i]\
    \ = {}\n        for j = 1, m do\n            max_filled[i][j] = capacity\n   \
    \         filled[i][j] = 0\n        end\n    end\n    for i = 1, n do\n      \
    \  for j = 1, m do\n            if grid[i][j] == 1 then\n                local\
    \ min_left = j - 1 > 0 and max_filled[i][j - 1] or capacity\n                local\
    \ min_right = j + 1 <= m and max_filled[i][j + 1] or capacity\n              \
    \  local min_above = i - 1 > 0 and max_filled[i - 1][j] or capacity\n        \
    \        local min_below = i + 1 <= n and max_filled[i + 1][j] or capacity\n \
    \               local min_fill = math.min(min_left, min_right, min_above, min_below)\n\
    \                max_filled[i][j] = math.min(min_fill, capacity)\n           \
    \ end\n        end\n    end\n    return max_filled\nend", "    -- num_rows, num_cols\
    \ = len(grid), len(grid[0])\n    local num_rows, num_cols = #grid, #grid[1]\n\
    \    local buckets_needed = 0\n    for i = 1, num_rows do\n        for j = 1,\
    \ num_cols do\n            if grid[i][j] == 1 then\n                buckets_needed\
    \ = buckets_needed + 1\n            end\n        end\n    end\n    return buckets_needed\
    \ // capacity\nend\nreturn max_fill", "    local total_water = 0\n    local max_water\
    \ = 0\n    for _, row in ipairs(grid) do\n        local water = 0\n        for\
    \ _, well in ipairs(row) do\n            water = water + well\n        end\n \
    \       total_water = total_water + water\n        max_water = math.max(max_water,\
    \ water)\n    end\n    return math.ceil(total_water / (capacity - max_water))\n\
    end", "    local m, n = #grid, #grid[1]\n    -- row 1, col 1\n    for i = 1, m\
    \ do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n         \
    \       local x, y = i, j\n                while x > 0 and grid[x][y] == 1 do\n\
    \                    grid[x][y] = -1\n                    x = x - 1\n        \
    \        end\n                while y > 0 and grid[x][y] == 1 do\n           \
    \         grid[x][y] = -1\n                    y = y - 1\n                end\n\
    \                while x < m and grid[x][y] == 1 do\n                    grid[x][y]\
    \ = -1\n                    x = x + 1\n                end\n                while\
    \ y < n and grid[x][y] == 1 do\n                    grid[x][y] = -1\n        \
    \            y = y + 1\n                end\n            end\n        end\n  \
    \  end\n    local count = 0\n    for i = 1, m do\n        for j = 1, n do\n  \
    \          if grid[i][j] == 1 then\n                local x, y = i, j\n      \
    \          while x > 0 and grid[x][y] == 1 do\n                    grid[x][y]\
    \ = -1\n                    x = x - 1\n                end\n                while\
    \ y > 0 and grid[x][y] == 1 do\n                    grid[x][y] = -1\n        \
    \            y = y - 1\n                end\n                while x < m and grid[x][y]\
    \ == 1 do\n                    grid[x][y] = -1\n                    x = x + 1\n\
    \                end\n                while y < n and grid[x][y] == 1 do\n   \
    \                 grid[x][y] = -1\n                    y = y + 1\n           \
    \     end\n                count = count + 1\n            end\n        end\n \
    \   end\n    return count\nend", "    local h, w = #grid, #grid[1]\n    local\
    \ maxf = 0\n    for _, row in ipairs(grid) do\n        for _, cell in ipairs(row)\
    \ do\n            maxf = math.max(maxf, cell)\n        end\n    end\n    local\
    \ function dfs(x, y, fill)\n        if x == 1 and y == 1 and fill == 0 then\n\
    \            return 1\n        end\n        if x > w or y > h or x < 1 or y <\
    \ 1 or fill < 0 then\n            return math.huge\n        end\n        local\
    \ path = math.huge\n        if x ~= 1 and y ~= 1 then\n            path = math.min(path,\
    \ dfs(x - 1, y, fill + grid[y][x - 1] - capacity))\n            path = math.min(path,\
    \ dfs(x, y - 1, fill + grid[y - 1][x] - capacity))\n        elseif x == 1 then\n\
    \            path = math.min(path, dfs(x, y - 1, fill + grid[y - 1][x] - capacity))\n\
    \        elseif y == 1 then\n            path = math.min(path, dfs(x - 1, y, fill\
    \ + grid[y][x - 1] - capacity))\n        end\n        return 1 + path\n    end\n\
    \    return dfs(w, h, 0)\nend", "  local L, H = 1, #grid\n  for y = 1, H do\n\
    \    local x, s = 1, 0\n    while x <= L do\n      if grid[y][x] == 1 then\n \
    \       s = s + 1\n        grid[y][x] = 0\n      elseif s > 0 then\n        x\
    \ = x + s\n        s = 0\n      end\n      x = x + 1\n    end\n    L = L + s\n\
    \  end\n  local W = #grid[1]\n  local r = 0\n  for x = 1, W do\n    local s =\
    \ 0\n    for y = 1, H do\n      if grid[y][x] == 1 then\n        s = s + 1\n \
    \       grid[y][x] = 0\n      elseif s > 0 then\n        local d = math.min(s,\
    \ capacity)\n        s = s - d\n        r = r + d\n      end\n    end\n    r =\
    \ r + s\n  end\n  return r\nend", "    local result = 0\n    local min_row = math.huge\n\
    \    for i = 1, #grid do\n        local row = grid[i]\n        local count = 0\n\
    \        for j = 1, #row do\n            count = count + row[j]\n        end\n\
    \        if count < min_row then\n            min_row = count\n        end\n \
    \       result = result + count\n    end\n    return math.max(result - min_row\
    \ * #grid, 0)\nend", "  local w, h = #grid[1], #grid\n  local ret = 0\n  for j\
    \ = 1, w do\n    for i = 1, h do\n      ret = ret + math.floor(grid[i][j] / capacity)\n\
    \      grid[i][j] = grid[i][j] % capacity\n    end\n  end\n  return ret\nend",
  "    local nrow, ncol = #grid, #grid[1]\n    local row_i, col_i = {}, {}\n    for\
    \ i = 1, nrow do\n        local capacity_i = 0\n        for j = 1, ncol do\n \
    \           capacity_i = capacity_i + grid[i][j]\n        end\n        if capacity_i\
    \ == 0 then\n            row_i[#row_i + 1] = i\n        end\n    end\n    for\
    \ j = 1, ncol do\n        local capacity_j = 0\n        for i = 1, nrow do\n \
    \           capacity_j = capacity_j + grid[i][j]\n        end\n        if capacity_j\
    \ == 0 then\n            col_i[#col_i + 1] = j\n        end\n    end\n    local\
    \ f = {}\n    f[1] = {}\n    for i = 1, nrow do\n        f[1][i] = 0\n    end\n\
    \    for i = 1, #row_i do\n        f[1][row_i[i]] = 1\n    end\n    for i = 2,\
    \ ncol do\n        f[i] = {}\n        for j = 1, nrow do\n            f[i][j]\
    \ = f[i - 1][j]\n        end\n        for j = 1, #col_i do\n            if col_i[j]\
    \ == i then\n                for k = 1, nrow do\n                    if f[i][k]\
    \ > 0 then\n                        f[i][k] = f[i][k] + 1\n                  \
    \  end\n                end\n            end\n        end\n    end\n    local\
    \ max_fill = 0\n    for i = 1, nrow do\n        max_fill = math.max(max_fill,\
    \ f[ncol][i])\n    end\n    return max_fill * capacity\nend\nreturn max_fill",
  "    local max_row, max_col = 0, 0\n    for row, wells in ipairs(grid) do\n    \
    \    for col, well in ipairs(wells) do\n            if well == 1 then\n      \
    \          max_row = math.max(max_row, row)\n                max_col = math.max(max_col,\
    \ col)\n            end\n        end\n    end\n    return max_row * max_col *\
    \ capacity\nend", "  local m, n = #grid, #grid[1]\n  local ans = 0\n  while true\
    \ do\n    local full, i, j = false, 1, 1\n    for i=1,m do\n      for j=1,n do\n\
    \        if grid[i][j] == 1 then\n          grid[i][j] = capacity\n          full\
    \ = true\n        end\n      end\n    end\n    if not full then\n      break\n\
    \    end\n    for i=1,m do\n      for j=1,n do\n        if grid[i][j] > 0 then\n\
    \          if i > 1 and grid[i-1][j] == 0 then\n            grid[i-1][j] = grid[i][j]\
    \ - 1\n          end\n          if i < m and grid[i+1][j] == 0 then\n        \
    \    grid[i+1][j] = grid[i][j] - 1\n          end\n          if j > 1 and grid[i][j-1]\
    \ == 0 then\n            grid[i][j-1] = grid[i][j] - 1\n          end\n      \
    \    if j < n and grid[i][j+1] == 0 then\n            grid[i][j+1] = grid[i][j]\
    \ - 1\n          end\n          grid[i][j] = 0\n        end\n      end\n    end\n\
    \    ans = ans + 1\n  end\n  return ans\nend", "    local m, n = #grid, #grid[1]\n\
    \    local count = 0\n    local row_cnt = 0\n    for i = 1, m do\n        row_cnt\
    \ = 0\n        for j = 1, n do\n            if grid[i][j] == 1 then\n        \
    \        row_cnt = row_cnt + 1\n            end\n        end\n        count =\
    \ count + math.ceil(row_cnt / capacity)\n    end\n    return count\nend", "  \
    \  local n, buckets = #grid, 0\n    for r = 1, n do\n        for c = 1, n do\n\
    \            if grid[r][c] == 1 then\n                buckets = buckets + 1\n\
    \                local row = grid[r]\n                for i = c, n do\n      \
    \              if capacity == 0 then break end\n                    if row[i]\
    \ == 1 then\n                        row[i] = 0\n                        capacity\
    \ = capacity - 1\n                    end\n                end\n            end\n\
    \        end\n    end\n    return buckets\nend\nreturn function(grid, capacity)\n\
    \    local n = #grid\n    local buckets = 0\n    local columns = {}\n    for r\
    \ = 1, n do\n        for c = 1, n do\n            if grid[r][c] == 1 then\n  \
    \              buckets = buckets + 1\n                table.insert(columns, c)\n\
    \            end\n        end\n    end\n    local i, bucket_count = 1, 1\n   \
    \ local col = columns[i]\n    for c = 1, n do\n        for r = 1, n do\n     \
    \       if grid[r][c] == 1 then\n                grid[r][c] = 0\n            \
    \    capacity = capacity - 1\n                if capacity == 0 then\n        \
    \            buckets = buckets + bucket_count\n                    bucket_count\
    \ = 1\n                    if i == #columns then break end\n                 \
    \   repeat\n                        i = i + 1\n                        col = columns[i]\n\
    \                    until col > c\n                    capacity = bucket_capacity\n\
    \                end\n            end\n        end\n        if col == c then\n\
    \            capacity = bucket_capacity\n            bucket_count = bucket_count\
    \ + 1\n            if i == #columns then break end\n            repeat\n     \
    \           i = i + 1\n                col = columns[i]\n            until col\
    \ > c\n        end\n    end\n    return buckets\nend", "    local N, M = #grid,\
    \ #grid[1]\n    local ok = {}\n    local function dfs(i, j, level)\n        local\
    \ id = i * M + j\n        if ok[id] then return end\n        ok[id] = level\n\
    \        local dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}}\n        for _, dir in\
    \ ipairs(dirs) do\n            local x, y = i + dir[1], j + dir[2]\n         \
    \   if x >= 1 and x <= N and y >= 1 and y <= M and grid[x][y] >= level then\n\
    \                dfs(x, y, level)\n            end\n        end\n    end\n   \
    \ local function fill(i, j, level)\n        local id = i * M + j\n        if ok[id]\
    \ == level then return end\n        ok[id] = level\n        local dirs = {{0,\
    \ -1}, {0, 1}, {-1, 0}, {1, 0}}\n        for _, dir in ipairs(dirs) do\n     \
    \       local x, y = i + dir[1], j + dir[2]\n            if x >= 1 and x <= N\
    \ and y >= 1 and y <= M and ok[x * M + y] ~= level then\n                fill(x,\
    \ y, level)\n            end\n        end\n    end\n    local function dfs_level(level)\n\
    \        ok = {}\n        for i = 1, N do\n            for j = 1, M do\n     \
    \           if grid[i][j] >= level then\n                    dfs(i, j, level)\n\
    \                end\n            end\n        end\n    end\n    local function\
    \ fill_level(level)\n        ok = {}\n        for i = 1, N do\n            for\
    \ j = 1, M do\n                if grid[i][j] >= level then\n                 \
    \   fill(i, j, level)\n                end\n            end\n        end\n   \
    \ end\n    local function count_level(level)\n        local res = 0\n        for\
    \ i = 1, N do\n            for j = 1, M do\n                if ok[i * M + j] ==\
    \ level then\n                    res =", "    local n, m = #grid, #grid[1]\n\
    \    local buckets, max_h = {}, 0\n    for i = 1, n do\n        buckets[i] = 0\n\
    \        for j = 1, m do\n            buckets[i] = buckets[i] + grid[i][j]\n \
    \           max_h = math.max(max_h, grid[i][j])\n        end\n    end\n    local\
    \ min_h = min_in_array(buckets)\n    if min_h > capacity then\n        return\
    \ -1\n    end\n    local function less_than_capacity(h)\n        return function(b)\n\
    \            return b < h\n        end\n    end\n    local function fill_to_h(h)\n\
    \        return function(b)\n            return b + h\n        end\n    end\n\
    \    local function adjust_buckets(h)\n        local use_count = 0\n        for\
    \ i = 1, n do\n            if buckets[i] < h then\n                use_count =\
    \ use_count + 1\n                buckets[i] = h\n            end\n        end\n\
    \        return use_count\n    end\n    local count = 0\n    for h = min_h, max_h\
    \ do\n        count = count + adjust_buckets(h)\n    end\n    return count\nend",
  "    local h, m = {}, 0\n    for _, row in ipairs(grid) do\n        for i = 1, #row\
    \ do\n            if row[i] == 1 then\n                table.insert(h, i)\n  \
    \          end\n        end\n        if #h > 0 then\n            local l, r =\
    \ table.remove(h, 1), table.remove(h, 1)\n            while #h > 0 do\n      \
    \          local cur = table.remove(h, 1)\n                if cur - r >= capacity\
    \ then\n                    m = math.max(m, r - l + 1)\n                    l,\
    \ r = cur, cur\n                else\n                    r = cur\n          \
    \      end\n            end\n            m = math.max(m, r - l + 1)\n        end\n\
    \    end\n    return m\nend", "    local row = #grid\n    local col = #grid[1]\n\
    \    local times = 0\n    local y = 0\n    while y < row do\n        local x =\
    \ 0\n        while x < col do\n            if grid[y][x] == 1 then\n         \
    \       -- empty this well\n                grid[y][x] = 0\n                local\
    \ c = capacity\n                while c > 0 do\n                    -- fill this\
    \ well\n                    if y - 1 >= 0 and grid[y - 1][x] == 1 then\n     \
    \                   grid[y - 1][x] = 0\n                        -- fill upper\
    \ well\n                        c = c - 1\n                    elseif x + 1 <\
    \ col and grid[y][x + 1] == 1 then\n                        grid[y][x + 1] = 0\n\
    \                        -- fill right well\n                        c = c - 1\n\
    \                    elseif y + 1 < row and grid[y + 1][x] == 1 then\n       \
    \                 grid[y + 1][x] = 0\n                        -- fill lower well\n\
    \                        c = c - 1\n                    elseif x - 1 >= 0 and\
    \ grid[y][x - 1] == 1 then\n                        grid[y][x - 1] = 0\n     \
    \                   -- fill left well\n                        c = c - 1\n   \
    \                 else\n                        break\n                    end\n\
    \                end\n                times = times + 1\n            end\n   \
    \         x = x + 1\n        end\n        y = y + 1\n    end\n    return times\n\
    end", "    if capacity == 0 then return 0 end\n    local rows, cols = #grid, #grid[1]\n\
    \    local result = 0\n    local function dfs(i, j, total)\n        if i > rows\
    \ or j > cols then return end\n        local water = grid[i][j]\n        if water\
    \ == 0 then return end\n        local next_total = water + total\n        if next_total\
    \ == capacity then\n            result = result + 1\n            total = 0\n \
    \       elseif next_total > capacity then\n            result = result + 1\n \
    \           total = next_total - capacity\n        else\n            total = next_total\n\
    \        end\n        dfs(i + 1, j, total)\n        dfs(i, j + 1, total)\n   \
    \ end\n    dfs(1, 1, 0)\n    return result\nend\nreturn max_fill", "    local\
    \ fill_amount, t = {}, 0\n    for row, wells in ipairs(grid) do\n        local\
    \ cur_fill = 0\n        for col, well in ipairs(wells) do\n            if well\
    \ == 1 then\n                cur_fill = cur_fill + 1\n            else\n     \
    \           if cur_fill > 0 then\n                    table.insert(fill_amount,\
    \ cur_fill)\n                    cur_fill = 0\n                end\n         \
    \   end\n        end\n        if cur_fill > 0 then\n            table.insert(fill_amount,\
    \ cur_fill)\n        end\n        t = t + cur_fill\n    end\n    local times =\
    \ 0\n    local left = 0\n    for i, amount in ipairs(fill_amount) do\n       \
    \ if amount + left > capacity then\n            times = times + math.ceil((amount\
    \ + left) / capacity)\n            left = amount + left - math.ceil((amount +\
    \ left) / capacity) * capacity\n        else\n            left = left + amount\n\
    \        end\n    end\n    return times + math.ceil(left / capacity)\nend\nreturn\
    \ max_fill", "    local max_water = 0\n    for i, row in ipairs(grid) do\n   \
    \     local sum = 0\n        for j, cell in ipairs(row) do\n            sum =\
    \ sum + cell\n            if sum > capacity then\n                max_water =\
    \ max_water + 1\n                sum = sum - capacity\n            end\n     \
    \   end\n    end\n    return max_water\nend", "    local n, m = #grid, #grid[1]\n\
    \    local capacity, best = capacity, {}\n    for i=1,n do\n        best[i] =\
    \ {}\n        for j=1,m do\n            best[i][j] = -1\n        end\n    end\n\
    \    local function fill(i, j)\n        if i == n then\n            return 0\n\
    \        end\n        if best[i][j] ~= -1 then\n            return best[i][j]\n\
    \        end\n        local result = math.huge\n        for j2=1,m do\n      \
    \      local dr = math.abs(j2 - j)\n            result = math.min(result, fill(i+1,\
    \ j2) + grid[i][j2] * dr)\n        end\n        best[i][j] = result\n        return\
    \ result\n    end\n    return fill(1,1)\nend\nreturn max_fill", "    local function\
    \ filled_rows(capacity)\n        local res = {}\n        for row = 1, #grid do\n\
    \            local num_full = 0\n            for _, v in ipairs(grid[row]) do\n\
    \                if v == 1 then\n                    num_full = num_full + 1\n\
    \                end\n            end\n            res[row] = math.min(num_full,\
    \ capacity)\n        end\n        return res\n    end\n    local curr_fill = filled_rows(capacity)\n\
    \    local last_fill = {}\n    local count = 0\n    while true do\n        count\
    \ = count + 1\n        for row = 1, #grid do\n            last_fill[row] = curr_fill[row]\n\
    \        end\n        for row = 1, #grid do\n            if curr_fill[row] < capacity\
    \ then\n                if row < #grid then\n                    local overflow\
    \ = math.min(capacity - curr_fill[row], last_fill[row + 1])\n                \
    \    curr_fill[row] = curr_fill[row] + overflow\n                    curr_fill[row\
    \ + 1] = curr_fill[row + 1] - overflow\n                end\n                if\
    \ row > 1 then\n                    local overflow = math.min(capacity - curr_fill[row],\
    \ last_fill[row - 1])\n                    curr_fill[row] = curr_fill[row] + overflow\n\
    \                    curr_fill[row - 1] = curr_fill[row - 1] - overflow\n    \
    \            end\n            end\n        end\n        if #last_fill == #curr_fill\
    \ then\n            local same = true\n            for row = 1, #grid do\n   \
    \             if last_fill[row] ~= curr_fill[row] then\n                    same\
    \ = false\n                    break\n                end\n            end\n \
    \           if same then\n                break\n            end\n        end\n\
    \    end\n    return count\nend\nreturn max_fill", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local q = {}\n    local function process(x, y)\n        if\
    \ x < 1 or x > n or y < 1 or y > m then\n            return\n        end\n   \
    \     if grid[x][y] == 1 then\n            q[#q + 1] = {x, y}\n            grid[x][y]\
    \ = 0\n        end\n    end\n    local function process_row(x, y)\n        if\
    \ y == m then\n            return\n        end\n        for i = y, m do\n    \
    \        if grid[x][i] == 1 then\n                process(x, i)\n            \
    \    break\n            end\n        end\n    end\n    local function process_col(x,\
    \ y)\n        if x == n then\n            return\n        end\n        for i =\
    \ x, n do\n            if grid[i][y] == 1 then\n                process(i, y)\n\
    \                break\n            end\n        end\n    end\n    local function\
    \ process_empty(x, y)\n        if x == n then\n            return\n        end\n\
    \        for i = x, n do\n            if grid[i][y] == 1 then\n              \
    \  process(i, y)\n                break\n            end\n        end\n    end\n\
    \    local x, y, cnt, i = 1, 1, 0, 1\n    while i <= #q do\n        x, y = q[i][1],\
    \ q[i][2]\n        if y < m then\n            for j = y + 1, m do\n          \
    \      if grid[x][j] == 1 then\n                    process(x, j)\n          \
    \          break\n                end\n            end\n        end\n        if\
    \ x < n then\n            for j = x + 1, n do\n                if grid[j][y] ==\
    \ 1 then\n                    process(j, j)\n                    break\n     \
    \           end\n            end\n        end\n        if (x == n or y == m) and\
    \ #q - i >= capacity then\n            cnt = cnt + 1\n            i = i + capacity\n\
    \        else\n            i = i + 1\n        end\n    end\n    return cnt\nend\n\
    return max_fill", "  local row, col = #grid, #grid[1]\n  local dp = {}\n  for\
    \ i = 1, row do\n    dp[i] = {}\n    for j = 1, col do\n      dp[i][j] = 1\n \
    \   end\n  end\n  for j = 1, col do\n    for i = 1, row do\n      if grid[i][j]\
    \ == 1 then\n        dp[i][j] = math.min(i, capacity)\n      else\n        if\
    \ i > 1 then\n          dp[i][j] = dp[i - 1][j]\n        end\n      end\n    end\n\
    \  end\n  return dp\nend", "  local m, n = #grid, #grid[1]\n  local total = 0\n\
    \  for i = 1, m do\n    local min_height = math.huge\n    for j = 1, n do\n  \
    \    if grid[i][j] == 1 then\n        min_height = math.min(min_height, j)\n \
    \     end\n    end\n    total = total + min_height\n  end\n  return math.floor(total\
    \ / capacity)\nend\nreturn max_fill", "    if not grid then return 0 end\n   \
    \ local n, m = #grid, #grid[1]\n    if n == 0 or m == 0 then return 0 end\n  \
    \  local function find_sum(grid, capacity)\n        local n, m = #grid, #grid[1]\n\
    \        local total = 0\n        for i = 1, n do\n            local sum = 0\n\
    \            for j = 1, m do\n                sum = sum + grid[i][j]\n       \
    \     end\n            local res = math.min(sum, capacity)\n            total\
    \ = total + res\n            if res < sum then return total end\n        end\n\
    \        return total\n    end\n    local function fill_one(grid, capacity)\n\
    \        local n, m = #grid, #grid[1]\n        local total = 0\n        for i\
    \ = 1, n do\n            for j = 1, m do\n                if grid[i][j] == 1 then\n\
    \                    grid[i][j] = 0\n                    local res = find_sum(grid,\
    \ capacity)\n                    total = total + res\n                    grid[i][j]\
    \ = 1\n                    if res == 0 then return total end\n               \
    \ end\n            end\n        end\n        return total\n    end\n    return\
    \ fill_one(grid, capacity)\nend", "    local len = #grid\n    local width = #grid[1]\n\
    \    local count = 0\n    for c = 1, width do\n        for r = 1, len do\n   \
    \         if grid[r][c] == 1 then\n                for rr = r, len do\n      \
    \              if grid[rr][c] == 1 then\n                        grid[rr][c] =\
    \ 0\n                        count = count + 1\n                    end\n    \
    \            end\n                break\n            end\n        end\n    end\n\
    \    for c = 1, width do\n        for r = len, 1, -1 do\n            if grid[r][c]\
    \ == 1 then\n                for rr = r, 1, -1 do\n                    if grid[rr][c]\
    \ == 1 then\n                        grid[rr][c] = 0\n                       \
    \ count = count + 1\n                    end\n                end\n          \
    \      break\n            end\n        end\n    end\n    return count\nend", " \
    \ if not grid or #grid < 1 then return 0 end\n  local m, n = #grid, #grid[1]\n\
    \  local max_column = 0\n  for i = 1, m do\n    local column = 0\n    for j =\
    \ 1, n do\n      if grid[i][j] == 1 then\n        column = column + 1\n      end\n\
    \    end\n    max_column = math.max(max_column, column)\n  end\n  return math.ceil(max_column\
    \ / capacity)\nend", "    local r, c = #grid, #grid[1]\n    local function fill(i,\
    \ j)\n        local h = grid[i][j]\n        grid[i][j] = 0\n        if h > capacity\
    \ then\n            grid[i][j] = h - capacity\n            return capacity\n \
    \       else\n            for _ = 1, i - 1 do\n                grid[i - _][j]\
    \ = 0\n            end\n            return h\n        end\n    end\n    local\
    \ function dfs(i, j)\n        if i > r then\n            return 0\n        end\n\
    \        local h = fill(i, j)\n        if j < c then\n            return h + dfs(i,\
    \ j + 1)\n        else\n            return h + dfs(i + 1, 1)\n        end\n  \
    \  end\n    return dfs(1, 1)\nend\nreturn max_fill", "    local fill = 0\n   \
    \ local row_size = 0\n    for _, row in ipairs(grid) do\n        local gsize =\
    \ 0\n        for _, v in ipairs(row) do\n            if v == 1 then\n        \
    \        gsize = gsize + 1\n            end\n        end\n        if gsize > row_size\
    \ then\n            row_size = gsize\n        end\n    end\n    local buckets\
    \ = {}\n    for i = 1, row_size do\n        buckets[i] = capacity\n    end\n \
    \   for _, row in ipairs(grid) do\n        for _, v in ipairs(row) do\n      \
    \      if v == 1 then\n                local filled = false\n                for\
    \ i = 1, row_size do\n                    if buckets[i] > 0 then\n           \
    \             buckets[i] = buckets[i] - 1\n                        filled = true\n\
    \                        break\n                    end\n                end\n\
    \                if not filled then\n                    for i = 1, row_size do\n\
    \                        buckets[i] = capacity - 1\n                    end\n\
    \                    fill = fill + 1\n                end\n            end\n \
    \       end\n    end\n    return fill\nend", "    local s = 0\n    for _, row\
    \ in ipairs(grid) do\n        local x = 0\n        for _, cell in ipairs(row)\
    \ do\n            x = x + cell\n        end\n        if x > s then\n         \
    \   s = x\n        end\n    end\n    if s > capacity then\n        return capacity\n\
    \    else\n        return s\n    end\nend", "    local fill = 0\n    local count\
    \ = 0\n    for _, row in ipairs(grid) do\n        local max = 0\n        for _,\
    \ v in ipairs(row) do\n            if v == 1 then\n                max = max +\
    \ 1\n            end\n        end\n        if max > fill then\n            count\
    \ = count + (max - fill)\n            fill = max\n        end\n    end\n    local\
    \ total = count * capacity\n    local available = fill * capacity\n    return\
    \ total - available\nend\nreturn max_fill", "  local max_fill = {}\n  local result\
    \ = 0\n  local m, n = #grid, #grid[1]\n  local min = math.min\n  for i = 1, m\
    \ do\n    max_fill[i] = {}\n    for j = 1, n do\n      max_fill[i][j] = grid[i][j]\
    \ + capacity * (i - 1)\n      result = max_fill[i][j]\n    end\n  end\n  for i\
    \ = 1, m do\n    for j = 1, n do\n      if i > 1 then\n        max_fill[i][j]\
    \ = min(max_fill[i][j], max_fill[i - 1][j] + capacity)\n      end\n      if j\
    \ > 1 then\n        max_fill[i][j] = min(max_fill[i][j], max_fill[i][j - 1] +\
    \ capacity)\n      end\n      result = max(result, max_fill[i][j])\n    end\n\
    \  end\n  return result\nend", "  local function full(well)\n    return well:gsub(\"\
    0\", \"1\")\n  end\n  local function drain(well, capacity)\n    local c, w = capacity,\
    \ well\n    for i=1,#w do\n      if w:sub(i,i) == \"1\" then\n        c = c -\
    \ 1\n        if c == 0 then return w:sub(1,i) end\n      end\n    end\n    return\
    \ w\n  end\n  local function depth(well)\n    local n = 0\n    for i=1,#well do\n\
    \      if well:sub(i,i) == \"1\" then n = n + 1 end\n    end\n    return n\n \
    \ end\n  local function lowest(grid)\n    local m = math.huge\n    for i=1,#grid\
    \ do\n      local d = depth(grid[i])\n      if d < m then m = d end\n    end\n\
    \    return m\n  end\n  local function update(grid, capacity)\n    local n = lowest(grid)\n\
    \    for i=1,#grid do\n      local d = depth(grid[i])\n      if d == n then\n\
    \        grid[i] = drain(grid[i], capacity)\n      end\n    end\n    return grid\n\
    \  end\n  local function is_empty(grid)\n    for i=1,#grid do\n      if grid[i]\
    \ ~= full(grid[i]) then return false end\n    end\n    return true\n  end\n  local\
    \ function fill(grid, capacity)\n    local n = 0\n    while not is_empty(grid)\
    \ do\n      grid = update(grid, capacity)\n      n = n + 1\n    end\n    return\
    \ n\n  end\n  local g = {}\n  for i=1,#grid do\n    g[i] = table.concat(grid[i])\n\
    \  end\n  return fill(g, capacity)\nend", "    local count = 0\n    for i, r in\
    \ ipairs(grid) do\n        local ones = 0\n        for j, c in ipairs(r) do\n\
    \            if c == 1 then\n                ones = ones + 1\n            end\n\
    \        end\n        if ones > 0 then\n            count = count + math.ceil(ones\
    \ / capacity)\n        end\n    end\n    return count\nend", "    local count\
    \ = 0\n    local function fill_helper(grid, capacity)\n        local function\
    \ max_capacity(grid, col)\n            local capacity = capacity\n           \
    \ for i = 1, #grid do\n                if grid[i][col] == 1 then\n           \
    \         capacity = capacity - 1\n                    if capacity < 0 then\n\
    \                        return -1\n                    end\n                end\n\
    \            end\n            return capacity\n        end\n        for col =\
    \ 1, #grid[1] do\n            local c = max_capacity(grid, col)\n            if\
    \ c >= 0 then\n                count = count + 1\n                for i = 1, #grid\
    \ do\n                    if grid[i][col] == 1 then\n                        grid[i][col]\
    \ = 0\n                    end\n                end\n            end\n       \
    \ end\n    end\n    fill_helper(grid, capacity)\n    fill_helper(zip(grid), capacity)\n\
    \    return count\nend", "  local n_row, n_col = #grid, #grid[1]\n  local bucket\
    \ = capacity\n  local max_fill_cnt = 0\n  for j = 1, n_col do\n    for i = 1,\
    \ n_row do\n      if grid[i][j] == 1 then\n        if bucket == 0 then\n     \
    \     bucket = capacity\n          max_fill_cnt = max_fill_cnt + 1\n        end\n\
    \        bucket = bucket - 1\n      end\n    end\n  end\n  return max_fill_cnt\n\
    end\nreturn max_fill", "    local res = 0\n    for i = 1, #grid do\n        local\
    \ sum = 0\n        for j = 1, #grid[i] do\n            sum = sum + grid[i][j]\n\
    \        end\n        local n = math.floor(sum / capacity)\n        res = res\
    \ + n + (sum - n * capacity == 0 and 0 or 1)\n    end\n    return res\nend\nreturn\
    \ {\n    max_fill = max_fill\n}", "    local n = #grid\n    local res = 0\n  \
    \  for i = 1, #grid[1] do\n        local count = 0\n        for j = 1, n do\n\
    \            count = count + grid[j][i]\n        end\n        res = res + math.ceil(count\
    \ / capacity)\n    end\n    return res\nend\nreturn max_fill", "    local n =\
    \ #grid\n    local m = #grid[1]\n    local function range(n)\n        local result\
    \ = {}\n        for i = 1, n do\n            result[i] = i\n        end\n    \
    \    return result\n    end\n    local function generate_water(i, j)\n       \
    \ local v = {}\n        for k = 1, capacity do\n            v[k] = {}\n      \
    \      for l = 1, capacity do\n                v[k][l] = grid[k + i - 1][l + j\
    \ - 1]\n            end\n        end\n        return v\n    end\n    local function\
    \ check_water(water)\n        for i = 1, capacity do\n            for j = 1, capacity\
    \ do\n                if water[i][j] == 1 then\n                    return true\n\
    \                end\n            end\n        end\n        return false\n   \
    \ end\n    local function move_water(water)\n        local result = {}\n     \
    \   for i = 1, capacity do\n            result[i] = {}\n            for j = 1,\
    \ capacity do\n                result[i][j] = 0\n            end\n        end\n\
    \        for i = 1, capacity do\n            for j = 1, capacity do\n        \
    \        local delta = i + j - 1\n                if delta <= capacity then\n\
    \                    result[i][j] = water[i][j]\n                end\n       \
    \     end\n        end\n        return result\n    end\n    local function fill_water(water)\n\
    \        local result = {}\n        for i = 1, capacity do\n            result[i]\
    \ = {}\n            for j = 1, capacity do\n                result[i][j] = 0\n\
    \            end\n        end\n        for i = 1, capacity do\n            for\
    \ j = 1, capacity do\n                local delta = i + j - 1\n              \
    \  if delta > capacity then\n                    result[i][j] = water[i][j]\n\
    \                end\n            end\n        end\n        return result\n  \
    \  end\n    local function sum_water(water)\n        local result = 0\n      \
    \  for i = 1, capacity do\n            for j = 1, capacity do\n              \
    \  result = result + water[i][j]\n            end\n        end\n        return\
    \ result\n    end\n    local function merge_water", "    local n = #grid\n   \
    \ local ans = 0\n    local function dfs(x, y, left)\n        if grid[x][y] ==\
    \ 0 or left == 0 then\n            return\n        end\n        ans = ans + 1\n\
    \        grid[x][y] = 0\n        if y ~= n and x ~= 1 then\n            dfs(x\
    \ - 1, y, left - 1)\n        end\n        if y ~= n and x ~= n then\n        \
    \    dfs(x + 1, y, left - 1)\n        end\n        if x ~= n then\n          \
    \  dfs(x, y + 1, left - 1)\n        end\n    end\n    for i = 1, n do\n      \
    \  for j = 1, n do\n            if grid[i][j] == 1 then\n                dfs(i,\
    \ j, capacity)\n            end\n        end\n    end\n    return ans\nend\nreturn\
    \ max_fill", "    local max_fills = 0\n    for _, well in ipairs(grid) do\n  \
    \      local buckets = 0\n        for _, water in ipairs(well) do\n          \
    \  buckets = buckets + water\n            if buckets >= capacity then\n      \
    \          max_fills = max_fills + buckets / capacity\n                buckets\
    \ = buckets % capacity\n            end\n        end\n        max_fills = max_fills\
    \ + buckets / capacity\n    end\n    return max_fills\nend\nreturn max_fill",
  "    -- Get the maximum amount of water of a single row.\n    local function max_water(row)\n\
    \        local max = 0\n        local water = 0\n        for i = 1, #row do\n\
    \            if row[i] == 1 then\n                max = math.max(max, water)\n\
    \                water = 0\n            else\n                water = water +\
    \ 1\n            end\n        end\n        return math.max(max, water)\n    end\n\
    \    -- Get the max amount of water per row and then return the number of times\
    \ we need to fill the buckets.\n    local function fill_times(grid, capacity)\n\
    \        local max = 0\n        for i = 1, #grid do\n            max = math.max(max,\
    \ max_water(grid[i]))\n        end\n        return math.ceil(max / capacity)\n\
    \    end\n    return fill_times(grid, capacity)\nend", "  local n, m = #grid,\
    \ #grid[1]\n  local r, c = 0, 0\n  local sum = 0\n  while r < n do\n    while\
    \ c < m do\n      local num = grid[r][c]\n      if num > 0 then\n        grid[r][c]\
    \ = 0\n        local filled = math.min(num, capacity)\n        sum = sum + filled\n\
    \        for i = r + 1, n do\n          grid[i][c] = grid[i][c] + filled\n   \
    \     end\n      end\n      c = c + 1\n    end\n    r = r + 1\n    c = 0\n  end\n\
    \  return sum\nend\nreturn max_fill", "    local max_bucket_water = 0\n    for\
    \ _, row in ipairs(grid) do\n        local bucket_water = 0\n        for _, well\
    \ in ipairs(row) do\n            bucket_water = bucket_water + well\n        \
    \    if bucket_water > capacity then\n                return capacity\n      \
    \      end\n        end\n        max_bucket_water = math.max(max_bucket_water,\
    \ bucket_water)\n    end\n    return max_bucket_water\nend", "    local n = #grid\n\
    \    local max_well_height = 0\n    for i = 1, n do\n        max_well_height =\
    \ math.max(max_well_height, max(grid[i]))\n    end\n    local total_water = 0\n\
    \    for i = 1, n do\n        for j = 1, #grid[i] do\n            if grid[i][j]\
    \ > 0 then\n                total_water = total_water + grid[i][j]\n         \
    \   end\n        end\n    end\n    local buckets = math.ceil(total_water / capacity)\n\
    \    local result = 0\n    local left, right = 1, n\n    while left <= right do\n\
    \        local height = math.floor((left + right) / 2)\n        local water =\
    \ 0\n        for i = 1, n do\n            for j = 1, #grid[i] do\n           \
    \     if grid[i][j] > 0 then\n                    water = water + math.min(grid[i][j],\
    \ height)\n                end\n            end\n        end\n        if water\
    \ >= buckets * capacity then\n            result = height\n            right =\
    \ height - 1\n        else\n            left = height + 1\n        end\n    end\n\
    \    return result\nend", "    local m, n = #grid, #grid[1]\n    local function\
    \ simulate(i, j)\n        -- \u8BA1\u7B97\u4E0B\u4E00\u4E2A\u64CD\u4F5C\u4F4D\u7F6E\
    \uFF0C\u6A2A\u5411\u4F18\u5148\u641C\u7D22\n        local next_i, next_j\n   \
    \     for jj = j + 1, n do\n            if grid[i][jj] == 1 then\n           \
    \     next_i, next_j = i, jj\n                break\n            end\n       \
    \ end\n        if not next_i then\n            for ii = i + 1, m do\n        \
    \        if grid[ii][j] == 1 then\n                    next_i, next_j = ii, j\n\
    \                    break\n                end\n            end\n        end\n\
    \        -- \u6CA1\u6709\u4E0B\u4E00\u4E2A\u64CD\u4F5C\u4F4D\u7F6E\uFF0C\u8FD4\
    \u56DE\u5F53\u524D\u4F4D\u7F6E\u7684\u586B\u5145\u503C\n        if not next_i\
    \ then\n            return capacity\n        end\n        -- \u6309\u7167\u6700\
    \u5C0F\u7684\u586B\u5145\u91CF\u8FDB\u884C\n        local fill = math.min(capacity,\
    \ (next_i - i) * (next_j - j))\n        -- \u51CF\u5C11\u4E0B\u4E00\u4E2A\u64CD\
    \u4F5C\u4F4D\u7F6E\u7684\u6C34\u91CF\n        grid[next_i][next_j] = grid[next_i][next_j]\
    \ - fill\n        -- \u9012\u5F52\u8BA1\u7B97\u4E0B\u4E00\u4E2A\u64CD\u4F5C\u4F4D\
    \u7F6E\n        return simulate(next_i, next_j)\n    end\n    -- \u521D\u59CB\u5316\
    \u64CD\u4F5C\u4F4D\u7F6E\n    local i, j = 1, 1\n    while i <= m and j <= n do\n\
    \        if grid[i][j] == 1 then\n            break\n        end\n        j =\
    \ j + 1\n        if j > n then\n            i = i + 1\n            j = 1\n   \
    \     end\n    end\n    if i > m or j > n then\n        return 0\n    end\n  \
    \  return simulate(i, j)\nend", "    -- first, compute the wells to be filled.\
    \ \n    -- we have to fill every well before any well below it in the grid\n \
    \   local to_fill = {}\n    for i=1,#grid do\n        for j=1,#grid[i] do\n  \
    \          if grid[i][j] == 1 then\n                to_fill[#to_fill+1] = {i,j}\n\
    \            end\n        end\n    end\n    -- now, we can use dp to compute the\
    \ minimum number of times that the bucket\n    -- has to be lowered\n    local\
    \ max_dist = capacity*#grid[1]\n    local dp = {}\n    for i=1,#grid do\n    \
    \    dp[i] = {}\n        for j=1,#grid[i] do\n            dp[i][j] = 0\n     \
    \   end\n    end\n    local function dp_fill(i,j)\n        if dp[i][j] > 0 then\
    \ return dp[i][j] end\n        local min_fill = max_dist\n        for _, pos in\
    \ ipairs(to_fill) do\n            local a,b = pos[1], pos[2]\n            local\
    \ dist = math.abs(a-i) + math.abs(b-j)\n            if dist <= max_dist then\n\
    \                min_fill = math.min(min_fill, dist + dp_fill(a,b))\n        \
    \    end\n        end\n        if min_fill == max_dist then\n            dp[i][j]\
    \ = 0\n        else\n            dp[i][j] = min_fill\n        end\n        return\
    \ dp[i][j]\n    end\n    local min_fill = max_dist\n    for _, pos in ipairs(to_fill)\
    \ do\n        local a,b = pos[1], pos[2]\n        min_fill = math.min(min_fill,\
    \ dp_fill(a,b))\n    end\n    return min_fill\nend", "    local sum, max = 0,\
    \ 0\n    for i = 1, #grid do\n        sum = sum + grid[i]\n        if sum > capacity\
    \ then\n            sum = capacity\n        end\n        if sum > max then\n \
    \           max = sum\n        end\n    end\n    return max\nend", "    local\
    \ n, m = #grid, #grid[1]\n    local results = {}\n    for i = 1, n do\n      \
    \  local idx, count = m, 0\n        for j = m, 1, -1 do\n            if grid[i][j]\
    \ == 1 then\n                count = count + 1\n                if count == capacity\
    \ then\n                    for k = idx, j, -1 do\n                        grid[i][k]\
    \ = 0\n                    end\n                    results[#results + 1] = count\n\
    \                    idx, count = j - 1, 0\n                end\n            end\n\
    \        end\n        if count > 0 then\n            for k = idx, 1, -1 do\n \
    \               grid[i][k] = 0\n            end\n            results[#results\
    \ + 1] = count\n        end\n    end\n    return results\nend\nreturn function(grid,\
    \ capacity)\n    local results = max_fill(grid, capacity)\n    while #results\
    \ > 0 do\n        local tmp = max_fill(grid, capacity)\n        if #tmp == 0 then\
    \ break end\n        for i = 1, #tmp do\n            results[#results + 1] = tmp[i]\n\
    \        end\n    end\n    return #results\nend", "    local function flatten(matrix)\n\
    \        local result = {}\n        for i = 1, #matrix do\n            for j =\
    \ 1, #matrix[i] do\n                table.insert(result, matrix[i][j])\n     \
    \       end\n        end\n        return result\n    end\n    local function sum(a)\n\
    \        local result = 0\n        for i = 1, #a do\n            result = result\
    \ + a[i]\n        end\n        return result\n    end\n    local function max(a)\n\
    \        local result = a[1]\n        for i = 2, #a do\n            if a[i] >\
    \ result then\n                result = a[i]\n            end\n        end\n \
    \       return result\n    end\n    local function get_fill(grid, capacity)\n\
    \        local wells = flatten(grid)\n        local fills = {}\n        local\
    \ total = sum(wells)\n        local max_fill = 0\n        local fill = 0\n   \
    \     local i = 1\n        while i <= #wells do\n            if wells[i] == 1\
    \ then\n                fill = fill + 1\n                if fill == capacity then\n\
    \                    fills[#fills + 1] = fill\n                    max_fill =\
    \ math.max(max_fill, fill)\n                    fill = 0\n                end\n\
    \            else\n                if fill > 0 then\n                    fills[#fills\
    \ + 1] = fill\n                    max_fill = math.max(max_fill, fill)\n     \
    \               fill = 0\n                end\n            end\n            i\
    \ = i + 1\n        end\n        if fill > 0 then\n            fills[#fills + 1]\
    \ = fill\n            max_fill = math.max(max_fill, fill)\n        end\n     \
    \   return total, max_fill, fills\n    end\n    local function fill_row(fills,\
    \ capacity)\n        local count = 0\n        for i = 1, #fills do\n         \
    \   local fill = fills[i]\n            if fill > 0 then\n                count\
    \ = count + math.ceil(fill / capacity)\n            end\n        end\n       \
    \ return count\n    end\n    local total, max_fill, fills = get_fill(grid, capacity)\n\
    \    local count = 0\n    local i = 1", "    local rows, cols = #grid, #grid[1]\n\
    \    local max = 0\n    for j = 1, cols do\n        local t = 0\n        for i\
    \ = 1, rows do\n            t = t + grid[i][j]\n        end\n        max = math.max(max,\
    \ t)\n    end\n    return math.min(max, capacity)\nend\nreturn function (grid,\
    \ capacity)\n    local rows, cols = #grid, #grid[1]\n    local max = max_fill(grid,\
    \ capacity)\n    local step = 0\n    for i = 1, rows do\n        local t = 0\n\
    \        for j = 1, cols do\n            t = t + grid[i][j]\n        end\n   \
    \     local m = math.min(max, t)\n        step = step + m\n        for j = 1,\
    \ cols do\n            grid[i][j] = grid[i][j] - m\n        end\n    end\n   \
    \ return step\nend", "    local function fill(x, y)\n        local n = 0\n   \
    \     for i = y, #grid do\n            if grid[i][x] == 1 then\n             \
    \   grid[i][x] = 0\n                n = n + 1\n            end\n            if\
    \ n == capacity then\n                break\n            end\n        end\n  \
    \      return n\n    end\n    local function empty(x, y)\n        local n = 0\n\
    \        for i = y, 1, -1 do\n            if grid[i][x] == 0 then\n          \
    \      grid[i][x] = 1\n                n = n + 1\n            end\n          \
    \  if n == capacity then\n                break\n            end\n        end\n\
    \        return n\n    end\n    local max_fill_count = 0\n    for x = 1, #grid[1]\
    \ do\n        max_fill_count = max_fill_count + fill(x, 1)\n    end\n    for y\
    \ = 2, #grid do\n        for x = 1, #grid[1] do\n            if grid[y][x] ==\
    \ 1 then\n                max_fill_count = max_fill_count + empty(x, y)\n    \
    \        end\n        end\n    end\n    return max_fill_count\nend\nreturn max_fill",
  "  local rows, cols = #grid, #grid[1]\n  local lower_limit = (rows - 1) * cols +\
    \ 1\n  local upper_limit = rows * cols\n  local total_water = 0\n  local function\
    \ water_for_row(row, col)\n    return grid[row][col] * (cols - col)\n  end\n \
    \ for row = 1, rows do\n    for col = 1, cols do\n      total_water = total_water\
    \ + water_for_row(row, col)\n    end\n  end\n  local lower_bound, upper_bound\
    \ = 0, math.huge\n  while lower_bound < upper_bound do\n    local mid = (lower_bound\
    \ + upper_bound) // 2\n    local curr_water = 0\n    local waste_water = 0\n \
    \   for row = 1, rows do\n      for col = 1, cols do\n        curr_water = curr_water\
    \ + water_for_row(row, col)\n        if curr_water > mid then\n          curr_water\
    \ = curr_water - water_for_row(row, col)\n          waste_water = waste_water\
    \ + (curr_water - mid)\n          curr_water = mid\n        end\n      end\n \
    \   end\n    if waste_water < lower_limit then\n      lower_bound = mid + 1\n\
    \    elseif waste_water > upper_limit then\n      upper_bound = mid\n    else\n\
    \      return mid\n    end\n  end\n  return lower_bound\nend\nreturn max_fill",
  "    local max_water, fill_count = 0, 0\n    for i, row in ipairs(grid) do\n   \
    \     for j, water in ipairs(row) do\n            if (water == 1) then\n     \
    \           fill_count = fill_count + 1\n                max_water = math.max(max_water,\
    \ water)\n            end\n        end\n    end\n    return math.ceil(max_water\
    \ / capacity) + fill_count\nend", "    local ret = 0\n    for _, row in ipairs(grid)\
    \ do\n        local low = 0\n        local high = 0\n        for _, col in ipairs(row)\
    \ do\n            if col == 1 then\n                high = high + 1\n        \
    \    else\n                low = math.max(low, high)\n                high = 0\n\
    \            end\n        end\n        ret = ret + math.min(low, capacity)\n \
    \   end\n    return ret\nend", "    local n, m = #grid, #grid[1]\n    local total\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                total = total + 1\n            end\n        end\n\
    \    end\n    local function dfs(i, j, count)\n        if i < 1 or i > n or j\
    \ < 1 or j > m or grid[i][j] == -1 then\n            return\n        end\n   \
    \     local v = grid[i][j]\n        grid[i][j] = -1\n        if v == 1 then\n\
    \            count = count + 1\n        end\n        if count == total then\n\
    \            return 1\n        end\n        if i < n and grid[i + 1][j] > 0 then\n\
    \            dfs(i + 1, j, count)\n        end\n        if j < m and grid[i][j\
    \ + 1] > 0 then\n            dfs(i, j + 1, count)\n        end\n        if i >\
    \ 1 and grid[i - 1][j] > 0 then\n            dfs(i - 1, j, count)\n        end\n\
    \        if j > 1 and grid[i][j - 1] > 0 then\n            dfs(i, j - 1, count)\n\
    \        end\n        grid[i][j] = v\n    end\n    local count = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              dfs(i, j, 0)\n                count = count + 1\n            end\n\
    \        end\n    end\n    return count\nend", "    local maxf = 0\n    for _,\
    \ row in ipairs(grid) do\n        local sum = 0\n        for _, w in ipairs(row)\
    \ do\n            sum = sum + w\n            if sum > capacity then\n        \
    \        maxf = maxf + 1\n                sum = 0\n            end\n        end\n\
    \        if sum > 0 then\n            maxf = maxf + 1\n        end\n    end\n\
    \    return maxf\nend\nreturn max_fill", "    local width = #grid[1]\n    local\
    \ max_wells = {}\n    for i = 1, width do\n        local max_well = 0\n      \
    \  for j = 1, #grid do\n            max_well = math.max(max_well, grid[j][i])\n\
    \        end\n        max_wells[i] = max_well\n    end\n    local count = 0\n\
    \    local i = 1\n    while i <= width do\n        if max_wells[i] > 0 then\n\
    \            count = count + 1\n            local taken = math.min(capacity, max_wells[i])\n\
    \            for j = 1, #grid do\n                if grid[j][i] > 0 then\n   \
    \                 grid[j][i] = grid[j][i] - taken\n                end\n     \
    \       end\n            i = i + taken\n        else\n            i = i + 1\n\
    \        end\n    end\n    return count\nend", "    local max_fill = {0}\n   \
    \ for row = 1, #grid do\n        local sum = 0\n        for col = 1, #grid[row]\
    \ do\n            sum = sum + grid[row][col]\n            if col < #grid[row]\
    \ then\n                max_fill[col] = math.max(max_fill[col], sum)\n       \
    \     end\n        end\n    end\n    return math.max(table.unpack(max_fill))\n\
    end", "    local count = 0\n    for row = 1, #grid do\n        local max_seq =\
    \ 0\n        local seq = 0\n        for col = 1, #grid[row] do\n            if\
    \ grid[row][col] == 1 then\n                seq = seq + 1\n            else\n\
    \                max_seq = math.max(max_seq, seq)\n                seq = 0\n \
    \           end\n        end\n        max_seq = math.max(max_seq, seq)\n     \
    \   if max_seq > 0 then\n            count = count + math.ceil(max_seq / capacity)\n\
    \        end\n    end\n    return count\nend", "    local rows, cols = #grid,\
    \ #grid[1]\n    local max = 0\n    for r = 1, rows do\n        for c = 1, cols\
    \ do\n            max = math.max(max, grid[r][c])\n        end\n    end\n    local\
    \ function dfs(grid, r, c, capacity, rows, cols)\n        if grid[r][c] == 0 then\n\
    \            return 0\n        end\n        grid[r][c] = 0\n        local count\
    \ = 1\n        if r > 1 then\n            count = count + dfs(grid, r - 1, c,\
    \ capacity, rows, cols)\n        end\n        if r < rows then\n            count\
    \ = count + dfs(grid, r + 1, c, capacity, rows, cols)\n        end\n        if\
    \ c > 1 then\n            count = count + dfs(grid, r, c - 1, capacity, rows,\
    \ cols)\n        end\n        if c < cols then\n            count = count + dfs(grid,\
    \ r, c + 1, capacity, rows, cols)\n        end\n        grid[r][c] = 1\n     \
    \   return count\n    end\n    local function fill(grid, capacity, rows, cols)\n\
    \        local count = 0\n        for r = 1, rows do\n            for c = 1, cols\
    \ do\n                local size = dfs(grid, r, c, capacity, rows, cols)\n   \
    \             if size > 0 then\n                    count = count + math.ceil(size\
    \ / capacity)\n                end\n            end\n        end\n        return\
    \ count\n    end\n    return fill(grid, capacity, rows, cols)\nend\nreturn max_fill",
  "    local m, n = #grid, #grid[1]\n    local max_i, max_j = -1, -1\n    local max_val\
    \ = -1\n    for i = 1, m do\n        for j = 1, n do\n            if grid[i][j]\
    \ > max_val then\n                max_val = grid[i][j]\n                max_i,\
    \ max_j = i, j\n            end\n        end\n    end\n    -- if there is no water,\
    \ no need to fill\n    if max_val == 0 then\n        return 0\n    end\n    --\
    \ fill the max well\n    local moves = 0\n    for i = 1, m do\n        for j =\
    \ 1, n do\n            local diff = max_val - grid[i][j]\n            if diff\
    \ > 0 then\n                if diff <= capacity then\n                    grid[i][j]\
    \ = max_val\n                    moves = moves + diff\n                else\n\
    \                    grid[i][j] = capacity\n                    moves = moves\
    \ + capacity\n                end\n            end\n        end\n    end\n   \
    \ return moves\nend", "    local n, m = #grid, #grid[1]\n    local result = 0\n\
    \    for i = 1, n do\n        result = result + math.ceil(grid[i][1] / capacity)\n\
    \        for j = 2, m do\n            local need = math.ceil(grid[i][j] / capacity)\n\
    \            result = result + math.max(0, need - math.ceil(grid[i][j - 1] / capacity))\n\
    \        end\n    end\n    return result\nend", "    local max_fill = 0\n    for\
    \ i, row in ipairs(grid) do\n        for j, col in ipairs(row) do\n          \
    \  if max_fill < grid[i][j] then\n                max_fill = grid[i][j]\n    \
    \        end\n        end\n    end\n    return max_fill * capacity\nend", "  \
    \  local m, n = #grid, #grid[1]\n    local max_fill = {}\n    local row = 0\n\
    \    for i = 1, m do\n        for j = 1, n do\n            if grid[i][j] == 1\
    \ then\n                row = row + 1\n            end\n        end\n        max_fill[i]\
    \ = {row, row * capacity}\n        row = 0\n    end\n    return max_fill\nend",
  "  local function fill(row, col)\n    local function pos_valid(row, col)\n     \
    \ return (row < 1 or row > #grid) and\n             (col < 1 or col > #grid[1])\n\
    \    end\n    if pos_valid(row, col) then\n      return 0\n    end\n    return\
    \ grid[row][col] == 1 and 1 or 0\n  end\n  local function bucket_capacity(row,\
    \ col)\n    local acc = 0\n    while acc < capacity do\n      acc = acc + fill(row,\
    \ col)\n      row = row + 1\n    end\n    return acc\n  end\n  local function\
    \ mfill(row, col)\n    local function get_bucket_capacity(row, col)\n      local\
    \ capacity = 0\n      for r = row, row + capacity - 1 do\n        capacity = capacity\
    \ + grid[r][col]\n      end\n      return capacity\n    end\n    local steps =\
    \ 0\n    while true do\n      if col > #grid[1] then\n        return steps\n \
    \     end\n      local capacity = bucket_capacity(row, col)\n      col = col +\
    \ 1\n      steps = steps + 1\n    end\n  end\n  local steps = 0\n  for i = 1,\
    \ #grid do\n    steps = steps + mfill(i, 1)\n  end\n  return steps\nend", "  \
    \  local wells = {}\n    local row, col = #grid, #grid[1]\n    local total = 0\n\
    \    for i = 1, row do\n        wells[i] = {}\n        for j = 1, col do\n   \
    \         if grid[i][j] == 1 then\n                wells[i][j] = capacity\n  \
    \              total = total + capacity\n            end\n        end\n    end\n\
    \    local turns = 0\n    local ix, iy = 1, 1\n    local ix_max, iy_max = row,\
    \ col\n    local i = 1\n    while total > 0 do\n        ix, iy = (i - 1) % row\
    \ + 1, math.floor((i - 1) / row) % col + 1\n        if wells[ix][iy] == 0 then\n\
    \            i = i + 1\n        else\n            turns = turns + 1\n        \
    \    local room = capacity\n            for ix = 1, ix_max do\n              \
    \  for iy = 1, iy_max do\n                    local slot = wells[ix][iy]\n   \
    \                 if slot > 0 then\n                        local fill = math.min(slot,\
    \ room)\n                        wells[ix][iy] = slot - fill\n               \
    \         room = room - fill\n                        total = total - fill\n \
    \                       if room == 0 then\n                            break\n\
    \                        end\n                    end\n                end\n \
    \               if room == 0 then\n                    break\n               \
    \ end\n            end\n            i = i + 1\n        end\n    end\n    return\
    \ turns\nend", "    local n, m = #grid, #grid[1]\n    local res = 0\n    local\
    \ r, c = 1, 1\n    while true do\n        if r > n then break end\n        while\
    \ c <= m do\n            local nc = c\n            while grid[r][c] == 0 do nc\
    \ = nc + 1 end\n            if nc - c > capacity then return -1 end\n        \
    \    if nc - c == capacity then\n                res = res + 1\n             \
    \   c = nc\n            else\n                res = res + 1\n                for\
    \ i = c, nc - 1 do grid[r][i] = 1 end\n                c = nc\n            end\n\
    \        end\n        c = 1\n        r = r + 1\n    end\n    return res\nend\n\
    return max_fill", "  local total = 0\n  for i = 1, #grid do\n    for j = 1, #grid[i]\
    \ do\n      if grid[i][j] == 1 then\n        total = total + 1\n      end\n  \
    \  end\n  end\n  return math.ceil(total / capacity)\nend", "    local n, m = #grid,\
    \ #grid[1]\n    local max_row, count = {}, 0\n    for i = 1, n do\n        local\
    \ row = grid[i]\n        local max_current, max_previous = row[1], (max_row[1]\
    \ or 0)\n        for j = 2, m do\n            local current, previous = row[j],\
    \ row[j - 1]\n            max_current = math.max(current, previous, max_current)\n\
    \            max_previous = math.max(previous, max_previous)\n            count\
    \ = count + math.max(0, math.min(max_current, max_previous) - row[j])\n      \
    \  end\n        max_row = row\n    end\n    return count * capacity\nend\nreturn\
    \ max_fill", "    local count = 0\n    for _, row in ipairs(grid) do\n       \
    \ local cells = {}\n        for j, c in ipairs(row) do\n            if c == 1\
    \ then\n                table.insert(cells, j)\n            end\n        end\n\
    \        local num_cells = #cells\n        local n = math.ceil(num_cells / capacity)\n\
    \        for i = 1, n do\n            local idx = (i - 1) * capacity + 1\n   \
    \         local left = cells[idx]\n            local right = cells[math.min(idx\
    \ + capacity - 1, num_cells)]\n            count = count + (right - left + 1)\n\
    \        end\n    end\n    return count\nend\nreturn max_fill", "    local row_count\
    \ = #grid\n    local col_count = #grid[1]\n    local max_col_fill = col_count\
    \ * capacity\n    local result = 0\n    local function fill(target)\n        local\
    \ cost = 0\n        local function fill_col(col, col_fill)\n            if col_fill\
    \ < target then\n                local fill_left = target - col_fill\n       \
    \         cost = cost + fill_left\n                col_fill = col_fill + fill_left\n\
    \            end\n            return col_fill\n        end\n        for col =\
    \ 1, col_count do\n            local col_fill = 0\n            for row = 1, row_count\
    \ do\n                col_fill = col_fill + grid[row][col]\n            end\n\
    \            col_fill = fill_col(col, col_fill)\n            grid[row_count +\
    \ 1][col] = col_fill\n        end\n        return cost\n    end\n    for row =\
    \ 1, row_count do\n        local row_fill = 0\n        for col = 1, col_count\
    \ do\n            row_fill = row_fill + grid[row][col]\n        end\n        grid[row][col_count\
    \ + 1] = row_fill\n        if row_fill == max_col_fill then\n            result\
    \ = result + fill(row_fill)\n        end\n    end\n    return result\nend\nreturn\
    \ max_fill", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n    \
    \    local row_fill = capacity\n        for _, well in ipairs(row) do\n      \
    \      if well == 1 then\n                row_fill = row_fill - 1\n          \
    \  end\n        end\n        if row_fill > max_fill then\n            max_fill\
    \ = row_fill\n        end\n    end\n    return max_fill\nend", "  local m, n =\
    \ #grid, #grid[1]\n  local i, j = 1, 1\n  local count = 0\n  for i = 1, m do\n\
    \    local row_max = 0\n    for j = 1, n do\n      row_max = math.max(row_max,\
    \ grid[i][j])\n    end\n    count = count + row_max\n  end\n  return math.ceil(count\
    \ / capacity)\nend", "  local result = 0\n  for i = 1, #grid do\n    local min_height\
    \ = capacity\n    for j = 1, #grid[i] do\n      min_height = math.min(min_height,\
    \ grid[i][j])\n    end\n    result = result + min_height\n  end\n  return result\n\
    end\nreturn function(grid, capacity)\n  local result = 0\n  local j = 1\n  while\
    \ j <= #grid[1] do\n    local column = {}\n    for i = 1, #grid do\n      table.insert(column,\
    \ grid[i][j])\n    end\n    result = result + max_fill(column, capacity)\n   \
    \ j = j + 1\n  end\n  return result\nend", "    local result = 0\n    local current_level\
    \ = 0\n    for i = 1, #grid do\n        local row = grid[i]\n        local row_max\
    \ = 0\n        for j = 1, #row do\n            local current = row[j]\n      \
    \      if current == 1 then\n                row_max = j\n            end\n  \
    \      end\n        local fill = row_max - current_level\n        if fill > 0\
    \ then\n            local buckets = math.ceil(fill / capacity)\n            result\
    \ = result + buckets\n            current_level = row_max\n        end\n    end\n\
    \    return result\nend\nreturn max_fill", "    local bucket = 0\n    local count\
    \ = 0\n    for _, row in ipairs(grid) do\n        bucket = 0\n        for _, cell\
    \ in ipairs(row) do\n            if cell == 1 then\n                local fill\
    \ = math.min(bucket, capacity)\n                bucket = bucket - fill\n     \
    \           cell = cell - fill\n                if cell == 1 then\n          \
    \          count = count + 1\n                    bucket = capacity\n        \
    \        end\n            end\n        end\n    end\n    return count\nend\nreturn\
    \ max_fill", "    local row, col = #grid, #grid[1]\n    local function max_fill_helper(row,\
    \ col, capacity)\n        if row == 1 then\n            return capacity\n    \
    \    end\n        local row_max, col_max = 0, 0\n        for i = 1, col do\n \
    \           row_max = math.max(row_max, grid[row][i])\n        end\n        for\
    \ i = 1, row do\n            col_max = math.max(col_max, grid[i][col])\n     \
    \   end\n        return math.max(max_fill_helper(row - 1, col, math.min(capacity,\
    \ row_max)),\n                        max_fill_helper(row, col - 1, math.min(capacity,\
    \ col_max)))\n    end\n    return max_fill_helper(row, col, capacity)\nend\nreturn\
    \ max_fill", "    local total = 0\n    for i = 1, #grid do\n        local row\
    \ = grid[i]\n        local r = math.floor(capacity / #row)\n        local max\
    \ = 0\n        for j = 1, #row do\n            if row[j] > max then\n        \
    \        max = row[j]\n            end\n        end\n        if max > r then\n\
    \            total = total + #row * r\n        else\n            total = total\
    \ + #row * max\n        end\n    end\n    return total\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local i = 1\n    local j = 1\n    local num_lowers\
    \ = 0\n    local in_bucket = 0\n    while true do\n        if i == n and j ==\
    \ m then\n            return num_lowers\n        end\n        local f = false\n\
    \        while j < m do\n            if grid[i][j] == 1 then\n               \
    \ f = true\n                break\n            end\n            j = j + 1\n  \
    \      end\n        if f then\n            local bucket_fill = capacity - in_bucket\n\
    \            local well_fill = 0\n            for x = i, n do\n              \
    \  for y = j, m do\n                    if grid[x][y] == 1 then\n            \
    \            well_fill = well_fill + 1\n                    end\n            \
    \    end\n            end\n            local lowers = math.min(bucket_fill, well_fill)\n\
    \            num_lowers = num_lowers + lowers\n            in_bucket = in_bucket\
    \ + lowers\n            if in_bucket == capacity then\n                in_bucket\
    \ = 0\n            end\n        end\n        i = i + 1\n        j = 1\n    end\n\
    end", "    local rows, cols = #grid, #grid[1]\n    local max_cols = {}\n    for\
    \ col = 1, cols do\n        max_cols[col] = 0\n        for row = 1, rows do\n\
    \            if grid[row][col] > 0 then\n                max_cols[col] = row\n\
    \            end\n        end\n    end\n    local max = 0\n    for col = 1, cols\
    \ do\n        local m = 0\n        for col1 = col, cols do\n            m = math.max(m,\
    \ max_cols[col1])\n            if m == capacity then\n                break\n\
    \            end\n        end\n        max = math.max(max, m)\n    end\n    return\
    \ max\nend", "    local max_height = math.huge\n    for i, row in ipairs(grid)\
    \ do\n        local m = 0\n        for j, _ in ipairs(row) do\n            if\
    \ grid[i][j] == 1 then\n                m = m + 1\n            end\n        end\n\
    \        max_height = math.min(max_height, m)\n    end\n    return max_height\n\
    end", "    local rows, cols = #grid, #grid[1]\n    local max_cols = {}\n    for\
    \ col = 1, cols do\n        max_cols[col] = 0\n        for row = 1, rows do\n\
    \            if grid[row][col] > 0 then\n                max_cols[col] = row\n\
    \            end\n        end\n    end\n    local res = 0\n    for _, max_col\
    \ in ipairs(max_cols) do\n        res = res + math.ceil(max_col / capacity)\n\
    \    end\n    return res\nend\nreturn max_fill", "  local m, n = #grid, #grid[1]\n\
    \  local sum = 0\n  for i = 1, m do\n    for j = 1, n do\n      sum = sum + grid[i][j]\n\
    \    end\n  end\n  if sum <= capacity then\n    return 0\n  end\n  local function\
    \ fill(col)\n    local cnt = 0\n    for i = 1, m do\n      if grid[i][col] ==\
    \ 1 then\n        grid[i][col] = 0\n        cnt = cnt + 1\n      end\n    end\n\
    \    return cnt\n  end\n  local function empty(col)\n    local cnt = 0\n    for\
    \ i = m, 1, -1 do\n      if grid[i][col] == 0 then\n        grid[i][col] = 1\n\
    \        cnt = cnt + 1\n      end\n    end\n    return cnt\n  end\n  local cnt\
    \ = 0\n  local left, right = 1, n\n  while left <= right do\n    if left == right\
    \ then\n      cnt = cnt + fill(left)\n      break\n    end\n    cnt = cnt + fill(left)\n\
    \    cnt = cnt + empty(right)\n    left = left + 1\n    right = right - 1\n  end\n\
    \  return cnt\nend\nreturn max_fill", "    local row = #grid\n    local col =\
    \ #grid[1]\n    local level = capacity\n    local count = 0\n    while true do\n\
    \        local i = 1\n        while i <= row do\n            local j = 1\n   \
    \         while j <= col do\n                if grid[i][j] >= level then\n   \
    \                 count = count + 1\n                    grid[i][j] = grid[i][j]\
    \ - capacity\n                end\n                j = j + 1\n            end\n\
    \            i = i + 1\n        end\n        if count == 0 then\n            break\n\
    \        end\n        count = 0\n        level = level - 1\n    end\n    return\
    \ capacity - level\nend", "  local result = 0\n  for i, row in ipairs(grid) do\n\
    \    local j = 1\n    while j <= #row do\n      if row[j] == 1 then\n        local\
    \ jj = j\n        while jj <= #row and row[jj] == 1 do\n          jj = jj + 1\n\
    \        end\n        if jj - j > capacity then\n          j = j + capacity\n\
    \        else\n          result = result + 1\n          j = jj\n        end\n\
    \      else\n        j = j + 1\n      end\n    end\n  end\n  return result\nend\n\
    return max_fill", "    -- f[i][j] the minimum number of buckets to fill j wells\
    \ on the first i rows\n    -- f[i][j] = min(f[i-1][j-k] + 1) = min(f[i-1][j-k]\
    \ + k)\n    -- f[i][j] = min(f[i-1][j-k] + k) if j >= k\n    -- f[i][j] = f[i-1][j]\
    \ otherwise\n    local m, n = #grid, #grid[1]\n    local dp = {}\n    for i =\
    \ 1, m do\n        dp[i] = {}\n        for j = 1, n do\n            dp[i][j] =\
    \ math.huge\n        end\n    end\n    dp[1][0] = 0\n    for i = 1, m do\n   \
    \     for j = 0, n do\n            for k = 0, capacity do\n                if\
    \ j >= k then\n                    dp[i][j] = math.min(dp[i][j], dp[i-1][j-k]\
    \ + k)\n                end\n            end\n        end\n    end\n    local\
    \ min = math.huge\n    for j = 0, n do\n        min = math.min(min, dp[m][j])\n\
    \    end\n    return min\nend", "    -- bucket_capacity: Integer representing\
    \ the capacity of a bucket\n    -- Return: Integer representing the minimum number\
    \ of times buckets need to be lowered to empty the wells\n    local function dfs(grid,\
    \ capacity, row, col, visited)\n        if row < 1 or row > #grid or col < 1 or\
    \ col > #grid[1] or visited[row][col] or grid[row][col] ~= 1 then\n          \
    \  return 0\n        end\n        visited[row][col] = true\n        local sum\
    \ = dfs(grid, capacity, row + 1, col, visited) + dfs(grid, capacity, row - 1,\
    \ col, visited) + dfs(grid, capacity, row, col + 1, visited) + dfs(grid, capacity,\
    \ row, col - 1, visited)\n        if sum > capacity then\n            return capacity\n\
    \        end\n        return sum\n    end\n    local visited = {}\n    for i =\
    \ 1, #grid do\n        visited[i] = {}\n    end\n    local res = 0\n    for i\
    \ = 1, #grid do\n        for j = 1, #grid[1] do\n            if grid[i][j] ==\
    \ 1 and not visited[i][j] then\n                res = res + dfs(grid, capacity,\
    \ i, j, visited)\n            end\n        end\n    end\n    return res\nend",
  "    local len = #grid\n    local col = grid[1]\n    local len_col = #col\n    local\
    \ max_fill = 0\n    for j = 1, len_col do\n        local fill = 0\n        for\
    \ i = 1, len do\n            fill = fill + grid[i][j]\n            if fill > capacity\
    \ then\n                fill = fill - capacity\n            else\n           \
    \     fill = 0\n            end\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return max_fill\nend", "    local m, n = #grid, #grid[1]\n\
    \    local visited = {}\n    local function dfs(i, j)\n        if i < 1 or i >\
    \ m or j < 1 or j > n or grid[i][j] == 0 or visited[i][j] then\n            return\
    \ 0\n        end\n        visited[i][j] = true\n        local fill = 0\n     \
    \   fill = fill + dfs(i + 1, j)\n        fill = fill + dfs(i - 1, j)\n       \
    \ fill = fill + dfs(i, j + 1)\n        fill = fill + dfs(i, j - 1)\n        return\
    \ math.min(fill, capacity)\n    end\n    local sum = 0\n    for i = 1, m do\n\
    \        visited[i] = {}\n    end\n    for i = 1, m do\n        for j = 1, n do\n\
    \            if grid[i][j] == 1 and not visited[i][j] then\n                sum\
    \ = sum + dfs(i, j)\n            end\n        end\n    end\n    return sum\nend\n\
    return {\n    max_fill = max_fill\n}", "  local result = 0\n  for _, row in ipairs(grid)\
    \ do\n    local amount = 0\n    for _, unit in ipairs(row) do\n      amount =\
    \ amount + unit\n      if amount == capacity then\n        result = result + 1\n\
    \        amount = 0\n      end\n    end\n    if amount > 0 then\n      result\
    \ = result + 1\n    end\n  end\n  return result\nend", "    local n, m = #grid,\
    \ #grid[1]\n    local ans = 0\n    local function fill(row, col)\n        if row\
    \ == n then return end\n        local max_col, max_col_value = 1, grid[row][1]\n\
    \        for j = 2, m do\n            if grid[row][j] > max_col_value then\n \
    \               max_col, max_col_value = j, grid[row][j]\n            end\n  \
    \      end\n        if row == 0 then\n            for j = 1, m do\n          \
    \      ans = ans + capacity - grid[row][j]\n                grid[row][j] = capacity\n\
    \            end\n        else\n            if max_col_value == capacity then\n\
    \                fill(row + 1, max_col)\n            else\n                local\
    \ need = capacity - max_col_value\n                ans = ans + need\n        \
    \        local used = 0\n                for j = 1, m do\n                   \
    \ local value = min(grid[row - 1][j], need - used)\n                    grid[row\
    \ - 1][j] = grid[row - 1][j] - value\n                    grid[row][j] = grid[row][j]\
    \ + value\n                    used = used + value\n                end\n    \
    \            fill(row + 1, max_col)\n            end\n        end\n    end\n \
    \   fill(0, 0)\n    return ans\nend\nreturn max_fill", "    local m, n = #grid,\
    \ #grid[1]\n    local visited = {}\n    local function dfs(i, j)\n        if i\
    \ > m or j > n or grid[i][j] == 0 or visited[i][j] then\n            return\n\
    \        end\n        visited[i][j] = true\n        if i == m and j == n then\n\
    \            return capacity\n        end\n        local mf = 0\n        local\
    \ mf1 = dfs(i + 1, j)\n        if mf1 then\n            mf = mf1\n        end\n\
    \        local mf2 = dfs(i, j + 1)\n        if mf2 then\n            mf = math.max(mf,\
    \ mf2)\n        end\n        if mf then\n            return math.min(mf, capacity\
    \ - grid[i][j])\n        end\n    end\n    local count = 0\n    for i = 1, m do\n\
    \        visited[i] = {}\n    end\n    for i = 1, m do\n        for j = 1, n do\n\
    \            if not visited[i][j] then\n                local delta = dfs(i, j)\n\
    \                if delta then\n                    count = count + delta\n  \
    \              end\n            end\n        end\n    end\n    return count\n\
    end\nreturn max_fill", "    local times = 0\n    local rows = #grid\n    local\
    \ cols = #grid[1]\n    local top = 1\n    local bottom = rows\n    local left\
    \ = 1\n    local right = cols\n    while top <= bottom and left <= right do\n\
    \        local is_top_row_found = false\n        local is_bottom_row_found = false\n\
    \        local is_left_col_found = false\n        local is_right_col_found = false\n\
    \        for i = left, right do\n            if grid[top][i] == 1 then\n     \
    \           is_top_row_found = true\n                break\n            end\n\
    \        end\n        for i = left, right do\n            if grid[bottom][i] ==\
    \ 1 then\n                is_bottom_row_found = true\n                break\n\
    \            end\n        end\n        for i = top, bottom do\n            if\
    \ grid[i][left] == 1 then\n                is_left_col_found = true\n        \
    \        break\n            end\n        end\n        for i = top, bottom do\n\
    \            if grid[i][right] == 1 then\n                is_right_col_found =\
    \ true\n                break\n            end\n        end\n        if not is_top_row_found\
    \ then\n            top = top + 1\n        end\n        if not is_bottom_row_found\
    \ then\n            bottom = bottom - 1\n        end\n        if not is_left_col_found\
    \ then\n            left = left + 1\n        end\n        if not is_right_col_found\
    \ then\n            right = right - 1\n        end\n        if is_top_row_found\
    \ and is_bottom_row_found and is_left_col_found and is_right_col_found then\n\
    \            times = times + 1\n            for i = top, bottom do\n         \
    \       for j = left, right do\n                    if grid[i][j] == 1 then\n\
    \                        grid[i][j] = 0\n                    end\n           \
    \     end\n            end\n        end\n    end\n    return times\nend", "  \
    \  -- TODO\nend", "  local max_level = 0\n  for _, row in ipairs(grid) do\n  \
    \  local n = math.min(capacity, #row)\n    local max_filled = math.max(table.unpack(row,\
    \ 1, n))\n    if max_filled > max_level then\n      max_level = max_filled\n \
    \   end\n  end\n  return max_level\nend", "    local s = {}\n    for i = 1, #grid\
    \ do\n        local r = {}\n        for j = 1, #grid[i] do\n            r[j] =\
    \ grid[i][j] * capacity\n        end\n        s[i] = r\n    end\n    for i = 1,\
    \ #grid do\n        for j = 1, #grid[i] do\n            if i > 1 then\n      \
    \          s[i][j] = math.max(s[i][j], s[i - 1][j])\n            end\n       \
    \     if j > 1 then\n                s[i][j] = math.max(s[i][j], s[i][j - 1])\n\
    \            end\n        end\n    end\n    return s[#grid][#grid[#grid]]\nend",
  "    local width = #grid[1]\n    local max_heights = {}\n    for i = 1, width do\n\
    \        max_heights[i] = 0\n    end\n    for _, row in ipairs(grid) do\n    \
    \    for i, cell in ipairs(row) do\n            if cell == 1 then\n          \
    \      max_heights[i] = max_heights[i] + 1\n            end\n        end\n   \
    \ end\n    local bucket_heights = {}\n    for i = 1, width do\n        bucket_heights[i]\
    \ = 0\n    end\n    local count = 0\n    for _, row in ipairs(grid) do\n     \
    \   for i, cell in ipairs(row) do\n            if cell == 1 then\n           \
    \     local diff = max_heights[i] - bucket_heights[i]\n                if diff\
    \ > 0 then\n                    local use = math.min(diff, capacity)\n       \
    \             bucket_heights[i] = bucket_heights[i] + use\n                  \
    \  count = count + use\n                end\n            end\n        end\n  \
    \  end\n    return count\nend\nreturn max_fill", "    local n, m = #grid, #grid[1]\n\
    \    local result = 0\n    for j = 1, m do\n        for i = 1, n do\n        \
    \    local v = grid[i][j]\n            if v > 0 then\n                result =\
    \ result + 1\n                grid[i][j] = v - capacity\n                if grid[i][j]\
    \ < 0 then\n                    grid[i][j] = 0\n                end\n        \
    \    end\n        end\n    end\n    return result\nend", "    local total = 0\n\
    \    for _, row in ipairs(grid) do\n        local max_current = 0\n        for\
    \ _, well in ipairs(row) do\n            if well == 1 then\n                max_current\
    \ = max_current + 1\n            else\n                if max_current > 0 then\n\
    \                    total = total + (math.floor(max_current / capacity) + 1)\n\
    \                    max_current = 0\n                end\n            end\n \
    \       end\n        if max_current > 0 then\n            total = total + (math.floor(max_current\
    \ / capacity) + 1)\n        end\n    end\n    return total\nend\nreturn max_fill",
  "    local m, n = #grid, #grid[1]\n    local s = {}\n    for i = 1, m do\n     \
    \   for j = 1, n do\n            if grid[i][j] == 1 then\n                s[#s\
    \ + 1] = j\n            end\n        end\n    end\n    if #s == 0 then\n     \
    \   return 0\n    end\n    table.sort(s)\n    local i, j = 1, 1\n    local res\
    \ = 0\n    while i <= #s do\n        while j <= #s and s[j] - s[i] + 1 <= capacity\
    \ do\n            j = j + 1\n        end\n        res = res + 1\n        i = j\n\
    \    end\n    return res\nend", "    local len = #grid\n    local function run(i,\
    \ j)\n        local r = (i > 0 and capacity or 0) + j\n        if i == len then\n\
    \            return r\n        end\n        return math.max(run(i + 1, r - grid[i\
    \ + 1][j + 1]), run(i + 1, r - grid[i + 1][j + 2]))\n    end\n    return run(0,\
    \ 0)\nend", "    local function fill(src_row, dest_row)\n        local water =\
    \ 0\n        for i = 1, #src_row do\n            if src_row[i] == 1 then\n   \
    \             water = water + 1\n            end\n            if dest_row[i] ==\
    \ 1 then\n                water = water - 1\n            end\n            if water\
    \ > capacity then\n                return false\n            end\n        end\n\
    \        return true\n    end\n    local function fill_all(grid, capacity)\n \
    \       local function fill_one(grid, capacity, r, c)\n            if grid[r][c]\
    \ == 1 then\n                return 0\n            end\n            local cur\
    \ = 0\n            for i = 1, r do\n                if grid[i][c] == 1 then\n\
    \                    cur = cur + 1\n                end\n            end\n   \
    \         if cur > capacity then\n                return false\n            end\n\
    \            grid[r][c] = 1\n            return true\n        end\n        local\
    \ max_r = #grid\n        local max_c = #grid[1]\n        for r = 1, max_r do\n\
    \            for c = 1, max_c do\n                if not fill_one(grid, capacity,\
    \ r, c) then\n                    return false\n                end\n        \
    \    end\n        end\n        return true\n    end\n    local max_c = #grid[1]\n\
    \    local max_r = #grid\n    local res = 0\n    while max_r > 0 do\n        if\
    \ not fill(grid[max_r], grid[max_r - 1]) then\n            if not fill_all(grid,\
    \ capacity) then\n                return -1\n            end\n            res\
    \ = res + 1\n        end\n        max_r = max_r - 1\n    end\n    return res\n\
    end\nreturn max_fill", "    local m, n = #grid, #grid[1]\n    local tot = 0\n\
    \    for i = 1, m do\n        local l = 1\n        while l <= n and grid[i][l]\
    \ == 0 do\n            l = l + 1\n        end\n        local r = n\n        while\
    \ r >= 1 and grid[i][r] == 0 do\n            r = r - 1\n        end\n        for\
    \ j = l, r do\n            tot = tot + grid[i][j]\n        end\n    end\n    return\
    \ math.ceil(tot / capacity)\nend\nreturn max_fill", "  local m, n = #grid, #grid[1]\n\
    \  local height = {}\n  for i = 1, m do\n    for j = 1, n do\n      height[j]\
    \ = (height[j] or 0) + grid[i][j]\n    end\n  end\n  local function get_next_level(grid,\
    \ i, j)\n    if grid[i][j] > 0 then\n      return i, j\n    end\n    local x,\
    \ y = i, j\n    while x < m and grid[x + 1][y] == 0 do\n      x = x + 1\n    end\n\
    \    while y < n and grid[x][y + 1] == 0 do\n      y = y + 1\n    end\n    return\
    \ x, y\n  end\n  local h = 0\n  local x, y = 1, 1\n  while true do\n    local\
    \ x1, y1 = get_next_level(grid, x, y)\n    if x1 == nil then\n      break\n  \
    \  end\n    if h > 0 then\n      h = h - 1\n    end\n    h = math.max(h, height[y1])\n\
    \    x, y = x1, y1\n  end\n  return h\nend", "  local row_count = #grid\n  local\
    \ col_count = #grid[1]\n  local row_maxes = new_array(row_count, 0)\n  local col_maxes\
    \ = new_array(col_count, 0)\n  for i = 1, row_count do\n    for j = 1, col_count\
    \ do\n      if grid[i][j] == 1 then\n        row_maxes[i] = row_maxes[i] + 1\n\
    \        col_maxes[j] = col_maxes[j] + 1\n      end\n    end\n  end\n  local function\
    \ val(a, i)\n    return a[i] or 0\n  end\n  local function sort_key(a, i)\n  \
    \  return val(a, i)\n  end\n  local row_sorted_is = sort_indices(row_maxes, sort_key)\n\
    \  local col_sorted_is = sort_indices(col_maxes, sort_key)\n  local rsi_i = 1\n\
    \  local csi_i = 1\n  local row_max_buckets = math.ceil(row_maxes[row_sorted_is[rsi_i]]\
    \ / capacity)\n  local col_max_buckets = math.ceil(col_maxes[col_sorted_is[csi_i]]\
    \ / capacity)\n  local ans = math.max(row_max_buckets, col_max_buckets)\n  while\
    \ rsi_i <= row_count and csi_i <= col_count do\n    if row_maxes[row_sorted_is[rsi_i]]\
    \ <= col_maxes[col_sorted_is[csi_i]] then\n      rsi_i = rsi_i + 1\n      row_max_buckets\
    \ = math.ceil(row_maxes[row_sorted_is[rsi_i]] / capacity)\n      ans = ans + col_max_buckets\n\
    \    else\n      csi_i = csi_i + 1\n      col_max_buckets = math.ceil(col_maxes[col_sorted_is[csi_i]]\
    \ / capacity)", "    local n, m = #grid, #grid[1]\n    local visited = {[0] =\
    \ {[0] = true}}\n    local function dfs(i, j, k)\n        if i < 0 or i >= n or\
    \ j < 0 or j >= m or visited[i] and visited[i][j] then\n            return 0\n\
    \        end\n        visited[i] = visited[i] or {}\n        visited[i][j] = true\n\
    \        return dfs(i - 1, j, k) + dfs(i + 1, j, k) + dfs(i, j - 1, k) + dfs(i,\
    \ j + 1, k) + grid[i][j]\n    end\n    local function fill(i, j, k)\n        if\
    \ k == 0 then\n            return 0\n        end\n        if i < 0 or i >= n or\
    \ j < 0 or j >= m or visited[i] and visited[i][j] then\n            return 1\n\
    \        end\n        visited[i] = visited[i] or {}\n        visited[i][j] = true\n\
    \        return fill(i - 1, j, k - 1) + fill(i + 1, j, k - 1) + fill(i, j - 1,\
    \ k - 1) + fill(i, j + 1, k - 1)\n    end\n    local function iter(i, j, k)\n\
    \        if i < 0 or i >= n or j < 0 or j >= m or visited[i] and visited[i][j]\
    \ then\n            return k\n        end\n        visited[i] = visited[i] or\
    \ {}\n        visited[i][j] = true\n        return math.max(iter(i - 1, j, k),\
    \ iter(i + 1, j, k), iter(i, j - 1, k), iter(i, j + 1, k), dfs(i, j, k) + fill(i,\
    \ j, k))\n    end\n    local res = 0\n    for i = 0, n - 1 do\n        for j =\
    \ 0, m - 1 do\n            if grid[i][j] == 1 then\n                res = res\
    \ + 1\n            end\n        end\n    end\n    local function clear", "   \
    \ local result = 0\n    local row_count = #grid\n    for row = 1, row_count do\n\
    \        local current_row = grid[row]\n        for col = 1, #current_row do\n\
    \            local current_cell = current_row[col]\n            if current_cell\
    \ == 1 then\n                current_row[col] = 0\n                result = result\
    \ + 1\n                if capacity > 1 then\n                    if col > 1 and\
    \ current_row[col - 1] == 1 then\n                        current_row[col - 1]\
    \ = 0\n                        capacity = capacity - 1\n                    end\n\
    \                    if col < #current_row and current_row[col + 1] == 1 then\n\
    \                        current_row[col + 1] = 0\n                        capacity\
    \ = capacity - 1\n                    end\n                    for i = row + 1,\
    \ row + capacity - 1 do\n                        if i <= row_count then\n    \
    \                        local next_row = grid[i]\n                          \
    \  if next_row[col] == 1 then\n                                next_row[col] =\
    \ 0\n                                capacity = capacity - 1\n               \
    \             end\n                        end\n                    end\n    \
    \            end\n            end\n        end\n    end\n    return result\nend\n\
    return max_fill", "    local m, n = #grid, #grid[1]\n    local q = {{0, 0, capacity}}\n\
    \    local t = 0\n    local visited = {}\n    while #q > 0 do\n        local size\
    \ = #q\n        while size > 0 do\n            local u = table.remove(q, 1)\n\
    \            size = size - 1\n            local row, col, water = u[1], u[2],\
    \ u[3]\n            if row >= 0 and row < m and col >= 0 and col < n and grid[row][col]\
    \ > 0 and not visited[row * n + col] then\n                if grid[row][col] <=\
    \ water then\n                    water = water - grid[row][col]\n           \
    \         grid[row][col] = 0\n                else\n                    grid[row][col]\
    \ = grid[row][col] - water\n                    water = 0\n                end\n\
    \                visited[row * n + col] = true\n                if water > 0 then\n\
    \                    table.insert(q, {row, col, water})\n                end\n\
    \            end\n        end\n        t = t + 1\n    end\n    return t - 1\n\
    end\nreturn max_fill", "    local m, n = #grid, #grid[1]\n    local function max_fill_helper(row,\
    \ col)\n        if row < 1 or row > m or col < 1 or col > n then return 0 end\n\
    \        local diff = capacity - grid[row][col]\n        if diff < 0 then return\
    \ 0 end\n        grid[row][col] = capacity\n        return diff + max_fill_helper(row\
    \ + 1, col) + max_fill_helper(row - 1, col) + max_fill_helper(row, col + 1) +\
    \ max_fill_helper(row, col - 1)\n    end\n    local function update_grid(row,\
    \ col)\n        if row < 1 or row > m or col < 1 or col > n then return end\n\
    \        if grid[row][col] > 0 then return end\n        grid[row][col] = 1\n \
    \       for i = -1, 1 do\n            for j = -1, 1 do\n                update_grid(row\
    \ + i, col + j)\n            end\n        end\n    end\n    local function fill_water(row,\
    \ col)\n        local count = 0\n        for i = 1, m do\n            for j =\
    \ 1, n do\n                if grid[i][j] == 0 then\n                    count\
    \ = count + max_fill_helper(i, j)\n                end\n            end\n    \
    \    end\n        return count\n    end\n    local function fill_soil(row, col)\n\
    \        local count = 0\n        for i = 1, m do\n            for j = 1, n do\n\
    \                if grid[i][j] < capacity then\n                    count = count\
    \ + max_fill_helper(i, j)\n                end\n            end\n        end\n\
    \        return count\n    end\n    local count = 0\n    for i = 1, m do\n   \
    \     for j = 1, n do\n            if grid[i][j] == 0 then\n                update_grid(i,\
    \ j)\n                count = count + fill_water(i, j)\n                count\
    \ = count + fill_soil(i, j)\n            end\n        end\n    end\n    return\
    \ count\nend\nreturn max_fill", "    -- print(grid, capacity)\n    local max =\
    \ 0\n    for _, row in ipairs(grid) do\n        for _, c in ipairs(row) do\n \
    \           max = math.max(max, c)\n        end\n    end\n    if max == 0 then\n\
    \        return 0\n    end\n    local t = {}\n    local function get(x, y)\n \
    \       t[x] = t[x] or {}\n        return t[x][y] or 0\n    end\n    local function\
    \ set(x, y, v)\n        t[x] = t[x] or {}\n        t[x][y] = v\n    end\n    local\
    \ n = #grid\n    local m = #grid[1]\n    local function fill(x, y, v)\n      \
    \  -- print(x, y, v)\n        if get(x, y) < v then\n            set(x, y, v)\n\
    \            if x > 1 then\n                fill(x - 1, y, v)\n            end\n\
    \            if x < n then\n                fill(x + 1, y, v)\n            end\n\
    \            if y > 1 then\n                fill(x, y - 1, v)\n            end\n\
    \            if y < m then\n                fill(x, y + 1, v)\n            end\n\
    \        end\n    end\n    local i = 1\n    while true do\n        local j = 1\n\
    \        while j <= m do\n            if grid[i][j] ~= 0 then\n              \
    \  fill(i, j, grid[i][j])\n                break\n            end\n          \
    \  j = j + 1\n        end\n        if j > m then\n            break\n        end\n\
    \        i = i + 1\n    end\n    local function subtract(v)\n        if v >= capacity\
    \ then\n            return capacity\n        else\n            return v\n    \
    \    end\n    end\n    local total = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] ~= 0 then\n                local d = get(i,\
    \ j) - grid[i][j]\n                -- print(i, j, grid[i][j], d)\n           \
    \     total = total + subtract(", "  for row = 1, #grid do\n    for col = 1, #grid[row]\
    \ do\n      grid[row][col] = capacity - grid[row][col]\n    end\n  end\n  return\
    \ grid\nend", "    local n, m = #grid, #grid[1]\n    local queues = {}\n    for\
    \ i = 1, n do\n        queues[i] = {}; queues[i].n = 0\n    end\n    local function\
    \ enqueue(i, j)\n        local queue = queues[i]\n        queue.n = queue.n +\
    \ 1\n        queue[queue.n] = j\n    end\n    local function dequeue(i)\n    \
    \    local queue = queues[i]\n        local j = queue[1]\n        for k = 1, queue.n-1\
    \ do\n            queue[k] = queue[k+1]\n        end\n        queue.n = queue.n\
    \ - 1\n        return j\n    end\n    local function count_next(grid, i, j)\n\
    \        local c = 0\n        if i < n and grid[i+1][j] == 1 then\n          \
    \  c = c + 1\n        end\n        if j < m and grid[i][j+1] == 1 then\n     \
    \       c = c + 1\n        end\n        return c\n    end\n    local function\
    \ count_previous(grid, i, j)\n        local c = 0\n        if i > 1 and grid[i-1][j]\
    \ == 1 then\n            c = c + 1\n        end\n        if j > 1 and grid[i][j-1]\
    \ == 1 then\n            c = c + 1\n        end\n        return c\n    end\n \
    \   local function visit(grid, i, j)\n        local count = count_next(grid, i,\
    \ j)\n        if count == 2 then\n            enqueue(i, j)\n        elseif count\
    \ == 1 then\n            grid[i][j] = 2\n        end\n    end\n    local function\
    \ walk(grid, i, j)\n        if grid[i][j] == 1 then\n            visit(grid, i,\
    \ j)\n        end\n    end\n    local function find_next(grid, i, j)\n       \
    \ if i < n and grid[i+1][j] == 1 then\n            return i+1, j\n        elseif\
    \ j < m and grid[i][j+1] == 1 then\n            return i, j+1\n        end\n",
  "    local n = #grid\n    local m = #grid[1]\n    local used = { }\n    for _ =\
    \ 1, n do used[#used + 1] = 0 end\n    local function dfs(from, to)\n        local\
    \ i = 0\n        while i < m do\n            if grid[from][i] == 1 then break\
    \ end\n            i = i + 1\n        end\n        if i == m then return true\
    \ end\n        while i < m do\n            if grid[from][i] == 0 then break end\n\
    \            used[from] = used[from] + 1\n            if used[from] == capacity\
    \ then\n                return false\n            end\n            i = i + 1\n\
    \        end\n        if dfs(to, from) then\n            for j = i, m - 1 do\n\
    \                if grid[from][j] == 1 then\n                    used[from] =\
    \ used[from] + 1\n                    if used[from] == capacity then\n       \
    \                 return false\n                    end\n                end\n\
    \            end\n            return true\n        end\n        return false\n\
    \    end\n    local ans = 0\n    while true do\n        if dfs(1, 2) then\n  \
    \          local i = 1\n            while i <= n do\n                if used[i]\
    \ == 0 then\n                    break\n                end\n                i\
    \ = i + 1\n            end\n            if i > n then\n                break\n\
    \            end\n        end\n        ans = ans + 1\n    end\n    return ans\n\
    end", "  local rows, cols = #grid, #grid[1]\n  local min = math.min\n  local memo\
    \ = {}\n  local function dfs(x, y)\n    local v = memo[x][y]\n    if v ~= nil\
    \ then\n      return v\n    end\n    if y == cols then\n      return 0\n    end\n\
    \    local result = grid[x][y] + dfs(x, y + 1)\n    if x > 1 then\n      result\
    \ = min(result, grid[x][y] + dfs(x - 1, y + 1))\n    end\n    if x < rows then\n\
    \      result = min(result, grid[x][y] + dfs(x + 1, y + 1))\n    end\n    memo[x][y]\
    \ = result\n    return result\n  end\n  for i = 1, rows do\n    memo[i] = {}\n\
    \  end\n  local result = 1 / 0\n  for i = 1, rows do\n    result = min(result,\
    \ dfs(i, 1))\n  end\n  return math.ceil(result / capacity)\nend\nreturn max_fill",
  "    local n = #grid\n    local m = #grid[1]\n    local max_area = capacity * (n\
    \ + m - 1)\n    local function count(i, j, height)\n        local fill = 0\n \
    \       for k = i, i + capacity - 1 do\n            if k < n and height[k] < m\
    \ then\n                fill = fill + m - height[k]\n            end\n       \
    \ end\n        for k = j, j + capacity - 1 do\n            if k < m and grid[i][k]\
    \ == 0 then\n                fill = fill + 1\n            end\n        end\n \
    \       return fill\n    end\n    local function fill(i, j, height)\n        local\
    \ fill = 0\n        for k = i, i + capacity - 1 do\n            if k < n and height[k]\
    \ < m then\n                fill = fill + m - height[k]\n                height[k]\
    \ = m\n            end\n        end\n        for k = j, j + capacity - 1 do\n\
    \            if k < m and grid[i][k] == 0 then\n                fill = fill +\
    \ 1\n                grid[i][k] = 1\n            end\n        end\n        return\
    \ fill\n    end\n    local function fill_bucket(i, j, height)\n        local fill\
    \ = 0\n        for k = i, i + capacity - 1 do\n            if k < n and height[k]\
    \ < m then\n                fill = fill + m - height[k]\n                height[k]\
    \ = m\n            end\n        end\n        for k = j, j + capacity - 1 do\n\
    \            if k < m and grid[i][k] == 0 then\n                fill = fill +\
    \ 1\n                grid[i][k] = 1\n            end\n        end\n        return\
    \ fill\n    end\n    local i, j = 1, 1\n    local fill = 0\n    local height =\
    \ {}\n    for k = 1, n do\n        height[k] = 0\n    end\n    local k = j\n \
    \   for l = 1, n do\n        for ; k < m and grid[l][k] == 0; k = k + 1 do\n \
    \       end\n        height[l] = k\n    end\n    k = i\n    while i <", "    local\
    \ total_capacity = capacity * #grid[1]\n    local max_water = 0\n    for i = 1,\
    \ #grid do\n        local water = 0\n        for j = 1, #grid[1] do\n        \
    \    water = water + grid[i][j]\n        end\n        max_water = math.max(max_water,\
    \ water)\n    end\n    return math.max(0, total_capacity - max_water)\nend", " \
    \   local row = #grid\n    local col = #grid[1]\n    local capacity = capacity\n\
    \    local water = 0\n    for i = 1, row do\n        for j = 1, col do\n     \
    \       if grid[i][j] == 1 then\n                water = water + 1\n         \
    \   end\n        end\n    end\n    return math.ceil(water / capacity)\nend", " \
    \   local n, m = #grid, #grid[1]\n    local dp = {}\n    for i = 1, n do\n   \
    \     dp[i] = {}\n        for j = 1, m do\n            dp[i][j] = -1\n       \
    \ end\n    end\n    local function dfs(i, j)\n        if i == n then\n       \
    \     return 0\n        end\n        if j == m then\n            return dfs(i\
    \ + 1, 1)\n        end\n        if dp[i][j] > -1 then\n            return dp[i][j]\n\
    \        end\n        local a = dfs(i, j + 1)\n        local b = 0\n        if\
    \ grid[i][j] == 1 then\n            b = dfs(i, j + 1) + 1\n        end\n     \
    \   local res = math.min(a, b)\n        if res > capacity then\n            res\
    \ = capacity\n        end\n        dp[i][j] = res\n        return res\n    end\n\
    \    return dfs(1, 1)\nend", "    local n = #grid\n    local min_cols = {}\n \
    \   for i = 1, n do\n        min_cols[i] = capacity\n    end\n    for j = 1, #grid[1]\
    \ do\n        local max_level = 0\n        for i = 1, n do\n            max_level\
    \ = math.max(max_level, grid[i][j])\n        end\n        for i = 1, n do\n  \
    \          min_cols[i] = math.min(min_cols[i], max_level - grid[i][j])\n     \
    \   end\n    end\n    local count = 0\n    for i = 1, n do\n        count = count\
    \ + min_cols[i]\n    end\n    return count\nend\nreturn max_fill", "    local\
    \ max = 0\n    for _, v in ipairs(grid) do\n        local sum = 0\n        for\
    \ i = 1, #v do\n            sum = sum + v[i]\n            if sum > max then\n\
    \                max = sum\n            end\n        end\n    end\n    return\
    \ math.min(max, capacity)\nend", "    local sum = 0\n    for _, r in ipairs(grid)\
    \ do\n        local m = 0\n        for _, c in ipairs(r) do\n            m = math.max(m,\
    \ c)\n        end\n        sum = sum + m\n    end\n    return math.floor(sum /\
    \ capacity)\nend", "    local row = 0\n    for i = 1, #grid do\n        row =\
    \ row + math.ceil(grid[i] / capacity)\n    end\n    return row\nend", "    local\
    \ function helper(i, j, c)\n        if i < 1 or i > #grid or j < 1 or j > #grid[1]\
    \ or grid[i][j] == 0 then return 0 end\n        if grid[i][j] == -1 then return\
    \ c end\n        local f = capacity - grid[i][j]\n        if f <= 0 then return\
    \ c end\n        grid[i][j] = -1\n        return helper(i-1, j, f) + helper(i+1,\
    \ j, f) + helper(i, j-1, f) + helper(i, j+1, f) + f\n    end\n    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        for j = 1, #grid[1] do\n            max_fill\
    \ = math.max(max_fill, helper(i, j, 0))\n        end\n    end\n    return max_fill\n\
    end", "    local bucket_count = 0\n    local water_used = 0\n    local water_left\
    \ = capacity\n    for r = 1, #grid do\n        local row = grid[r]\n        for\
    \ c = 1, #row do\n            local well = row[c]\n            if well == 1 then\n\
    \                if water_left == 0 then\n                    bucket_count = bucket_count\
    \ + 1\n                    water_left = capacity\n                end\n      \
    \          water_left = water_left - 1\n                water_used = water_used\
    \ + 1\n            end\n        end\n    end\n    if water_left > 0 then\n   \
    \     bucket_count = bucket_count + 1\n    end\n    return bucket_count\nend\n\
    return max_fill", "    local level = 0\n    for r = 1, #grid do\n        for c\
    \ = 1, #grid[r] do\n            if grid[r][c] == 1 then\n                grid[r][c]\
    \ = 0\n                level = level + 1\n            end\n        end\n    end\n\
    \    local rounds = (level - 1) // capacity + 1\n    return rounds\nend\nreturn\
    \ max_fill", "    local function fill(wells, capacity)\n        local max = 0\n\
    \        for _, well in ipairs(wells) do\n            max = math.max(max, well)\n\
    \        end\n        if max > capacity then\n            return capacity\n  \
    \      else\n            return max\n        end\n    end\n    local steps = 0\n\
    \    for _, wells in ipairs(grid) do\n        steps = steps + fill(wells, capacity)\n\
    \    end\n    return steps\nend\nreturn max_fill", "    local result = 0\n   \
    \ local row_count = #grid\n    local col_count = #grid[1]\n    local current_capacity\
    \ = capacity\n    local function lower(row, col)\n        if row > row_count then\n\
    \            return\n        end\n        local unit = grid[row][col]\n      \
    \  if current_capacity >= unit then\n            current_capacity = current_capacity\
    \ - unit\n        else\n            local delta = unit - current_capacity\n  \
    \          current_capacity = capacity - delta\n            result = result +\
    \ 1\n        end\n        if col == col_count then\n            lower(row + 1,\
    \ 1)\n        else\n            lower(row, col + 1)\n        end\n    end\n  \
    \  lower(1, 1)\n    return result\nend\nreturn max_fill", "  local m, n = #grid,\
    \ #grid[1]\n  local total = 0\n  for i = 1, m do\n    for j = 1, n do\n      total\
    \ = total + grid[i][j]\n    end\n  end\n  return math.ceil(total / capacity)\n\
    end\nreturn {\n  max_fill = max_fill,\n}", "    local length = #grid\n    local\
    \ max_height = 0\n    for i=1, length do\n        for j=1, #grid[i] do\n     \
    \       max_height = math.max(max_height, grid[i][j])\n        end\n    end\n\
    \    local total_volume = 0\n    for i=1, length do\n        for j=1, #grid[i]\
    \ do\n            total_volume = total_volume + grid[i][j]\n        end\n    end\n\
    \    local function get_volume(index, height)\n        local sum = 0\n       \
    \ for i=1, length do\n            sum = sum + math.min(height, grid[i][index])\n\
    \        end\n        return sum\n    end\n    local lower_bound = 1\n    local\
    \ upper_bound = max_height\n    while lower_bound < upper_bound do\n        local\
    \ middle = math.floor((lower_bound + upper_bound) / 2)\n        local volume =\
    \ get_volume(1, middle)\n        if volume < total_volume then\n            lower_bound\
    \ = middle + 1\n        else\n            upper_bound = middle\n        end\n\
    \    end\n    local height = lower_bound\n    local sum = 0\n    local count =\
    \ 0\n    for i=1, #grid[1] do\n        for j=1, length do\n            local height_\
    \ = math.min(height, grid[j][i])\n            if height_ > 0 then\n          \
    \      sum = sum + height_\n                grid[j][i] = grid[j][i] - height_\n\
    \            end\n        end\n        count = count + math.ceil(sum / capacity)\n\
    \        sum = 0\n    end\n    return count\nend", "  local max_water = 0\n  for\
    \ _, v in ipairs(grid) do\n    local row_water = 0\n    for _, vv in ipairs(v)\
    \ do\n      if vv == 1 then\n        row_water = row_water + 1\n      else\n \
    \       row_water = 0\n      end\n    end\n    max_water = math.max(max_water,\
    \ row_water)\n  end\n  return math.ceil(max_water / capacity)\nend", "    if not\
    \ capacity then\n        capacity = 1\n    end\n    local len = #grid\n    local\
    \ wlen = #grid[1]\n    local max_fill = 0\n    for i = 1, len do\n        for\
    \ j = 1, wlen do\n            if grid[i][j] == 1 then\n                local k\
    \ = i + 1\n                while grid[k] and grid[k][j] == 0 do\n            \
    \        k = k + 1\n                end\n                if k <= len then\n  \
    \                  grid[k][j] = grid[k][j] + 1\n                    max_fill =\
    \ max_fill + 1\n                end\n            end\n        end\n    end\n \
    \   return max_fill\nend", "  local m, n = #grid, #grid[1]\n  local max_fill =\
    \ 0\n  for i = 1, m do\n    local s = 0\n    for j = 1, n do\n      if grid[i][j]\
    \ == 1 then\n        s = s + 1\n      else\n        max_fill = math.max(max_fill,\
    \ s)\n        s = 0\n      end\n    end\n    max_fill = math.max(max_fill, s)\n\
    \  end\n  local h = math.floor(max_fill / capacity)\n  if h * capacity < max_fill\
    \ then\n    h = h + 1\n  end\n  return h\nend", "    local max_level = 0\n   \
    \ for _, row in ipairs(grid) do\n        local level = 0\n        for _, well\
    \ in ipairs(row) do\n            if well == 1 then\n                level = level\
    \ + 1\n            else\n                break\n            end\n        end\n\
    \        max_level = math.max(max_level, level)\n    end\n    local result = math.ceil(max_level\
    \ / capacity)\n    return result\nend", "    local max_fill_so_far = 0\n    local\
    \ fill_count = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n  \
    \          if grid[i][j] == 1 then\n                max_fill_so_far = max_fill_so_far\
    \ + 1\n            else\n                max_fill_so_far = 0\n            end\n\
    \            if max_fill_so_far == capacity then\n                fill_count =\
    \ fill_count + 1\n                max_fill_so_far = 0\n            end\n     \
    \   end\n        max_fill_so_far = 0\n    end\n    return fill_count\nend", " \
    \   local m, n = #grid, #grid[1]\n    local grid2 = {}\n    for i = 1, m do\n\
    \        grid2[i] = {}\n        for j = 1, n do\n            grid2[i][j] = capacity\n\
    \        end\n    end\n    local ans = 0\n    for i = 1, m do\n        for j =\
    \ 1, n do\n            if grid[i][j] == 1 then\n                ans = ans + 1\n\
    \                grid2[i][j] = 0\n                local q = {{i, j}}\n       \
    \         local visited = {}\n                while #q > 0 do\n              \
    \      local q1 = {}\n                    for k = 1, #q do\n                 \
    \       local x, y = q[k][1], q[k][2]\n                        for dx = -1, 1\
    \ do\n                            for dy = -1, 1 do\n                        \
    \        if dx ~= 0 or dy ~= 0 then\n                                    local\
    \ x1, y1 = x + dx, y + dy\n                                    if x1 >= 1 and\
    \ x1 <= m and y1 >= 1 and y1 <= n then\n                                     \
    \   if grid2[x1][y1] > 0 and not visited[x1 * n + y1] then\n                 \
    \                           visited[x1 * n + y1] = true\n                    \
    \                        table.insert(q1, {x1, y1})\n                        \
    \                end\n                                    end\n              \
    \                  end\n                            end\n                    \
    \    end\n                    end\n                    local max_fill = 0\n  \
    \                  for k = 1, #q1 do\n                        local x, y = q1[k][1],\
    \ q1[k][2]\n                        if grid2[x][y] > max_fill then\n         \
    \                   max_fill = grid2[x][y]\n                        end\n    \
    \                end\n                    if max_fill > 0 then\n             \
    \           ans = ans + 1\n                        for k = 1, #q1 do\n       \
    \                     local x, y = q1[k][1], q1[k][2]\n                      \
    \      grid2[x][y] = grid2[x][y] - max_fill\n                        end\n   \
    \                 end\n                    q = q1\n                end\n     \
    \       end\n        end\n    end\n   ", "    local row_maxes = {}\n    for row\
    \ = 1, #grid do\n        local r = grid[row]\n        local count = 0\n      \
    \  for j = 1, #r do\n            count = count + r[j]\n        end\n        table.insert(row_maxes,\
    \ count)\n    end\n    local min_max = math.min(unpack(row_maxes))\n    local\
    \ count = 0\n    for i = 1, #row_maxes do\n        count = count + (row_maxes[i]\
    \ - min_max)\n    end\n    return count\nend", "    local _, m = #grid, #grid[1]\n\
    \    local max_column = vector.new(m, capacity)\n    for i=1,_ do\n        for\
    \ j=1,m do\n            if grid[i][j] == 1 then\n                if max_column[j]\
    \ == 0 then\n                    return -1\n                end\n            \
    \    max_column[j] = max_column[j] - 1\n            end\n        end\n    end\n\
    \    local res = 0\n    for i=1,_ do\n        for j=1,m do\n            if grid[i][j]\
    \ == 1 then\n                res = res + 1\n            end\n        end\n   \
    \ end\n    return res\nend", "  local nrows, ncols = #grid, #grid[1]\n  local\
    \ min_height = math.huge\n  for i = 1, nrows do\n    for j = 1, ncols do\n   \
    \   if grid[i][j] == 1 then\n        min_height = math.min(min_height, i)\n  \
    \    end\n    end\n  end\n  local row_total = 0\n  for i = 1, nrows do\n    local\
    \ sum = 0\n    for j = 1, ncols do\n      sum = sum + grid[i][j]\n    end\n  \
    \  row_total = row_total + math.ceil(sum / capacity)\n  end\n  return math.min(row_total,\
    \ math.ceil(ncols / capacity) * (nrows - min_height + 1))\nend", "    -- fill\
    \ in 1s\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n           \
    \ if grid[i][j] == 1 then\n                for k = i, capacity + i - 1 do\n  \
    \                  if k > #grid then\n                        break\n        \
    \            end\n                    grid[k][j] = 1\n                end\n  \
    \          end\n        end\n    end\n    -- count the number of 1s\n    local\
    \ fill = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n        \
    \    if grid[i][j] == 1 then\n                fill = fill + 1\n            end\n\
    \        end\n    end\n    return fill\nend", "    local sum = 0\n    for _, row\
    \ in ipairs(grid) do\n        for _, item in ipairs(row) do\n            sum =\
    \ sum + item\n        end\n    end\n    local times = math.ceil(sum / capacity)\n\
    \    return times\nend", "    local nrows = #grid\n    local ncols = #grid[1]\n\
    \    local nwells = nrows * ncols\n    local row_avg = Array.new(nrows, 0)\n \
    \   for i = 1, nrows do\n        local avg = 0\n        for j = 1, ncols do\n\
    \            avg = avg + grid[i][j]\n        end\n        row_avg[i] = avg / ncols\n\
    \    end\n    local row_empty = 0\n    local row_full = 0\n    for i = 1, nrows\
    \ do\n        if row_avg[i] == 0 then\n            row_empty = row_empty + 1\n\
    \        elseif row_avg[i] == 1 then\n            row_full = row_full + 1\n  \
    \      end\n    end\n    if row_empty == nrows then\n        return 0\n    end\n\
    \    local avg = row_full / (nrows - row_empty)\n    local nfull = Array.new(nrows,\
    \ 0)\n    for i = 1, nrows do\n        if row_avg[i] == 1 then\n            nfull[i]\
    \ = ncols\n        else\n            nfull[i] = math.floor(avg * ncols)\n    \
    \    end\n    end\n    local refill = nfull:clone()\n    local nrefill = 0\n \
    \   for i = 1, nrows do\n        if row_avg[i] == 0 then\n            for j =\
    \ 1, ncols do\n                if grid[i][j] == 1 then\n                    nrefill\
    \ = nrefill + 1\n                    if nfull[i] < ncols then\n              \
    \          nfull[i] = nfull[i] + 1\n                    else\n               \
    \         nfull[i + 1] = nfull[i + 1] + 1\n                    end\n         \
    \       end\n            end\n        end\n    end\n    while true do\n      \
    \  local nrefill_new = 0\n        local nfull_new = nfull:clone()\n        for\
    \ i = 1, nrows do\n            if row_avg[i] == 0 then\n                local\
    \ n = math.min(refill[i], capacity)\n               ", "    local row, col = #grid,\
    \ #grid[1]\n    local l, r = col + 1, col + 1\n    local count = 0\n    for i\
    \ = 1, row do\n        for j = 1, col do\n            if grid[i][j] > 0 then\n\
    \                count = count + 1\n                l = math.min(l, j)\n     \
    \           r = math.max(r, j)\n            end\n        end\n    end\n    return\
    \ math.max(0, count - capacity * (r - l + 1))\nend\nreturn max_fill", "    --\
    \ max fill approach:\n    -- for each column, max fill the wells\n    -- for each\
    \ row, max fill the wells\n    -- this will result in the buckets emptying all\
    \ of the wells\n    -- the total number of times that the buckets need to be lowered\
    \ is the sum of the above two operations\n    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local row_capacity = capacity // cols\n    local col_capacity\
    \ = capacity // rows\n    local result = 0\n    for i = 1, rows do\n        for\
    \ j = 1, cols do\n            if grid[i][j] > 0 then\n                if row_capacity\
    \ > 0 then\n                    result = result + 1\n                    row_capacity\
    \ = row_capacity - 1\n                else\n                    row_capacity =\
    \ capacity // cols\n                    result = result + 1\n                end\n\
    \            end\n        end\n    end\n    for j = 1, cols do\n        for i\
    \ = 1, rows do\n            if grid[i][j] > 0 then\n                if col_capacity\
    \ > 0 then\n                    result = result + 1\n                    col_capacity\
    \ = col_capacity - 1\n                else\n                    col_capacity =\
    \ capacity // rows\n                    result = result + 1\n                end\n\
    \            end\n        end\n    end\n    return result\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local result = 0\n    local max_row = 0\n\
    \    local max_col = 0\n    for i = 1, n do\n        for j = 1, m do\n       \
    \     local x = grid[i][j]\n            if x == 1 then\n                max_row\
    \ = math.max(max_row, i)\n                max_col = math.max(max_col, j)\n   \
    \         end\n        end\n    end\n    local height = math.min(max_row, max_col)\n\
    \    local width = math.max(max_row, max_col)\n    if height < width then\n  \
    \      local tmp = width\n        width = height\n        height = tmp\n    end\n\
    \    local work = capacity - width + 1\n    local result = height * work\n   \
    \ return result\nend\nreturn max_fill", "    local ret = 0\n    for _, v in ipairs(grid)\
    \ do\n        local s, r = 0, 0\n        for _, u in ipairs(v) do\n          \
    \  if u == 1 then\n                s = s + 1\n            else\n             \
    \   r = math.max(r, s)\n                s = 0\n            end\n        end\n\
    \        r = math.max(r, s)\n        ret = ret + math.ceil(r / capacity)\n   \
    \ end\n    return ret\nend\nreturn max_fill", "  local m, n = #grid, #grid[1]\n\
    \  local total = 0\n  for i = 1, m do\n    for j = 1, n do\n      if grid[i][j]\
    \ == 1 then\n        grid[i][j] = 0\n        total = total + 1\n      end\n  \
    \  end\n  end\n  local fill_rate = total / (m * n)\n  if fill_rate == 0 then\n\
    \    return 0\n  end\n  if capacity < fill_rate then\n    return -1\n  end\n \
    \ return capacity / fill_rate - 1\nend", "    local max_per_row = {}\n    for\
    \ i, row in ipairs(grid) do\n        local max = 0\n        for j, val in ipairs(row)\
    \ do\n            if val == 1 then\n                max = max + 1\n          \
    \  end\n        end\n        max_per_row[i] = max\n    end\n    return math.max(unpack(max_per_row))\
    \ * capacity\nend", "    local max_row, max_col = 0, 0\n    for _, row in ipairs(grid)\
    \ do\n        max_row = math.max(max_row, row)\n        max_col = math.max(max_col,\
    \ row[#row])\n    end\n    if capacity == 1 then\n        return max_row * #grid\
    \ + max_col * #row\n    end\n    local sum = 0\n    for _, row in ipairs(grid)\
    \ do\n        sum = sum + math.ceil(row / capacity)\n    end\n    return sum\n\
    end", "    local n, m = #grid, #grid[1]\n    local result = 0\n    local function\
    \ get_water(grid, row, col)\n        local total = 0\n        while row <= n and\
    \ grid[row][col] == 1 do\n            total = total + 1\n            grid[row][col]\
    \ = 2\n            row = row + 1\n        end\n        return total\n    end\n\
    \    for row = 1, n do\n        for col = 1, m do\n            if grid[row][col]\
    \ == 1 then\n                local water = get_water(grid, row, col)\n       \
    \         local times = math.ceil(water / capacity)\n                result =\
    \ result + times\n            end\n        end\n    end\n    return result\nend\n\
    return max_fill", "  local rows = #grid\n  local cols = #grid[1]\n  local buckets\
    \ = 0\n  -- starting from the bottom row, fill buckets with water\n  for row =\
    \ rows, 1, -1 do\n    local extracted = 0\n    -- examine a single row, extracting\
    \ water as possible\n    for col = 1, cols do\n      if grid[row][col] == 1 then\n\
    \        -- we need to extract water\n        local amount = 1 - extracted\n \
    \       -- make sure we don't extract too much water\n        amount = math.min(amount,\
    \ capacity - buckets)\n        extracted = extracted + amount\n        buckets\
    \ = buckets + amount\n      end\n    end\n    -- if buckets are full, dump them\n\
    \    if buckets == capacity then\n      buckets = 0\n    end\n  end\n  return\
    \ buckets\nend", "    local n, r = #grid, 0\n    for i=1, n do\n        local\
    \ sum = 0\n        for j=1, n do\n            sum = sum + grid[i][j]\n       \
    \     if sum > capacity then\n                r = r + sum - capacity\n       \
    \         sum = capacity\n            end\n        end\n        r = r + sum\n\
    \    end\n    return r\nend", "    local max = 0\n    for i = 1, #grid do\n  \
    \      for j = 1, #grid[i] do\n            if grid[i][j] > max then\n        \
    \        max = grid[i][j]\n            end\n        end\n    end\n    if max ==\
    \ 0 then\n        return 0\n    end\n    local fill = 0\n    while fill + max\
    \ <= capacity do\n        fill = fill + max\n    end\n    return fill\nend", " \
    \   local n = #grid\n    if n == 0 then\n        return 0\n    end\n    local\
    \ m = #grid[1]\n    if m == 0 then\n        return 0\n    end\n    local cache\
    \ = {}\n    local function dfs(i, j)\n        if i < 1 or i > n or j < 1 or j\
    \ > m then\n            return 0\n        end\n        local key = string.format(\"\
    %d,%d\", i, j)\n        if cache[key] ~= nil then\n            return cache[key]\n\
    \        end\n        local res = grid[i][j]\n        local left = math.max(0,\
    \ dfs(i-1, j) - capacity)\n        local up = math.max(0, dfs(i, j-1) - capacity)\n\
    \        res = res + left + up\n        cache[key] = res\n        return res\n\
    \    end\n    return dfs(n, m)\nend", "    local m, n = #grid, #grid[1]\n    local\
    \ function can_fill(i, j)\n        return i >= 1 and i <= m and j >= 1 and j <=\
    \ n and grid[i][j] > 0\n    end\n    local visited = {}\n    local function dfs(i,\
    \ j)\n        if not can_fill(i, j) or visited[i .. \",\" .. j] then\n       \
    \     return 0\n        end\n        visited[i .. \",\" .. j] = true\n       \
    \ local sum = capacity - grid[i][j]\n        sum = sum + dfs(i - 1, j)\n     \
    \   sum = sum + dfs(i + 1, j)\n        sum = sum + dfs(i, j - 1)\n        sum\
    \ = sum + dfs(i, j + 1)\n        sum = math.min(sum, capacity)\n        grid[i][j]\
    \ = grid[i][j] + sum\n        return sum\n    end\n    local res = 0\n    for\
    \ i = 1, m do\n        for j = 1, n do\n            res = res + dfs(i, j)\n  \
    \      end\n    end\n    return res\nend", "    local water = {}\n    local max_y\
    \ = #grid\n    local max_x = #grid[1]\n    for i = 1, #grid do\n        for j\
    \ = 1, #grid[i] do\n            if grid[i][j] == 1 then\n                table.insert(water,\
    \ {i, j})\n            end\n        end\n    end\n    local count = 0\n    while\
    \ #water > 0 do\n        count = count + 1\n        local new_water = {}\n   \
    \     for _, w in ipairs(water) do\n            local x, y = w[1], w[2]\n    \
    \        if x > 1 and grid[x - 1][y] == 0 then\n                grid[x - 1][y]\
    \ = 1\n                table.insert(new_water, {x - 1, y})\n            end\n\
    \            if x < max_y and grid[x + 1][y] == 0 then\n                grid[x\
    \ + 1][y] = 1\n                table.insert(new_water, {x + 1, y})\n         \
    \   end\n            if y > 1 and grid[x][y - 1] == 0 then\n                grid[x][y\
    \ - 1] = 1\n                table.insert(new_water, {x, y - 1})\n            end\n\
    \            if y < max_x and grid[x][y + 1] == 0 then\n                grid[x][y\
    \ + 1] = 1\n                table.insert(new_water, {x, y + 1})\n            end\n\
    \        end\n        if #new_water > capacity then\n            return -1\n \
    \       end\n        water = new_water\n    end\n    return count\nend\nreturn\
    \ max_fill", "    local n, m = #grid, #grid[1]\n    local max_fill = capacity\n\
    \    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] > 0 then\n\
    \                max_fill = math.min(max_fill, capacity - grid[i][j])\n      \
    \      end\n        end\n    end\n    return max_fill\nend", "  local n, m = #grid,\
    \ #grid[1]\n  local max_fill_row = function(row)\n    local fill, i = 0, 0\n \
    \   for i = 1, #row do\n      if row[i] == 1 then\n        fill = fill + 1\n \
    \     else\n        fill = 0\n      end\n      if fill > capacity then\n     \
    \   return capacity\n      end\n    end\n    return fill\n  end\n  local result\
    \ = 0\n  for i = 1, n do\n    local fill = max_fill_row(grid[i])\n    if fill\
    \ > 0 then\n      result = result + fill\n      grid[i] = grid[i]:sub(#grid[i]\
    \ - fill + 1)\n    end\n  end\n  return result\nend\nreturn max_fill", "  local\
    \ m, n = #grid, #grid[1]\n  local total = 0\n  for i = 1, m do\n    for j = 1,\
    \ n do\n      total = total + grid[i][j]\n    end\n  end\n  local max_height =\
    \ math.floor(total / n)\n  local min_depth = math.max(0, max_height - capacity)\n\
    \  for i = 1, m do\n    for j = 1, n do\n      if grid[i][j] > max_height then\n\
    \        return -1\n      end\n      if grid[i][j] < min_depth then\n        grid[i][j]\
    \ = min_depth\n      end\n    end\n  end\n  local fill = 0\n  for i = 1, m do\n\
    \    for j = 1, n do\n      if grid[i][j] < max_height then\n        fill = fill\
    \ + max_height - grid[i][j]\n      end\n    end\n  end\n  return fill\nend\nreturn\
    \ max_fill", "  local function fill(i, j)\n    if grid[i][j] == 1 then\n     \
    \ grid[i][j] = 0\n      if i > 1 then\n        fill(i - 1, j)\n      end\n   \
    \   if i < #grid then\n        fill(i + 1, j)\n      end\n      if j > 1 then\n\
    \        fill(i, j - 1)\n      end\n      if j < #grid[i] then\n        fill(i,\
    \ j + 1)\n      end\n    end\n  end\n  local function lower()\n    local limit\
    \ = 0\n    for i = 1, #grid do\n      for j = 1, #grid[i] do\n        if grid[i][j]\
    \ == 1 then\n          limit = i\n          break\n        end\n      end\n  \
    \  end\n    if limit > capacity then\n      return\n    end\n    local n = 0\n\
    \    for i = 1, limit do\n      for j = 1, #grid[i] do\n        if grid[i][j]\
    \ == 1 then\n          fill(i, j)\n          n = n + 1\n        end\n      end\n\
    \    end\n    return n\n  end\n  local n = 0\n  while true do\n    local count\
    \ = lower()\n    if count == nil then\n      break\n    end\n    n = n + count\n\
    \  end\n  return n\nend", "  local function max_num_extracts(g, row, col, cap)\n\
    \    if row == 0 then return 0 end\n    local prev_row = row - 1\n    local prev_col\
    \ = col\n    local prev_val = g[prev_row][prev_col]\n    local val = g[row][col]\n\
    \    if prev_val == 0 then\n      return max_num_extracts(g, prev_row, prev_col,\
    \ cap)\n    elseif prev_val >= cap then\n      return 1 + max_num_extracts(g,\
    \ prev_row, prev_col, cap)\n    elseif prev_val + val >= cap then\n      return\
    \ 1 + max_num_extracts(g, prev_row, prev_col, cap)\n    elseif prev_val + val\
    \ < cap then\n      return 1 + max_num_extracts(g, prev_row, prev_col, cap - prev_val\
    \ - val)\n    end\n  end\n  local m = #grid\n  local n = #grid[1]\n  local result\
    \ = 0\n  for row = m, 1, -1 do\n    for col = n, 1, -1 do\n      result = result\
    \ + max_num_extracts(grid, row, col, capacity)\n    end\n  end\n  return result\n\
    end\nreturn max_fill", "    -- there are only two options: 0 or capacity\n   \
    \ local curr = capacity\n    local fill = 0\n    for _, row in ipairs(grid) do\n\
    \        for _, unit in ipairs(row) do\n            if unit == 1 then\n      \
    \          -- drop water into the well\n                fill = fill + (capacity\
    \ - curr)\n                curr = capacity\n            else\n               \
    \ curr = curr - 1\n            end\n        end\n    end\n    return fill\nend\n\
    return {\n    max_fill = max_fill\n}", "    local steps = 0\n    for i = 1, #grid\
    \ do\n        local cur = capacity\n        for j = 1, #grid[i] do\n         \
    \   if grid[i][j] == 1 then\n                cur = 0\n            else\n     \
    \           cur = cur + 1\n            end\n            if cur > capacity then\n\
    \                cur = capacity\n            end\n        end\n        steps =\
    \ steps + capacity - cur\n    end\n    return steps\nend\nreturn max_fill", " \
    \ local n, m = #grid, #grid[1]\n  local max_per_row = {}\n  for i=1,n do max_per_row[i]\
    \ = 0 end\n  for i=1,n do\n    for j=1,m do\n      if grid[i][j] == 1 then\n \
    \       max_per_row[i] = max_per_row[i] + 1\n      end\n    end\n  end\n  local\
    \ max_per_col = {}\n  for j=1,m do max_per_col[j] = 0 end\n  for j=1,m do\n  \
    \  for i=1,n do\n      if grid[i][j] == 1 then\n        max_per_col[j] = max_per_col[j]\
    \ + 1\n      end\n    end\n  end\n  local function min_fill(water)\n    local\
    \ fill = 0\n    for _, v in ipairs(water) do\n      fill = fill + math.ceil(v\
    \ / capacity)\n    end\n    return fill\n  end\n  local res = min_fill(max_per_row)\n\
    \  for j=1,m do\n    local fill = min_fill(max_per_col)\n    if fill < res then\
    \ res = fill end\n    local water = {}\n    for i=1,n do\n      water[i] = max_per_row[i]\n\
    \    end\n    for i=1,n do\n      if grid[i][j] == 1 then\n        max_per_col[j]\
    \ = max_per_col[j] - 1\n        max_per_row[i] = max_per_row[i] - 1\n      end\n\
    \    end\n    for i=1,n do\n      if water[i] - max_per_row[i] > 0 then\n    \
    \    max_per_col[j] = max_per_col[j] + water[i] - max_per_row[i]\n      end\n\
    \    end\n  end\n  return res\nend\nreturn max_fill", "    local i, x, sum = 1,\
    \ #grid[1], 0\n    while i <= x do\n        local j, y = 1, #grid\n        while\
    \ j <= y do\n            if grid[j][i] == 1 then\n                grid[j][i] =\
    \ 0\n                sum = sum + 1\n            end\n            j = j + 1\n \
    \       end\n        i = i + 1\n    end\n    return math.ceil(sum / capacity)\n\
    end", "    local result = 0\n    local l = 0\n    local r = capacity\n    local\
    \ total = 0\n    for i = 1, #grid do\n        local row = grid[i]\n        local\
    \ hole = 0\n        for j = 1, #row do\n            if row[j] == 1 then\n    \
    \            hole = hole + 1\n            end\n        end\n        total = total\
    \ + hole\n        local row_l = hole - capacity\n        if row_l > 0 then\n \
    \           l = l + row_l\n            r = capacity\n        else\n          \
    \  r = r - hole\n        end\n        result = result + hole\n    end\n    return\
    \ result - math.max(l, r)\nend\nreturn max_fill", "    local max_fill = -1\n \
    \   for i, row in ipairs(grid) do\n        local sum = 0\n        for j, col in\
    \ ipairs(row) do\n            sum = sum + col\n            if sum > capacity then\n\
    \                max_fill = math.max(max_fill, j - 1)\n                break\n\
    \            end\n        end\n        if sum <= capacity then\n            max_fill\
    \ = math.max(max_fill, #row)\n        end\n    end\n    return max_fill\nend",
  "    local max_fill = 0\n    for i, row in ipairs(grid) do\n        local fill =\
    \ 0\n        for j, col in ipairs(row) do\n            fill = fill + col\n   \
    \         if fill > capacity then\n                return capacity\n         \
    \   end\n        end\n        if fill > max_fill then\n            max_fill =\
    \ fill\n        end\n    end\n    return max_fill\nend", "    -- print(grid)\n\
    \    -- print(capacity)\n    local max = 0\n    for i = 1, #grid do\n        for\
    \ j = 1, #grid[i] do\n            if grid[i][j] == 1 then\n                max\
    \ = j\n            end\n        end\n    end\n    local last_row_sum = 0\n   \
    \ for j = 1, #grid[#grid] do\n        last_row_sum = last_row_sum + grid[#grid][j]\n\
    \    end\n    if max < last_row_sum then\n        return 0\n    end\n    local\
    \ counter = 0\n    for i = 1, #grid do\n        local row_sum = 0\n        for\
    \ j = 1, #grid[i] do\n            row_sum = row_sum + grid[i][j]\n        end\n\
    \        -- print(row_sum)\n        counter = counter + math.ceil(row_sum / capacity)\n\
    \    end\n    return counter\nend", "    local n, m = #grid, #grid[1]\n    local\
    \ row_maxes = {}\n    for i=1, n do\n        local max_value = 0\n        for\
    \ j=1, m do\n            max_value = math.max(max_value, grid[i][j])\n       \
    \ end\n        row_maxes[i] = max_value\n    end\n    local col_maxes = {}\n \
    \   for j=1, m do\n        local max_value = 0\n        for i=1, n do\n      \
    \      max_value = math.max(max_value, grid[i][j])\n        end\n        col_maxes[j]\
    \ = max_value\n    end\n    local result = 0\n    for i=1, n do\n        for j=1,\
    \ m do\n            result = result + math.max(0, row_maxes[i] - grid[i][j])\n\
    \            result = result + math.max(0, col_maxes[j] - grid[i][j])\n      \
    \  end\n    end\n    return result // (2 * capacity)\nend\nreturn max_fill", " \
    \   local result = 0\n    local offset = 0\n    local row_size = #grid[1]\n  \
    \  for i = 1, #grid do\n        if grid[i][1] == 1 then\n            offset =\
    \ offset + 1\n        end\n        for j = 1, row_size do\n            if grid[i][j]\
    \ == 1 then\n                grid[i][j] = 0\n                result = result +\
    \ 1\n            end\n        end\n        for j = 1, offset do\n            if\
    \ i - j > 0 and grid[i - j][row_size] == 1 then\n                grid[i - j][row_size]\
    \ = 0\n                result = result + 1\n            end\n        end\n   \
    \ end\n    return result\nend\nreturn max_fill", "    local max, count = 0, 0\n\
    \    for i = 1, #grid do\n        local s = 0\n        for j = 1, #grid[i] do\n\
    \            s = s + grid[i][j]\n            max = math.max(max, s)\n        end\n\
    \        count = count + math.min(capacity, max)\n    end\n    return count\n\
    end", "    local r, c = #grid, #grid[1]\n    local fill_min = 0\n    local wells\
    \ = {}\n    for i = 1, r do\n        for j = 1, c do\n            if grid[i][j]\
    \ > 0 then\n                wells[#wells + 1] = {i, j}\n                fill_min\
    \ = math.max(fill_min, grid[i][j])\n            end\n        end\n    end\n  \
    \  -- the max fill level is either the capacity or the max wells[,2] filled to\n\
    \    local res = fill_min\n    local n = #wells\n    for _, fill in ipairs{capacity,\
    \ fill_min} do\n        local fails = {}\n        for i = 1, n do\n          \
    \  local idx = (i - 1) % n + 1\n            local row, col = wells[idx][1], wells[idx][2]\n\
    \            if grid[row][col] < fill then\n                fails[#fails + 1]\
    \ = idx\n            end\n        end\n        local filled = {}\n        local\
    \ this_res = 0\n        for k = 1, #fails do\n            for i = 1, n do\n  \
    \              local idx = (i - 1) % n + 1\n                local row, col = wells[idx][1],\
    \ wells[idx][2]\n                if not filled[idx] and fill - grid[row][col]\
    \ <= capacity then\n                    filled[idx] = true\n                 \
    \   this_res = this_res + 1\n                    grid[row][col] = grid[row][col]\
    \ + capacity\n                    break\n                end\n            end\n\
    \        end\n        res = math.min(res, this_res)\n    end\n    return res\n\
    end", "    local fill = 0\n    local n = #grid\n    local m = #grid[1]\n    local\
    \ stack = {}\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                fill = fill + 1\n                table.insert(stack,\
    \ {i, j})\n            end\n        end\n    end\n    while #stack > 0 do\n  \
    \      local k = 1\n        while k <= #stack do\n            local t = stack[k]\n\
    \            local i, j = t[1], t[2]\n            if i < n and grid[i + 1][j]\
    \ == 1 then\n                if fill == 0 then\n                    return 0\n\
    \                end\n                fill = fill - 1\n                grid[i\
    \ + 1][j] = 2\n                k = k + 1\n            elseif j < m and grid[i][j\
    \ + 1] == 1 then\n                if fill == 0 then\n                    return\
    \ 0\n                end\n                fill = fill - 1\n                grid[i][j\
    \ + 1] = 2\n                k = k + 1\n            else\n                table.remove(stack,\
    \ k)\n            end\n        end\n    end\n    return fill\nend", "    local\
    \ result = 0\n    local n = #grid\n    local m = #grid[1]\n    local f = {}\n\
    \    local function dfs(i, j)\n        if j == m then\n            f[i] = 1\n\
    \            return f[i]\n        end\n        if f[i] then\n            return\
    \ f[i]\n        end\n        local new_i = i + capacity\n        if new_i > n\
    \ then\n            new_i = n\n        end\n        local new_j = j + 1\n    \
    \    local max_cur = 0\n        local max_next = 0\n        for k = i, new_i do\n\
    \            if grid[k][j] == 1 then\n                local t = 1 + dfs(k, new_j)\n\
    \                if t > max_cur then\n                    max_cur = t\n      \
    \          end\n            end\n        end\n        for k = i, new_i do\n  \
    \          if grid[k][j] == 1 then\n                local t = dfs(k, new_j)\n\
    \                if t > max_next then\n                    max_next = t\n    \
    \            end\n            end\n        end\n        if max_cur > max_next\
    \ then\n            f[i] = max_cur\n        else\n            f[i] = max_next\n\
    \        end\n        return f[i]\n    end\n    for i = 1, n do\n        if grid[i][1]\
    \ == 1 then\n            local t = dfs(i, 2)\n            if t > result then\n\
    \                result = t\n            end\n        end\n    end\n    return\
    \ result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
