name: HumanEval_48_is_palindrome
language: lua
prompt: "-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- True\n\
  -- >>> is_palindrome('aba')\n-- True\n-- >>> is_palindrome('aaaaa')\n-- True\n--\
  \ >>> is_palindrome('zbcd')\n-- False\nlocal function is_palindrome(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n\
  \    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'),\
  \ true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'),\
  \ false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'),\
  \ false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return text == text:reverse()\nend", "    return text == string.reverse(text)\n\
    end", "\t-- comparing end and start letters\n\t-- until index of the letter in\
    \ the middle\n\tfor i = 1, math.floor(#text / 2) do\n\t\tif text:sub(i, i) ~=\
    \ text:sub(#text - i + 1, #text - i + 1) then\n\t\t\treturn false\n\t\tend\n\t\
    end\n\treturn true\nend", "    if not text or #text == 0 then\n        return\
    \ true\n    end", "  return text == string.reverse(text)\nend", "    local head,\
    \ tail = 1, #text\n    while head < tail do\n        if text:sub(head, head) ~=\
    \ text:sub(tail, tail) then\n            return false\n        end\n        head\
    \ = head + 1\n        tail = tail - 1\n    end\n    return true\nend", "  return\
    \ text == reverse(text)\nend", "    local left_idx = 1\n    local right_idx =\
    \ #text\n    while left_idx < right_idx do\n        if text:sub(left_idx, left_idx)\
    \ ~= text:sub(right_idx, right_idx) then\n            return false\n        end\n\
    \        left_idx = left_idx + 1\n        right_idx = right_idx - 1\n    end\n\
    \    return true\nend", "    local len = #text\n    for i = 1, math.floor(len\
    \ / 2) do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \            return false\n        end\n    end\n    return true\nend", "    return\
    \ text == string.reverse(text)\nend", "    if text == '' then\n        return\
    \ true\n    end\n    local left = 1\n    local right = #text\n    while left <\
    \ right do\n        if text:sub(left, left) ~= text:sub(right, right) then\n \
    \           return false\n        end\n        left = left + 1\n        right\
    \ = right - 1\n    end\n    return true\nend", "  local reverse = string.reverse(text)\n\
    \  return text == reverse\nend", "  return string.reverse(text) == text\nend",
  "    return text == string.reverse(text)\nend", "\treturn text == string.reverse(text)\n\
    end", "  -- Base case\n  if #text <= 1 then\n    return true\n  end", "  local\
    \ len = #text\n  for i = 1, len do\n    if text:sub(i, i) ~= text:sub(len + 1\
    \ - i, len + 1 - i) then\n      return false\n    end\n  end\n  return true\n\
    end", "    local text_len = string.len(text)\n    for i = 1, text_len do\n   \
    \     if string.sub(text, i, i) ~= string.sub(text, text_len-i+1, text_len-i+1)\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "    return text == reverse(text)\nend", "\treturn text == string.reverse(text)\n\
    end", "  for i = 1, #text / 2 do\n    if text:sub(i, i) ~= text:sub(#text - i\
    \ + 1, #text - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "    return text == string.reverse(text)\nend", "\t-- Remove non-alphabetic\
    \ characters\n\tlocal text = text:gsub('[^%a]', '')\n\t-- Lowercase the text\n\
    \tlocal text = text:lower()\n\tlocal palindrome = {}\n\tlocal half = math.floor(#text\
    \ / 2)\n\tfor i = 1, half do\n\t\t-- Get the first letter\n\t\tlocal first = text:sub(i,\
    \ i)\n\t\t-- Get the last letter\n\t\tlocal last = text:sub(-i, -i)\n\t\t-- Compare\
    \ the letters\n\t\tif first ~= last then\n\t\t\t-- If the letters are not equal\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "    local len = string.len(text)\n\
    \    local is_palindrome = true\n    local half_len = math.floor(len / 2)\n  \
    \  for i = 1, half_len do\n        if string.sub(text, i, i) ~= string.sub(text,\
    \ len - i + 1, len - i + 1) then\n            is_palindrome = false\n        \
    \    break\n        end\n    end\n    return is_palindrome\nend", "  local len\
    \ = text:len()\n  for i = 1, len / 2 do\n    if text:sub(i, i) ~= text:sub(len\
    \ - i + 1, len - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "    if #text < 2 then\n        return true\n    end\n    if text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n        return is_palindrome(text:sub(2, -2))\n\
    \    end\n    return false\nend", "  local len = text:len()\n  local half = math.floor(len\
    \ / 2)\n  local is_palindrome = true\n  for i = 1, half do\n    local a = text:sub(i,\
    \ i)\n    local b = text:sub(len - i + 1, len - i + 1)\n    if a ~= b then\n \
    \     is_palindrome = false\n      break\n    end\n  end\n  return is_palindrome\n\
    end", "    local len = string.len(text)\n    for i = 1, math.floor(len / 2) do\n\
    \        if string.sub(text, i, i) ~= string.sub(text, len - i + 1, len - i +\
    \ 1) then\n            return false\n        end\n    end\n    return true\nend",
  "    if #text < 2 then\n        return true\n    end\n    if text:sub(1, 1) == text:sub(-1,\
    \ -1) then\n        return is_palindrome(text:sub(2, -2))\n    end\n    return\
    \ false\nend", "  if text == string.reverse(text) then\n    return true\n  else\n\
    \    return false\n  end\nend", "  local len = #text\n  local hlen = len / 2\n\
    \  local rem = len % 2 == 1 and hlen + 1 or hlen\n  for i = 1, hlen do\n    if\
    \ text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  if text:len() <= 1 then\n    return true\n\
    \  elseif text:sub(1, 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2,\
    \ -2))\n  else\n    return false\n  end\nend", "    -- text is a palindrome if\
    \ it is equal to its reversed\n    return text == string.reverse(text)\nend",
  "    if (not text) or (#text == 0) then\n        return true\n    end", "    if\
    \ #text <= 1 then\n        return true\n    elseif text:sub(1, 1) == text:sub(-1,\
    \ -1) then\n        return is_palindrome(text:sub(2, -2))\n    else\n        return\
    \ false\n    end\nend", "  if not text then return false end\n  local text_length\
    \ = string.len(text)\n  if text_length == 0 then return true end\n  for i = 1,\
    \ math.floor(text_length / 2) do\n    if text:sub(i, i) ~= text:sub(text_length\
    \ - i + 1, text_length - i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  local text_len = #text\n  local half_len = math.floor(text_len\
    \ / 2)\n  for i = 1, half_len do\n    if text:sub(i, i) ~= text:sub(text_len -\
    \ i + 1, text_len - i + 1) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    text = normalize(text)\n    for i = 1, #text do\n        if\
    \ text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    return is_palindrome_iter(text,\
    \ 1, #text)\nend", "  if string.len(text) == 0 then\n    return true\n  end\n\
    \  -- let's use iterative approach\n  local front = 1\n  local back = string.len(text)\n\
    \  while front < back do\n    if text:sub(front, front) ~= text:sub(back, back)\
    \ then\n      return false\n    end\n    front = front + 1\n    back = back -\
    \ 1\n  end\n  return true\nend", "\tif text == text:reverse() then\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tend\nend", "  return text == text:reverse()\n\
    end", "    local len = #text\n    for i = 1, len do\n        if text:sub(i, i)\
    \ ~= text:sub(len - i + 1, len - i + 1) then\n            return false\n     \
    \   end\n    end\n    return true\nend", "    local length = #text\n    for i\
    \ = 1, length // 2 do\n        if text:sub(i, i) ~= text:sub(length + 1 - i, length\
    \ + 1 - i) then\n            return false\n        end\n    end\n    return true\n\
    end", "    local text_size = #text\n    local left = 1\n    local right = text_size\n\
    \    for _ = 1, text_size, 1 do\n        if text:sub(left, left) ~= text:sub(right,\
    \ right) then\n            return false\n        end\n        left = left + 1\n\
    \        right = right - 1\n    end\n    return true\nend", "  --[[\n  local t\
    \ = {}\n  for i = 1, #text do\n    t[i] = text:sub(i, i)\n  end\n  local left\
    \ = 1\n  local right = #text\n  while left < right do\n    if t[left] ~= t[right]\
    \ then\n      return false\n    end\n    left = left + 1\n    right = right -\
    \ 1\n  end\n  return true\n  --]]\n  --[[\n  local l = #text\n  local len = math.floor(l\
    \ / 2)\n  for i = 1, len do\n    if text:sub(i, i) ~= text:sub(l - i + 1, l -\
    \ i + 1) then\n      return false\n    end\n  end\n  return true\n  --]]\n  --[[\n\
    \  local t = {}\n  for i = 1, #text do\n    t[i] = text:sub(i, i)\n  end\n  for\
    \ i = 1, math.floor(#text / 2) do\n    if t[i] ~= t[#text - i + 1] then\n    \
    \  return false\n    end\n  end\n  return true\n  --]]\n  --[[\n  local l = #text\n\
    \  for i = 1, math.floor(l / 2) do\n    if text:sub(i, i) ~= text:sub(l - i +\
    \ 1, l - i + 1) then\n      return false\n    end\n  end\n  return true\n  --]]\n\
    \  --[[\n  local t = {}\n  for i = 1, #text do\n    t[i] = text:sub(i, i)\n  end\n\
    \  for i = 1, math.floor(#text / 2) do\n    if t[i] ~= t[#text - i + 1] then\n\
    \      return false\n    end\n  end\n  return true\n  --]]\n  --[[\n  local t\
    \ = {}\n  for i = 1, #text do\n    t[i] = text:sub(i, i)\n  end\n  for i = 1,\
    \ math.floor(#text / 2) do\n    if t[i] ~= t[#text", "  local n = #text\n  for\
    \ i = 1, (n/2) do\n    if text:sub(i, i) ~= text:sub(n+1-i, n+1-i) then\n    \
    \  return false\n    end\n  end\n  return true\nend", "  -- TODO: implement this\n\
    \  return text == string.reverse(text)\nend", "  for i = 1, math.floor(#text /\
    \ 2) do\n    if text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local length =\
    \ #text\n    for i = 1, math.floor(length / 2) do\n        if text:sub(i, i) ~=\
    \ text:sub(length - i + 1, length - i + 1) then\n            return false\n  \
    \      end\n    end\n    return true\nend", "  return text == string.reverse(text)\n\
    end", "    return text == str_reverse(text)\nend", "\tlocal text_length = string.len(text)\n\
    \tif text_length == 0 then\n\t\treturn true\n\tend\n\tlocal half_length = math.floor(text_length\
    \ / 2)\n\treturn text:sub(1, half_length) == text:sub(text_length, text_length\
    \ - half_length + 1):reverse()\nend", "    local tlen = #text\n    if (tlen ==\
    \ 0) then\n        return true\n    end\n    local hlen = math.floor(tlen / 2)\n\
    \    local fpart = string.sub(text, 1, hlen)\n    local spart = string.sub(text,\
    \ tlen - hlen + 1, tlen)\n    spart = string.reverse(spart)\n    return fpart\
    \ == spart\nend", "  local strlen = string.len(text)\n  local half_strlen = strlen\
    \ / 2\n  for i = 1, half_strlen do\n    if (text:sub(i, i) ~= text:sub(strlen\
    \ + 1 - i, strlen + 1 - i)) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "    local len = string.len(text)\n    local half = math.floor(len\
    \ / 2)", "  local len = string.len(text)\n  for i = 1, len do\n    if text:sub(i,\
    \ i) ~= text:sub(len - i + 1, len - i + 1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "    local rev = string.reverse(text)\n    return\
    \ text == rev\nend", "\tif #text == 0 then\n\t\treturn true\n\tend\n\t\n\t-- check\
    \ if the first and last characters are equal\n\tif string.lower(text:sub(1, 1))\
    \ == string.lower(text:sub(-1, -1)) then\n\t\t-- if so, strip first and last characters\
    \ and check the result for palindrome\n\t\treturn is_palindrome(text:sub(2, -2))\n\
    \telse\n\t\treturn false\n\tend\nend", "  if not text or #text < 2 then\n    return\
    \ true\n  end\n  local text_len = #text\n  local is_odd = text_len % 2 == 1\n\
    \  local first_half_len = text_len // 2\n  local first_half = sub(text, 1, first_half_len)\n\
    \  local second_half_len = first_half_len + is_odd\n  local second_half = sub(text,\
    \ second_half_len + 1, text_len)\n  local is_palindrome = first_half == string.reverse(second_half)\n\
    \  return is_palindrome\nend", "  local len = string.len(text)\n  local half =\
    \ math.floor(len / 2)\n  local last = len - 1\n  for i = 0, half do\n    if text:sub(i,\
    \ i) ~= text:sub(last - i, last - i) then\n      return false\n    end\n  end\n\
    \  return true\nend", "\treturn string.sub(text, 1, 1) == string.sub(text, -1,\
    \ -1) and (text == '' or is_palindrome(string.sub(text, 2, -2)))\nend", "  return\
    \ text == string.reverse(text)\nend", "    local length = #text\n    for i = 1,\
    \ length do\n        if (text:sub(i, i) ~= text:sub(length, length)) then\n  \
    \          return false\n        end\n        length = length - 1\n    end\n \
    \   return true\nend", "    local len = string.len(text)\n    for i = 1, len /\
    \ 2 do\n        if string.sub(text, i, i) ~= string.sub(text, len - i + 1, len\
    \ - i + 1) then\n            return false\n        end\n    end\n    return true\n\
    end", "    local length = string.len(text)\n    for i = 1, length / 2 do\n   \
    \     if text:sub(i, i) ~= text:sub(length - i + 1, length - i + 1) then\n   \
    \         return false\n        end\n    end\n    return true\nend", "    local\
    \ reversed = string.reverse(text)\n    if text == reversed then\n        return\
    \ true\n    else\n        return false\n    end\nend", "\tfor i = 1, #text / 2\
    \ do\n\t\tif text:sub(i, i) ~= text:sub(#text - i + 1, #text - i + 1) then\n\t\
    \t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "\tif text == reverse(text)\
    \ then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "    if text ==\
    \ reverse(text) then\n        return true\n    else\n        return false\n  \
    \  end\nend", "\tif text == nil then\n\t\treturn false\n\tend\n\tlocal l = string.len(text)\n\
    \tif l == 0 then\n\t\treturn true\n\tend\n\tlocal n = math.floor(l / 2)\n\tfor\
    \ i = 1, n do\n\t\tif string.sub(text, i, i) ~= string.sub(text, l - i + 1, l\
    \ - i + 1) then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "  \
    \  local len = #text\n    for i = 1, len // 2 do\n        if text:sub(i, i) ~=\
    \ text:sub(len - i + 1, len - i + 1) then\n            return false\n        end\n\
    \    end\n    return true\nend", "    return text == text:reverse()\nend", " \
    \ local text_len = #text\n  local middle = math.floor(text_len / 2)", "    --\
    \ computes the length of the string, i.e., the number of characters\n    local\
    \ n = #text\n    -- corner case: string of length 0 or 1 is a palindrome\n   \
    \ if n < 2 then\n        return true\n    end\n    -- check first and last character\n\
    \    if text:sub(1, 1) ~= text:sub(n, n) then\n        return false\n    end\n\
    \    -- recursively check the substring text[2:n-1]\n    return is_palindrome(text:sub(2,\
    \ n-1))\nend", "    local len = string.len(text)\n    for i = 1, math.floor(len\
    \ / 2) do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n\
    \            return false\n        end\n    end\n    return true\nend", "    return\
    \ (text == string.reverse(text))\nend", "  if text == '' then\n    return true\n\
    \  end\n  local length = strlen(text)\n  if length == 1 then\n    return true\n\
    \  end\n  local mid = math.floor(length / 2)\n  local first_half = strsub(text,\
    \ 1, mid)\n  local second_half = strsub(text, length - mid + 1, length)\n  local\
    \ second_half_reversed = strrev(second_half)\n  if first_half == second_half_reversed\
    \ then\n    return true\n  end\n  return false\nend", "  -- TODO: Implement me!\n\
    \  -- [base case]\n  if text == '' then\n    return true\n  end\n  -- [base case]\n\
    \  if text:len() == 1 then\n    return true\n  end\n  -- [recursive step]\n  if\
    \ text:sub(1,1) == text:sub(-1) then\n    return is_palindrome(text:sub(2,-2))\n\
    \  end\n  -- [recursive step]\n  return false\nend", "    if text == '' then\n\
    \        return true\n    end\n    local first = string.sub(text, 1, 1)\n    local\
    \ last = string.sub(text, -1, -1)\n    if first ~= last then\n        return false\n\
    \    end\n    local middle = string.sub(text, 2, -2)\n    return is_palindrome(middle)\n\
    end", "\treturn text == text:reverse()\nend", "  local i = 1\n  local j = #text\n\
    \  while i < j do\n    if text:sub(i, i) ~= text:sub(j, j) then\n      return\
    \ false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\nend", " \
    \   -- FIXME: Implement this\n    return false\nend", "    return text == string.reverse(text)\n\
    end", "    local len = #text\n    for i = 1, math.floor(len / 2) do\n        if\
    \ text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    local i = 1\n    local\
    \ j = text:len()\n    while i < j do\n        if text:sub(i, i) ~= text:sub(j,\
    \ j) then\n            return false\n        end\n        i = i + 1\n        j\
    \ = j - 1\n    end\n    return true\nend", "    return text == string.reverse(text)\n\
    end", "    local first = 1\n    local last = #text\n    while last > first do\n\
    \        if text:sub(first, first) ~= text:sub(last, last) then\n            return\
    \ false\n        end\n        first = first + 1\n        last = last - 1\n   \
    \ end\n    return true\nend", "\tlocal length = string.len(text)\n\tlocal half\
    \ = math.floor(length / 2)", "\treturn text == string.reverse(text)\nend", " \
    \ return text == string.reverse(text)\nend", "    return string.reverse(text)\
    \ == text\nend", "  local n = #text\n  for i = 1, math.floor(n / 2) do\n    if\
    \ text:sub(i, i) ~= text:sub(n - i + 1, n - i + 1) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  for i = 1, #text do\n    if text:sub(i,\
    \ i) ~= text:sub(#text + 1 - i, #text + 1 - i) then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local len = text:len()\n  for i = 1, len / 2 do\n\
    \    if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  -- all palindromes of length\
    \ < 2 are valid\n  if #text < 2 then\n    return true\n  end", "  local len =\
    \ #text\n  for i = 1, len/2 do\n    if text:sub(i, i) ~= text:sub(len - i + 1,\
    \ len - i + 1) then\n      return false\n    end\n  end\n  return true\nend",
  "    if text == '' then\n        return true\n    end\n    if text:sub(1, 1) ==\
    \ text:sub(-1, -1) then\n        return is_palindrome(text:sub(2, -2))\n    end\n\
    \    return false\nend", "    local len = string.len(text)\n    local half = math.floor(len\
    \ / 2)\n    local part1 = string.sub(text, 1, half)\n    local part2 = string.sub(text,\
    \ len % 2 + 1, -1)\n    local rev2 = string.reverse(part2)\n    return part1 ==\
    \ rev2\nend", "\tif text == '' then\n\t\treturn true\n\tend\n\tlocal len = string.len(text)\n\
    \tif len == 1 then\n\t\treturn true\n\tend\n\tlocal first = text:sub(1, 1)\n\t\
    local last = text:sub(len, len)\n\tif first ~= last then\n\t\treturn false\n\t\
    end\n\treturn is_palindrome(text:sub(2, len - 1))\nend", "\treturn text == string.reverse(text)\n\
    end", "    -- Need to handle case if text is empty string\n    if #text == 0 then\n\
    \        return true\n    end", "\treturn text == string.reverse(text)\nend",
  "    if not text or #text == 0 then\n        return true\n    end", "\tif #text\
    \ == 0 then\n\t\treturn true\n\tend\n\tif string.sub(text, 1, 1) == string.sub(text,\
    \ #text, #text) then\n\t\treturn is_palindrome(string.sub(text, 2, #text - 1))\n\
    \telse\n\t\treturn false\n\tend\nend", "  local len = strlen(text)\n  local half_len\
    \ = ceil(len / 2)\n  local first_half = sub(text, 1, half_len)\n  local second_half\
    \ = sub(text, -half_len)\n  return first_half == reversed(second_half)\nend",
  "\t-- this is a quick and dirty palindrome checker (notice the len() operator)\n\
    \t-- it is not the most efficient way to do things, but it is readable\n\treturn\
    \ string.lower(text) == string.reverse(string.lower(text))\nend", "    return\
    \ string.reverse(text) == text\nend", "    local length = #text\n    local half_length\
    \ = math.floor(length / 2)\n    for i = 1, half_length do\n        if text:sub(i,\
    \ i) ~= text:sub(length - i + 1, length - i + 1) then\n            return false\n\
    \        end\n    end\n    return true\nend", "    -- Base case\n    if #text\
    \ <= 1 then\n        return true\n    else\n        -- Recursion\n        return\
    \ (string.sub(text, 1, 1) == string.sub(text, -1, -1)) and\n               is_palindrome(string.sub(text,\
    \ 2, -2))\n    end\nend", "  local len = string.len(text)\n  local i = 1\n  while\
    \ i <= len do\n    if text:sub(i, i) ~= text:sub(len, len) then\n      return\
    \ false\n    end\n    i = i + 1\n    len = len - 1\n  end\n  return true\nend",
  "  local len = text:len()\n  local low = 1\n  local high = len\n  while low < high\
    \ do\n    if text:sub(low, low) ~= text:sub(high, high) then\n      return false\n\
    \    end\n    low = low + 1\n    high = high - 1\n  end\n  return true\nend",
  "    return string.reverse(text) == text\nend", "    -- For empty string or single\
    \ character string\n    if #text < 2 then\n        return true\n    end", "\t\
    return text == string.reverse(text)\nend", "  local length = utf8.len(text)\n\
    \  for i = 1, math.floor(length / 2) do\n    if utf8.sub(text, i, i) ~= utf8.sub(text,\
    \ length - i + 1, length - i + 1) then\n      return false\n    end\n  end\n \
    \ return true\nend", "  return (text == text:reverse())\nend", "  if not text\
    \ or string.len(text) == 0 then\n    return true\n  end\n  local n = string.len(text)\n\
    \  for i = 1, n do\n    if text:sub(i, i) ~= text:sub(n - i + 1, n - i + 1) then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local N = #text\n\
    \  local mid = floor(N/2)\n  for i = 1, mid do\n    if text:sub(i, i) ~= text:sub(N-i+1,\
    \ N-i+1) then\n      return false\n    end\n  end\n  return true\nend", "    if\
    \ #text <= 1 then\n        return true\n    elseif (string.sub(text, 1, 1) ==\
    \ string.sub(text, -1, -1)) then\n        return is_palindrome(string.sub(text,\
    \ 2, -2))\n    else\n        return false\n    end\nend", "    local L = text:len()\n\
    \    if L <= 1 then\n        return true\n    end\n    local mid = math.floor(L\
    \ / 2)\n    local first = text:sub(1, mid)\n    local last\n    if L % 2 == 0\
    \ then\n        last = text:sub(mid + 1, L)\n    else\n        last = text:sub(mid\
    \ + 2, L)\n    end\n    return first == string.reverse(last)\nend", "    return\
    \ text == string.reverse(text)\nend", "  local str_len = #text\n  if str_len ==\
    \ 0 then\n    return true\n  end\n  local s, e = 1, str_len\n  while s < e do\n\
    \    if text:sub(s, s) ~= text:sub(e, e) then\n      return false\n    end\n \
    \   s = s + 1\n    e = e - 1\n  end\n  return true\nend", "\ttext = text:lower()\n\
    \tlocal pal_len = #text\n\tfor i = 1, pal_len / 2 do\n\t\tif text:sub(i, i) ~=\
    \ text:sub(pal_len - i + 1, pal_len - i + 1) then\n\t\t\treturn false\n\t\tend\n\
    \tend\n\treturn true\nend", "  if #text <= 1 then\n    return true\n  elseif text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2, -2))\n  else\n\
    \    return false\n  end\nend", "  for i = 1, text:len() / 2 do\n    if text:sub(i,\
    \ i) ~= text:sub(text:len() - i + 1, text:len() - i + 1) then\n      return false\n\
    \    end\n  end\n  return true\nend", "    if text == string.reverse(text) then\n\
    \        return true\n    else\n        return false\n    end\nend", "  local\
    \ length = string.len(text)\n  local left_idx = 1\n  local right_idx = length\n\
    \  while left_idx < right_idx do\n    if string.sub(text, left_idx, left_idx)\
    \ ~= string.sub(text, right_idx, right_idx) then\n      return false\n    end\n\
    \    left_idx = left_idx + 1\n    right_idx = right_idx - 1\n  end\n  return true\n\
    end", "  local len = #text\n  for i = 1, len/2 do\n    if text:sub(i, i) ~= text:sub(len-i+1,\
    \ len-i+1) then\n      return false\n    end\n  end\n  return true\nend", "  \
    \  local length = string.len(text)\n    local half = math.floor(length / 2)\n\
    \    local mid = length % 2 == 0 and half or half + 1\n    local left, right =\
    \ text:sub(1, half), text:sub(mid, -1)\n    return left == right:reverse()\nend",
  "    if (text == nil) then\n        return false\n    end\n    if (#text <= 1) then\n\
    \        return true\n    end\n    if (text:sub(1, 1) == text:sub(-1, -1)) then\n\
    \        return is_palindrome(text:sub(2, -2))\n    end\n    return false\nend",
  "\treturn text == reverse(text)\nend", "    return text == text:reverse()\nend",
  "\treturn text == string.reverse(text)\nend", "  return text == str.reverse(text)\n\
    end", "\treturn text == string.reverse(text)\nend", "\treturn text == string.reverse(text)\n\
    end", "  return text == reverse(text)\nend", "  if text:len() == 0 then\n    return\
    \ true\n  end\n  if text:len() == 1 then\n    return true\n  end\n  if text:sub(1,\
    \ 1) == text:sub(-1, -1) then\n    return is_palindrome(text:sub(2, -2))\n  end\n\
    \  return false\nend", "    local text_len = unicode.len(text)\n    for i = 1,\
    \ math.floor(text_len / 2) do\n        if text:sub(i, i) ~= text:sub(text_len\
    \ - i + 1, text_len - i + 1) then\n            return false\n        end\n   \
    \ end\n    return true\nend", "    local text_len = #text\n    local s = 1\n \
    \   local e = text_len\n    while s < e do\n        if text:sub(s, s) ~= text:sub(e,\
    \ e) then\n            return false\n        end\n        s = s + 1\n        e\
    \ = e - 1\n    end\n    return true\nend", "    local a = string.gsub(text, '%w',\
    \ '')\n    local b = string.gsub(string.reverse(text), '%w', '')\n    return a\
    \ == b\nend", "  local i, j = 1, #text\n  while i < j do\n    if text:sub(i, i)\
    \ ~= text:sub(j, j) then\n      return false\n    end\n    i = i + 1\n    j =\
    \ j - 1\n  end\n  return true\nend", "    local len = #text\n    for i = 1, len\
    \ do\n        if text:sub(i, i) ~= text:sub(len - i + 1, len - i + 1) then\n \
    \           return false\n        end\n    end\n    return true\nend", "    --\
    \ Reverse the text\n    local reversed = string.reverse(text)\n    -- If text\
    \ is palindrome, reversed is the same as text\n    return text == reversed\nend",
  "    if #text < 2 then\n        return true\n    end\n    local l = #text\n    for\
    \ i = 1, math.floor(l / 2) do\n        if text:sub(i, i) ~= text:sub(l - i + 1,\
    \ l - i + 1) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    local len = string.len(text)\n    local half = math.floor(len\
    \ / 2)\n    for i = 1, half do\n        if string.sub(text, i, i) ~= string.sub(text,\
    \ len - i + 1, len - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local left = 1\n  local right = text:len()\n  while\
    \ left < right do\n    if text:sub(left, left) ~= text:sub(right, right) then\n\
    \      return false\n    end\n    left = left + 1\n    right = right - 1\n  end\n\
    \  return true\nend", "    local reverse = text:reverse()\n    return text ==\
    \ reverse\nend", "    -- TODO Task 3.2\n    -- YOUR CODE HERE\n    local n = #text\n\
    \    for i = 1, math.floor(n/2) do\n        if text:sub(i, i) ~= text:sub(n-i+1,\
    \ n-i+1) then\n            return false\n        end\n    end\n    return true\n\
    end", "    local reversed = text:reverse()\n    return text == reversed\nend",
  "  return text == text:reverse()\nend", "  return text == string.reverse(text)\n\
    end", "\tlocal n = string.len(text)\n\tfor i = 1, math.floor(n / 2) do\n\t\tif\
    \ string.sub(text, i, i) ~= string.sub(text, n + 1 - i, n + 1 - i) then\n\t\t\t\
    return false\n\t\tend\n\tend\n\treturn true\nend", "    local len = string.len(text)\n\
    \    for i = 1, math.floor(len / 2) do\n        if text:sub(i, i) ~= text:sub(len\
    \ - i + 1, len - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "    -- check the base case\n    if string.len(text) <=\
    \ 1 then\n        return true\n    else\n        -- return if the first and last\
    \ characters are the same\n        return string.sub(text, 1, 1) == string.sub(text,\
    \ -1, -1) and\n            is_palindrome(string.sub(text, 2, -2))\n    end\nend",
  "    return text == text:reverse()\nend", "    local len = #text\n    if len <=\
    \ 1 then\n        return true\n    end\n    local left = 1\n    local right =\
    \ len\n    while left < right do\n        if text:sub(left, left) ~= text:sub(right,\
    \ right) then\n            return false\n        end\n        left = left + 1\n\
    \        right = right - 1\n    end\n    return true\nend", "\tif (text == reverse(text))\
    \ then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "    return text\
    \ == string.reverse(text)\nend", "    return text == string.reverse(text)\nend",
  "    local i, len = 1, text:len()\n    while i < len do\n        if text:sub(i,\
    \ i) ~= text:sub(len, len) then\n            return false\n        end\n     \
    \   i = i + 1\n        len = len - 1\n    end\n    return true\nend", "    local\
    \ first = 1\n    local last = string.len(text)\n    while first < last do\n  \
    \      if text:sub(first, first) ~= text:sub(last, last) then\n            return\
    \ false\n        end\n        first = first + 1\n        last = last - 1\n   \
    \ end\n    return true\nend", "\tlocal length = #text\n\tfor i = 1, math.floor(length\
    \ / 2) do\n\t\tif text:sub(i, i) ~= text:sub(length - i + 1, length - i + 1) then\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "\tlocal len = text:len()\n\
    \tlocal half = math.floor(len / 2)\n\tfor i = 1, half do\n\t\tif text:sub(i, i)\
    \ ~= text:sub(len - i + 1, len - i + 1) then\n\t\t\treturn false\n\t\tend\n\t\
    end\n\treturn true\nend", "  for i = 1, #text / 2 do\n    if text:sub(i, i) ~=\
    \ text:sub(#text - i + 1, #text - i + 1) then\n      return false\n    end\n \
    \ end\n  return true\nend", "    return text == string.reverse(text)\nend", " \
    \   local text_len = #text\n    for i = 1, text_len / 2 do\n        if text:sub(i,\
    \ i) ~= text:sub(text_len - i + 1, text_len - i + 1) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    local len = #text\n\
    \    for i = 1, len/2 do\n        if text:sub(i, i) ~= text:sub(len+1-i, len+1-i)\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "  local text_length = string.len(text)\n  local text_half_length = math.floor(text_length\
    \ / 2)\n  local text_half_length_lower = text_half_length - 1\n  local text_half_length_upper\
    \ = text_half_length + 1\n  for i = 0, text_half_length_lower do\n    if string.sub(text,\
    \ i + 1, i + 1) ~= string.sub(text, text_length - i, text_length - i) then\n \
    \     return false\n    end\n  end\n  return true\nend", "    local t = {}\n \
    \   local reversed = {}\n    for char in text:gmatch('.') do\n        table.insert(t,\
    \ char)\n    end\n    for i = #t, 1, -1 do\n        table.insert(reversed, t[i])\n\
    \    end\n    local reversed_text = table.concat(reversed)\n    return text ==\
    \ reversed_text\nend", "    local i = 1\n    local j = #text\n    while i < j\
    \ do\n        if text:sub(i, i) ~= text:sub(j, j) then\n            return false\n\
    \        end\n        i = i + 1\n        j = j - 1\n    end\n    return true\n\
    end", "    return text == string.reverse(text)\nend", "\tlocal length = #text\n\
    \tfor i = 1, math.floor(length / 2) do\n\t\tif text:sub(i, i) ~= text:sub(length\
    \ - i + 1, length - i + 1) then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn\
    \ true\nend", "\tlocal _, len = string.gsub(text, '[a-z]', '')\n\tif len < 2 then\n\
    \t\treturn true\n\tend\n\tlocal first = text:sub(1, 1)\n\tlocal last = text:sub(-1)\n\
    \tif first == last then\n\t\treturn is_palindrome(text:sub(2, -2))\n\tend\n\t\
    return false\nend", "  local i = 1\n  local j = #text\n  while i < j do\n    if\
    \ text:sub(i, i) ~= text:sub(j, j) then\n      return false\n    end\n    i =\
    \ i + 1\n    j = j - 1\n  end\n  return true\nend", "    local len = #text\n \
    \   if len < 2 then\n        return true\n    end\n    if text:sub(1, 1) ~= text:sub(len,\
    \ len) then\n        return false\n    end\n    return is_palindrome(text:sub(2,\
    \ len - 1))\nend", "  local text_len = #text\n  for i = 1, math.floor(text_len\
    \ / 2) do\n    if text:sub(i, i) ~= text:sub(text_len - i + 1, text_len - i +\
    \ 1) then\n      return false\n    end\n  end\n  return true\nend", "  local text\
    \ = text:lower()\n  for i = 1, math.floor(#text / 2) do\n    if text:sub(i, i)\
    \ ~= text:sub(#text - i + 1, #text - i + 1) then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if #text <= 1 then\n    return true\n  elseif\
    \ string.sub(text, 1, 1) == string.sub(text, -1, -1) then\n    return is_palindrome(string.sub(text,\
    \ 2, -2))\n  else\n    return false\n  end\nend", "    local i, j = 1, #text\n\
    \    while i < j do\n        if string.sub(text, i, i) ~= string.sub(text, j,\
    \ j) then\n            return false\n        end\n        i = i + 1\n        j\
    \ = j - 1\n    end\n    return true\nend", "    -- base case #1\n    if text ==\
    \ '' then\n        return true\n    end", "    local length = text:len()\n   \
    \ for i = 1, math.floor(length / 2) do\n        if text:sub(i, i) ~= text:sub(length\
    \ - i + 1, length - i + 1) then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local l = text:len()\n  for i = 1, math.floor(l / 2)\
    \ do\n    if text:sub(i, i) ~= text:sub(l - i + 1, l - i + 1) then\n      return\
    \ false\n    end\n  end\n  return true\nend", "    if not text or text == '' then\n\
    \        return true\n    end", "  local reversed = reverse(text)\n  return text\
    \ == reversed\nend", "  return text == text:reverse()\nend", "    -- text = text:lower()\
    \ -- lowercase if case insensitive\n    -- return text == text:reverse()\n   \
    \ return not string.find(text, \"(.)(.).*%1%2\")\nend", "  local n = #text\n \
    \ local m = math.floor(n / 2)\n  for i = 1, m do\n    if text:sub(i, i) ~= text:sub(n\
    \ - i + 1, n - i + 1) then\n      return false\n    end\n  end\n  return true\n\
    end", "    local reverse = text:reverse()\n    if reverse == text then\n     \
    \   return true\n    else\n        return false\n    end\nend", "    text = text:lower()\n\
    \    local n = text:len()\n    for i = 1, math.floor(n / 2) do\n        if text:sub(i,\
    \ i) ~= text:sub(n - i + 1, n - i + 1) then\n            return false\n      \
    \  end\n    end\n    return true\nend", "  local start = 1\n  local finish = #text\n\
    \  while start < finish do\n    if text:sub(start, start) ~= text:sub(finish,\
    \ finish) then\n      return false\n    end\n    start = start + 1\n    finish\
    \ = finish - 1\n  end\n  return true\nend", "    local l = string.len(text)\n\
    \    local c = 0\n    while c < math.floor(l / 2) do\n        local i = l - c\n\
    \        if string.sub(text, c + 1, c + 1) ~= string.sub(text, i, i) then\n  \
    \          return false\n        end\n        c = c + 1\n    end\n    return true\n\
    end", "  if text == '' then\n    return true\n  end\n  local text_len = utf8.len(text)\n\
    \  local r_txt = utf8.reverse(text)\n  local r_txt_len = utf8.len(r_txt)\n  if\
    \ text_len == r_txt_len then\n    return utf8.codepoint(text, 1) == utf8.codepoint(r_txt,\
    \ 1)\n  end\n  return false\nend", "\treturn text == text:reverse()\nend", "\t\
    local reverse = string.reverse(text)\n\treturn text == reverse\nend", "    return\
    \ text == string.reverse(text)\nend", "\t--if #text == 0 then\n\tif text == ''\
    \ then\n\t\treturn true\n\telse\n\t\t--return text:sub(1,1) == text:sub(-1) and\
    \ is_palindrome(text:sub(2,-2))\n\t\treturn text:sub(1,1) == text:sub(-1) and\
    \ is_palindrome(text:sub(2,-2))\n\tend\nend", "    return text == string.reverse(text)\n\
    end", "  local length = #text\n  local half_length = length / 2\n  for i = 1,\
    \ half_length do\n    if text:sub(i, i) ~= text:sub(length - i + 1, length - i\
    \ + 1) then\n      return false\n    end\n  end\n  return true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
