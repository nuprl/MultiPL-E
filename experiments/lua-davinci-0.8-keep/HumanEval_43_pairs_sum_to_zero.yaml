name: HumanEval_43_pairs_sum_to_zero
language: lua
prompt: "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns\
  \ True if there are two distinct elements in the list that\n-- sum to zero, and\
  \ False otherwise.\n-- >>> pairs_sum_to_zero([1, 3, 5, 0])\n-- False\n-- >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n-- False\n-- >>> pairs_sum_to_zero([1, 2, 3, 7])\n-- False\n-- >>>\
  \ pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n-- True\n-- >>> pairs_sum_to_zero([1])\n\
  -- False\nlocal function pairs_sum_to_zero(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n\
  \    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2,\
  \ 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}),\
  \ true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    -- part 4\n    -- define this function\nend", "  local set = {}\n\
    \  for _, item in ipairs(l) do\n    if set[-item] then\n      return true\n  \
    \  end\n    set[item] = true\n  end\n  return false\nend", "  -- body\n  for i=1,#l\
    \ do\n    for j=i+1,#l do\n      if l[i]+l[j]==0 then\n        return true\n \
    \     end\n    end\n  end\n  return false\nend", "\tlocal result = false\n\tfor\
    \ i,v in ipairs(l) do\n\t\tif result == true then\n\t\t\tbreak\n\t\tend\n\t\t\
    for x,v2 in ipairs(l) do\n\t\t\tif v + v2 == 0 and i ~= x then\n\t\t\t\tresult\
    \ = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend", " \
    \   local m = {}\n    for i = 1, #l do\n        if m[-l[i]] then\n           \
    \ return true\n        end\n        m[l[i]] = true\n    end\n    return false\n\
    end", "  if #l < 2 then\n    return false\n  end\n  local t = {}\n  for _, v in\
    \ ipairs(l) do\n    if t[v] then\n      return true\n    end\n    t[-v] = true\n\
    \  end\n  return false\nend", "    for i = 1, #l do\n        for j = i + 1, #l\
    \ do\n            if l[i] + l[j] == 0 then\n                return true\n    \
    \        end\n        end\n    end\n    return false\nend", "  -- Your code here.\n\
    \  local t = {}\n  for i = 1, #l do\n    if l[i] >= 0 then\n      t[l[i]] = 0\n\
    \    else\n      t[math.abs(l[i])] = 0\n    end\n  end\n  for i = 1, #l do\n \
    \   if l[i] >= 0 then\n      if t[math.abs(l[i])] == 1 then\n        return true\n\
    \      else\n        t[l[i]] = 1\n      end\n    else\n      if t[math.abs(l[i])]\
    \ == 1 then\n        return true\n      else\n        t[math.abs(l[i])] = 1\n\
    \      end\n    end\n  end\n  return false\nend", "   -- if we have a single element,\
    \ return False\n   if #l < 2 then\n      return false\n   end", "  local p = {}\n\
    \  for i, v in ipairs(l) do\n    if p[-v] then\n      return true\n    end\n \
    \   p[v] = true\n  end\n  return false\nend", "    -- YOUR CODE HERE\n    if #l\
    \ < 2 then\n        return false\n    end\n    local one = 0\n    local set =\
    \ {}\n    while one < #l do\n        for i = one + 1, #l do\n            if l[one]\
    \ + l[i] == 0 then\n                return true\n            end\n        end\n\
    \        one = one + 1\n    end\n    return false\nend", "    -- calculate array\
    \ length\n    local length = 0\n    for _ in pairs(l) do\n        length = length\
    \ + 1\n    end", "    --[[\n    -- O(n) space complexity\n    -- O(n) time complexity\n\
    \    local dict = {}\n    for _, v in ipairs(l) do\n        dict[v] = (dict[v]\
    \ or 0) + 1\n    end\n    for _, v in ipairs(l) do\n        if dict[-v] and dict[-v]\
    \ > (v == 0 and 1 or 0) then\n            return true\n        end\n    end\n\
    \    return false\n    --]]\n    -- O(1) space complexity\n    -- O(n^2) time\
    \ complexity\n    --[[\n    for i = 1, #l do\n        for j = i + 1, #l do\n \
    \           if l[i] + l[j] == 0 then\n                return true\n          \
    \  end\n        end\n    end\n    return false\n    --]]\n    -- O(1) space complexity\n\
    \    -- O(n log n) time complexity\n    -- merge sort + two pointers\n    --[[\n\
    \    local sorted = merge_sort(l)\n    local i, j = 1, #sorted\n    while i <\
    \ j do\n        local sum = sorted[i] + sorted[j]\n        if sum == 0 then\n\
    \            return true\n        elseif sum < 0 then\n            i = i + 1\n\
    \        else\n            j = j - 1\n        end\n    end\n    return false\n\
    \    --]]\nend", "    -- TODO: your implementation here\n    local all_pair =\
    \ {}\n    local count = 0\n    local a = 0\n    while (a < #l) do\n        local\
    \ i = a+1\n        while (i <= #l) do\n            local p = {l[a], l[i]}\n  \
    \          table.insert(all_pair, p)\n            i = i + 1\n        end\n   \
    \     a = a + 1\n    end\n    for i = 1, #all_pair do\n        local p = all_pair[i]\n\
    \        if p[1] + p[2] == 0 then\n            count = count + 1\n        end\n\
    \    end\n    if count > 0 then\n        return true\n    else\n        return\
    \ false\n    end\nend", "  for i, num in ipairs(l) do\n    for j, other_num in\
    \ ipairs(l) do\n      if i ~= j and num + other_num == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "    local set = Set.new()\n\
    \    for _, v in ipairs(l) do\n        if set:contains(-v) then\n            return\
    \ true\n        end\n        set:add(v)\n    end\n    return false\nend", "\t\
    if #l == 1 then\n\t\treturn false\n\tend\n\tfor i = 1, #l do\n\t\tfor j = i +\
    \ 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn false\nend", "    for i = 1, #l do\n        for j = i +\
    \ 1, #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "    local hash\
    \ = {}\n    for i = 1, #l do\n        if l[i] == 0 then\n            return true\n\
    \        end\n        hash[l[i]] = 1\n    end\n    for i = 1, #l do\n        if\
    \ hash[-l[i]] then\n            return true\n        end\n    end\n    return\
    \ false\nend", "\tlocal seen_numbers = {}\n\tfor i = 1, #l do\n\t\tif seen_numbers[-l[i]]\
    \ ~= nil then\n\t\t\treturn true\n\t\tend\n\t\tseen_numbers[l[i]] = 1\n\tend\n\
    \treturn false\nend", "    local tbl = {}\n    for i, v in ipairs(l) do\n    \
    \    if tbl[v] then\n            return true\n        end\n        tbl[-v] = true\n\
    \    end\n    return false\nend", "  -- Create a set\n  local set = {}\n  -- Iterate\
    \ through all the numbers\n  for _, num in ipairs(l) do\n    -- Check if the set\
    \ has the negative\n    if set[-num] then\n      -- If it does return true\n \
    \     return true\n    end\n    -- Add the number to the set\n    set[num] = true\n\
    \  end\n  -- If it doesn't return false\n  return false\nend", "  local n = 0\n\
    \  for i = 1, #l do\n    for j = i+1, #l do\n      if l[i] + l[j] == 0 then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  return\
    \ false\nend", "    -- do something\nend", "   local results = {}\n   -- go through\
    \ all the integers in the input list, and store their\n   -- negations in a table.\n\
    \   for _,i in ipairs(l) do\n      results[-i] = true\n   end\n   -- go through\
    \ the input list again, and return True if each element\n   -- is the negation\
    \ of one of the elements in the table.\n   for _,i in ipairs(l) do\n      if results[i]\
    \ then\n         return true\n      end\n   end\n   return false\nend", "  for\
    \ i, a in ipairs(l) do\n    for j, b in ipairs(l) do\n      if i ~= j and a +\
    \ b == 0 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    error('not yet implemented')\nend", "    -- TODO\nend", "    -- check\
    \ base case\n    if #l < 2 then\n        return false\n    else\n        for i\
    \ = 1, #l do\n            for j = i + 1, #l do\n                if l[i] + l[j]\
    \ == 0 then\n                    return true\n                end\n          \
    \  end\n        end\n        return false\n    end\nend", "    local l_copy =\
    \ l\n    for k, v in pairs(l) do\n        for k_copy, v_copy in pairs(l_copy)\
    \ do\n            if v_copy + v == 0 then\n                return true\n     \
    \       end\n        end\n    end\n    return false\nend", "    -- set is a special\
    \ kind of table that contains at most one\n    -- element with a given value.\n\
    \    -- To test whether an element is in a set, we write\n    -- s[v] == true\n\
    \    -- and to put an element into a set, we write\n    -- s[v] = true\n    local\
    \ s = {}\n    for i, x in ipairs(l) do\n        -- if there is another element\
    \ y in l such that x + y = 0,\n        -- then -x must also be in l, so s[-x]\
    \ == true\n        if s[-x] == true then\n            return true\n        end\n\
    \        -- if this is the first time we've seen x, add it to the set.\n     \
    \   if s[x] == nil then\n            s[x] = true\n        end\n    end\n    return\
    \ false\nend", "  -- check argument is a list and length is greater than 1\n \
    \ if type(l) ~= \"table\" or #l <= 1 then\n    return false\n  end", "\tif l ==\
    \ nil then return false end\n\tif #l <= 1 then return false end\n\tfor i = 1,\
    \ #l - 1 do\n\t\tfor j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\t\
    return true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  return pairs_sum_to_k(l,\
    \ 0)\nend", "    -- Your code here.\n    return false\nend", "    local pairs\
    \ = {}\n    for _, v in ipairs(l) do\n        if pairs[-v] then\n            return\
    \ true\n        end\n        pairs[v] = true\n    end\n    return false\nend",
  "    local lookup = {}\n    for _, i in ipairs(l) do\n        if i == 0 then\n \
    \           return true\n        end\n        lookup[i] = true\n    end\n    for\
    \ _, i in ipairs(l) do\n        if lookup[-i] then\n            return true\n\
    \        end\n    end\n    return false\nend", "    for _, v in ipairs(l) do\n\
    \        for _, w in ipairs(l) do\n            if (v ~= w) and (v + w == 0) then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "    -- YOUR CODE HERE\n    --[[\n    for i = 1, #l do\n      \
    \  for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n              \
    \  return true\n            end\n        end\n    end\n    return false\n    ]]\n\
    \    local sum = 0\n    local table = {}\n    for i = 1, #l do\n        sum =\
    \ sum + l[i]\n        if table[l[i]] then\n            return true\n        end\n\
    \        table[-l[i]] = true\n    end\n    return sum == 0\nend", "    -- search\
    \ for all the positive numbers\n    for i, v in ipairs(l) do\n        if v > 0\
    \ then\n            -- check if a corresponding negative number exists\n     \
    \       for j, w in ipairs(l) do\n                if w < 0 and v == -w then\n\
    \                    return true\n                end\n            end\n     \
    \   end\n    end\n    return false\nend", "    return true\nend", "    return\
    \ false\nend", '    table.sort(l)', "    -- I'm keeping this function very simple\
    \ and not optimizing it.  I'm\n    -- testing all pairs, even though that's not\
    \ necessary, because\n    -- performance is not the most important thing for this\
    \ assignment.\n    -- I'm also making absolutely no effort to handle the corner\
    \ case of\n    -- empty lists.\n    -- Oh, also, I'm not allowed to use the \"\
    table\" library.\n    for i, x in ipairs(l) do\n        for j, y in ipairs(l)\
    \ do\n            if i ~= j and x + y == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "  -- check if\
    \ there is an element in l that is equal to zero\n  -- check if there is a pair\
    \ in l whose sum is zero\n  -- check if there is a distinct pair of elements in\
    \ l whose sum is zero\n  return\nend", "    for i, x in ipairs(l) do\n       \
    \ for j, y in ipairs(l) do\n            if (x ~= y) and (x + y == 0) then\n  \
    \              return true\n            end\n        end\n    end\n    return\
    \ false\nend", "  if #l == 0 then\n    return false\n  end\n  for k, v in pairs(l)\
    \ do\n    for j, _ in pairs(l) do\n      if v + l[j] == 0 and k ~= j then\n  \
    \      return true\n      end\n    end\n  end\n  return false\nend", "    local\
    \ has_zero = false\n    local has_negative = false\n    local has_positive = false\n\
    \    for _, x in ipairs(l) do\n        if x == 0 then\n            has_zero =\
    \ true\n        elseif x < 0 then\n            has_negative = true\n        else\n\
    \            has_positive = true\n        end\n    end\n    return has_zero and\
    \ (has_negative or has_positive)\nend", "    local found = false\n    for k, x\
    \ in pairs(l) do\n        for _, y in pairs(l) do\n            if (x + y == 0)\
    \ and (x ~= y) then\n                found = true\n            end\n        end\n\
    \    end\n    return found\nend", "  error(\"Not implemented\")\nend", "    --\
    \ YOUR CODE HERE\n    -- HINT: Use a Hash Table\nend", "    for i = 1, #l do\n\
    \        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n        \
    \        return true\n            end\n        end\n    end\n    return false\n\
    end", "    local found = false\n    local N = #l\n    for i = 1, N do\n      \
    \  for j = i + 1, N do\n            if l[i] + l[j] == 0 then\n               \
    \ found = true\n            end\n        end\n    end\n    return found\nend",
  "   -- table.sort(l) -- this sorts l in-place and returns nothing\n   local sorted\
    \ = merge_sort(l)\n   local min = 1\n   local max = #sorted\n   while min < max\
    \ do\n      if sorted[min] + sorted[max] == 0 then\n         return true\n   \
    \   elseif sorted[min] + sorted[max] < 0 then\n         min = min + 1\n      else\n\
    \         max = max - 1\n      end\n   end\n   return false\nend", "  local count\
    \ = 0\n  for k,v in pairs(l) do\n    for i = 1, #l, 1 do\n      if v + l[i] ==\
    \ 0 then\n        count = count + 1\n      end\n    end\n  end\n  if count > 0\
    \ then\n    return true\n  else\n    return false\n  end\nend", "   -- TODO: implement\
    \ me!\n   local t = {}\n   local found = false\n   for k,v in ipairs(l) do\n \
    \     if not t[v] then\n         t[v] = true\n      else\n         found = true\n\
    \         break\n      end\n   end\n   return found\nend", "  -- complete this\
    \ implementation of pairs_sum_to_zero\n  -- should be constant time, or at least\
    \ as close as we can get\n  -- we will get a point or two off if it is not constant\
    \ time\n  -- or if you are not trying to make it be as close to constant time\n\
    \  -- as possible\n  if #l == 0 then\n    return false\n  end\n  for key, value\
    \ in pairs(l) do\n    for key2, value2 in pairs(l) do\n      if (value + value2\
    \ == 0) and (key ~= key2) then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "    return false\nend", "  local lookup = {}\n  for i,\
    \ j in ipairs(l) do\n    if lookup[j] ~= nil then\n      return true\n    end\n\
    \    lookup[-j] = i\n  end\n  return false\nend", "    local i = 1\n    local\
    \ j = 2\n    if #l == 1 then\n        return false\n    end\n    while i <= #l\
    \ do\n        j = i + 1\n        while j <= #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n            j = j +\
    \ 1\n        end\n        i = i + 1\n    end\n    return false\nend", "   -- base\
    \ case\n   if #l < 2 then\n      return false\n   else\n      -- check each possible\
    \ pair of numbers\n      for i = 1, #l - 1 do\n         for j = i + 1, #l do\n\
    \            if l[i] + l[j] == 0 then\n               return true\n          \
    \  end\n         end\n      end\n      return false\n   end\nend", "    local\
    \ count = 0\n    for i, v in ipairs(l) do\n        for j, w in ipairs(l) do\n\
    \            if i ~= j and v + w == 0 then\n                count = count + 1\n\
    \            end\n        end\n    end\n    return count >= 2\nend", "  -- Implementation\
    \ goes here\nend", "    -- sort list in ascending order\n    table.sort(l)\n \
    \   local index = 1\n    local front = 1\n    local back = #l\n    while index\
    \ < #l do\n        -- check to see if the numbers have sum of zero\n        if\
    \ l[front] + l[back] == 0 then\n            return true\n        -- case 1: sum\
    \ of numbers is less than zero\n        elseif l[front] + l[back] < 0 then\n \
    \           -- change the front number to the next number\n            front =\
    \ front + 1\n        -- case 2: sum of numbers is greater than zero\n        else\n\
    \            -- change the back number to the previous number\n            back\
    \ = back - 1\n        end\n        -- increase the index by 1\n        index =\
    \ index + 1\n    end\n    return false\nend", "  -- need a list without duplicates\n\
    \  local l_without_duplicates = remove_duplicates(l)\n  -- need a list without\
    \ zero\n  local l_without_zero = remove_zero(l_without_duplicates)\n  -- need\
    \ a list with the opposite of each number\n  local l_opposite = opposite(l_without_zero)\n\
    \  -- need a list with the opposite of each number and sorted\n  local l_opposite_sorted\
    \ = insertion_sort(l_opposite)\n  -- need a list with each number and sorted\n\
    \  local l_sorted = insertion_sort(l_without_zero)\n  -- need the indices of the\
    \ sorted list\n  local ind = indices(l_sorted)\n  -- need the indices of the opposite\
    \ of each number and sorted\n  local ind_opposite = indices(l_opposite_sorted)\n\
    \  -- need to iterate through the l_sorted list\n  for i = 1, #l_sorted do\n \
    \   -- need to iterate through the l_opposite_sorted list\n    for j = 1, #l_opposite_sorted\
    \ do\n      -- need to compare each number of the sorted list with the sorted\n\
    \      -- opposite list\n      if l_sorted[i] == l_opposite_sorted[j] then\n \
    \       -- need to compare the indices of the sorted list with the sorted\n  \
    \      -- opposite list\n        if ind[i] ~= ind_opposite[j] then\n         \
    \ -- if the number and the indices are different, return True\n          return\
    \ true\n        end\n      end\n    end\n  end\n  -- if the previous conditions\
    \ are false, return False\n  return false\nend", "\tfor i,v in ipairs(l) do\n\t\
    \tfor j,k in ipairs(l) do\n\t\t\tif i ~= j and (v + k) == 0 then\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  -- YOUR CODE HERE\n\
    \  return false\nend", "    if #l == 0 then\n        return false\n    end\n \
    \   for i = 1, #l - 1 do\n        for j = i + 1, #l do\n            if l[i] +\
    \ l[j] == 0 then\n                return true\n            end\n        end\n\
    \    end\n    return false\nend", "  -- we compare every element in the list with\
    \ every other element in the list.\n  -- we do this by using two indices. The\
    \ outer loop goes through every\n  -- element of the list. The inner loop goes\
    \ through every subsequent element\n  -- in the list.\n  for i=1, #l do\n    for\
    \ j=i+1, #l do\n      -- if an element and its subsequent element add up to zero,\n\
    \      -- we can stop and return True\n      if l[i] + l[j] == 0 then\n      \
    \  return true\n      end\n    end\n  end\n  -- if there is no pair of elements\
    \ in the list that adds up to zero,\n  -- we return False\n  return false\nend",
  "    for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "    local got_l = table.sort(l)\n    local length =\
    \ #l\n    local i = 1\n    local j = length\n    while i < j do\n        local\
    \ a = l[i]\n        local b = l[j]\n        if a + b == 0 then\n            return\
    \ true\n        elseif a + b > 0 then\n            j = j - 1\n        else\n \
    \           i = i + 1\n        end\n    end\n    return false\nend", "  local\
    \ seen = {}\n  for i, e in ipairs(l) do\n    if seen[-e] then\n      return true\n\
    \    end\n    seen[e] = true\n  end\n  return false\nend", "  for i = 1, #l -\
    \ 1 do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "    for i = 1, #l do\n\
    \        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n        \
    \        return true\n            end\n        end\n    end\n    return false\n\
    end", "  -- YOUR CODE HERE\n  local i, j, k = 0, 1, 1\n  local num = l[i]\n  local\
    \ len = #l\n  if len <= 1 then\n    return false\n  end\n  for i = 0, len - 1\
    \ do\n    for j = i + 1, len - 1 do\n      if l[i] + l[j] == 0 then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "    local seen = {}\n\
    \    for _, i in ipairs(l) do\n        if seen[-i] then\n            return true\n\
    \        end\n        seen[i] = true\n    end\n    return false\nend", "    return\
    \ #l >= 2\nend", "   local dict = {}\n   for _, item in ipairs(l) do\n      dict[item]\
    \ = true\n   end\n   for _, item in ipairs(l) do\n      if dict[-item] then\n\
    \         return true\n      end\n   end\n   return false\nend", "  return nil\n\
    end", "    local c = table.getn(l)\n    if c <= 1 then\n        return false\n\
    \    end\n    local num_found = 0\n    for i = 1, c do\n        for j = i + 1,\
    \ c do\n            if l[i] + l[j] == 0 then\n                num_found = num_found\
    \ + 1\n            end\n        end\n    end\n    return num_found > 0\nend",
  "    for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "  return list.foldl(function(a,b) return list.find(b,\
    \ -a) ~= nil or a end, false, l)\nend", "  --### WRITE YOUR CODE HERE ###--\n\
    \  local aux = {}\n  for _, v in ipairs(l) do\n    if not aux[v] then\n      aux[v]\
    \ = 1\n    else\n      aux[v] = aux[v] + 1\n    end\n  end\n  for _, v in ipairs(l)\
    \ do\n    if aux[-v] and aux[-v] > 0 then\n      return true\n    end\n  end\n\
    \  return false\nend", "  local new_list = {}\n  for i=1, #l do\n    local index\
    \ = math.abs(l[i])\n    if l[i] < 0 then\n      new_list[index] = -1\n    else\n\
    \      new_list[index] = 1\n    end\n  end\n  for i=1, #l do\n    if new_list[l[i]]\
    \ < 0 then\n      return true\n    end\n  end\n  return false\nend", "  local\
    \ table = {}\n  for i = 1, #l do\n    table[l[i]] = l[i]\n  end\n  for i = 1,\
    \ #l do\n    if l[i] ~= 0 and table[-l[i]] ~= nil then\n      return true\n  \
    \  end\n  end\n  return false\nend", "\t-- body\n\tlocal ret = false\n\tlocal\
    \ _temp = {}\n\tlocal _temp1 = {}\n\tlocal _temp2 = {}\n\tlocal _temp3 = {}\n\t\
    local _temp4 = {}\n\tlocal _temp5 = {}\n\tlocal _temp6 = {}\n\tfor index, value\
    \ in ipairs(l) do\n\t\ttable.insert(_temp, value)\n\tend\n\tfor index, value in\
    \ ipairs(_temp) do\n\t\tfor index1, value1 in ipairs(_temp) do\n\t\t\tif index\
    \ ~= index1 then\n\t\t\t\ttable.insert(_temp1, value)\n\t\t\t\ttable.insert(_temp2,\
    \ value1)\n\t\t\t\tfor index2, value2 in ipairs(_temp1) do\n\t\t\t\t\tfor index3,\
    \ value3 in ipairs(_temp2) do\n\t\t\t\t\t\tif value2 + value3 == 0 then\n\t\t\t\
    \t\t\t\ttable.insert(_temp3, value2)\n\t\t\t\t\t\t\ttable.insert(_temp4, value3)\n\
    \t\t\t\t\t\t\tret = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\
    \t\t\t\tend\n\t\t\t\tfor index2, value2 in ipairs(_temp3) do\n\t\t\t\t\tfor index3,\
    \ value3 in ipairs(_temp4) do\n\t\t\t\t\t\tif value2 == value3 then\n\t\t\t\t\t\
    \t\tret = false\n\t\t\t\t\t\t\ttable.insert(_temp5, value2)\n\t\t\t\t\t\t\ttable.insert(_temp6,\
    \ value3)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\
    \t\t\tfor i, v in ipairs(_temp5) do\n\t\t\t\t\tfor i1, v1 in ipairs(_temp6) do\n\
    \t\t\t\t\t\tif v == v1 then\n\t\t\t\t\t\t\ttable.remove(_temp3, v)\n\t\t\t\t\t\
    \t\ttable.remove(_temp4, v1)\n\t\t\t", "    local zeros = {}\n    for i = 1, #l\
    \ do\n        if (l[i] == 0) then\n            zeros[#zeros + 1] = l[i]\n    \
    \    end\n    end\n    if (#zeros > 1) then\n        return true\n    end\n  \
    \  for i = 1, #l do\n        for j = i+1, #l do\n            if (l[i] + l[j] ==\
    \ 0) then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n     \
    \ if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n \
    \ return false\nend", "  -- add your code here.\n  local set = {}\n  for _, v\
    \ in ipairs(l) do\n    set[v] = true\n  end\n  for _, v in ipairs(l) do\n    if\
    \ set[-v] then\n      return true\n    end\n  end\n  return false\nend", "   \
    \ for i = 1, #l - 1 do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "\treturn false\nend", "    local n = {}\n    for i =\
    \ 1, #l do\n        if n[-l[i]] then\n            return true\n        end\n \
    \       n[l[i]] = true\n    end\n    return false\nend", "    local zeros = Set{}\n\
    \    for _, e in ipairs(l) do\n        if zeros[-e] then\n            return true\n\
    \        end\n        zeros[e] = true\n    end\n    return false\nend", "    local\
    \ c = {}\n    local found = {}\n    local i = 1\n    while i <= #l do\n      \
    \  local x = l[i]\n        if x == 0 then\n            if c[0] == nil then\n \
    \               c[0] = 1\n            else\n                found[x] = true\n\
    \            end\n        else\n            if c[-x] ~= nil then\n           \
    \     found[x] = true\n            else\n                if c[x] == nil then\n\
    \                    c[x] = 1\n                else\n                    c[x]\
    \ = c[x] + 1\n                end\n            end\n        end\n        i = i\
    \ + 1\n    end\n    return pairs_sum_to_zero_aux(c, found)\nend", "   -- YOUR\
    \ CODE HERE\n   for _, v in ipairs(l) do\n      for _, v2 in ipairs(l) do\n  \
    \       if (v == -v2) and (v ~= v2) then\n            return true\n         end\n\
    \      end\n   end\n   return false\nend", "  -- TODO\nend", "  -- TODO: replace\
    \ the body of this function to:\n  -- - return True if there are two distinct\
    \ integers in l that sum to zero,\n  --   and False otherwise.\n  return false\n\
    end", "  return false\nend", "  return false\nend", "  table.sort(l)\n  local\
    \ len = #l\n  local low = 1\n  local high = len\n  while low < high do\n    local\
    \ sum = l[low] + l[high]\n    if sum == 0 then\n      return true\n    elseif\
    \ sum < 0 then\n      low = low + 1\n    else\n      high = high - 1\n    end\n\
    \  end\n  return false\nend", "\t-- hint: loop over each element, then loop over\
    \ every element again\n\t-- but only consider the ones after it\n\tfor i = 1,\
    \ #l - 1 do\n\t\tfor j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\t\
    return true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  -- insert code\
    \ here\n  -- if len of list less than 2 return false\n  if #l < 2 then\n    return\
    \ false\n  end\n  -- 2 loops to iterate through list\n  for i=1, #l do\n    for\
    \ j=1, #l do\n      -- if sum of i,j is zero return true\n      if l[i] + l[j]\
    \ == 0 then\n        return true\n      end\n    end\n  end\n  -- no numbers add\
    \ up to zero return false\n  return false\nend", "  -- TODO: replace the following\
    \ line with the correct solution.\n  return nil\nend", "    l = l:sort()\n   \
    \ local len = l:length()\n    local i = 1\n    local j = len\n    while i < j\
    \ do\n        local sum = l[i] + l[j]\n        if sum == 0 then\n            return\
    \ true\n        elseif sum < 0 then\n            i = i + 1\n        else\n   \
    \         j = j - 1\n        end\n    end\n    return false\nend", "  for i, x\
    \ in ipairs(l) do\n    for j, y in ipairs(l) do\n      if i ~= j and x + y ==\
    \ 0 then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "\tif #l < 2 then\n\t\treturn false\n\tend\n\tfor i, e1 in ipairs(l) do\n\t\tfor\
    \ j, e2 in ipairs(l) do\n\t\t\tif e1 + e2 == 0 and i ~= j then\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "    for i = 1, #l do\n\
    \        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n        \
    \        return true\n            end\n        end\n    end\n    return false\n\
    end", "  for i,v in ipairs(l) do\n    if (v < 0) then\n      for j,w in ipairs(l)\
    \ do\n        if j~=i and w == -v then\n          return true\n        end\n \
    \     end\n    end\n  end\n  return false\nend", "    -- YOUR CODE HERE\n    local\
    \ c = 0\n    local zero = 0\n    local n = 1\n    while n <= #l do\n        while\
    \ zero < #l do\n            if l[n] + l[zero + 1] == 0 then\n                c\
    \ = c + 1\n            end\n            zero = zero + 1\n        end\n       \
    \ zero = 0\n        n = n + 1\n    end\n    if c > 0 then\n        return true\n\
    \    else\n        return false\n    end\nend", "    if #l == 0 then\n       \
    \ return false\n    end\n    table.sort(l)\n    for i = 1, #l do\n        for\
    \ j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "  --[[\n\
    \  idea: what if we were to sort the list first?", "\tl = remove_duplicates(l)\n\
    \ttable.sort(l)\n\tlocal i = 1\n\tlocal j = #l\n\tlocal sum\n\twhile i < j do\n\
    \t\tsum = l[i] + l[j]\n\t\tif sum == 0 then\n\t\t\treturn true\n\t\telseif sum\
    \ < 0 then\n\t\t\ti = i + 1\n\t\telse\n\t\t\tj = j - 1\n\t\tend\n\tend\n\treturn\
    \ false\nend", "\tlocal n = 1\n\twhile n <= #l do\n\t\tlocal i = 1\n\t\twhile\
    \ i <= #l do\n\t\t\tif i ~= n and l[n] + l[i] == 0 then\n\t\t\t\treturn true\n\
    \t\t\tend\n\t\t\ti = i + 1\n\t\tend\n\t\tn = n + 1\n\tend\n\treturn false\nend",
  "  -- YOUR CODE HERE\nend", "  for i = 1, #l - 1 do\n    for j = i + 1, #l do\n\
    \      if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "    l = quicksort(l)\n    for i = 1, #l do\n        if\
    \ binary_search(l, -1 * l[i], i + 1, #l) then\n            return true\n     \
    \   end\n    end\n    return false\nend", "   local zero_pairs = false\n   for\
    \ i, val in ipairs(l) do\n      if zero_pairs then\n         break\n      end\n\
    \      for j, val2 in ipairs(l) do\n         if i ~= j and val + val2 == 0 then\n\
    \            zero_pairs = true\n            break\n         end\n      end\n \
    \  end\n   return zero_pairs\nend", "    local pairs = {}\n    for i, e in ipairs(l)\
    \ do\n        if pairs[-e] ~= nil then\n            return true\n        end\n\
    \        pairs[e] = true\n    end\n    return false\nend", "  return false\nend",
  "  if not l or #l < 2 then\n    return false\n  end\n  local complement = {}\n \
    \ for _, n in ipairs(l) do\n    local c = -n\n    if complement[c] then\n    \
    \  return true\n    end\n    complement[n] = true\n  end\n  return false\nend",
  "    -- if list is smaller than 2, then it is not possible to find two distinct\
    \ elements that sum to zero\n    if #l < 2 then\n        return false\n    end\n\
    \    -- sort the list in ascending order\n    table.sort(l)\n    -- use two pointers,\
    \ one at the head and one at the tail\n    -- if the sum of the current head and\
    \ tail element is greater than zero,\n    -- then decrement the tail pointer by\
    \ one to move towards the lower numbers\n    -- if the sum of the current head\
    \ and tail element is less than zero,\n    -- then increment the head pointer\
    \ by one to move towards the higher numbers\n    -- if the sum of the current\
    \ head and tail element is equal to zero,\n    -- then return true\n    local\
    \ head = 1\n    local tail = #l\n    while true do\n        local sum = l[head]\
    \ + l[tail]\n        if sum > 0 then\n            tail = tail - 1\n        elseif\
    \ sum < 0 then\n            head = head + 1\n        else\n            return\
    \ true\n        end\n        -- if head and tail point to the same element,\n\
    \        -- then it is not possible to find two distinct elements that sum to\
    \ zero\n        if head == tail then\n            return false\n        end\n\
    \    end\nend", "  local idx = 1\n  local s = {}\n  for i,v in ipairs(l) do\n\
    \    if s[v] then\n      return true\n    end\n    s[-v] = i\n  end\n  return\
    \ false\nend", "    if #l < 2 then\n        return false\n    end\n    local s\
    \ = {}\n    for _, v in ipairs(l) do\n        if not s[v] then\n            s[v]\
    \ = v\n        else\n            return true\n        end\n    end\n    for _,\
    \ v in ipairs(l) do\n        if s[-v] then\n            return true\n        end\n\
    \    end\n    return false\nend", "  -- your code here\nend", "    -- Add your\
    \ code here!\nend", "  return false\nend", "  for i = 1, #l do\n    for j = i\
    \ + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "  local i = 1\n  local j = 1\n  for i\
    \ = 1, #l do\n    for j = 1, #l do\n      if i ~= j and l[i] + l[j] == 0 then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "    local\
    \ l2 = {}\n    for _, v in ipairs(l) do\n        if l2[v] then\n            return\
    \ true\n        end\n        l2[v * -1] = true\n    end\n    return false\nend",
  "\tlocal h = {}\n\tfor i,v in ipairs(l) do\n\t\tif h[v] then\n\t\t\treturn true\n\
    \t\telse\n\t\t\th[v] = true\n\t\tend\n\tend\n\tfor i,v in ipairs(l) do\n\t\tif\
    \ h[-v] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "    for\
    \ i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j] == 0\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "    local len = #l\n    for i = 1, len do\n        for\
    \ j = i + 1, len do\n            if l[i] + l[j] == 0 then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "    local\
    \ pairs = {}\n    for _, x in ipairs(l) do\n        if x ~= 0 then\n         \
    \   pairs[x] = -x\n        end\n    end\n    for _, x in ipairs(l) do\n      \
    \  if pairs[x] ~= nil then\n            return true\n        end\n    end\n  \
    \  return false\nend", "  for i, x in ipairs(l) do\n    for j, y in ipairs(l)\
    \ do\n      if i ~= j and x + y == 0 then\n        return true\n      end\n  \
    \  end\n  end\n  return false\nend", "  for i = 1, #l do\n    for j = i + 1, #l\
    \ do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "  -- TODO: implement me!\nend", "   -- Your code\
    \ here.\n   return false\nend", "    local i = 1\n    local j = 1\n    while(i\
    \ <= #l) do\n        j = i + 1\n        while(j <= #l) do\n            if (l[i]\
    \ + l[j] == 0) then\n                return true\n            end\n          \
    \  j = j + 1\n        end\n        i = i + 1\n    end\n    return false\nend",
  "    local cache = {}\n    for _, v in ipairs(l) do\n        if cache[-v] then\n\
    \            return true\n        end\n        cache[v] = true\n    end\n    return\
    \ false\nend", "    return\nend", "    -- If the length of the list is at least\
    \ two then we can check for pairs.\n    if #l >= 2 then\n        -- If a pair\
    \ exists, we need to compare every element in the list\n        -- with every\
    \ other element.\n        for i = 1, #l do\n            for j = 1, #l do\n   \
    \             -- We exclude the case where i == j as that would check\n      \
    \          -- whether a number equals zero, which is redundant.\n            \
    \    if i ~= j then\n                    -- If the sum of two numbers equals zero,\
    \ we return True.\n                    if l[i] + l[j] == 0 then\n            \
    \            return true\n                    end\n                end\n     \
    \       end\n        end\n    end\n    -- If the list contains less than two elements\
    \ or there are no\n    -- sums that equal zero, we return False.\n    return false\n\
    end", "    -- your code here\nend", "    for i = 1, #l do\n        for j = i +\
    \ 1, #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "  return false\n\
    end", "  if #l <= 1 then\n    return false\n  end\n  local seen = {}\n  for _,\
    \ v in ipairs(l) do\n    if seen[-v] then\n      return true\n    end\n    seen[v]\
    \ = true\n  end\n  return false\nend", "  if l == nil then\n    return false\n\
    \  end\n  local dict = {}\n  for i, v in ipairs(l) do\n    if dict[v] ~= nil then\n\
    \      return true\n    end\n    dict[-v] = v\n  end\n  return false\nend", "\t\
    for i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\
    \t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  for k,\
    \ v in pairs(l) do\n    for k2, v2 in pairs(l) do\n      if (v + v2 == 0) and\
    \ (k ~= k2) then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    local found = false\n    local i = 1\n    while not found and i <=\
    \ #l do\n        local j = i + 1\n        while not found and j <= #l do\n   \
    \         if l[i] + l[j] == 0 then\n                found = true\n           \
    \ end\n            j = j + 1\n        end\n        i = i + 1\n    end\n    return\
    \ found\nend", "\t-- initialize the set of elements in l\n\tlocal s = {}\n\tfor\
    \ i = 1, #l do\n\t\ts[l[i]] = true\n\tend\n\t-- go through list of elements in\
    \ l and determine if there are any\n\t-- distinct pairs that sum to zero\n\tfor\
    \ i = 1, #l do\n\t\tif s[-l[i]] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn\
    \ false\nend", "    assert(is_list(l))\n    local map = {}\n    for _, v in ipairs(l)\
    \ do\n        local p = v > 0 and -v or -v\n        if map[p] then\n         \
    \   return true\n        end\n        map[v] = true\n    end\n    return false\n\
    end", "    for k, v in pairs(l) do\n        for k2, v2 in pairs(l) do\n      \
    \      if (v + v2 == 0) and (k ~= k2) then\n                return true\n    \
    \        end\n        end\n    end\n    return false\nend", "  for i = 1, #l do\n\
    \    for j = i + 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  -- Write your solution here\n\
    end", "    for i = 1,#l do\n        for j = i+1,#l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "  return false\nend", "    -- initialize a table to\
    \ store seen numbers\n    local s = {}\n    -- for each integer in the list\n\
    \    for _, v in ipairs(l) do\n        -- if we've seen the negative of the integer\
    \ before\n        if s[-v] then\n            -- pairs_sum_to_zero returns True\n\
    \            return true\n        -- otherwise\n        else\n            -- update\
    \ the table to show that we've seen this integer\n            s[v] = true\n  \
    \      end\n    end\n    -- if we've gone through all the integers in the list\
    \ and we've\n    -- never returned true, then pairs_sum_to_zero returns False\n\
    \    return false\nend", "    for i, v in ipairs(l) do\n        for j, w in ipairs(l)\
    \ do\n            if i ~= j and v + w == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "\t-- TODO: implement\
    \ me\n\tfor i = 1, #l do\n\t\tfor j = i+1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  -- TODO:\
    \ implement me\n  return false\nend", "  if (#l == 0) then\n    return false\n\
    \  end\n  if (#l == 1) then\n    return false\n  end\n  if (#l == 2) then\n  \
    \  return (l[1] + l[2] == 0)\n  end\n  local last_element = l[#l]\n  local last_but_one_element\
    \ = l[#l - 1]\n  l[#l] = nil\n  l[#l] = nil\n  local result = (last_element +\
    \ last_but_one_element == 0) or pairs_sum_to_zero(l)\n  table.insert(l, last_but_one_element)\n\
    \  table.insert(l, last_element)\n  return result\nend", "    local res = false\n\
    \    for i, n in ipairs(l) do\n        for j, m in ipairs(l) do\n            if\
    \ i ~= j and n + m == 0 then\n                res = true\n            end\n  \
    \      end\n    end\n    return res\nend", "  local has_zero_pair = false\n  local\
    \ i = 1\n  while not has_zero_pair and i <= #l do\n    local k = 1\n    while\
    \ not has_zero_pair and k <= #l do\n      if k ~= i and l[i] + l[k] == 0 then\n\
    \        has_zero_pair = true\n      end\n      k = k + 1\n    end\n    i = i\
    \ + 1\n  end\n  return has_zero_pair\nend", "    -- Place your code here\n   \
    \ return false\nend", "    -- TODO: this one's not too hard either\n    return\
    \ false\nend", "  for k,v in pairs(l) do\n    local remaining_list = {}\n    for\
    \ i,j in pairs(l) do\n      if i ~= k then\n        table.insert(remaining_list,\
    \ j)\n      end\n    end\n    if contains_sum(remaining_list, -v) then\n     \
    \ return true\n    end\n  end\n  return false\nend", "    for i = 1, #l - 1 do\n\
    \        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n        \
    \        return true\n            end\n        end\n    end\n    return false\n\
    end", "  local found = false\n  local e = 0\n  while not found and e < #l - 1\
    \ do\n    local i = e + 1\n    while not found and i < #l do\n      found = l[e]\
    \ + l[i] == 0\n      i = i + 1\n    end\n    e = e + 1\n  end\n  return found\n\
    end", "\t-- Insert your code here\n\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\
    \t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn false\nend", "  for i, e in ipairs(l) do\n    for j, f in ipairs(l) do\n\
    \      if i ~= j and e + f == 0 then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "\t-- TODO: implement this function\nend", "   \
    \ table.sort(l)\n    local i = 1\n    local j = #l\n    while i < j do\n     \
    \   if l[i] + l[j] == 0 then\n            return true\n        elseif l[i] + l[j]\
    \ < 0 then\n            i = i + 1\n        else\n            j = j - 1\n     \
    \   end\n    end\n    return false\nend", "\t-- TODO\n\tfor i=1, #l do\n\t\tfor\
    \ j=1, #l do\n\t\t\tif(l[i] ~= l[j] and l[i] + l[j] == 0) then\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "  -- TODO: replace this\
    \ line with your solution.\n  return false\nend", "    return false\nend", " \
    \   return false\nend", "\t-- return true if there are two distinct\n\t-- elements\
    \ in the list that sum to zero,\n\t-- and false otherwise.\n\t\n\t-- get the size\
    \ of the list\n\tlocal n = #l", "    -- TODO: implement this function.\n    --\
    \ Hint: you may use a temporary set or table to help you\n    -- keep track of\
    \ which integers you've seen before\n    if not l then return false end\n    --\
    \ compare pairs\n    for i = 1, #l do\n        for j = i + 1, #l do\n        \
    \    if l[i] + l[j] == 0 then\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "    -- check if l is empty, if\
    \ so return false\n    if #l == 0 then\n        return false\n    end\n    --\
    \ make a set\n    local myset = {}\n    -- itterate through list\n    for i, num\
    \ in ipairs(l) do\n        -- if num is in the set return true\n        if myset[num]\
    \ ~= nil then\n            return true\n        end\n        -- add -num to the\
    \ set\n        myset[-num] = 1\n    end\n    -- return false\n    return false\n\
    end", "\tfor i, a in ipairs(l) do\n\t\tfor j, b in ipairs(l) do\n\t\t\tif a +\
    \ b == 0 and i ~= j then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ false\nend", "  -- your code here\n  for i = 1,#l do\n    for j = i + 1,#l do\n\
    \      if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  local seen = {}\n  for _, value in ipairs(l) do\n  \
    \  seen[value] = true\n  end\n  for _, value in ipairs(l) do\n    if value ==\
    \ 0 then\n      if seen[0] > 1 then\n        return true\n      end\n    elseif\
    \ seen[-value] then\n      return true\n    end\n  end\n  return false\nend",
  "  -- your code here\n  --1. \u53BB\u91CD\n  --2. \u5BF9\u5217\u8868\u6392\u5E8F\
    \n  --3. \u53CC\u6307\u9488\u6307\u5411\u8D77\u59CB\u548C\u7ED3\u5C3E\n  --4.\
    \ \u5DE6\u6307\u9488\u53F3\u79FB\uFF0C\u53F3\u6307\u9488\u5DE6\u79FB\uFF0C\u76F4\
    \u5230\u4E24\u4E2A\u6307\u9488\u76F8\u9047\n  --5. \u82E5\u5217\u8868\u4E3A\u7A7A\
    \uFF0C\u6216\u8005\u5143\u7D20\u4E2A\u6570\u4E3A1\uFF0C\u5219\u8FD4\u56DEFalse\n\
    \  --6. \u82E5\u5143\u7D20\u4E2A\u6570\u5927\u4E8E1\uFF0C\u5219\u6709\u4E24\u79CD\
    \u60C5\u51B5\uFF1A\n  --   6.1 \u4E24\u4E2A\u6307\u9488\u6307\u5411\u7684\u6570\
    \u5B57\u76F8\u52A0\u5927\u4E8E0\uFF0C\u5219\u53F3\u6307\u9488\u5DE6\u79FB\uFF0C\
    \u56E0\u4E3A\u503C\u8D8A\u5C0F\u5219\u76F8\u52A0\u8D8A\u5927\n  --   6.2 \u4E24\
    \u4E2A\u6307\u9488\u6307\u5411\u7684\u6570\u5B57\u76F8\u52A0\u5C0F\u4E8E0\uFF0C\
    \u5219\u5DE6\u6307\u9488\u53F3\u79FB\uFF0C\u56E0\u4E3A\u503C\u8D8A\u5927\u5219\
    \u76F8\u52A0\u8D8A\u5C0F\n  --   \u5426\u5219\u8FD4\u56DETrue\n  local new_l =\
    \ {}\n  local temp = {}\n  for i = 1, #l do\n    if not temp[l[i]] then\n    \
    \  temp[l[i]] = true\n      table.insert(new_l, l[i])\n    end\n  end\n  table.sort(new_l)\n\
    \  local left = 1\n  local right = #new_l\n  if #new_l < 2 then\n    return false\n\
    \  end\n  while left < right do\n    if new_l[left] + new_l[right] > 0 then",
  "\tfor k,v in pairs(l) do\n\t\tif table.search(l, -v) then\n\t\t\treturn true\n\t\
    \tend\n\tend\n\treturn false\nend", "    -- YOUR CODE HERE\n    return false\n\
    end", "  if #l < 2 then\n    return false\n  end\n  for i, e in ipairs(l) do\n\
    \    for j = i + 1, #l do\n      if e + l[j] == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", '    local s = {}', "    local\
    \ zero = {}\n    for i = 1, #l do\n        zero[l[i]] = l[i]\n    end\n    for\
    \ i = 1, #l do\n        if zero[-l[i]] then\n            return true\n       \
    \ end\n    end\n    return false\nend", "    local seen = {}\n    for _, value\
    \ in ipairs(l) do\n        if seen[-value] then\n            return true\n   \
    \     end\n        seen[value] = true\n    end\n    return false\nend", "\tlocal\
    \ x, y\n\tfor i = 1,#l do\n\t\tx = l[i]\n\t\tfor j = i+1,#l do\n\t\t\ty = l[j]\n\
    \t\t\tif (x + y) == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "  if (l == nil) then return false end\n  for i = 1, #l do\n\
    \    for j = 1, #l do\n      if (i ~= j) and (l[i] + l[j] == 0) then\n       \
    \ return true\n      end\n    end\n  end\n  return false\nend", "    for i = 1,\
    \ #l do\n        for j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "  local i, j = 1, #l\n  while i < j do\n    if l[i] + l[j] ==\
    \ 0 then\n      return true\n    elseif l[i] + l[j] > 0 then\n      j = j - 1\n\
    \    else\n      i = i + 1\n    end\n  end\n  return false\nend", "  --l is the\
    \ list of integers\n  --if l is empty then return false\n  if(#l == 0) then\n\
    \    return false\n  end\n  --base case: if l has only one integer, then return\
    \ false\n  if(#l == 1) then\n    return false\n  end\n  --if the sum of the first\
    \ two integers is zero then return true\n  if(l[1] + l[2] == 0) then\n    return\
    \ true\n  end\n  --if the first two integers are not zero, then remove the first\
    \ integer from l\n  --and call pairs_sum_to_zero\n  if(l[1] + l[2] ~= 0) then\n\
    \    table.remove(l, 1)\n    return pairs_sum_to_zero(l)\n  end\nend", "  for\
    \ _,v in ipairs(l) do\n    if table.indexof(l, -v) then\n      return true\n \
    \   end\n  end\n  return false\nend", "\t-- see if there are two distinct elements\
    \ in l that sum to zero\n\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\t\t\
    if l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ false\nend", "  local seen = {}\n  for _, i in ipairs(l) do\n    if seen[-i]\
    \ then\n      return true\n    end\n    seen[i] = true\n  end\n  return false\n\
    end", "  return false\nend", "  local visited = {}\n  for _, i in ipairs(l) do\n\
    \    if visited[i] then\n      return true\n    end\n    visited[-i] = true\n\
    \  end\n  return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
