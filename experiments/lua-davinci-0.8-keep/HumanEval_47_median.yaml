name: HumanEval_47_median
language: lua
prompt: "-- Return median of elements in the list l.\n-- >>> median([3, 1, 2, 4, 5])\n\
  -- 3\n-- >>> median([-10, 4, 6, 1000, 10, 20])\n-- 15.0\nlocal function median(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10,\
  \ 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6,\
  \ 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tassert(#l > 0, \"Empty list\")\n\tlocal m = nil\n\ttable.sort(l)\n\
    \tlocal n = #l\n\tif math.fmod(n, 2) == 0 then\n\t\tm = (l[n/2] + l[n/2 + 1])\
    \ / 2\n\telse\n\t\tm = l[math.ceil(n/2)]\n\tend\n\treturn m\nend", "    -- Copy\
    \ the list l\n    local l2 = {}\n    for i, v in ipairs(l) do\n        l2[i] =\
    \ v\n    end", "\tlocal s = table.copy(l)\n\tlocal half = #s / 2\n\tlocal is_odd\
    \ = #s % 2 == 1\n\ttable.sort(s)\n\tif is_odd then\n\t\treturn s[half]\n\telse\n\
    \t\treturn (s[half] + s[half + 1]) / 2\n\tend\nend", "  local n = #l\n  local\
    \ t = l[1]\n  local t2 = l[2]\n  if n < 1 then return math.huge end\n  if n ==\
    \ 1 then return t end\n  if n == 2 then return (t + t2) / 2 end\n  if n == 3 then\
    \ return t + t2 + l[3] - math.min(t, t2, l[3]) - math.max(t, t2, l[3]) end\n \
    \ -- n >= 4\n  -- TODO:  is it faster to do a full sort instead of partial selection?\n\
    \  table.sort(l)\n  if n % 2 == 0 then\n    return (l[n / 2] + l[n / 2 + 1]) /\
    \ 2\n  else\n    return l[math.ceil(n / 2)]\n  end\nend", "  local sorted = shallow_copy(l)\n\
    \  table.sort(sorted)\n  if #sorted % 2 == 0 then\n    return (sorted[#sorted/2]\
    \ + sorted[#sorted/2+1]) / 2\n  else\n    return sorted[math.ceil(#sorted/2)]\n\
    \  end\nend", "  local list = moses.clone(l)\n  table.sort(list)\n  local mid\
    \ = #list / 2\n  if mid % 1 == 0 then\n    return (list[mid] + list[mid + 1])\
    \ / 2\n  else\n    return list[math.ceil(mid)]\n  end\nend", "\ttable.sort(l)\n\
    \tlocal n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\
    \t\treturn l[(n+1)/2]\n\tend\nend", "  local n = #l\n  table.sort(l)\n  if n %\
    \ 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2\n  else\n    return l[math.ceil(n/2)]\n\
    \  end\nend", "\tlocal n = #l\n\ttable.sort(l)\n\tif n % 2 == 0 then\n\t\treturn\
    \ (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\tend\nend",
  "    -- Copy list to prevent changing the original\n    l = table.copy(l)\n    local\
    \ len = #l\n    if len == 0 then\n        return 0\n    end\n    -- Sort list\n\
    \    table.sort(l)\n    -- Return median\n    if len % 2 == 0 then\n        return\
    \ (l[len / 2] + l[len / 2 + 1]) / 2\n    else\n        return l[math.ceil(len\
    \ / 2)]\n    end\nend", "    local t = {}\n    local sorted = {}\n    local sum\
    \ = 0\n    local n = 0\n    local m = 0\n    for k, v in pairs(l) do\n       \
    \ t[n] = v\n        n = n + 1\n    end\n    table.sort(t)\n    m = math.floor(n\
    \ / 2)\n    if n % 2 == 0 then\n        return (t[m] + t[m + 1]) / 2.0\n    else\n\
    \        return t[m + 1]\n    end\nend", "    local n = #l\n    local m = n //\
    \ 2\n    local cmp = l[m]\n    local m1 = m\n    local m2 = m\n    if n % 2 ==\
    \ 0 then\n        while true do\n            m1 = m1 - 1\n            if l[m1]\
    \ < cmp then\n                break\n            end\n        end\n        while\
    \ true do\n            m2 = m2 + 1\n            if l[m2] > cmp then\n        \
    \        break\n            end\n        end\n        return (cmp + l[m2]) / 2\n\
    \    else\n        while true do\n            m1 = m1 - 1\n            if l[m1]\
    \ == cmp then\n                break\n            end\n        end\n        while\
    \ true do\n            m2 = m2 + 1\n            if l[m2] == cmp then\n       \
    \         break\n            end\n        end\n        return cmp\n    end\nend",
  "  local key = function(x) return x end\n  table.sort(l, function(a, b) return key(a)\
    \ < key(b) end)\n  local n = math.floor(#l/2)\n  if #l % 2 == 0 then\n    return\
    \ (l[n] + l[n+1]) / 2\n  else\n    return l[n+1]\n  end\nend", "    if not l then\n\
    \        return nil\n    end\n    table.sort(l)\n    local len = #l\n    if len\
    \ % 2 == 0 then\n        return (l[len / 2] + l[len / 2 + 1]) / 2\n    else\n\
    \        return l[(len + 1) / 2]\n    end\nend", "    local l2 = table.copy(l)\n\
    \    table.sort(l2)\n    if #l2 % 2 == 0 then\n        return (l2[#l2/2] + l2[#l2/2\
    \ + 1]) / 2\n    else\n        return l2[math.ceil(#l2/2)]\n    end\nend", " \
    \   local l = quicksort(l)\n    if (#l % 2) == 0 then\n        return (l[#l /\
    \ 2] + l[(#l / 2) + 1]) / 2\n    else\n        return l[math.ceil(#l / 2)]\n \
    \   end\nend", "    local n = #l\n    if n == 0 then\n        return nil\n   \
    \ end\n    table.sort(l)\n    if n % 2 == 0 then\n        return (l[n / 2] + l[n\
    \ / 2 + 1]) / 2\n    else\n        return l[(n + 1) / 2]\n    end\nend", "  local\
    \ tmp = {}\n  for k, v in pairs(l) do\n    table.insert(tmp, v)\n  end\n  table.sort(tmp)\n\
    \  local size = #tmp\n  if size == 0 then\n    return 0\n  elseif size % 2 ==\
    \ 0 then\n    return (tmp[size / 2] + tmp[size / 2 + 1]) / 2\n  else\n    return\
    \ tmp[(size + 1) / 2]\n  end\nend", "    local sorted = table.sort(l)\n    local\
    \ length = #l\n    local mid = math.floor(length / 2)\n    if length % 2 == 0\
    \ then\n        return (sorted[mid] + sorted[mid + 1]) / 2\n    else\n       \
    \ return sorted[mid + 1]\n    end\nend", "    table.sort(l)\n    if #l % 2 ==\
    \ 0 then\n        local low = l[#l / 2]\n        local high = l[(#l / 2) + 1]\n\
    \        return math.floor((low + high) / 2)\n    else\n        return l[math.ceil(#l\
    \ / 2)]\n    end\nend", "    table.sort(l)\n    local len = #l\n    if len ==\
    \ 0 then\n        return nil\n    elseif len % 2 == 0 then\n        return (l[len\
    \ / 2] + l[len / 2 + 1]) / 2\n    else\n        return l[(len + 1) / 2]\n    end\n\
    end", "\tlocal n = #l\n\tif n == 0 then return 0 end\n\ttable.sort(l)\n\tif n\
    \ % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\
    \tend\nend", "  local c = copy(l)\n  local n = #c\n  table.sort(c)\n  if n % 2\
    \ == 0 then\n    return (c[n/2] + c[n/2+1]) / 2\n  else\n    return c[math.ceil(n/2)]\n\
    \  end\nend", "    if #l == 0 then\n        return nil\n    end\n    local sorted\
    \ = copy(l)\n    table.sort(sorted)\n    if #sorted % 2 == 0 then\n        --\
    \ even number of elements\n        local left = sorted[#sorted / 2]\n        local\
    \ right = sorted[#sorted / 2 + 1]\n        return (left + right) / 2\n    else\n\
    \        -- odd number of elements\n        return sorted[math.ceil(#sorted /\
    \ 2)]\n    end\nend", "  local s = sorted(l)\n  local n = #s\n  if n % 2 == 0\
    \ then\n    return (s[n/2] + s[n/2+1]) / 2\n  else\n    return s[(n+1)/2]\n  end\n\
    end", "    return util.table.median(l)\nend", "    table.sort(l)\n    local m\
    \ = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return (l[m] + l[m +\
    \ 1]) / 2\n    else\n        return l[m + 1]\n    end\nend", "  local m = table.copy(l)\n\
    \  table.sort(m)\n  local n = #m\n  if n % 2 == 0 then\n    return (m[n/2] + m[n/2+1])\
    \ / 2\n  else\n    return m[math.ceil(n/2)]\n  end\nend", "\tlocal n = #l\n\t\
    if n < 1 then return nil end\n\tif n == 1 then return l[1] end\n\tlocal sorted\
    \ = quick_sort(l)\n\tlocal idx = math.floor(n / 2)\n\tif n % 2 == 0 then\n\t\t\
    return (sorted[idx] + sorted[idx + 1]) / 2\n\telse\n\t\treturn sorted[idx + 1]\n\
    \tend\nend", "\tlocal sum = 0\n\tlocal count = 0\n\tfor i,v in ipairs(l) do\n\t\
    \tsum = sum + v\n\t\tcount = count + 1\n\tend\n\treturn sum / count\nend", " \
    \ local r = copy(l)\n  table.sort(r)\n  local n = #r\n  local m = math.floor(n\
    \ / 2)\n  if n % 2 == 0 then\n    return (r[m] + r[m + 1]) / 2\n  else\n    return\
    \ r[m + 1]\n  end\nend", "  local r = sorted(l)\n  if #r % 2 == 0 then\n    return\
    \ (r[#r/2] + r[#r/2+1]) / 2\n  else\n    return r[math.ceil(#r/2)]\n  end\nend",
  "  local tmp = {}\n  for i,v in ipairs(l) do\n    table.insert(tmp, v)\n  end\n\
    \  table.sort(tmp)\n  local n = #tmp\n  if n == 0 then\n    return 0\n  elseif\
    \ n % 2 == 0 then\n    return (tmp[n/2] + tmp[n/2+1]) / 2\n  else\n    return\
    \ tmp[math.ceil(n/2)]\n  end\nend", "  table.sort(l)\n  local n = #l\n  local\
    \ r = n % 2\n  if n < 1 then\n    return nil\n  elseif r == 0 then\n    return\
    \ (l[n / 2] + l[n / 2 + 1]) / 2\n  else\n    return l[math.ceil(n / 2)]\n  end\n\
    end", "  local m = (l[#l / 2] + l[(#l + 1) / 2]) / 2\n  return m\nend", "  local\
    \ sorted = table.deepcopy(l)\n  table.sort(sorted)\n  local n = #sorted\n  if\
    \ n % 2 == 0 then\n    return (sorted[n / 2] + sorted[n / 2 + 1]) / 2\n  else\n\
    \    return sorted[(n + 1) / 2]\n  end\nend", "    local n = #l\n    local idx_middle\
    \ = math.floor(n / 2)\n    local s = sort(l)\n    if n % 2 == 0 then\n       \
    \ return (s[idx_middle] + s[idx_middle + 1]) / 2\n    else\n        return s[idx_middle\
    \ + 1]\n    end\nend", "    return quantile(l, .5)\nend", "    local len = #l\n\
    \    local sortedList = table.copy(l)\n    table.sort(sortedList)\n    if math.fmod(len,\
    \ 2) == 0 then\n        return (sortedList[len / 2] + sortedList[len / 2 + 1])\
    \ / 2\n    else\n        return sortedList[(len + 1) / 2]\n    end\nend", "  return\
    \ (l[#l/2] + l[(#l/2)+1]) / 2\nend", "  local ll = List.sort(l)\n  local n = List.length(ll)\n\
    \  if n == 0 then return 0 end\n  if n % 2 == 1 then\n    return ll[math.floor(n\
    \ / 2) + 1]\n  else\n    return (ll[n / 2] + ll[n / 2 + 1]) / 2\n  end\nend",
  "  local sum = 0\n  local count = 0\n  local t = {}\n  local m = {}\n  -- Table.sort\
    \ sorts in place, so we need a copy\n  for k, v in pairs(l) do\n    t[k] = v\n\
    \  end\n  -- This is the way to sort a table in Lua!\n  table.sort(t)\n  -- Get\
    \ the middle element and return\n  if #t % 2 == 0 then\n    -- Even\n    m[1]\
    \ = t[#t / 2]\n    m[2] = t[#t / 2 + 1]\n    return (m[1] + m[2]) / 2\n  else\n\
    \    -- Odd\n    return t[(#t + 1) / 2]\n  end\nend", "  local values = pq.new()\n\
    \  for i = 1, #l do\n    pq.insert(values, l[i])\n  end\n  local n = #l\n  if\
    \ n % 2 == 0 then\n    local x = pq.pop(values)\n    local y = pq.pop(values)\n\
    \    return (x + y) / 2\n  else\n    return pq.pop(values)\n  end\nend", "\tif\
    \ #l == 0 then\n\t\treturn 0\n\tend\n\ttable.sort(l)\n\tlocal idx = math.floor(#l\
    \ / 2)\n\tif #l % 2 == 0 then\n\t\treturn (l[idx] + l[idx + 1]) / 2\n\telse\n\t\
    \treturn l[idx + 1]\n\tend\nend", "\tif not l then return end\n\tif #l == 0 then\
    \ return end\n\tif #l == 1 then return l[1] end\n\ttable.sort(l)\n\tif #l % 2\
    \ == 0 then\n\t\tlocal n = #l / 2\n\t\treturn (l[n] + l[n + 1]) / 2\n\telse\n\t\
    \treturn l[math.ceil(#l / 2)]\n\tend\nend", "    local tmp = {}\n    for i,v in\
    \ ipairs(l) do\n        tmp[i] = v\n    end\n    table.sort(tmp)\n    local n\
    \ = #tmp\n    if n % 2 == 0 then\n        return (tmp[n/2] + tmp[n/2+1]) / 2\n\
    \    else\n        return tmp[math.ceil(n/2)]\n    end\nend", "    local sorted\
    \ = {}\n    for _, value in ipairs(l) do\n        sorted[#sorted + 1] = value\n\
    \    end\n    table.sort(sorted)\n    if #sorted % 2 == 0 then\n        return\
    \ (sorted[#sorted / 2] + sorted[#sorted / 2 + 1]) / 2\n    else\n        return\
    \ sorted[math.ceil(#sorted / 2)]\n    end\nend", "  local c = #l\n  if c % 2 ==\
    \ 0 then\n    return (l[c/2] + l[c/2+1]) / 2\n  else\n    return l[(c+1)/2]\n\
    \  end\nend", "    local len = #l\n    local sorted = quick_sort(l)\n    if len\
    \ % 2 == 0 then\n        return (sorted[len / 2] + sorted[len / 2 + 1]) / 2\n\
    \    else\n        return sorted[(len + 1) / 2]\n    end\nend", "    local sorted\
    \ = table.sort(l)\n    if #l%2 == 0 then\n        return (sorted[#l/2] + sorted[#l/2+1])/2\n\
    \    else\n        return sorted[math.ceil(#l/2)]\n    end\nend", "    -- sort\
    \ the list\n    table.sort(l)\n    -- if the number of elements in the list is\
    \ odd, return the middle element\n    if #l % 2 == 1 then\n        return l[math.ceil(#l\
    \ / 2)]\n    else\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n    end\nend",
  "    table.sort(l)\n    local lLen = #l\n    if lLen % 2 == 0 then\n        return\
    \ ((l[lLen / 2] + l[lLen / 2 + 1]) / 2)\n    else\n        return l[math.ceil(lLen\
    \ / 2)]\n    end\nend", "  local l_sort = sort(l)\n  local len = length(l_sort)\n\
    \  if not odd(len) then\n    local sum = l_sort[int(len / 2)] + l_sort[int(len\
    \ / 2) + 1]\n    return sum / 2\n  else\n    return l_sort[int(len / 2) + 1]\n\
    \  end\nend", "    assert(l)\n    assert(#l > 0)\n    table.sort(l)\n    local\
    \ p = (#l + 1) / 2\n    if (p % 1) == 0 then\n        return l[p]\n    else\n\
    \        return (l[p - 0.5] + l[p + 0.5]) / 2\n    end\nend", "    local s = sort(l)\n\
    \    local n = #s\n    if n%2 == 0 then\n        return (s[n/2] + s[n/2+1])/2\n\
    \    else\n        return s[math.ceil(n/2)]\n    end\nend", "    table.sort(l)\n\
    \    if #l % 2 == 0 then\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n   \
    \ else\n        return l[math.ceil(#l / 2)]\n    end\nend", "\tlocal tmp = {}\n\
    \tfor i,v in ipairs(l) do\n\t\ttmp[i] = v\n\tend\n\ttable.sort(tmp)\n\tlocal n\
    \ = #tmp\n\tif n % 2 == 0 then\n\t\treturn (tmp[n/2] + tmp[n/2+1]) / 2\n\telse\n\
    \t\treturn tmp[math.ceil(n/2)]\n\tend\nend", "  local sorted = copy(l)\n  table.sort(sorted)\n\
    \  local middle = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return (sorted[middle]\
    \ + sorted[middle + 1]) / 2\n  else\n    return sorted[middle + 1]\n  end\nend",
  "  local sl = cpy(l)\n  sort(sl)\n  return (sl[#sl / 2] + sl[(#sl / 2) + 1]) / 2\n\
    end", "  local a = l\n  local n = #a\n  local half = n/2\n  table.sort(a)\n  local\
    \ m = (a[half] + a[half+1])/2\n  return m\nend", "\tlocal li = 1\n\tlocal lj =\
    \ #l\n\tlocal lmid = math.floor((li + lj) / 2)\n\tlocal lmin = math.min(unpack(l))\n\
    \tlocal lmax = math.max(unpack(l))\n\tlocal lrange = lmax - lmin\n\tlocal lmedian\
    \ = l[lmid]\n\tlocal lq1 = (l[math.floor(lmid / 2)] + l[math.ceil(lmid / 2)])\
    \ / 2\n\tlocal lq3 = (l[math.floor((#l + lmid) / 2)] + l[math.ceil((#l + lmid)\
    \ / 2)]) / 2\n\tlocal liqr = lq3 - lq1\n\tlocal loutliers = {}\n\tlocal lnew_l\
    \ = {}\n\t-- get outliers (1.5 IQR)\n\tfor _, v in ipairs(l) do\n\t\tif (v > lq3\
    \ + liqr * 1.5) or (v < lq1 - liqr * 1.5) then\n\t\t\ttable.insert(loutliers,\
    \ v)\n\t\telse\n\t\t\ttable.insert(lnew_l, v)\n\t\tend\n\tend\n\t--print(\"l =\
    \ \" .. table.concat(l, \", \"))\n\t--print(\"outliers = \" .. table.concat(loutliers,\
    \ \", \"))\n\t--print(\"new_l = \" .. table.concat(lnew_l, \", \"))\n\treturn\
    \ median(lnew_l)\nend", "  local n = #l\n  if n == 0 then return 0 end\n  table.sort(l)\n\
    \  if n%2 == 0 then\n    return (l[n/2] + l[n/2+1])/2\n  else\n    return l[math.ceil(n/2)]\n\
    \  end\nend", "  return (max(l) + min(l)) / 2\nend", "\tlocal sum, count = 0,\
    \ 0\n\tlocal sorted = table.sort(l)\n\tfor i, v in ipairs(sorted) do\n\t\tsum\
    \ = sum + v\n\t\tcount = count + 1\n\tend\n\treturn sum / count\nend", "    local\
    \ r = deepcopy(l)\n    table.sort(r)\n    return r[math.ceil(#r / 2)]\nend", " \
    \   local sl = sort(l)\n    local n = #sl\n    if n == 0 then\n        return\
    \ nil\n    elseif n % 2 == 1 then\n        return sl[math.ceil(n/2)]\n    else\n\
    \        return (sl[n/2] + sl[n/2+1]) / 2\n    end\nend", "  assert(type(l) ==\
    \ \"table\", \"bad argument to 'median' (table expected, got \" .. type(l) ..\
    \ \")\")\n  local h = {}\n  for i, v in ipairs(l) do\n    table.insert(h, v)\n\
    \  end\n  table.sort(h)\n  local len = #h\n  if len % 2 == 0 then\n    return\
    \ (h[len / 2] + h[len / 2 + 1]) / 2\n  else\n    return h[(len + 1) / 2]\n  end\n\
    end", "    if #l == 0 then return nil end\n    local sum = 0\n    local count\
    \ = 0\n    local sorted = l:copy()\n    sorted:sort()\n    for i = 1, #sorted\
    \ do\n        sum = sum + sorted[i]\n        count = count + 1\n    end\n    return\
    \ sum / count\nend", "  local n = table.getn(l)\n  if n == 0 then\n    return\
    \ nil\n  end\n  if n % 2 == 1 then\n    return l[(n + 1) / 2]\n  else\n    return\
    \ (l[n / 2] + l[n / 2 + 1]) / 2\n  end\nend", "  -- Sort the list in ascending\
    \ order\n  table.sort(l)\n  local size = #l\n  -- find the index of middle element\n\
    \  local mid_index = size/2\n  if size % 2 == 0 then\n    -- get value of middle\
    \ elements and compute the median\n    return (l[mid_index] + l[mid_index+1])/2\n\
    \  else\n    -- get value of middle element\n    return l[math.ceil(mid_index)]\n\
    \  end\nend", "  local sorted = bubblesort(l)\n  local center = math.floor(#l\
    \ / 2)\n  if #l % 2 == 0 then\n    return (sorted[center] + sorted[center + 1])\
    \ / 2\n  else\n    return sorted[center + 1]\n  end\nend", "\tlocal n = len(l)\n\
    \tif n == 0 then return nil, \"median of an empty list\" end\n\tlocal v = n %\
    \ 2\n\tif v == 0 then\n\t\tlocal m = (l[n/2] + l[n/2+1]) / 2\n\t\treturn m\n\t\
    else\n\t\treturn l[(n+1)/2]\n\tend\nend", "  local function comp(a, b)\n    return\
    \ a < b\n  end\n  local sl = table.sort(l, comp)\n  local n = #sl\n  if n % 2\
    \ == 0 then\n    return (sl[n/2] + sl[n/2 + 1]) / 2\n  else\n    return sl[(n\
    \ + 1) / 2]\n  end\nend", "    assert(#l > 0, \"Empty list\")\n    local sorted_l\
    \ = sort(l)\n    local m = (#sorted_l + 1) / 2\n    if m % 1 == 0 then\n     \
    \   return sorted_l[m]\n    else\n        return (sorted_l[m - 0.5] + sorted_l[m\
    \ + 0.5]) / 2\n    end\nend", "  if type(l) ~= \"table\" then\n    error(\"bad\
    \ argument #1 (expected table, got \" .. type(l) .. \")\", 2)\n  end\n  if #l\
    \ == 0 then\n    return nil\n  end\n  local t = copy(l)\n  sort(t)\n  local n\
    \ = #t\n  if n % 2 == 0 then\n    return (t[n / 2] + t[n / 2 + 1]) / 2\n  else\n\
    \    return t[(n + 1) / 2]\n  end\nend", "    if #l == 0 then\n        return\
    \ 0\n    end\n    -- sort list\n    sort(l)\n    -- get middle position\n    local\
    \ pos = math.floor(#l / 2)\n    -- even elements\n    if #l % 2 == 0 then\n  \
    \      return (l[pos] + l[pos + 1]) / 2\n    end\n    -- odd elements\n    return\
    \ l[pos + 1]\nend", "  if type(l) ~= \"table\" then\n    error(\"list expected,\
    \ got \" .. type(l))\n  end\n  local len = #l\n  if len == 0 then\n    return\
    \ nil\n  end\n  table.sort(l)\n  local even = len % 2 == 0\n  local middle = math.floor(len\
    \ / 2)\n  if even then\n    return (l[middle] + l[middle + 1]) / 2\n  else\n \
    \   return l[middle + 1]\n  end\nend", "  local arr = list_to_table(l)\n  table.sort(arr)\n\
    \  local len = #arr\n  if len % 2 == 0 then\n    return (arr[len / 2] + arr[len\
    \ / 2 + 1]) / 2\n  else\n    return arr[(len + 1) / 2]\n  end\nend", "\tif not\
    \ l then\n\t\treturn nil\n\tend\n\tif #l == 0 then\n\t\treturn nil\n\tend\n\t\
    if #l == 1 then\n\t\treturn l[1]\n\tend\n\tlocal a = table.copy(l)\n\ttable.sort(a)\n\
    \tif #a % 2 == 0 then\n\t\treturn (a[#a / 2] + a[#a / 2 + 1]) / 2\n\telse\n\t\t\
    return a[math.ceil(#a / 2)]\n\tend\nend", "    table.sort(l)\n    if (#l % 2 ==\
    \ 0) then\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n    else\n        return\
    \ l[math.ceil(#l / 2)]\n    end\nend", "  -- sort and divide by two, if even average\
    \ values\n  -- if odd, return middle value\n  local sl = sort(l)\n  local ln =\
    \ #sl\n  if ln % 2 == 0 then\n    return (sl[ln/2] + sl[ln/2 + 1]) / 2\n  else\n\
    \    return sl[ln/2]\n  end\nend", "    local tmp = l\n    local n = #tmp\n  \
    \  local sum = 0", "  local function compare(a, b)\n    return a < b\n  end\n\
    \  local sorted = merge_sort(l, compare)\n  local length = #sorted\n  if length\
    \ % 2 == 0 then\n    return (sorted[length/2] + sorted[length/2 + 1]) / 2\n  else\n\
    \    return sorted[math.ceil(length/2)]\n  end\nend", "  local len = #l\n  local\
    \ i = len/2\n  -- sort list in increasing order\n  table.sort(l)\n  -- if len\
    \ is odd then median is element in middle of list\n  if len % 2 == 1 then\n  \
    \  return l[math.ceil(i)]\n  -- if len is even then median is average of two middle\
    \ elements\n  else\n    return (l[i] + l[i+1])/2\n  end\nend", "  local l2 = table.sort(l)\n\
    \  if (#l2 % 2) == 0 then\n    local i1 = (#l2 / 2)\n    local i2 = i1 + 1\n \
    \   return (l2[i1] + l2[i2]) / 2\n  else\n    local i = math.ceil(#l2 / 2)\n \
    \   return l2[i]\n  end\nend", "  local t = tablex.copy(l)\n  table.sort(t)\n\
    \  local x, y = t[#t // 2], t[#t // 2 + 1]\n  return (#t % 2 == 0) and (x + y)\
    \ / 2 or x\nend", "    local sl = sort(l)\n    local n = #sl\n    local hn = math.floor(n\
    \ / 2)", "    table.sort(l)\n    local n = #l\n    local m = n // 2\n    if (n\
    \ % 2) == 0 then\n        return (l[m] + l[m + 1]) / 2\n    else\n        return\
    \ l[m + 1]\n    end\nend", "  table.sort(l)\n  local m = #l\n  if m % 2 == 0 then\n\
    \    return (l[m / 2] + l[m / 2 + 1]) / 2\n  else\n    return l[math.ceil(m /\
    \ 2)]\n  end\nend", "  local n = #l\n  if n % 2 == 0 then\n    return (l[n / 2]\
    \ + l[n / 2 + 1]) / 2\n  else\n    return l[math.ceil(n / 2)]\n  end\nend", " \
    \   local t = {}\n    for _,v in ipairs(l) do\n        table.insert(t,v)\n   \
    \ end\n    table.sort(t)\n    local n = #t\n    if n % 2 == 0 then\n        return\
    \ (t[n/2] + t[n/2+1]) / 2\n    else\n        return t[math.ceil(n/2)]\n    end\n\
    end", "    local n = #l\n    table.sort(l)\n    if n % 2 == 0 then\n        return\
    \ (l[n/2] + l[n/2+1]) / 2\n    else\n        return l[(n+1)/2]\n    end\nend",
  "    local n = #l\n    if n < 1 then return 0 end\n    local temp={}\n    for i=1,n\
    \ do\n        temp[i]=l[i]\n    end\n    table.sort(temp)\n    if math.fmod(n,2)==0\
    \ then\n        return (temp[n/2]+temp[n/2+1])/2\n    else\n        return temp[math.ceil(n/2)]\n\
    \    end\nend", "    local p, k, c = 0, 0, 0\n    for _, v in ipairs(l) do\n \
    \       if p < v then\n            p = v\n            k = c\n        end\n   \
    \     c = c + 1\n    end\n    c = c - 1\n    l[k] = l[c]\n    l[c] = p\n    if\
    \ math.fmod(c, 2) == 0 then\n        return (l[c / 2] + l[c / 2 + 1]) / 2\n  \
    \  else\n        return l[(c + 1) / 2]\n    end\nend", "    table.sort(l)\n  \
    \  local n = #l\n    if n%2 == 0 then\n        return (l[n/2] + l[n/2+1])/2\n\
    \    else\n        return l[math.ceil(n/2)]\n    end\nend", "    local s = table.sort(l)\n\
    \    return (l[(#l / 2)] + l[math.ceil(#l / 2)]) / 2\nend", "  -- Determines whether\
    \ the length of the list is odd.\n  local n = #l\n  local odd = n % 2 == 1\n \
    \ -- If odd, return the middle element of the list.\n  if odd then\n    return\
    \ l[(n - 1) / 2 + 1]\n  -- If even, return the mean of the middle two elements.\n\
    \  else\n    return (l[n / 2] + l[n / 2 + 1]) / 2\n  end\nend", "    local sorted\
    \ = sort(l)\n    local len = length(l)\n    local mid = len / 2\n    if len %\
    \ 2 == 0 then\n        return mean(sub(sorted, mid, mid + 1))\n    else\n    \
    \    return sorted[mid + 1]\n    end\nend", "  assert(type(l) == \"table\", \"\
    median expects a table\")\n  local t = list.deepcopy(l)\n  local size = #t\n \
    \ if size == 0 then return 0 end\n  table.sort(t)\n  if size % 2 == 0 then\n \
    \   return (t[size/2] + t[size/2+1]) / 2\n  else\n    return t[math.ceil(size/2)]\n\
    \  end\nend", "\tl = table.sort(l)\n\tif #l % 2 == 0 then\n\t\treturn (l[#l /\
    \ 2] + l[#l / 2 + 1]) / 2\n\telse\n\t\treturn l[math.ceil(#l / 2)]\n\tend\nend",
  "  local t = {}\n  local len = 0\n  for _, v in ipairs(l) do\n    t[len+1] = v\n\
    \    len = len + 1\n  end\n  table.sort(t)\n  local m = len % 2\n  if m == 0 then\n\
    \    return (t[len/2] + t[len/2+1]) / 2\n  else\n    return t[(len+1)/2]\n  end\n\
    end", "  if #l == 0 then\n    return nil\n  end\n  table.sort(l)\n  local half\
    \ = math.floor(#l / 2)\n  if #l % 2 == 0 then\n    return (l[half] + l[half +\
    \ 1]) / 2\n  else\n    return l[half + 1]\n  end\nend", "    local copy = l\n\
    \    local length = #copy\n    if length == 0 then\n        return nil, \"Median\
    \ is undefined for empty list.\"\n    end\n    table.sort(copy)\n    if length\
    \ % 2 == 0 then\n        return (copy[length / 2] + copy[length / 2 + 1]) / 2\n\
    \    else\n        return copy[length // 2 + 1]\n    end\nend", "\tlocal t = {}\n\
    \tfor _, v in ipairs(l) do\n\t\tt[#t + 1] = v\n\tend\n\ttable.sort(t)\n\tif #t\
    \ % 2 == 0 then\n\t\treturn (t[#t / 2] + t[#t / 2 + 1]) / 2\n\telse\n\t\treturn\
    \ t[math.ceil(#t / 2)]\n\tend\nend", "\tif #l == 0 then\n\t\treturn 0\n\tend\n\
    \t\n\tlocal len = #l\n\tlocal index = math.floor(len / 2) + 1\n\ttable.sort(l)\n\
    \t\n\tif len % 2 == 0 then\n\t\treturn (l[index] + l[index - 1]) / 2\n\telse\n\
    \t\treturn l[index]\n\tend\nend", "\tlocal m = clone(l)\n\ttable.sort(m)\n\treturn\
    \ (m[#m] + m[#m - 1]) / 2\nend", "    local list = sort(l)\n    local len = length(list)\n\
    \    if is_even(len) then\n        return (list[len/2] + list[len/2 + 1]) / 2\n\
    \    else\n        return list[(len + 1)/2]\n    end\nend", "  if #l == 0 then\
    \ return nil end\n  table.sort(l)\n  return (#l % 2 == 0) and (l[#l/2] + l[#l/2+1])/2\
    \ or l[math.ceil(#l/2)]\nend", "\tlocal sortedL = quickSort(l)\n\tlocal n = #sortedL\n\
    \tif (n % 2 == 0) then\n\t\treturn (sortedL[n/2] + sortedL[n/2 + 1]) / 2\n\telse\n\
    \t\treturn sortedL[math.ceil(n/2)]\n\tend\nend", "  local tmp = {}\n  for _, v\
    \ in ipairs(l) do\n    table.insert(tmp, v)\n  end\n  table.sort(tmp)\n  if #tmp\
    \ % 2 == 0 then\n    return (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n  else\n\
    \    return tmp[math.ceil(#tmp / 2)]\n  end\nend", "    if #l == 0 then\n    \
    \    return nil\n    end\n    -- Sort list\n    table.sort(l)\n    -- Get half\
    \ of the list\n    local half = math.floor(#l / 2)\n    -- Check if list is odd\n\
    \    if math.fmod(#l, 2) == 1 then\n        return l[half + 1]\n    else\n   \
    \     return (l[half] + l[half + 1]) / 2\n    end\nend", "\tassert(type(l) ==\
    \ \"table\")\n\tlocal f = l\n\ttable.sort(f)\n\tlocal len = #f\n\tif len % 2 ==\
    \ 0 then\n\t\treturn (f[len / 2] + f[len / 2 + 1]) / 2\n\telse\n\t\treturn f[math.ceil(len\
    \ / 2)]\n\tend\nend", "    local tmp = {}\n    for _, v in ipairs(l) do\n    \
    \    table.insert(tmp, v)\n    end\n    table.sort(tmp)\n    if #tmp % 2 == 0\
    \ then\n        return (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n    else\n   \
    \     return tmp[(#tmp + 1) / 2]\n    end\nend", "    local count = #l\n    local\
    \ idx = math.floor(count / 2)\n    if count % 2 == 0 then\n        return (l[idx]\
    \ + l[idx + 1]) / 2\n    else\n        return l[idx + 1]\n    end\nend", "   \
    \ local sorted = {}\n    for k, v in pairs(l) do\n        table.insert(sorted,\
    \ v)\n    end\n    table.sort(sorted)\n    if #sorted % 2 == 0 then\n        return\
    \ (sorted[#sorted / 2] + sorted[#sorted / 2 + 1]) / 2\n    else\n        return\
    \ sorted[math.ceil(#sorted / 2)]\n    end\nend", "  local list = copy_list(l)\n\
    \  sort(list)\n  local index = math.floor(#list / 2)\n  if (#list % 2) == 0 then\n\
    \    return (list[index] + list[index + 1]) / 2\n  else\n    return list[index\
    \ + 1]\n  end\nend", "    if #l == 0 then return nil end\n    local lst = sort(l)\n\
    \    local m = #lst // 2\n    if #lst % 2 == 0 then\n        return (lst[m] +\
    \ lst[m+1]) / 2\n    else\n        return lst[m+1]\n    end\nend", "  local length\
    \ = #l\n  local n = math.floor(length / 2)\n  if length % 2 == 0 then\n    return\
    \ (l[n] + l[n + 1]) / 2\n  else\n    return l[n + 1]\n  end\nend", "  table.sort(l)\n\
    \  local len = #l\n  local m = math.floor(len / 2) + 1\n  if len % 2 == 0 then\n\
    \    return (l[m - 1] + l[m]) / 2\n  else\n    return l[m]\n  end\nend", "   \
    \ local l = deepcopy(l)\n    table.sort(l)\n    if #l % 2 == 0 then\n        return\
    \ (l[#l / 2] + l[#l / 2 + 1]) / 2\n    else\n        return l[math.ceil(#l / 2)]\n\
    \    end\nend", "  table.sort(l)\n  local n = #l\n  if n == 0 then\n    return\
    \ 0\n  elseif n % 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2\n  else\n  \
    \  return l[math.ceil(n/2)]\n  end\nend", "    table.sort(l)\n    local s = (#l\
    \ % 2 == 0) and (l[#l / 2] + l[#l / 2 + 1]) / 2 or l[math.ceil(#l / 2)]\n    return\
    \ s\nend", "  return nil\nend", "    local n = #l\n    table.sort(l)\n    if n\
    \ % 2 == 0 then\n        return (l[n/2] + l[n/2+1]) / 2\n    else\n        return\
    \ l[math.ceil(n/2)]\n    end\nend", "\t-- Sort the input.\n\ttable.sort(l)\n\t\
    -- Extract the length and the middle element.\n\tlocal len = #l\n\tlocal mid =\
    \ math.floor(len / 2)\n\t-- Return the result.\n\tif len % 2 == 0 then\n\t\treturn\
    \ (l[mid] + l[mid + 1]) / 2\n\telse\n\t\treturn l[mid + 1]\n\tend\nend", "   \
    \ local half = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return (l[half]\
    \ + l[half + 1]) / 2\n    else\n        return l[half + 1]\n    end\nend", "\t\
    local t = sorted_copy(l)\n\treturn t[#t/2]\nend", "    local list = {}\n    for\
    \ _, v in ipairs(l) do\n        list[#list + 1] = v\n    end\n    table.sort(list)\n\
    \    local i = math.floor(#list / 2)\n    if #list % 2 == 0 then\n        return\
    \ (list[i] + list[i + 1]) / 2\n    else\n        return list[i + 1]\n    end\n\
    end", "  assert(#l > 0, \"cannot calculate median of empty list\")\n  local buf\
    \ = {}\n  for i, val in ipairs(l) do\n    buf[i] = val\n  end\n  table.sort(buf)\n\
    \  if #buf % 2 == 0 then\n    return (buf[#buf/2] + buf[#buf/2+1]) / 2\n  else\n\
    \    return buf[math.ceil(#buf/2)]\n  end\nend", "    assert(is_list(l), \"l is\
    \ not a list.\")\n    assert(#l > 0, \"l is empty.\")\n    assert(is_number(l[1]),\
    \ \"l contains a non-number.\")\n    local t = table.copy(l)\n    local m = #t/2\n\
    \    table.sort(t)\n    if #t % 2 == 0 then\n        return (t[m] + t[m+1])/2\n\
    \    else\n        return t[math.ceil(m)]\n    end\nend", "    local function\
    \ get_median(l)\n        local length = table_length(l)\n        if length ==\
    \ 0 then\n            return nil\n        end\n        if length % 2 == 0 then\n\
    \            return (l[length/2] + l[length/2 + 1]) / 2\n        else\n      \
    \      return l[math.ceil(length/2)]\n        end\n    end\n    table.sort(l)\n\
    \    return get_median(l)\nend", "    local m\n    local i = 0\n    for _, v in\
    \ pairs(l) do\n        m = m and (m + v) / 2 or v\n        i = i + 1\n    end\n\
    \    return m\nend", "    -- check input\n    assert(#l > 0, \"List argument l\
    \ was empty.\")\n    for i, v in ipairs(l) do\n        assert(type(v) == \"number\"\
    , \"List contained a non-number element at index \" .. i .. \": \" .. tostring(v))\n\
    \    end", "\tlocal t = sort(l)\n\tlocal len = #t\n\tlocal i = math.floor(len\
    \ / 2)\n\treturn (len % 2 == 0) and (t[i] + t[i + 1]) / 2 or t[i + 1]\nend", "\t\
    local n = #l\n\tif n == 0 then\n\t\treturn nil\n\telseif n == 1 then\n\t\treturn\
    \ l[1]\n\telse\n\t\ttable.sort(l)\n\t\tif n % 2 == 0 then\n\t\t\treturn (l[n/2]\
    \ + l[n/2+1]) / 2\n\t\telse\n\t\t\treturn l[math.ceil(n/2)]\n\t\tend\n\tend\n\
    end", "  local temp = copy(l)\n  local middle = (table.getn(temp) + 1) / 2\n \
    \ table.sort(temp)\n  if table.getn(temp) % 2 == 0 then\n    return (temp[middle]\
    \ + temp[middle+1]) / 2\n  else\n    return temp[math.ceil(middle)]\n  end\nend",
  "    local n = #l\n    if n == 0 then\n        return 0\n    end\n    table.sort(l)\n\
    \    local m = (n - 1) / 2\n    if m == math.floor(m) then\n        return (l[m]\
    \ + l[m + 1]) / 2\n    else\n        return l[math.ceil(m)]\n    end\nend", "\t\
    table.sort(l)\n\tlocal n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n / 2] + l[n\
    \ / 2 + 1]) / 2\n\telse\n\t\treturn l[(n + 1) / 2]\n\tend\nend", "    local n\
    \ = #l\n    assert(n > 0, \"Expected the list to have at least one element.\"\
    )\n    local m\n    if n % 2 == 0 then\n        local i = n / 2\n        m = 0.5\
    \ * (l[i] + l[i + 1])\n    else\n        m = l[(n + 1) / 2]\n    end\n    return\
    \ m\nend", "  -- implement here\nend", "    return list_nth(merge_sort(l), math.ceil(#l\
    \ / 2))\nend", "    local sorted = merge_sort(l)\n    local length = #sorted\n\
    \    local center = math.floor(length / 2)\n    if length % 2 == 0 then\n    \
    \    return (sorted[center] + sorted[center + 1]) / 2\n    else\n        return\
    \ sorted[center + 1]\n    end\nend", "\tif #l == 0 then return nil end\n\ttable.sort(l)\n\
    \tif #l % 2 == 0 then\n\t\treturn (l[#l/2] + l[#l/2+1]) / 2\n\telse\n\t\treturn\
    \ l[math.ceil(#l/2)]\n\tend\nend", "    local hl = heap.new()\n    for _, v in\
    \ ipairs(l) do\n        hl:push(v)\n    end\n    hl:sort()\n    -- print(hl)\n\
    \    local n = #l\n    if n % 2 == 0 then\n        return (hl:pop() + hl:pop())\
    \ / 2\n    else\n        return hl:pop()\n    end\nend", "    local t = table.sort(l)\n\
    \    return (t[#t / 2] + t[(#t / 2) + 1]) / 2\nend", "  local half = math.floor(#l\
    \ / 2)\n  if #l % 2 == 0 then\n    return (l[half] + l[half + 1]) / 2\n  else\n\
    \    return l[half + 1]\n  end\nend", "    table.sort(l)\n    local len = #l\n\
    \    if len == 0 then\n        return nil\n    elseif len == 1 then\n        return\
    \ l[1]\n    elseif len % 2 == 0 then\n        return (l[len/2] + l[len/2 + 1])\
    \ / 2\n    else\n        return l[math.ceil(len/2)]\n    end\nend", "  -- Sort\
    \ table l into ascending order by insertion sort\n  local sorted = {}\n  for k,\
    \ v in pairs(l) do\n    local j = 1\n    while j <= #sorted and v > sorted[j]\
    \ do\n      j = j + 1\n    end\n    table.insert(sorted, j, v)\n  end", "    if\
    \ l == nil or #l == 0 then\n        return 0\n    end\n    return Numeric.median(l)\n\
    end", "    local sorted = l\n    table.sort(sorted)\n    return ((sorted[math.floor(#sorted\
    \ / 2)] + sorted[math.ceil(#sorted / 2)]) / 2)\nend", "\tlocal result, count =\
    \ 0, 0\n\tlocal sorted = copyTable(l)\n\ttable.sort(sorted)\n\tcount = #sorted\n\
    \tif count % 2 == 0 then\n\t\tresult = (sorted[count / 2] + sorted[count / 2 +\
    \ 1]) / 2\n\telse\n\t\tresult = sorted[(count + 1) / 2]\n\tend\n\treturn result\n\
    end", "  local n = #l\n  if n == 0 then return nil end\n  local ll = table.sort(l)\n\
    \  if n % 2 == 0 then\n    return (ll[n / 2] + ll[n / 2 + 1]) / 2\n  else\n  \
    \  return ll[math.ceil(n / 2)]\n  end\nend", "  local a = sort(l)\n  local n =\
    \ len(a)\n  if (n % 2) == 0 then\n    return (a[n / 2] + a[(n / 2) + 1]) / 2\n\
    \  else\n    return a[(n + 1) / 2]\n  end\nend", "    table.sort(l)\n    local\
    \ median = l[math.ceil(#l / 2)]\n    return median\nend", "\tif #l == 0 then return\
    \ 0 end\n\t\n\tlocal sorted = {}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(sorted,\
    \ v)\n\tend\n\ttable.sort(sorted)\n\t\n\tlocal mid = math.floor(#l/2)\n\tif #l\
    \ % 2 == 0 then\n\t\treturn (sorted[mid] + sorted[mid+1]) / 2\n\telse\n\t\treturn\
    \ sorted[mid+1]\n\tend\nend", "  -- sorting the list\n  local sorted = table.sort(l)\n\
    \  local len = table.getn(sorted)\n  -- if list has even number of elements, then\
    \ return average of the middle two\n  if len % 2 == 0 then\n    return ((sorted[len/2]\
    \ + sorted[len/2 + 1]) / 2)\n  else\n    return sorted[(len + 1) / 2]\n  end\n\
    end", "  local c = table.copy(l)\n  sort(c)\n  local i = #c / 2\n  if i == math.floor(i)\
    \ then\n    return (c[i] + c[i + 1]) / 2\n  else\n    return c[math.ceil(i)]\n\
    \  end\nend", "  table.sort(l)\n  local n = #l\n  if n % 2 == 0 then\n    return\
    \ (l[n / 2] + l[n / 2 + 1]) / 2\n  else\n    return l[math.ceil(n / 2)]\n  end\n\
    end", "  local l = table.sort(l)\n  local len = #l\n  if len % 2 == 0 then\n \
    \   return (l[len/2] + l[len/2 + 1]) / 2\n  else\n    return l[math.ceil(len/2)]\n\
    \  end\nend", "    assert(type(l) == \"table\")\n    assert(#l > 0)\n    local\
    \ sorted = l:clone()\n    sorted:sort()\n    local mid = #sorted / 2\n    if mid\
    \ % 1 == 0 then\n        return (sorted[mid] + sorted[mid + 1]) / 2\n    else\n\
    \        return sorted[math.ceil(mid)]\n    end\nend", "  table.sort(l)\n  local\
    \ m = #l\n  if m % 2 == 0 then\n    return (l[m/2] + l[m/2+1]) / 2\n  else\n \
    \   return l[math.ceil(m/2)]\n  end\nend", "  local l_sort = table.copy(l)\n \
    \ table.sort(l_sort)\n  local length = #l_sort\n  if length % 2 == 0 then\n  \
    \  return (l_sort[length / 2] + l_sort[length / 2 + 1]) / 2\n  else\n    return\
    \ l_sort[(length + 1) / 2]\n  end\nend", "    local m = math.floor(#l / 2)\n \
    \   local r = #l % 2\n    if r == 0 then\n        return (l[m] + l[m + 1]) / 2\n\
    \    else\n        return l[m + 1]\n    end\nend", "  if #l == 0 then return 0\
    \ end\n  table.sort(l)\n  local i = #l / 2\n  return (#l % 2 == 0) and (l[i] +\
    \ l[i + 1]) / 2 or l[i + 1]\nend", "  local l = Table(l)\n  l:sort()\n  local\
    \ is_even = (l:len() % 2 == 0)\n  local m = is_even and 0.5 or 0.0\n  local i\
    \ = math.floor(l:len() * 0.5)\n  return (l[i] + l[i + 1]) * m\nend", "  table.sort(l)\n\
    \  if #l % 2 == 0 then\n    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n  else\n \
    \   return l[math.ceil(#l / 2)]\n  end\nend", "    local function sort(l, l2)\n\
    \        if #l == 0 then\n            return l2\n        end\n        local x\
    \ = l[1]\n        local l2_ = l2\n        for i = 2, #l do\n            local\
    \ xi = l[i]\n            if xi < x then\n                l2_ = {[1] = xi, unpack(l2_)}\n\
    \            else\n                l2_[#l2_ + 1] = xi\n            end\n     \
    \   end\n        l2_[#l2_ + 1] = x\n        return sort(slice(l, 2, #l), l2_)\n\
    \    end\n    local sorted = sort(l, {})\n    if #sorted % 2 == 0 then\n     \
    \   return (sorted[#sorted / 2] + sorted[#sorted / 2 + 1]) / 2\n    else\n   \
    \     return sorted[(#sorted + 1) / 2]\n    end\nend", "  if #l == 0 then\n  \
    \  return 0\n  end\n  table.sort(l)\n  if #l % 2 == 0 then\n    return (l[#l /\
    \ 2] + l[#l / 2 + 1]) / 2\n  else\n    return l[math.ceil(#l / 2)]\n  end\nend",
  "    local k = #l\n    if k == 0 then\n        return 0\n    end\n    table.sort(l)\n\
    \    if k % 2 == 0 then\n        return (l[k / 2] + l[k / 2 + 1]) / 2\n    else\n\
    \        return l[(k + 1) / 2]\n    end\nend", "  table.sort(l)\n  return (#l\
    \ % 2 == 0) and (l[#l/2] + l[#l/2+1])/2 or l[math.ceil(#l/2)]\nend", "    table.sort(l)\n\
    \    local half = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return\
    \ (l[half] + l[half + 1]) / 2\n    else\n        return l[half + 1]\n    end\n\
    end", "    table.sort(l)\n    if #l % 2 == 0 then\n        return (l[#l / 2] +\
    \ l[#l / 2 + 1]) / 2\n    else\n        return l[math.ceil(#l / 2)]\n    end\n\
    end", "    local sorted_l = sort(l)\n    local n = #sorted_l\n    if n % 2 ==\
    \ 0 then\n        return (sorted_l[n // 2] + sorted_l[n // 2 + 1]) / 2\n    else\n\
    \        return sorted_l[n // 2 + 1]\n    end\nend", "    table.sort(l)\n    local\
    \ i = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return (l[i] + l[i\
    \ + 1]) / 2\n    else\n        return l[i + 1]\n    end\nend", "  local function\
    \ median_sorted(m)\n    local l = #m\n    if l % 2 == 0 then\n      return (m[l/2]\
    \ + m[l/2+1]) / 2\n    else\n      return m[math.ceil(l/2)]\n    end\n  end\n\
    \  return median_sorted(quick_sort(l))\nend", "  local c = {}\n  local n = 0\n\
    \  for i = 1, #l do\n    local r = l[i]\n    if type(r) == \"number\" then\n \
    \     n = n + 1\n      c[n] = r\n    end\n  end\n  if n == 0 then\n    return\
    \ nil\n  end\n  table.sort(c)\n  if n % 2 == 1 then\n    return c[math.ceil(n\
    \ / 2)]\n  else\n    return (c[n / 2] + c[n / 2 + 1]) / 2\n  end\nend", "    local\
    \ sorted = copy(l)\n    table.sort(sorted)\n    local n = #sorted\n    if n%2\
    \ == 0 then\n        return (sorted[n/2] + sorted[n/2+1])/2\n    else\n      \
    \  return sorted[(n+1)/2]\n    end\nend", "    local length = #l\n    local index\
    \ = 1 + math.floor(length/2)\n    local sorted = table.sort(l)\n    if length\
    \ % 2 == 0 then\n        return (sorted[index] + sorted[index+1]) / 2\n    else\n\
    \        return sorted[index]\n    end\nend", "\tlocal sl = sorted_list(l)\n\t\
    local len = #sl\n\tlocal m = floor(len / 2)\n\tif len % 2 == 0 then\n\t\treturn\
    \ (sl[m] + sl[m + 1]) / 2\n\telse\n\t\treturn sl[m + 1]\n\tend\nend", "    local\
    \ idx = #l / 2\n    local sorted = table.copy(l)\n    table.sort(sorted)\n   \
    \ if #l % 2 == 0 then\n        return (sorted[idx] + sorted[idx + 1]) / 2\n  \
    \  else\n        return sorted[math.ceil(idx)]\n    end\nend", "  table.sort(l)\n\
    \  local n = #l\n  if n == 0 then\n    return 0\n  elseif n % 2 == 0 then\n  \
    \  return (l[n/2] + l[n/2+1]) / 2\n  else\n    return l[(n+1)/2]\n  end\nend",
  "    local sorted = {}\n    for k, v in pairs(l) do\n        sorted[k] = v\n   \
    \ end\n    table.sort(sorted)\n    if #sorted % 2 == 0 then\n        return (sorted[#sorted\
    \ / 2] + sorted[#sorted / 2 + 1]) / 2\n    else\n        return sorted[math.ceil(#sorted\
    \ / 2)]\n    end\nend", "  local rl = clone(l)\n  table.sort(rl)\n  local midpos\
    \ = math.floor(#rl / 2)\n  if #rl % 2 == 0 then\n    return (rl[midpos] + rl[midpos\
    \ + 1]) / 2\n  else\n    return rl[midpos + 1]\n  end\nend", "    local median\
    \ = 0\n    local n = #l\n    table.sort(l)\n    if n % 2 == 0 then\n        median\
    \ = (l[n / 2] + l[n / 2 + 1]) / 2\n    else\n        median = l[(n + 1) / 2]\n\
    \    end\n    return median\nend", "\tlocal n = #l\n\tif n % 2 == 0 then\n\t\t\
    return (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\tend\n\
    end", "  if #l == 0 then\n    return nil\n  end\n  l = sorted(l)\n  if #l % 2\
    \ == 0 then\n    local h = #l / 2\n    return (l[h] + l[h + 1]) / 2\n  else\n\
    \    return l[(#l + 1) / 2]\n  end\nend", "  local function add(x, y) return x\
    \ + y end\n  local function sub(x, y) return x - y end\n  local function div(x,\
    \ y) return x / y end\n  local function mul(x, y) return x * y end\n  local function\
    \ mod(x, y) return x % y end\n  local function exp(x, y) return x ^ y end\n  local\
    \ function eq(x, y) return x == y end\n  local function neq(x, y) return x ~=\
    \ y end\n  local function lt(x, y) return x < y end\n  local function le(x, y)\
    \ return x <= y end\n  local function head(x) return x[1] end\n  local function\
    \ tail(x) return x[2] end\n  local function empty(x) return x == nil end\n  local\
    \ function length(x) return #x end\n  local function cons(x, y) return {x, y}\
    \ end\n  local function append(x, y) return {unpack(x), unpack(y)} end\n  local\
    \ function reverse(x) return {unpack(x, #x, 1)} end\n  local function filter(f,\
    \ x) return {f(unpack(x))} end\n  local function reduce(f, x, y)\n    local acc\
    \ = y\n    for i = 1, #x do\n      acc = f(acc, x[i])\n    end\n    return acc\n\
    \  end\n  local function sort(x) return {unpack(x)} end\n  local function calc(x)\
    \ return {unpack(x)} end\n  local function map(f, x)\n    local ret = {}\n   \
    \ for i = 1, #x do\n      ret[i] = f(x[i])\n    end\n    return ret\n  end\n \
    \ local function print(x)\n    if #x > 0 then\n      io.write(tostring(x[1]))\n\
    \      for i = 2, #x do\n        io.write(\",\", tostring(x[i]))\n      end\n\
    \    end\n    io.write(\"\\n\")\n  end\n  local function exec(x)\n    if #x ==\
    \ 0 then\n     ", "    local function compare(a, b)\n        return a < b\n  \
    \  end\n    table.sort(l, compare)\n    if #l % 2 == 0 then\n        return (l[#l\
    \ / 2] + l[#l / 2 + 1]) / 2\n    else\n        return l[math.ceil(#l / 2)]\n \
    \   end\nend", "\ttable.sort(l)\n\tif (math.fmod(#l, 2) == 0) then\n\t\treturn\
    \ (l[#l/2] + l[#l/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(#l/2)]\n\tend\nend",
  "  local function median_sort(a, b)\n    return a < b\n  end\n  table.sort(l, median_sort)\n\
    \  local n = #l\n  if n % 2 == 0 then\n    return (l[n / 2] + l[n / 2 + 1]) /\
    \ 2\n  else\n    return l[math.ceil(n / 2)]\n  end\nend", "    local t = {}\n\
    \    for _, v in ipairs(l) do\n        table.insert(t, v)\n    end\n    table.sort(t)\n\
    \    local count = #t\n    if (count % 2) == 0 then\n        return (t[count /\
    \ 2] + t[(count / 2) + 1]) / 2\n    else\n        return t[math.ceil(count / 2)]\n\
    \    end\nend", "  local sl = sort(l)\n  if length(sl) % 2 == 0 then\n    return\
    \ (sl[length(sl) / 2] + sl[length(sl) / 2 + 1]) / 2\n  else\n    return sl[(length(sl)\
    \ + 1) / 2]\n  end\nend", "    return quantile(l, 0.5)\nend", "  table.sort(l)\n\
    \  local n = #l\n  if n % 2 == 0 then\n    return (l[n / 2] + l[n / 2 + 1]) /\
    \ 2\n  else\n    return l[(n + 1) / 2]\n  end\nend", "  local sl = quicksort(l)\n\
    \  local mid_idx = #sl / 2\n  if math.floor(mid_idx) == mid_idx then\n    return\
    \ (sl[mid_idx] + sl[mid_idx + 1]) / 2\n  else\n    return sl[math.ceil(mid_idx)]\n\
    \  end\nend", "  local tmp = {}\n  for _, v in ipairs(l) do\n    table.insert(tmp,\
    \ v)\n  end\n  table.sort(tmp)\n  if #tmp % 2 == 0 then\n    return (tmp[#tmp\
    \ / 2] + tmp[#tmp / 2 + 1]) / 2\n  else\n    return tmp[math.ceil(#tmp / 2)]\n\
    \  end\nend", "    return nth_element(l, math.floor(#l / 2))\nend", "  table.sort(l)\n\
    \  local len = #l\n  local half = math.floor(len / 2)\n  if len % 2 == 0 then\n\
    \    return (l[half] + l[half + 1]) / 2\n  else\n    return l[half + 1]\n  end\n\
    end", "    local n = #l\n    local m = math.floor(n / 2)\n    if n == 0 then\n\
    \        return 0\n    elseif n % 2 == 0 then\n        return (l[m] + l[m + 1])\
    \ / 2\n    else\n        return l[m + 1]\n    end\nend", "  assert(type(l) ==\
    \ \"table\", \"Expected list\")\n  if #l == 0 then\n    return nil\n  end\n  local\
    \ t = sort(l)\n  if #t % 2 == 0 then\n    return (t[#t / 2] + t[#t / 2 + 1]) /\
    \ 2\n  else\n    return t[math.ceil(#t / 2)]\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
